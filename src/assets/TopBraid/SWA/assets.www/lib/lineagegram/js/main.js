(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.LineageGram = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   3.3.1
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  return typeof x === 'function' || typeof x === 'object' && x !== null;
}

function isFunction(x) {
  return typeof x === 'function';
}

var _isArray = undefined;
if (!Array.isArray) {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
} else {
  _isArray = Array.isArray;
}

var isArray = _isArray;

var len = 0;
var vertxNext = undefined;
var customSchedulerFn = undefined;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  return function () {
    vertxNext(flush);
  };
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var r = require;
    var vertx = r('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = undefined;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var _arguments = arguments;

  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;

  if (_state) {
    (function () {
      var callback = _arguments[_state - 1];
      asap(function () {
        return invokeCallback(_state, child, callback, parent._result);
      });
    })();
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  _resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(16);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var GET_THEN_ERROR = new ErrorObject();

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    GET_THEN_ERROR.error = error;
    return GET_THEN_ERROR;
  }
}

function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
  try {
    then.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        _resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      _reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      _reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    _reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return _resolve(promise, value);
    }, function (reason) {
      return _reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$) {
  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$ === GET_THEN_ERROR) {
      _reject(promise, GET_THEN_ERROR.error);
    } else if (then$$ === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$)) {
      handleForeignThenable(promise, maybeThenable, then$$);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function _resolve(promise, value) {
  if (promise === value) {
    _reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function _reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;

  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = undefined,
      callback = undefined,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function ErrorObject() {
  this.error = null;
}

var TRY_CATCH_ERROR = new ErrorObject();

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = undefined,
      error = undefined,
      succeeded = undefined,
      failed = undefined;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      _reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
      _resolve(promise, value);
    } else if (failed) {
      _reject(promise, error);
    } else if (settled === FULFILLED) {
      fulfill(promise, value);
    } else if (settled === REJECTED) {
      _reject(promise, value);
    }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      _resolve(promise, value);
    }, function rejectPromise(reason) {
      _reject(promise, reason);
    });
  } catch (e) {
    _reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function Enumerator(Constructor, input) {
  this._instanceConstructor = Constructor;
  this.promise = new Constructor(noop);

  if (!this.promise[PROMISE_ID]) {
    makePromise(this.promise);
  }

  if (isArray(input)) {
    this._input = input;
    this.length = input.length;
    this._remaining = input.length;

    this._result = new Array(this.length);

    if (this.length === 0) {
      fulfill(this.promise, this._result);
    } else {
      this.length = this.length || 0;
      this._enumerate();
      if (this._remaining === 0) {
        fulfill(this.promise, this._result);
      }
    }
  } else {
    _reject(this.promise, validationError());
  }
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
};

Enumerator.prototype._enumerate = function () {
  var length = this.length;
  var _input = this._input;

  for (var i = 0; this._state === PENDING && i < length; i++) {
    this._eachEntry(_input[i], i);
  }
};

Enumerator.prototype._eachEntry = function (entry, i) {
  var c = this._instanceConstructor;
  var resolve$$ = c.resolve;

  if (resolve$$ === resolve) {
    var _then = getThen(entry);

    if (_then === then && entry._state !== PENDING) {
      this._settledAt(entry._state, i, entry._result);
    } else if (typeof _then !== 'function') {
      this._remaining--;
      this._result[i] = entry;
    } else if (c === Promise) {
      var promise = new c(noop);
      handleMaybeThenable(promise, entry, _then);
      this._willSettleAt(promise, i);
    } else {
      this._willSettleAt(new c(function (resolve$$) {
        return resolve$$(entry);
      }), i);
    }
  } else {
    this._willSettleAt(resolve$$(entry), i);
  }
};

Enumerator.prototype._settledAt = function (state, i, value) {
  var promise = this.promise;

  if (promise._state === PENDING) {
    this._remaining--;

    if (state === REJECTED) {
      _reject(promise, value);
    } else {
      this._result[i] = value;
    }
  }

  if (this._remaining === 0) {
    fulfill(promise, this._result);
  }
};

Enumerator.prototype._willSettleAt = function (promise, i) {
  var enumerator = this;

  subscribe(promise, undefined, function (value) {
    return enumerator._settledAt(FULFILLED, i, value);
  }, function (reason) {
    return enumerator._settledAt(REJECTED, i, reason);
  });
};

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  _reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {function} resolver
  Useful for tooling.
  @constructor
*/
function Promise(resolver) {
  this[PROMISE_ID] = nextId();
  this._result = this._state = undefined;
  this._subscribers = [];

  if (noop !== resolver) {
    typeof resolver !== 'function' && needsResolver();
    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
  }
}

Promise.all = all;
Promise.race = race;
Promise.resolve = resolve;
Promise.reject = reject;
Promise._setScheduler = setScheduler;
Promise._setAsap = setAsap;
Promise._asap = asap;

Promise.prototype = {
  constructor: Promise,

  /**
    The primary way of interacting with a promise is through its `then` method,
    which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.
  
    ```js
    findUser().then(function(user){
      // user is available
    }, function(reason){
      // user is unavailable, and you are given the reason why
    });
    ```
  
    Chaining
    --------
  
    The return value of `then` is itself a promise.  This second, 'downstream'
    promise is resolved with the return value of the first promise's fulfillment
    or rejection handler, or rejected if the handler throws an exception.
  
    ```js
    findUser().then(function (user) {
      return user.name;
    }, function (reason) {
      return 'default name';
    }).then(function (userName) {
      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
      // will be `'default name'`
    });
  
    findUser().then(function (user) {
      throw new Error('Found user, but still unhappy');
    }, function (reason) {
      throw new Error('`findUser` rejected and we're unhappy');
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
    });
    ```
    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
  
    ```js
    findUser().then(function (user) {
      throw new PedagogicalException('Upstream error');
    }).then(function (value) {
      // never reached
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // The `PedgagocialException` is propagated all the way down to here
    });
    ```
  
    Assimilation
    ------------
  
    Sometimes the value you want to propagate to a downstream promise can only be
    retrieved asynchronously. This can be achieved by returning a promise in the
    fulfillment or rejection handler. The downstream promise will then be pending
    until the returned promise is settled. This is called *assimilation*.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // The user's comments are now available
    });
    ```
  
    If the assimliated promise rejects, then the downstream promise will also reject.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // If `findCommentsByAuthor` fulfills, we'll have the value here
    }, function (reason) {
      // If `findCommentsByAuthor` rejects, we'll have the reason here
    });
    ```
  
    Simple Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let result;
  
    try {
      result = findResult();
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
    findResult(function(result, err){
      if (err) {
        // failure
      } else {
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findResult().then(function(result){
      // success
    }, function(reason){
      // failure
    });
    ```
  
    Advanced Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let author, books;
  
    try {
      author = findAuthor();
      books  = findBooksByAuthor(author);
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
  
    function foundBooks(books) {
  
    }
  
    function failure(reason) {
  
    }
  
    findAuthor(function(author, err){
      if (err) {
        failure(err);
        // failure
      } else {
        try {
          findBoooksByAuthor(author, function(books, err) {
            if (err) {
              failure(err);
            } else {
              try {
                foundBooks(books);
              } catch(reason) {
                failure(reason);
              }
            }
          });
        } catch(error) {
          failure(err);
        }
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findAuthor().
      then(findBooksByAuthor).
      then(function(books){
        // found books
    }).catch(function(reason){
      // something went wrong
    });
    ```
  
    @method then
    @param {Function} onFulfilled
    @param {Function} onRejected
    Useful for tooling.
    @return {Promise}
  */
  then: then,

  /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
  
    ```js
    function findAuthor(){
      throw new Error('couldn't find that author');
    }
  
    // synchronous
    try {
      findAuthor();
    } catch(reason) {
      // something went wrong
    }
  
    // async with promises
    findAuthor().catch(function(reason){
      // something went wrong
    });
    ```
  
    @method catch
    @param {Function} onRejection
    Useful for tooling.
    @return {Promise}
  */
  'catch': function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};

function polyfill() {
    var local = undefined;

    if (typeof global !== 'undefined') {
        local = global;
    } else if (typeof self !== 'undefined') {
        local = self;
    } else {
        try {
            local = Function('return this')();
        } catch (e) {
            throw new Error('polyfill failed because global object is unavailable in this environment');
        }
    }

    var P = local.Promise;

    if (P) {
        var promiseToString = null;
        try {
            promiseToString = Object.prototype.toString.call(P.resolve());
        } catch (e) {
            // silently ignored
        }

        if (promiseToString === '[object Promise]' && !P.cast) {
            return;
        }
    }

    local.Promise = Promise;
}

polyfill();
// Strange compat..
Promise.polyfill = polyfill;
Promise.Promise = Promise;

return Promise;

})));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":3}],2:[function(require,module,exports){
/*! FileSaver.js v1.3.6
 *
 * A saveAs() FileSaver implementation.
 *
 * By Travis Clarke, https://travismclarke.com
 * By Eli Grey, http://eligrey.com
 *
 * License: MIT (https://github.com/clarketm/FileSaver.js/blob/master/LICENSE.md)
 */

;(function (root, factory) {
    if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
        module.exports = root.document ? factory(root, true) : function (w) {
            if (!w.document) {
                throw new Error("FileSaver requires a window with a document");
            }
            return factory(w);
        };
    } else {
        factory(root);
    }
}(window || this, function (window, noGlobal) {
        "use strict";
        // IE <10 is explicitly unsupported
        if (typeof window === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
            return;
        }
        var
            doc = window.document
            // only get URL when necessary in case Blob.js hasn't overridden it yet
            , get_URL = function () {
                return window.URL || window.webkitURL || window;
            }
            , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
            , can_use_save_link = "download" in save_link
            , click = function (node) {
                var event = new MouseEvent("click");
                node.dispatchEvent(event);
            }
            , is_safari = /constructor/i.test(window.HTMLElement) || window.safari
            , is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent)
            , throw_outside = function (ex) {
                (window.setImmediate || window.setTimeout)(function () {
                    throw ex;
                }, 0);
            }
            , force_saveable_type = "application/octet-stream"
            // the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
            , arbitrary_revoke_timeout = 1000 * 40 // in ms
            , revoke = function (file) {
                var revoker = function () {
                    if (typeof file === "string") { // file is an object URL
                        get_URL().revokeObjectURL(file);
                    } else { // file is a File
                        file.remove();
                    }
                };
                setTimeout(revoker, arbitrary_revoke_timeout);
            }
            , dispatch = function (filesaver, event_types, event) {
                event_types = [].concat(event_types);
                var i = event_types.length;
                while (i--) {
                    var listener = filesaver["on" + event_types[i]];
                    if (typeof listener === "function") {
                        try {
                            listener.call(filesaver, event || filesaver);
                        } catch (ex) {
                            throw_outside(ex);
                        }
                    }
                }
            }
            , auto_bom = function (blob) {
                // prepend BOM for UTF-8 XML and text/* types (including HTML)
                // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
                if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
                    return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
                }
                return blob;
            }
            , FileSaver = function (blob, name, no_auto_bom) {
                if (!no_auto_bom) {
                    blob = auto_bom(blob);
                }
                // First try a.download, then web filesystem, then object URLs
                var
                    filesaver = this
                    , type = blob.type
                    , force = type === force_saveable_type
                    , object_url
                    , dispatch_all = function () {
                        dispatch(filesaver, "writestart progress write writeend".split(" "));
                    }
                    // on any filesys errors revert to saving with object URLs
                    , fs_error = function () {
                        if ((is_chrome_ios || (force && is_safari)) && window.FileReader) {
                            // Safari doesn't allow downloading of blob urls
                            var reader = new FileReader();
                            reader.onloadend = function () {
                                var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
                                var popup = window.open(url, '_blank');
                                if (!popup) window.location.href = url;
                                url = undefined; // release reference before dispatching
                                filesaver.readyState = filesaver.DONE;
                                dispatch_all();
                            };
                            reader.readAsDataURL(blob);
                            filesaver.readyState = filesaver.INIT;
                            return;
                        }
                        // don't create more object URLs than needed
                        if (!object_url) {
                            object_url = get_URL().createObjectURL(blob);
                        }
                        if (force) {
                            window.location.href = object_url;
                        } else {
                            var opened = window.open(object_url, "_blank");
                            if (!opened) {
                                // Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
                                window.location.href = object_url;
                            }
                        }
                        filesaver.readyState = filesaver.DONE;
                        dispatch_all();
                        revoke(object_url);
                    }
                    ;
                filesaver.readyState = filesaver.INIT;

                if (can_use_save_link) {
                    object_url = get_URL().createObjectURL(blob);
                    setTimeout(function () {
                        save_link.href = object_url;
                        save_link.download = name;
                        click(save_link);
                        dispatch_all();
                        revoke(object_url);
                        filesaver.readyState = filesaver.DONE;
                    });
                    return;
                }

                fs_error();
            }
            , FS_proto = FileSaver.prototype
            , saveAs = function (blob, name, no_auto_bom) {
                return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
            }
            ;
        // IE 10+ (native saveAs)
        if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
            saveAs = function (blob, name, no_auto_bom) {
                name = name || blob.name || "download";

                if (!no_auto_bom) {
                    blob = auto_bom(blob);
                }
                return navigator.msSaveOrOpenBlob(blob, name);
            };
        }

        FS_proto.abort = function () {
        };
        FS_proto.readyState = FS_proto.INIT = 0;
        FS_proto.WRITING = 1;
        FS_proto.DONE = 2;

        FS_proto.error =
            FS_proto.onwritestart =
                FS_proto.onprogress =
                    FS_proto.onwrite =
                        FS_proto.onabort =
                            FS_proto.onerror =
                                FS_proto.onwriteend =
                                    null;

        if (typeof define === "function" && define.amd) {
            define("file-saverjs", [], function () {
                return saveAs;
            });
        }

        if (typeof noGlobal === 'undefined') {
            window.saveAs = saveAs;
        }
        return saveAs;
    }
));

},{}],3:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],4:[function(require,module,exports){
;(function(undefined) {
  'use strict';

  var __instances = {};

  /**
   * This is the sigma instances constructor. One instance of sigma represent
   * one graph. It is possible to represent this grapÄ¥ with several renderers
   * at the same time. By default, the default renderer (WebGL + Canvas
   * polyfill) will be used as the only renderer, with the container specified
   * in the configuration.
   *
   * @param  {?*}    conf The configuration of the instance. There are a lot of
   *                      different recognized forms to instantiate sigma, check
   *                      example files, documentation in this file and unit
   *                      tests to know more.
   * @return {sigma}      The fresh new sigma instance.
   *
   * Instanciating sigma:
   * ********************
   * If no parameter is given to the constructor, the instance will be created
   * without any renderer or camera. It will just instantiate the graph, and
   * other modules will have to be instantiated through the public methods,
   * like "addRenderer" etc:
   *
   *  > s0 = new sigma();
   *  > s0.addRenderer({
   *  >   type: 'canvas',
   *  >   container: 'my-container-id'
   *  > });
   *
   * In most of the cases, sigma will simply be used with the default renderer.
   * Then, since the only required parameter is the DOM container, there are
   * some simpler way to call the constructor. The four following calls do the
   * exact same things:
   *
   *  > s1 = new sigma('my-container-id');
   *  > s2 = new sigma(document.getElementById('my-container-id'));
   *  > s3 = new sigma({
   *  >   container: document.getElementById('my-container-id')
   *  > });
   *  > s4 = new sigma({
   *  >   renderers: [{
   *  >     container: document.getElementById('my-container-id')
   *  >   }]
   *  > });
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters, when calling the
   * constructor with to top level configuration object (fourth case in the
   * previous examples):
   *
   *   {?string} id        The id of the instance. It will be generated
   *                       automatically if not specified.
   *   {?array}  renderers An array containing objects describing renderers.
   *   {?object} graph     An object containing an array of nodes and an array
   *                       of edges, to avoid having to add them by hand later.
   *   {?object} settings  An object containing instance specific settings that
   *                       will override the default ones defined in the object
   *                       sigma.settings.
   */
  var sigma = function(conf) {
    // Local variables:
    // ****************
    var i,
        l,
        a,
        c,
        o,
        id;

    sigma.classes.dispatcher.extend(this);

    // Private attributes:
    // *******************
    var _self = this,
        _conf = conf || {};

    // Little shortcut:
    // ****************
    // The configuration is supposed to have a list of the configuration
    // objects for each renderer.
    //  - If there are no configuration at all, then nothing is done.
    //  - If there are no renderer list, the given configuration object will be
    //    considered as describing the first and only renderer.
    //  - If there are no renderer list nor "container" object, it will be
    //    considered as the container itself (a DOM element).
    //  - If the argument passed to sigma() is a string, it will be considered
    //    as the ID of the DOM container.
    if (
      typeof _conf === 'string' ||
      _conf instanceof HTMLElement
    )
      _conf = {
        renderers: [_conf]
      };
    else if (Object.prototype.toString.call(_conf) === '[object Array]')
      _conf = {
        renderers: _conf
      };

    // Also check "renderer" and "container" keys:
    o = _conf.renderers || _conf.renderer || _conf.container;
    if (!_conf.renderers || _conf.renderers.length === 0)
      if (
        typeof o === 'string' ||
        o instanceof HTMLElement ||
        (typeof o === 'object' && 'container' in o)
      )
        _conf.renderers = [o];

    // Recense the instance:
    if (_conf.id) {
      if (__instances[_conf.id])
        throw 'sigma: Instance "' + _conf.id + '" already exists.';
      Object.defineProperty(this, 'id', {
        value: _conf.id
      });
    } else {
      id = 0;
      while (__instances[id])
        id++;
      Object.defineProperty(this, 'id', {
        value: '' + id
      });
    }
    __instances[this.id] = this;

    // Initialize settings function:
    this.settings = new sigma.classes.configurable(
      sigma.settings,
      _conf.settings || {}
    );

    // Initialize locked attributes:
    Object.defineProperty(this, 'graph', {
      value: new sigma.classes.graph(this.settings),
      configurable: true
    });
    Object.defineProperty(this, 'middlewares', {
      value: [],
      configurable: true
    });
    Object.defineProperty(this, 'cameras', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'renderers', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'renderersPerCamera', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'cameraFrames', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'camera', {
      get: function() {
        return this.cameras[0];
      }
    });
    Object.defineProperty(this, 'events', {
      value: [
        'click',
        'rightClick',
        'clickStage',
        'doubleClickStage',
        'rightClickStage',
        'clickNode',
        'clickNodes',
        'doubleClickNode',
        'doubleClickNodes',
        'rightClickNode',
        'rightClickNodes',
        'overNode',
        'overNodes',
        'outNode',
        'outNodes',
        'downNode',
        'downNodes',
        'upNode',
        'upNodes'
      ],
      configurable: true
    });

    // Add a custom handler, to redispatch events from renderers:
    this._handler = (function(e) {
      var k,
          data = {};

      for (k in e.data)
        data[k] = e.data[k];

      data.renderer = e.target;
      this.dispatchEvent(e.type, data);
    }).bind(this);

    // Initialize renderers:
    a = _conf.renderers || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addRenderer(a[i]);

    // Initialize middlewares:
    a = _conf.middlewares || [];
    for (i = 0, l = a.length; i < l; i++)
      this.middlewares.push(
        typeof a[i] === 'string' ?
          sigma.middlewares[a[i]] :
          a[i]
      );

    // Check if there is already a graph to fill in:
    if (typeof _conf.graph === 'object' && _conf.graph) {
      this.graph.read(_conf.graph);

      // If a graph is given to the to the instance, the "refresh" method is
      // directly called:
      this.refresh();
    }

    // Deal with resize:
    window.addEventListener('resize', function() {
      if (_self.settings)
        _self.refresh();
    });
  };




  /**
   * This methods will instantiate and reference a new camera. If no id is
   * specified, then an automatic id will be generated.
   *
   * @param  {?string}              id Eventually the camera id.
   * @return {sigma.classes.camera}    The fresh new camera instance.
   */
  sigma.prototype.addCamera = function(id) {
    var self = this,
        camera;

    if (!arguments.length) {
      id = 0;
      while (this.cameras['' + id])
        id++;
      id = '' + id;
    }

    if (this.cameras[id])
      throw 'sigma.addCamera: The camera "' + id + '" already exists.';

    camera = new sigma.classes.camera(id, this.graph, this.settings);
    this.cameras[id] = camera;

    // Add a quadtree to the camera:
    camera.quadtree = new sigma.classes.quad();

    // Add an edgequadtree to the camera:
    if (sigma.classes.edgequad !== undefined) {
      camera.edgequadtree = new sigma.classes.edgequad();
    }

    camera.bind('coordinatesUpdated', function(e) {
      self.renderCamera(camera, camera.isAnimated);
    });

    this.renderersPerCamera[id] = [];

    return camera;
  };

  /**
   * This method kills a camera, and every renderer attached to it.
   *
   * @param  {string|camera} v The camera to kill or its ID.
   * @return {sigma}           Returns the instance.
   */
  sigma.prototype.killCamera = function(v) {
    v = typeof v === 'string' ? this.cameras[v] : v;

    if (!v)
      throw 'sigma.killCamera: The camera is undefined.';

    var i,
        l,
        a = this.renderersPerCamera[v.id];

    for (l = a.length, i = l - 1; i >= 0; i--)
      this.killRenderer(a[i]);

    delete this.renderersPerCamera[v.id];
    delete this.cameraFrames[v.id];
    delete this.cameras[v.id];

    if (v.kill)
      v.kill();

    return this;
  };

  /**
   * This methods will instantiate and reference a new renderer. The "type"
   * argument can be the constructor or its name in the "sigma.renderers"
   * package. If no type is specified, then "sigma.renderers.def" will be used.
   * If no id is specified, then an automatic id will be generated.
   *
   * @param  {?object}  options Eventually some options to give to the renderer
   *                            constructor.
   * @return {renderer}         The fresh new renderer instance.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the "options"
   * object:
   *
   *   {?string}            id     Eventually the renderer id.
   *   {?(function|string)} type   Eventually the renderer constructor or its
   *                               name in the "sigma.renderers" package.
   *   {?(camera|string)}   camera Eventually the renderer camera or its
   *                               id.
   */
  sigma.prototype.addRenderer = function(options) {
    var id,
        fn,
        camera,
        renderer,
        o = options || {};

    // Polymorphism:
    if (typeof o === 'string')
      o = {
        container: document.getElementById(o)
      };
    else if (o instanceof HTMLElement)
      o = {
        container: o
      };

    // If the container still is a string, we get it by id
    if (typeof o.container === 'string')
      o.container = document.getElementById(o.container);

    // Reference the new renderer:
    if (!('id' in o)) {
      id = 0;
      while (this.renderers['' + id])
        id++;
      id = '' + id;
    } else
      id = o.id;

    if (this.renderers[id])
      throw 'sigma.addRenderer: The renderer "' + id + '" already exists.';

    // Find the good constructor:
    fn = typeof o.type === 'function' ? o.type : sigma.renderers[o.type];
    fn = fn || sigma.renderers.def;

    // Find the good camera:
    camera = 'camera' in o ?
      (
        o.camera instanceof sigma.classes.camera ?
          o.camera :
          this.cameras[o.camera] || this.addCamera(o.camera)
      ) :
      this.addCamera();

    if (this.cameras[camera.id] !== camera)
      throw 'sigma.addRenderer: The camera is not properly referenced.';

    // Instantiate:
    renderer = new fn(this.graph, camera, this.settings, o);
    this.renderers[id] = renderer;
    Object.defineProperty(renderer, 'id', {
      value: id
    });

    // Bind events:
    if (renderer.bind)
      renderer.bind(
        [
          'click',
          'rightClick',
          'clickStage',
          'doubleClickStage',
          'rightClickStage',
          'clickNode',
          'clickNodes',
          'clickEdge',
          'clickEdges',
          'doubleClickNode',
          'doubleClickNodes',
          'doubleClickEdge',
          'doubleClickEdges',
          'rightClickNode',
          'rightClickNodes',
          'rightClickEdge',
          'rightClickEdges',
          'overNode',
          'overNodes',
          'overEdge',
          'overEdges',
          'outNode',
          'outNodes',
          'outEdge',
          'outEdges',
          'downNode',
          'downNodes',
          'downEdge',
          'downEdges',
          'upNode',
          'upNodes',
          'upEdge',
          'upEdges'
        ],
        this._handler
      );

    // Reference the renderer by its camera:
    this.renderersPerCamera[camera.id].push(renderer);

    return renderer;
  };

  /**
   * This method kills a renderer.
   *
   * @param  {string|renderer} v The renderer to kill or its ID.
   * @return {sigma}             Returns the instance.
   */
  sigma.prototype.killRenderer = function(v) {
    v = typeof v === 'string' ? this.renderers[v] : v;

    if (!v)
      throw 'sigma.killRenderer: The renderer is undefined.';

    var a = this.renderersPerCamera[v.camera.id],
        i = a.indexOf(v);

    if (i >= 0)
      a.splice(i, 1);

    if (v.kill)
      v.kill();

    delete this.renderers[v.id];

    return this;
  };




  /**
   * This method calls the "render" method of each renderer, with the same
   * arguments than the "render" method, but will also check if the renderer
   * has a "process" method, and call it if it exists.
   *
   * It is useful for quadtrees or WebGL processing, for instance.
   *
   * @param  {?object}  options Eventually some options to give to the refresh
   *                            method.
   * @return {sigma}            Returns the instance itself.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the "options"
   * object:
   *
   *   {?boolean} skipIndexation A flag specifying wether or not the refresh
   *                             function should reindex the graph in the
   *                             quadtrees or not (default: false).
   */
  sigma.prototype.refresh = function(options) {
    var i,
        l,
        k,
        a,
        c,
        bounds,
        prefix = 0;

    options = options || {};

    // Call each middleware:
    a = this.middlewares || [];
    for (i = 0, l = a.length; i < l; i++)
      a[i].call(
        this,
        (i === 0) ? '' : 'tmp' + prefix + ':',
        (i === l - 1) ? 'ready:' : ('tmp' + (++prefix) + ':')
      );

    // Then, for each camera, call the "rescale" middleware, unless the
    // settings specify not to:
    for (k in this.cameras) {
      c = this.cameras[k];
      if (
        c.settings('autoRescale') &&
        this.renderersPerCamera[c.id] &&
        this.renderersPerCamera[c.id].length
      )
        sigma.middlewares.rescale.call(
          this,
          a.length ? 'ready:' : '',
          c.readPrefix,
          {
            width: this.renderersPerCamera[c.id][0].width,
            height: this.renderersPerCamera[c.id][0].height
          }
        );
      else
        sigma.middlewares.copy.call(
          this,
          a.length ? 'ready:' : '',
          c.readPrefix
        );

      if (!options.skipIndexation) {
        // Find graph boundaries:
        bounds = sigma.utils.getBoundaries(
          this.graph,
          c.readPrefix
        );

        // Refresh quadtree:
        c.quadtree.index(this.graph.nodes(), {
          prefix: c.readPrefix,
          bounds: {
            x: bounds.minX,
            y: bounds.minY,
            width: bounds.maxX - bounds.minX,
            height: bounds.maxY - bounds.minY
          }
        });

        // Refresh edgequadtree:
        if (
          c.edgequadtree !== undefined &&
          c.settings('drawEdges') &&
          c.settings('enableEdgeHovering')
        ) {
          c.edgequadtree.index(this.graph, {
            prefix: c.readPrefix,
            bounds: {
              x: bounds.minX,
              y: bounds.minY,
              width: bounds.maxX - bounds.minX,
              height: bounds.maxY - bounds.minY
            }
          });
        }
      }
    }

    // Call each renderer:
    a = Object.keys(this.renderers);
    for (i = 0, l = a.length; i < l; i++)
      if (this.renderers[a[i]].process) {
        if (this.settings('skipErrors'))
          try {
            this.renderers[a[i]].process();
          } catch (e) {
            console.log(
              'Warning: The renderer "' + a[i] + '" crashed on ".process()"'
            );
          }
        else
          this.renderers[a[i]].process();
      }

    this.render();

    return this;
  };

  /**
   * This method calls the "render" method of each renderer.
   *
   * @return {sigma} Returns the instance itself.
   */
  sigma.prototype.render = function() {
    var i,
        l,
        a,
        prefix = 0;

    // Call each renderer:
    a = Object.keys(this.renderers);
    for (i = 0, l = a.length; i < l; i++)
      if (this.settings('skipErrors'))
        try {
          this.renderers[a[i]].render();
        } catch (e) {
          if (this.settings('verbose'))
            console.log(
              'Warning: The renderer "' + a[i] + '" crashed on ".render()"'
            );
        }
      else
        this.renderers[a[i]].render();

    return this;
  };

  /**
   * This method calls the "render" method of each renderer that is bound to
   * the specified camera. To improve the performances, if this method is
   * called too often, the number of effective renderings is limitated to one
   * per frame, unless you are using the "force" flag.
   *
   * @param  {sigma.classes.camera} camera The camera to render.
   * @param  {?boolean}             force  If true, will render the camera
   *                                       directly.
   * @return {sigma}                       Returns the instance itself.
   */
  sigma.prototype.renderCamera = function(camera, force) {
    var i,
        l,
        a,
        self = this;

    if (force) {
      a = this.renderersPerCamera[camera.id];
      for (i = 0, l = a.length; i < l; i++)
        if (this.settings('skipErrors'))
          try {
            a[i].render();
          } catch (e) {
            if (this.settings('verbose'))
              console.log(
                'Warning: The renderer "' + a[i].id + '" crashed on ".render()"'
              );
          }
        else
          a[i].render();
    } else {
      if (!this.cameraFrames[camera.id]) {
        a = this.renderersPerCamera[camera.id];
        for (i = 0, l = a.length; i < l; i++)
          if (this.settings('skipErrors'))
            try {
              a[i].render();
            } catch (e) {
              if (this.settings('verbose'))
                console.log(
                  'Warning: The renderer "' +
                    a[i].id +
                    '" crashed on ".render()"'
                );
            }
          else
            a[i].render();

        this.cameraFrames[camera.id] = requestAnimationFrame(function() {
          delete self.cameraFrames[camera.id];
        });
      }
    }

    return this;
  };

  /**
   * This method calls the "kill" method of each module and destroys any
   * reference from the instance.
   */
  sigma.prototype.kill = function() {
    var k;

    // Dispatching event
    this.dispatchEvent('kill');

    // Kill graph:
    this.graph.kill();

    // Kill middlewares:
    delete this.middlewares;

    // Kill each renderer:
    for (k in this.renderers)
      this.killRenderer(this.renderers[k]);

    // Kill each camera:
    for (k in this.cameras)
      this.killCamera(this.cameras[k]);

    delete this.renderers;
    delete this.cameras;

    // Kill everything else:
    for (k in this)
      if (this.hasOwnProperty(k))
        delete this[k];

    delete __instances[this.id];
  };




  /**
   * Returns a clone of the instances object or a specific running instance.
   *
   * @param  {?string} id Eventually an instance ID.
   * @return {object}     The related instance or a clone of the instances
   *                      object.
   */
  sigma.instances = function(id) {
    return arguments.length ?
      __instances[id] :
      sigma.utils.extend({}, __instances);
  };



  /**
   * The current version of sigma:
   */
  sigma.version = '1.2.1';




  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined')
    throw 'An object called sigma is already in the global scope.';

  this.sigma = sigma;

}).call(this);

/**
 * conrad.js is a tiny JavaScript jobs scheduler,
 *
 * Version: 0.1.0
 * Sources: http://github.com/jacomyal/conrad.js
 * Doc:     http://github.com/jacomyal/conrad.js#readme
 *
 * License:
 * --------
 * Copyright Â© 2013 Alexis Jacomy, Sciences-Po mÃ©dialab
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * The Software is provided "as is", without warranty of any kind, express or
 * implied, including but not limited to the warranties of merchantability,
 * fitness for a particular purpose and noninfringement. In no event shall the
 * authors or copyright holders be liable for any claim, damages or other
 * liability, whether in an action of contract, tort or otherwise, arising
 * from, out of or in connection with the software or the use or other dealings
 * in the Software.
 */
(function(global) {
  'use strict';

  // Check that conrad.js has not been loaded yet:
  if (global.conrad)
    throw new Error('conrad already exists');


  /**
   * PRIVATE VARIABLES:
   * ******************
   */

  /**
   * A flag indicating whether conrad is running or not.
   *
   * @type {Number}
   */
  var _lastFrameTime;

  /**
   * A flag indicating whether conrad is running or not.
   *
   * @type {Boolean}
   */
  var _isRunning = false;

  /**
   * The hash of registered jobs. Each job must at least have a unique ID
   * under the key "id" and a function under the key "job". This hash
   * contains each running job and each waiting job.
   *
   * @type {Object}
   */
  var _jobs = {};

  /**
   * The hash of currently running jobs.
   *
   * @type {Object}
   */
  var _runningJobs = {};

  /**
   * The array of currently running jobs, sorted by priority.
   *
   * @type {Array}
   */
  var _sortedByPriorityJobs = [];

  /**
   * The array of currently waiting jobs.
   *
   * @type {Object}
   */
  var _waitingJobs = {};

  /**
   * The array of finished jobs. They are stored in an array, since two jobs
   * with the same "id" can happen at two different times.
   *
   * @type {Array}
   */
  var _doneJobs = [];

  /**
   * A dirty flag to keep conrad from starting: Indeed, when addJob() is called
   * with several jobs, conrad must be started only at the end. This flag keeps
   * me from duplicating the code that effectively adds a job.
   *
   * @type {Boolean}
   */
  var _noStart = false;

  /**
   * An hash containing some global settings about how conrad.js should
   * behave.
   *
   * @type {Object}
   */
  var _parameters = {
    frameDuration: 20,
    history: true
  };

  /**
   * This object contains every handlers bound to conrad events. It does not
   * requirea any DOM implementation, since the events are all JavaScript.
   *
   * @type {Object}
   */
  var _handlers = Object.create(null);


  /**
   * PRIVATE FUNCTIONS:
   * ******************
   */

  /**
   * Will execute the handler everytime that the indicated event (or the
   * indicated events) will be triggered.
   *
   * @param  {string|array|object} events  The name of the event (or the events
   *                                       separated by spaces).
   * @param  {function(Object)}    handler The handler to bind.
   * @return {Object}                      Returns conrad.
   */
  function _bind(events, handler) {
    var i,
        i_end,
        event,
        eArray;

    if (!arguments.length)
      return;
    else if (
      arguments.length === 1 &&
      Object(arguments[0]) === arguments[0]
    )
      for (events in arguments[0])
        _bind(events, arguments[0][events]);
    else if (arguments.length > 1) {
      eArray =
        Array.isArray(events) ?
          events :
          events.split(/ /);

      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
        event = eArray[i];

        if (!_handlers[event])
          _handlers[event] = [];

        // Using an object instead of directly the handler will make possible
        // later to add flags
        _handlers[event].push({
          handler: handler
        });
      }
    }
  }

  /**
   * Removes the handler from a specified event (or specified events).
   *
   * @param  {?string}           events  The name of the event (or the events
   *                                     separated by spaces). If undefined,
   *                                     then all handlers are removed.
   * @param  {?function(Object)} handler The handler to unbind. If undefined,
   *                                     each handler bound to the event or the
   *                                     events will be removed.
   * @return {Object}            Returns conrad.
   */
  function _unbind(events, handler) {
    var i,
        i_end,
        j,
        j_end,
        a,
        event,
        eArray = Array.isArray(events) ?
                   events :
                   events.split(/ /);

    if (!arguments.length)
      _handlers = Object.create(null);
    else if (handler) {
      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
        event = eArray[i];
        if (_handlers[event]) {
          a = [];
          for (j = 0, j_end = _handlers[event].length; j !== j_end; j += 1)
            if (_handlers[event][j].handler !== handler)
              a.push(_handlers[event][j]);

          _handlers[event] = a;
        }

        if (_handlers[event] && _handlers[event].length === 0)
          delete _handlers[event];
      }
    } else
      for (i = 0, i_end = eArray.length; i !== i_end; i += 1)
        delete _handlers[eArray[i]];
  }

  /**
   * Executes each handler bound to the event.
   *
   * @param  {string}  events The name of the event (or the events separated
   *                          by spaces).
   * @param  {?Object} data   The content of the event (optional).
   * @return {Object}         Returns conrad.
   */
  function _dispatch(events, data) {
    var i,
        j,
        i_end,
        j_end,
        event,
        eventName,
        eArray = Array.isArray(events) ?
                   events :
                   events.split(/ /);

    data = data === undefined ? {} : data;

    for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
      eventName = eArray[i];

      if (_handlers[eventName]) {
        event = {
          type: eventName,
          data: data || {}
        };

        for (j = 0, j_end = _handlers[eventName].length; j !== j_end; j += 1)
          try {
            _handlers[eventName][j].handler(event);
          } catch (e) {}
      }
    }
  }

  /**
   * Executes the most prioritary job once, and deals with filling the stats
   * (done, time, averageTime, currentTime, etc...).
   *
   * @return {?Object} Returns the job object if it has to be killed, null else.
   */
  function _executeFirstJob() {
    var i,
        l,
        test,
        kill,
        pushed = false,
        time = __dateNow(),
        job = _sortedByPriorityJobs.shift();

    // Execute the job and look at the result:
    test = job.job();

    // Deal with stats:
    time = __dateNow() - time;
    job.done++;
    job.time += time;
    job.currentTime += time;
    job.weightTime = job.currentTime / (job.weight || 1);
    job.averageTime = job.time / job.done;

    // Check if the job has to be killed:
    kill = job.count ? (job.count <= job.done) : !test;

    // Reset priorities:
    if (!kill) {
      for (i = 0, l = _sortedByPriorityJobs.length; i < l; i++)
        if (_sortedByPriorityJobs[i].weightTime > job.weightTime) {
          _sortedByPriorityJobs.splice(i, 0, job);
          pushed = true;
          break;
        }

      if (!pushed)
        _sortedByPriorityJobs.push(job);
    }

    return kill ? job : null;
  }

  /**
   * Activates a job, by adding it to the _runningJobs object and the
   * _sortedByPriorityJobs array. It also initializes its currentTime value.
   *
   * @param  {Object} job The job to activate.
   */
  function _activateJob(job) {
    var l = _sortedByPriorityJobs.length;

    // Add the job to the running jobs:
    _runningJobs[job.id] = job;
    job.status = 'running';

    // Add the job to the priorities:
    if (l) {
      job.weightTime = _sortedByPriorityJobs[l - 1].weightTime;
      job.currentTime = job.weightTime * (job.weight || 1);
    }

    // Initialize the job and dispatch:
    job.startTime = __dateNow();
    _dispatch('jobStarted', __clone(job));

    _sortedByPriorityJobs.push(job);
  }

  /**
   * The main loop of conrad.js:
   *  . It executes job such that they all occupate the same processing time.
   *  . It stops jobs that do not need to be executed anymore.
   *  . It triggers callbacks when it is relevant.
   *  . It starts waiting jobs when they need to be started.
   *  . It injects frames to keep a constant frapes per second ratio.
   *  . It stops itself when there are no more jobs to execute.
   */
  function _loop() {
    var k,
        o,
        l,
        job,
        time,
        deadJob;

    // Deal with the newly added jobs (the _jobs object):
    for (k in _jobs) {
      job = _jobs[k];

      if (job.after)
        _waitingJobs[k] = job;
      else
        _activateJob(job);

      delete _jobs[k];
    }

    // Set the _isRunning flag to false if there are no running job:
    _isRunning = !!_sortedByPriorityJobs.length;

    // Deal with the running jobs (the _runningJobs object):
    while (
      _sortedByPriorityJobs.length &&
      __dateNow() - _lastFrameTime < _parameters.frameDuration
    ) {
      deadJob = _executeFirstJob();

      // Deal with the case where the job has ended:
      if (deadJob) {
        _killJob(deadJob.id);

        // Check for waiting jobs:
        for (k in _waitingJobs)
          if (_waitingJobs[k].after === deadJob.id) {
            _activateJob(_waitingJobs[k]);
            delete _waitingJobs[k];
          }
      }
    }

    // Check if conrad still has jobs to deal with, and kill it if not:
    if (_isRunning) {
      // Update the _lastFrameTime:
      _lastFrameTime = __dateNow();

      _dispatch('enterFrame');
      setTimeout(_loop, 0);
    } else
      _dispatch('stop');
  }

  /**
   * Adds one or more jobs, and starts the loop if no job was running before. A
   * job is at least a unique string "id" and a function, and there are some
   * parameters that you can specify for each job to modify the way conrad will
   * execute it. If a job is added with the "id" of another job that is waiting
   * or still running, an error will be thrown.
   *
   * When a job is added, it is referenced in the _jobs object, by its id.
   * Then, if it has to be executed right now, it will be also referenced in
   * the _runningJobs object. If it has to wait, then it will be added into the
   * _waitingJobs object, until it can start.
   *
   * Keep reading this documentation to see how to call this method.
   *
   * @return {Object} Returns conrad.
   *
   * Adding one job:
   * ***************
   * Basically, a job is defined by its string id and a function (the job). It
   * is also possible to add some parameters:
   *
   *  > conrad.addJob('myJobId', myJobFunction);
   *  > conrad.addJob('myJobId', {
   *  >   job: myJobFunction,
   *  >   someParameter: someValue
   *  > });
   *  > conrad.addJob({
   *  >   id: 'myJobId',
   *  >   job: myJobFunction,
   *  >   someParameter: someValue
   *  > });
   *
   * Adding several jobs:
   * ********************
   * When adding several jobs at the same time, it is possible to specify
   * parameters for each one individually or for all:
   *
   *  > conrad.addJob([
   *  >   {
   *  >     id: 'myJobId1',
   *  >     job: myJobFunction1,
   *  >     someParameter1: someValue1
   *  >   },
   *  >   {
   *  >     id: 'myJobId2',
   *  >     job: myJobFunction2,
   *  >     someParameter2: someValue2
   *  >   }
   *  > ], {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *  > conrad.addJob({
   *  >   myJobId1: {,
   *  >     job: myJobFunction1,
   *  >     someParameter1: someValue1
   *  >   },
   *  >   myJobId2: {,
   *  >     job: myJobFunction2,
   *  >     someParameter2: someValue2
   *  >   }
   *  > }, {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *  > conrad.addJob({
   *  >   myJobId1: myJobFunction1,
   *  >   myJobId2: myJobFunction2
   *  > }, {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *
   *  Recognized parameters:
   *  **********************
   *  Here is the exhaustive list of every accepted parameters:
   *
   *    {?Function} end      A callback to execute when the job is ended. It is
   *                         not executed if the job is killed instead of ended
   *                         "naturally".
   *    {?Integer}  count    The number of time the job has to be executed.
   *    {?Number}   weight   If specified, the job will be executed as it was
   *                         added "weight" times.
   *    {?String}   after    The id of another job (eventually not added yet).
   *                         If specified, this job will start only when the
   *                         specified "after" job is ended.
   */
  function _addJob(v1, v2) {
    var i,
        l,
        o;

    // Array of jobs:
    if (Array.isArray(v1)) {
      // Keep conrad to start until the last job is added:
      _noStart = true;

      for (i = 0, l = v1.length; i < l; i++)
        _addJob(v1[i].id, __extend(v1[i], v2));

      _noStart = false;
      if (!_isRunning) {
        // Update the _lastFrameTime:
        _lastFrameTime = __dateNow();

        _dispatch('start');
        _loop();
      }
    } else if (typeof v1 === 'object') {
      // One job (object):
      if (typeof v1.id === 'string')
        _addJob(v1.id, v1);

      // Hash of jobs:
      else {
        // Keep conrad to start until the last job is added:
        _noStart = true;

        for (i in v1)
          if (typeof v1[i] === 'function')
            _addJob(i, __extend({
              job: v1[i]
            }, v2));
          else
            _addJob(i, __extend(v1[i], v2));

        _noStart = false;
        if (!_isRunning) {
          // Update the _lastFrameTime:
          _lastFrameTime = __dateNow();

          _dispatch('start');
          _loop();
        }
      }

    // One job (string, *):
    } else if (typeof v1 === 'string') {
      if (_hasJob(v1))
        throw new Error(
          '[conrad.addJob] Job with id "' + v1 + '" already exists.'
        );

      // One job (string, function):
      if (typeof v2 === 'function') {
        o = {
          id: v1,
          done: 0,
          time: 0,
          status: 'waiting',
          currentTime: 0,
          averageTime: 0,
          weightTime: 0,
          job: v2
        };

      // One job (string, object):
      } else if (typeof v2 === 'object') {
        o = __extend(
          {
            id: v1,
            done: 0,
            time: 0,
            status: 'waiting',
            currentTime: 0,
            averageTime: 0,
            weightTime: 0
          },
          v2
        );

      // If none of those cases, throw an error:
      } else
        throw new Error('[conrad.addJob] Wrong arguments.');

      // Effectively add the job:
      _jobs[v1] = o;
      _dispatch('jobAdded', __clone(o));

      // Check if the loop has to be started:
      if (!_isRunning && !_noStart) {
        // Update the _lastFrameTime:
        _lastFrameTime = __dateNow();

        _dispatch('start');
        _loop();
      }

    // If none of those cases, throw an error:
    } else
      throw new Error('[conrad.addJob] Wrong arguments.');

    return this;
  }

  /**
   * Kills one or more jobs, indicated by their ids. It is only possible to
   * kill running jobs or waiting jobs. If you try to kill a job that does not
   * exist or that is already killed, a warning will be thrown.
   *
   * @param  {Array|String} v1 A string job id or an array of job ids.
   * @return {Object}       Returns conrad.
   */
  function _killJob(v1) {
    var i,
        l,
        k,
        a,
        job,
        found = false;

    // Array of job ids:
    if (Array.isArray(v1))
      for (i = 0, l = v1.length; i < l; i++)
        _killJob(v1[i]);

    // One job's id:
    else if (typeof v1 === 'string') {
      a = [_runningJobs, _waitingJobs, _jobs];

      // Remove the job from the hashes:
      for (i = 0, l = a.length; i < l; i++)
        if (v1 in a[i]) {
          job = a[i][v1];

          if (_parameters.history) {
            job.status = 'done';
            _doneJobs.push(job);
          }

          _dispatch('jobEnded', __clone(job));
          delete a[i][v1];

          if (typeof job.end === 'function')
            job.end();

          found = true;
        }

      // Remove the priorities array:
      a = _sortedByPriorityJobs;
      for (i = 0, l = a.length; i < l; i++)
        if (a[i].id === v1) {
          a.splice(i, 1);
          break;
        }

      if (!found)
        throw new Error('[conrad.killJob] Job "' + v1 + '" not found.');

    // If none of those cases, throw an error:
    } else
      throw new Error('[conrad.killJob] Wrong arguments.');

    return this;
  }

  /**
   * Kills every running, waiting, and just added jobs.
   *
   * @return {Object} Returns conrad.
   */
  function _killAll() {
    var k,
        jobs = __extend(_jobs, _runningJobs, _waitingJobs);

    // Take every jobs and push them into the _doneJobs object:
    if (_parameters.history)
      for (k in jobs) {
        jobs[k].status = 'done';
        _doneJobs.push(jobs[k]);

        if (typeof jobs[k].end === 'function')
          jobs[k].end();
      }

    // Reinitialize the different jobs lists:
    _jobs = {};
    _waitingJobs = {};
    _runningJobs = {};
    _sortedByPriorityJobs = [];

    // In case some jobs are added right after the kill:
    _isRunning = false;

    return this;
  }

  /**
   * Returns true if a job with the specified id is currently running or
   * waiting, and false else.
   *
   * @param  {String}  id The id of the job.
   * @return {?Object} Returns the job object if it exists.
   */
  function _hasJob(id) {
    var job = _jobs[id] || _runningJobs[id] || _waitingJobs[id];
    return job ? __extend(job) : null;
  }

  /**
   * This method will set the setting specified by "v1" to the value specified
   * by "v2" if both are given, and else return the current value of the
   * settings "v1".
   *
   * @param  {String}   v1 The name of the property.
   * @param  {?*}       v2 Eventually, a value to set to the specified
   *                       property.
   * @return {Object|*} Returns the specified settings value if "v2" is not
   *                    given, and conrad else.
   */
  function _settings(v1, v2) {
    var o;

    if (typeof a1 === 'string' && arguments.length === 1)
      return _parameters[a1];
    else {
      o = (typeof a1 === 'object' && arguments.length === 1) ?
        a1 || {} :
        {};
      if (typeof a1 === 'string')
        o[a1] = a2;

      for (var k in o)
        if (o[k] !== undefined)
          _parameters[k] = o[k];
        else
          delete _parameters[k];

      return this;
    }
  }

  /**
   * Returns true if conrad is currently running, and false else.
   *
   * @return {Boolean} Returns _isRunning.
   */
  function _getIsRunning() {
    return _isRunning;
  }

  /**
   * Unreference every job that is stored in the _doneJobs object. It will
   * not be possible anymore to get stats about these jobs, but it will release
   * the memory.
   *
   * @return {Object} Returns conrad.
   */
  function _clearHistory() {
    _doneJobs = [];
    return this;
  }

  /**
   * Returns a snapshot of every data about jobs that wait to be started, are
   * currently running or are done.
   *
   * It is possible to get only running, waiting or done jobs by giving
   * "running", "waiting" or "done" as fist argument.
   *
   * It is also possible to get every job with a specified id by giving it as
   * first argument. Also, using a RegExp instead of an id will return every
   * jobs whose ids match the RegExp. And these two last use cases work as well
   * by giving before "running", "waiting" or "done".
   *
   * @return {Array} The array of the matching jobs.
   *
   * Some call examples:
   * *******************
   *  > conrad.getStats('running')
   *  > conrad.getStats('waiting')
   *  > conrad.getStats('done')
   *  > conrad.getStats('myJob')
   *  > conrad.getStats(/test/)
   *  > conrad.getStats('running', 'myRunningJob')
   *  > conrad.getStats('running', /test/)
   */
  function _getStats(v1, v2) {
    var a,
        k,
        i,
        l,
        stats,
        pattern,
        isPatternString;

    if (!arguments.length) {
      stats = [];

      for (k in _jobs)
        stats.push(_jobs[k]);

      for (k in _waitingJobs)
        stats.push(_waitingJobs[k]);

      for (k in _runningJobs)
        stats.push(_runningJobs[k]);

      stats = stats.concat(_doneJobs);
    }

    if (typeof v1 === 'string')
      switch (v1) {
        case 'waiting':
          stats = __objectValues(_waitingJobs);
          break;
        case 'running':
          stats = __objectValues(_runningJobs);
          break;
        case 'done':
          stats = _doneJobs;
          break;
        default:
          pattern = v1;
      }

    if (v1 instanceof RegExp)
      pattern = v1;

    if (!pattern && (typeof v2 === 'string' || v2 instanceof RegExp))
      pattern = v2;

    // Filter jobs if a pattern is given:
    if (pattern) {
      isPatternString = typeof pattern === 'string';

      if (stats instanceof Array) {
        a = stats;
      } else if (typeof stats === 'object') {
        a = [];

        for (k in stats)
          a = a.concat(stats[k]);
      } else {
        a = [];

        for (k in _jobs)
          a.push(_jobs[k]);

        for (k in _waitingJobs)
          a.push(_waitingJobs[k]);

        for (k in _runningJobs)
          a.push(_runningJobs[k]);

        a = a.concat(_doneJobs);
      }

      stats = [];
      for (i = 0, l = a.length; i < l; i++)
        if (isPatternString ? a[i].id === pattern : a[i].id.match(pattern))
          stats.push(a[i]);
    }

    return __clone(stats);
  }


  /**
   * TOOLS FUNCTIONS:
   * ****************
   */

  /**
   * This function takes any number of objects as arguments, copies from each
   * of these objects each pair key/value into a new object, and finally
   * returns this object.
   *
   * The arguments are parsed from the last one to the first one, such that
   * when two objects have keys in common, the "earliest" object wins.
   *
   * Example:
   * ********
   *  > var o1 = {
   *  >       a: 1,
   *  >       b: 2,
   *  >       c: '3'
   *  >     },
   *  >     o2 = {
   *  >       c: '4',
   *  >       d: [ 5 ]
   *  >     };
   *  > __extend(o1, o2);
   *  > // Returns: {
   *  > //   a: 1,
   *  > //   b: 2,
   *  > //   c: '3',
   *  > //   d: [ 5 ]
   *  > // };
   *
   * @param  {Object+} Any number of objects.
   * @return {Object}  The merged object.
   */
  function __extend() {
    var i,
        k,
        res = {},
        l = arguments.length;

    for (i = l - 1; i >= 0; i--)
      for (k in arguments[i])
        res[k] = arguments[i][k];

    return res;
  }

  /**
   * This function simply clones an object. This object must contain only
   * objects, arrays and immutable values. Since it is not public, it does not
   * deal with cyclic references, DOM elements and instantiated objects - so
   * use it carefully.
   *
   * @param  {Object} The object to clone.
   * @return {Object} The clone.
   */
  function __clone(item) {
    var result, i, k, l;

    if (!item)
      return item;

    if (Array.isArray(item)) {
      result = [];
      for (i = 0, l = item.length; i < l; i++)
        result.push(__clone(item[i]));
    } else if (typeof item === 'object') {
      result = {};
      for (i in item)
        result[i] = __clone(item[i]);
    } else
      result = item;

    return result;
  }

  /**
   * Returns an array containing the values of an object.
   *
   * @param  {Object} The object.
   * @return {Array}  The array of values.
   */
  function __objectValues(o) {
    var k,
        a = [];

    for (k in o)
      a.push(o[k]);

    return a;
  }

  /**
   * A short "Date.now()" polyfill.
   *
   * @return {Number} The current time (in ms).
   */
  function __dateNow() {
    return Date.now ? Date.now() : new Date().getTime();
  }

  /**
   * Polyfill for the Array.isArray function:
   */
  if (!Array.isArray)
    Array.isArray = function(v) {
      return Object.prototype.toString.call(v) === '[object Array]';
    };


  /**
   * EXPORT PUBLIC API:
   * ******************
   */
  var conrad = {
    hasJob: _hasJob,
    addJob: _addJob,
    killJob: _killJob,
    killAll: _killAll,
    settings: _settings,
    getStats: _getStats,
    isRunning: _getIsRunning,
    clearHistory: _clearHistory,

    // Events management:
    bind: _bind,
    unbind: _unbind,

    // Version:
    version: '0.1.0'
  };

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = conrad;
    exports.conrad = conrad;
  }
  global.conrad = conrad;
})(this);

// Hardcoded export for the node.js version:
var sigma = this.sigma,
    conrad = this.conrad;

sigma.conrad = conrad;

// Dirty polyfills to permit sigma usage in node
if (typeof HTMLElement === 'undefined')
  HTMLElement = function() {};

if (typeof window === 'undefined')
  window = {
    addEventListener: function() {}
  };

if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports)
    exports = module.exports = sigma;
  exports.sigma = sigma;
}

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  var _root = this;

  // Initialize packages:
  sigma.utils = sigma.utils || {};

  /**
   * MISC UTILS:
   */
  /**
   * This function takes any number of objects as arguments, copies from each
   * of these objects each pair key/value into a new object, and finally
   * returns this object.
   *
   * The arguments are parsed from the last one to the first one, such that
   * when several objects have keys in common, the "earliest" object wins.
   *
   * Example:
   * ********
   *  > var o1 = {
   *  >       a: 1,
   *  >       b: 2,
   *  >       c: '3'
   *  >     },
   *  >     o2 = {
   *  >       c: '4',
   *  >       d: [ 5 ]
   *  >     };
   *  > sigma.utils.extend(o1, o2);
   *  > // Returns: {
   *  > //   a: 1,
   *  > //   b: 2,
   *  > //   c: '3',
   *  > //   d: [ 5 ]
   *  > // };
   *
   * @param  {object+} Any number of objects.
   * @return {object}  The merged object.
   */
  sigma.utils.extend = function() {
    var i,
        k,
        res = {},
        l = arguments.length;

    for (i = l - 1; i >= 0; i--)
      for (k in arguments[i])
        res[k] = arguments[i][k];

    return res;
  };

  /**
   * A short "Date.now()" polyfill.
   *
   * @return {Number} The current time (in ms).
   */
  sigma.utils.dateNow = function() {
    return Date.now ? Date.now() : new Date().getTime();
  };

  /**
   * Takes a package name as parameter and checks at each lebel if it exists,
   * and if it does not, creates it.
   *
   * Example:
   * ********
   *  > sigma.utils.pkg('a.b.c');
   *  > a.b.c;
   *  > // Object {};
   *  >
   *  > sigma.utils.pkg('a.b.d');
   *  > a.b;
   *  > // Object { c: {}, d: {} };
   *
   * @param  {string} pkgName The name of the package to create/find.
   * @return {object}         The related package.
   */
  sigma.utils.pkg = function(pkgName) {
    return (pkgName || '').split('.').reduce(function(context, objName) {
      return (objName in context) ?
        context[objName] :
        (context[objName] = {});
    }, _root);
  };

  /**
   * Returns a unique incremental number ID.
   *
   * Example:
   * ********
   *  > sigma.utils.id();
   *  > // 1;
   *  >
   *  > sigma.utils.id();
   *  > // 2;
   *  >
   *  > sigma.utils.id();
   *  > // 3;
   *
   * @param  {string} pkgName The name of the package to create/find.
   * @return {object}         The related package.
   */
  sigma.utils.id = (function() {
    var i = 0;
    return function() {
      return ++i;
    };
  })();

  /**
   * This function takes an hexa color (for instance "#ffcc00" or "#fc0") or a
   * rgb / rgba color (like "rgb(255,255,12)" or "rgba(255,255,12,1)") and
   * returns an integer equal to "r * 255 * 255 + g * 255 + b", to gain some
   * memory in the data given to WebGL shaders.
   *
   * Note that the function actually caches its results for better performance.
   *
   * @param  {string} val The hexa or rgba color.
   * @return {number}     The number value.
   */
  var floatColorCache = {};

  sigma.utils.floatColor = function(val) {

    // Is the color already computed?
    if (floatColorCache[val])
      return floatColorCache[val];

    var original = val,
        r = 0,
        g = 0,
        b = 0;

    if (val[0] === '#') {
      val = val.slice(1);

      if (val.length === 3) {
        r = parseInt(val.charAt(0) + val.charAt(0), 16);
        g = parseInt(val.charAt(1) + val.charAt(1), 16);
        b = parseInt(val.charAt(2) + val.charAt(2), 16);
      }
      else {
        r = parseInt(val.charAt(0) + val.charAt(1), 16);
        g = parseInt(val.charAt(2) + val.charAt(3), 16);
        b = parseInt(val.charAt(4) + val.charAt(5), 16);
      }
    } else if (val.match(/^ *rgba? *\(/)) {
      val = val.match(
        /^ *rgba? *\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\) *$/
      );
      r = +val[1];
      g = +val[2];
      b = +val[3];
    }

    var color = (
      r * 256 * 256 +
      g * 256 +
      b
    );

    // Caching the color
    floatColorCache[original] = color;

    return color;
  };

    /**
   * Perform a zoom into a camera, with or without animation, to the
   * coordinates indicated using a specified ratio.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the animation
   * object:
   *
   *   {?number} duration     An amount of time that means the duration of the
   *                          animation. If this parameter doesn't exist the
   *                          zoom will be performed without animation.
   *   {?function} onComplete A function to perform it after the animation. It
   *                          will be performed even if there is no duration.
   *
   * @param {camera}     The camera where perform the zoom.
   * @param {x}          The X coordiantion where the zoom goes.
   * @param {y}          The Y coordiantion where the zoom goes.
   * @param {ratio}      The ratio to apply it to the current camera ratio.
   * @param {?animation} A dictionary with options for a possible animation.
   */
  sigma.utils.zoomTo = function(camera, x, y, ratio, animation) {
    var settings = camera.settings,
        count,
        newRatio,
        animationSettings,
        coordinates;

    // Create the newRatio dealing with min / max:
    newRatio = Math.max(
      settings('zoomMin'),
      Math.min(
        settings('zoomMax'),
        camera.ratio * ratio
      )
    );

    // Check that the new ratio is different from the initial one:
    if (newRatio !== camera.ratio) {
      // Create the coordinates variable:
      ratio = newRatio / camera.ratio;
      coordinates = {
        x: x * (1 - ratio) + camera.x,
        y: y * (1 - ratio) + camera.y,
        ratio: newRatio
      };

      if (animation && animation.duration) {
        // Complete the animation setings:
        count = sigma.misc.animation.killAll(camera);
        animation = sigma.utils.extend(
          animation,
          {
            easing: count ? 'quadraticOut' : 'quadraticInOut'
          }
        );

        sigma.misc.animation.camera(camera, coordinates, animation);
      } else {
        camera.goTo(coordinates);
        if (animation && animation.onComplete)
          animation.onComplete();
      }
    }
  };

  /**
   * Return the control point coordinates for a quadratic bezier curve.
   *
   * @param  {number} x1  The X coordinate of the start point.
   * @param  {number} y1  The Y coordinate of the start point.
   * @param  {number} x2  The X coordinate of the end point.
   * @param  {number} y2  The Y coordinate of the end point.
   * @return {x,y}        The control point coordinates.
   */
  sigma.utils.getQuadraticControlPoint = function(x1, y1, x2, y2) {
    return {
      x: (x1 + x2) / 2 + (y2 - y1) / 4,
      y: (y1 + y2) / 2 + (x1 - x2) / 4
    };
  };

  /**
    * Compute the coordinates of the point positioned
    * at length t in the quadratic bezier curve.
    *
    * @param  {number} t  In [0,1] the step percentage to reach
    *                     the point in the curve from the context point.
    * @param  {number} x1 The X coordinate of the context point.
    * @param  {number} y1 The Y coordinate of the context point.
    * @param  {number} x2 The X coordinate of the ending point.
    * @param  {number} y2 The Y coordinate of the ending point.
    * @param  {number} xi The X coordinate of the control point.
    * @param  {number} yi The Y coordinate of the control point.
    * @return {object}    {x,y}.
  */
  sigma.utils.getPointOnQuadraticCurve = function(t, x1, y1, x2, y2, xi, yi) {
    // http://stackoverflow.com/a/5634528
    return {
      x: Math.pow(1 - t, 2) * x1 + 2 * (1 - t) * t * xi + Math.pow(t, 2) * x2,
      y: Math.pow(1 - t, 2) * y1 + 2 * (1 - t) * t * yi + Math.pow(t, 2) * y2
    };
  };

  /**
    * Compute the coordinates of the point positioned
    * at length t in the cubic bezier curve.
    *
    * @param  {number} t  In [0,1] the step percentage to reach
    *                     the point in the curve from the context point.
    * @param  {number} x1 The X coordinate of the context point.
    * @param  {number} y1 The Y coordinate of the context point.
    * @param  {number} x2 The X coordinate of the end point.
    * @param  {number} y2 The Y coordinate of the end point.
    * @param  {number} cx The X coordinate of the first control point.
    * @param  {number} cy The Y coordinate of the first control point.
    * @param  {number} dx The X coordinate of the second control point.
    * @param  {number} dy The Y coordinate of the second control point.
    * @return {object}    {x,y} The point at t.
  */
  sigma.utils.getPointOnBezierCurve =
    function(t, x1, y1, x2, y2, cx, cy, dx, dy) {
    // http://stackoverflow.com/a/15397596
    // Blending functions:
    var B0_t = Math.pow(1 - t, 3),
        B1_t = 3 * t * Math.pow(1 - t, 2),
        B2_t = 3 * Math.pow(t, 2) * (1 - t),
        B3_t = Math.pow(t, 3);

    return {
      x: (B0_t * x1) + (B1_t * cx) + (B2_t * dx) + (B3_t * x2),
      y: (B0_t * y1) + (B1_t * cy) + (B2_t * dy) + (B3_t * y2)
    };
  };

  /**
   * Return the coordinates of the two control points for a self loop (i.e.
   * where the start point is also the end point) computed as a cubic bezier
   * curve.
   *
   * @param  {number} x    The X coordinate of the node.
   * @param  {number} y    The Y coordinate of the node.
   * @param  {number} size The node size.
   * @return {x1,y1,x2,y2} The coordinates of the two control points.
   */
  sigma.utils.getSelfLoopControlPoints = function(x , y, size) {
    return {
      x1: x - size * 7,
      y1: y,
      x2: x,
      y2: y + size * 7
    };
  };

  /**
   * Return the euclidian distance between two points of a plane
   * with an orthonormal basis.
   *
   * @param  {number} x1  The X coordinate of the first point.
   * @param  {number} y1  The Y coordinate of the first point.
   * @param  {number} x2  The X coordinate of the second point.
   * @param  {number} y2  The Y coordinate of the second point.
   * @return {number}     The euclidian distance.
   */
  sigma.utils.getDistance = function(x0, y0, x1, y1) {
    return Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));
  };

  /**
   * Return the coordinates of the intersection points of two circles.
   *
   * @param  {number} x0  The X coordinate of center location of the first
   *                      circle.
   * @param  {number} y0  The Y coordinate of center location of the first
   *                      circle.
   * @param  {number} r0  The radius of the first circle.
   * @param  {number} x1  The X coordinate of center location of the second
   *                      circle.
   * @param  {number} y1  The Y coordinate of center location of the second
   *                      circle.
   * @param  {number} r1  The radius of the second circle.
   * @return {xi,yi}      The coordinates of the intersection points.
   */
  sigma.utils.getCircleIntersection = function(x0, y0, r0, x1, y1, r1) {
    // http://stackoverflow.com/a/12219802
    var a, dx, dy, d, h, rx, ry, x2, y2;

    // dx and dy are the vertical and horizontal distances between the circle
    // centers:
    dx = x1 - x0;
    dy = y1 - y0;

    // Determine the straight-line distance between the centers:
    d = Math.sqrt((dy * dy) + (dx * dx));

    // Check for solvability:
    if (d > (r0 + r1)) {
        // No solution. circles do not intersect.
        return false;
    }
    if (d < Math.abs(r0 - r1)) {
        // No solution. one circle is contained in the other.
        return false;
    }

    //'point 2' is the point where the line through the circle intersection
    // points crosses the line between the circle centers.

    // Determine the distance from point 0 to point 2:
    a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);

    // Determine the coordinates of point 2:
    x2 = x0 + (dx * a / d);
    y2 = y0 + (dy * a / d);

    // Determine the distance from point 2 to either of the intersection
    // points:
    h = Math.sqrt((r0 * r0) - (a * a));

    // Determine the offsets of the intersection points from point 2:
    rx = -dy * (h / d);
    ry = dx * (h / d);

    // Determine the absolute intersection points:
    var xi = x2 + rx;
    var xi_prime = x2 - rx;
    var yi = y2 + ry;
    var yi_prime = y2 - ry;

    return {xi: xi, xi_prime: xi_prime, yi: yi, yi_prime: yi_prime};
  };

  /**
    * Check if a point is on a line segment.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the line start point.
    * @param  {number} y1      The Y coordinate of the line start point.
    * @param  {number} x2      The X coordinate of the line end point.
    * @param  {number} y2      The Y coordinate of the line end point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if point is "close to" the line
    *                          segment, false otherwise.
  */
  sigma.utils.isPointOnSegment = function(x, y, x1, y1, x2, y2, epsilon) {
    // http://stackoverflow.com/a/328122
    var crossProduct = Math.abs((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)),
        d = sigma.utils.getDistance(x1, y1, x2, y2),
        nCrossProduct = crossProduct / d; // normalized cross product

    return (nCrossProduct < epsilon &&
     Math.min(x1, x2) <= x && x <= Math.max(x1, x2) &&
     Math.min(y1, y2) <= y && y <= Math.max(y1, y2));
  };

  /**
    * Check if a point is on a quadratic bezier curve segment with a thickness.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the curve start point.
    * @param  {number} y1      The Y coordinate of the curve start point.
    * @param  {number} x2      The X coordinate of the curve end point.
    * @param  {number} y2      The Y coordinate of the curve end point.
    * @param  {number} cpx     The X coordinate of the curve control point.
    * @param  {number} cpy     The Y coordinate of the curve control point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if (x,y) is on the curve segment,
    *                          false otherwise.
  */
  sigma.utils.isPointOnQuadraticCurve =
    function(x, y, x1, y1, x2, y2, cpx, cpy, epsilon) {
    // Fails if the point is too far from the extremities of the segment,
    // preventing for more costly computation:
    var dP1P2 = sigma.utils.getDistance(x1, y1, x2, y2);
    if (Math.abs(x - x1) > dP1P2 || Math.abs(y - y1) > dP1P2) {
      return false;
    }

    var dP1 = sigma.utils.getDistance(x, y, x1, y1),
        dP2 = sigma.utils.getDistance(x, y, x2, y2),
        t = 0.5,
        r = (dP1 < dP2) ? -0.01 : 0.01,
        rThreshold = 0.001,
        i = 100,
        pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy),
        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),
        old_dt;

    // This algorithm minimizes the distance from the point to the curve. It
    // find the optimal t value where t=0 is the start point and t=1 is the end
    // point of the curve, starting from t=0.5.
    // It terminates because it runs a maximum of i interations.
    while (i-- > 0 &&
      t >= 0 && t <= 1 &&
      (dt > epsilon) &&
      (r > rThreshold || r < -rThreshold)) {
      old_dt = dt;
      pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy);
      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);

      if (dt > old_dt) {
        // not the right direction:
        // halfstep in the opposite direction
        r = -r / 2;
        t += r;
      }
      else if (t + r < 0 || t + r > 1) {
        // oops, we've gone too far:
        // revert with a halfstep
        r = r / 2;
        dt = old_dt;
      }
      else {
        // progress:
        t += r;
      }
    }

    return dt < epsilon;
  };


  /**
    * Check if a point is on a cubic bezier curve segment with a thickness.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the curve start point.
    * @param  {number} y1      The Y coordinate of the curve start point.
    * @param  {number} x2      The X coordinate of the curve end point.
    * @param  {number} y2      The Y coordinate of the curve end point.
    * @param  {number} cpx1    The X coordinate of the 1st curve control point.
    * @param  {number} cpy1    The Y coordinate of the 1st curve control point.
    * @param  {number} cpx2    The X coordinate of the 2nd curve control point.
    * @param  {number} cpy2    The Y coordinate of the 2nd curve control point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if (x,y) is on the curve segment,
    *                          false otherwise.
  */
  sigma.utils.isPointOnBezierCurve =
    function(x, y, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2, epsilon) {
    // Fails if the point is too far from the extremities of the segment,
    // preventing for more costly computation:
    var dP1CP1 = sigma.utils.getDistance(x1, y1, cpx1, cpy1);
    if (Math.abs(x - x1) > dP1CP1 || Math.abs(y - y1) > dP1CP1) {
      return false;
    }

    var dP1 = sigma.utils.getDistance(x, y, x1, y1),
        dP2 = sigma.utils.getDistance(x, y, x2, y2),
        t = 0.5,
        r = (dP1 < dP2) ? -0.01 : 0.01,
        rThreshold = 0.001,
        i = 100,
        pt = sigma.utils.getPointOnBezierCurve(
          t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2),
        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),
        old_dt;

    // This algorithm minimizes the distance from the point to the curve. It
    // find the optimal t value where t=0 is the start point and t=1 is the end
    // point of the curve, starting from t=0.5.
    // It terminates because it runs a maximum of i interations.
    while (i-- > 0 &&
      t >= 0 && t <= 1 &&
      (dt > epsilon) &&
      (r > rThreshold || r < -rThreshold)) {
      old_dt = dt;
      pt = sigma.utils.getPointOnBezierCurve(
        t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2);
      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);

      if (dt > old_dt) {
        // not the right direction:
        // halfstep in the opposite direction
        r = -r / 2;
        t += r;
      }
      else if (t + r < 0 || t + r > 1) {
        // oops, we've gone too far:
        // revert with a halfstep
        r = r / 2;
        dt = old_dt;
      }
      else {
        // progress:
        t += r;
      }
    }

    return dt < epsilon;
  };


  /**
   * ************
   * EVENTS UTILS:
   * ************
   */
  /**
   * Here are some useful functions to unify extraction of the information we
   * need with mouse events and touch events, from different browsers:
   */

  /**
   * Extract the local X position from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The local X value of the mouse.
   */
  sigma.utils.getX = function(e) {
    return (
      (e.offsetX !== undefined && e.offsetX) ||
      (e.layerX !== undefined && e.layerX) ||
      (e.clientX !== undefined && e.clientX)
    );
  };

  /**
   * Extract the local Y position from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The local Y value of the mouse.
   */
  sigma.utils.getY = function(e) {
    return (
      (e.offsetY !== undefined && e.offsetY) ||
      (e.layerY !== undefined && e.layerY) ||
      (e.clientY !== undefined && e.clientY)
    );
  };

  /**
   * The pixel ratio of the screen. Taking zoom into account
   *
   * @return {number}        Pixel ratio of the screen
   */
  sigma.utils.getPixelRatio = function() {
    var ratio = 1;
    if (window.screen.deviceXDPI !== undefined &&
         window.screen.logicalXDPI !== undefined &&
         window.screen.deviceXDPI > window.screen.logicalXDPI) {
        ratio = window.screen.systemXDPI / window.screen.logicalXDPI;
    }
    else if (window.devicePixelRatio !== undefined) {
        ratio = window.devicePixelRatio;
    }
    return ratio;
  };

  /**
   * Extract the width from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The width of the event's target.
   */
  sigma.utils.getWidth = function(e) {
    var w = (!e.target.ownerSVGElement) ?
              e.target.width :
              e.target.ownerSVGElement.width;

    return (
      (typeof w === 'number' && w) ||
      (w !== undefined && w.baseVal !== undefined && w.baseVal.value)
    );
  };

  /**
   * Extract the center from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {object}   The center of the event's target.
   */
  sigma.utils.getCenter = function(e) {
    var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 :
        sigma.utils.getPixelRatio();
    return {
      x: sigma.utils.getWidth(e) / (2 * ratio),
      y: sigma.utils.getHeight(e) / (2 * ratio)
    };
  };

  /**
   * Convert mouse coords to sigma coords
   *
   * @param  {event}   e A mouse or touch event.
   * @param  {number?} x The x coord to convert
   * @param  {number?} x The y coord to convert
   *
   * @return {object}    The standardized event
   */
  sigma.utils.mouseCoords = function(e, x, y) {
    x = x || sigma.utils.getX(e);
    y = y || sigma.utils.getY(e);
    return {
        x: x - sigma.utils.getCenter(e).x,
        y: y - sigma.utils.getCenter(e).y,
        clientX: e.clientX,
        clientY: e.clientY,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey,
        shiftKey: e.shiftKey
    };
  };

  /**
   * Extract the height from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The height of the event's target.
   */
  sigma.utils.getHeight = function(e) {
    var h = (!e.target.ownerSVGElement) ?
              e.target.height :
              e.target.ownerSVGElement.height;

    return (
      (typeof h === 'number' && h) ||
      (h !== undefined && h.baseVal !== undefined && h.baseVal.value)
    );
  };

  /**
   * Extract the wheel delta from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The wheel delta of the mouse.
   */
  sigma.utils.getDelta = function(e) {
    return (
      (e.wheelDelta !== undefined && e.wheelDelta) ||
      (e.detail !== undefined && -e.detail)
    );
  };

  /**
   * Returns the offset of a DOM element.
   *
   * @param  {DOMElement} dom The element to retrieve the position.
   * @return {object}         The offset of the DOM element (top, left).
   */
  sigma.utils.getOffset = function(dom) {
    var left = 0,
        top = 0;

    while (dom) {
      top = top + parseInt(dom.offsetTop);
      left = left + parseInt(dom.offsetLeft);
      dom = dom.offsetParent;
    }

    return {
      top: top,
      left: left
    };
  };

  /**
   * Simulates a "double click" event.
   *
   * @param  {HTMLElement} target   The event target.
   * @param  {string}      type     The event type.
   * @param  {function}    callback The callback to execute.
   */
  sigma.utils.doubleClick = function(target, type, callback) {
    var clicks = 0,
        self = this,
        handlers;

    target._doubleClickHandler = target._doubleClickHandler || {};
    target._doubleClickHandler[type] = target._doubleClickHandler[type] || [];
    handlers = target._doubleClickHandler[type];

    handlers.push(function(e) {
      clicks++;

      if (clicks === 2) {
        clicks = 0;
        return callback(e);
      } else if (clicks === 1) {
        setTimeout(function() {
          clicks = 0;
        }, sigma.settings.doubleClickTimeout);
      }
    });

    target.addEventListener(type, handlers[handlers.length - 1], false);
  };

  /**
   * Unbind simulated "double click" events.
   *
   * @param  {HTMLElement} target   The event target.
   * @param  {string}      type     The event type.
   */
  sigma.utils.unbindDoubleClick = function(target, type) {
    var handler,
        handlers = (target._doubleClickHandler || {})[type] || [];

    while ((handler = handlers.pop())) {
      target.removeEventListener(type, handler);
    }

    delete (target._doubleClickHandler || {})[type];
  };




  /**
   * Here are just some of the most basic easing functions, used for the
   * animated camera "goTo" calls.
   *
   * If you need some more easings functions, don't hesitate to add them to
   * sigma.utils.easings. But I will not add some more here or merge PRs
   * containing, because I do not want sigma sources full of overkill and never
   * used stuff...
   */
  sigma.utils.easings = sigma.utils.easings || {};
  sigma.utils.easings.linearNone = function(k) {
    return k;
  };
  sigma.utils.easings.quadraticIn = function(k) {
    return k * k;
  };
  sigma.utils.easings.quadraticOut = function(k) {
    return k * (2 - k);
  };
  sigma.utils.easings.quadraticInOut = function(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k;
    return - 0.5 * (--k * (k - 2) - 1);
  };
  sigma.utils.easings.cubicIn = function(k) {
    return k * k * k;
  };
  sigma.utils.easings.cubicOut = function(k) {
    return --k * k * k + 1;
  };
  sigma.utils.easings.cubicInOut = function(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k * k;
    return 0.5 * ((k -= 2) * k * k + 2);
  };




  /**
   * ************
   * WEBGL UTILS:
   * ************
   */
  /**
   * Loads a WebGL shader and returns it.
   *
   * @param  {WebGLContext}           gl           The WebGLContext to use.
   * @param  {string}                 shaderSource The shader source.
   * @param  {number}                 shaderType   The type of shader.
   * @param  {function(string): void} error        Callback for errors.
   * @return {WebGLShader}                         The created shader.
   */
  sigma.utils.loadShader = function(gl, shaderSource, shaderType, error) {
    var compiled,
        shader = gl.createShader(shaderType);

    // Load the shader source
    gl.shaderSource(shader, shaderSource);

    // Compile the shader
    gl.compileShader(shader);

    // Check the compile status
    compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

    // If something went wrong:
    if (!compiled) {
      if (error) {
        error(
          'Error compiling shader "' + shader + '":' +
          gl.getShaderInfoLog(shader)
        );
      }

      gl.deleteShader(shader);
      return null;
    }

    return shader;
  };

  /**
   * Creates a program, attaches shaders, binds attrib locations, links the
   * program and calls useProgram.
   *
   * @param  {Array.<WebGLShader>}    shaders   The shaders to attach.
   * @param  {Array.<string>}         attribs   The attribs names.
   * @param  {Array.<number>}         locations The locations for the attribs.
   * @param  {function(string): void} error     Callback for errors.
   * @return {WebGLProgram}                     The created program.
   */
  sigma.utils.loadProgram = function(gl, shaders, attribs, loc, error) {
    var i,
        linked,
        program = gl.createProgram();

    for (i = 0; i < shaders.length; ++i)
      gl.attachShader(program, shaders[i]);

    if (attribs)
      for (i = 0; i < attribs.length; ++i)
        gl.bindAttribLocation(
          program,
          locations ? locations[i] : i,
          opt_attribs[i]
        );

    gl.linkProgram(program);

    // Check the link status
    linked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!linked) {
      if (error)
        error('Error in program linking: ' + gl.getProgramInfoLog(program));

      gl.deleteProgram(program);
      return null;
    }

    return program;
  };




  /**
   * *********
   * MATRICES:
   * *********
   * The following utils are just here to help generating the transformation
   * matrices for the WebGL renderers.
   */
  sigma.utils.pkg('sigma.utils.matrices');

  /**
   * The returns a 3x3 translation matrix.
   *
   * @param  {number} dx The X translation.
   * @param  {number} dy The Y translation.
   * @return {array}     Returns the matrix.
   */
  sigma.utils.matrices.translation = function(dx, dy) {
    return [
      1, 0, 0,
      0, 1, 0,
      dx, dy, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 rotation matrix.
   *
   * @param  {number}  angle The rotation angle.
   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.
   * @return {array}         Returns the matrix.
   */
  sigma.utils.matrices.rotation = function(angle, m2) {
    var cos = Math.cos(angle),
        sin = Math.sin(angle);

    return m2 ? [
      cos, -sin,
      sin, cos
    ] : [
      cos, -sin, 0,
      sin, cos, 0,
      0, 0, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 homothetic transformation matrix.
   *
   * @param  {number}  ratio The scaling ratio.
   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.
   * @return {array}         Returns the matrix.
   */
  sigma.utils.matrices.scale = function(ratio, m2) {
    return m2 ? [
      ratio, 0,
      0, ratio
    ] : [
      ratio, 0, 0,
      0, ratio, 0,
      0, 0, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 homothetic transformation matrix.
   *
   * @param  {array}   a  The first matrix.
   * @param  {array}   b  The second matrix.
   * @param  {boolean} m2 If true, the function will assume both matrices are
   *                      2x2.
   * @return {array}      Returns the matrix.
   */
  sigma.utils.matrices.multiply = function(a, b, m2) {
    var l = m2 ? 2 : 3,
        a00 = a[0 * l + 0],
        a01 = a[0 * l + 1],
        a02 = a[0 * l + 2],
        a10 = a[1 * l + 0],
        a11 = a[1 * l + 1],
        a12 = a[1 * l + 2],
        a20 = a[2 * l + 0],
        a21 = a[2 * l + 1],
        a22 = a[2 * l + 2],
        b00 = b[0 * l + 0],
        b01 = b[0 * l + 1],
        b02 = b[0 * l + 2],
        b10 = b[1 * l + 0],
        b11 = b[1 * l + 1],
        b12 = b[1 * l + 2],
        b20 = b[2 * l + 0],
        b21 = b[2 * l + 1],
        b22 = b[2 * l + 2];

    return m2 ? [
      a00 * b00 + a01 * b10,
      a00 * b01 + a01 * b11,
      a10 * b00 + a11 * b10,
      a10 * b01 + a11 * b11
    ] : [
      a00 * b00 + a01 * b10 + a02 * b20,
      a00 * b01 + a01 * b11 + a02 * b21,
      a00 * b02 + a01 * b12 + a02 * b22,
      a10 * b00 + a11 * b10 + a12 * b20,
      a10 * b01 + a11 * b11 + a12 * b21,
      a10 * b02 + a11 * b12 + a12 * b22,
      a20 * b00 + a21 * b10 + a22 * b20,
      a20 * b01 + a21 * b11 + a22 * b21,
      a20 * b02 + a21 * b12 + a22 * b22
    ];
  };
}).call(this);

;(function(global) {
  'use strict';

  /**
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
   * requestAnimationFrame polyfill by Erik MÃ¶ller.
   * fixes from Paul Irish and Tino Zijdel
   * MIT license
   */
  var x,
      lastTime = 0,
      vendors = ['ms', 'moz', 'webkit', 'o'];

  for (x = 0; x < vendors.length && !global.requestAnimationFrame; x++) {
    global.requestAnimationFrame =
      global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame =
      global[vendors[x] + 'CancelAnimationFrame'] ||
      global[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!global.requestAnimationFrame)
    global.requestAnimationFrame = function(callback, element) {
      var currTime = new Date().getTime(),
          timeToCall = Math.max(0, 16 - (currTime - lastTime)),
          id = global.setTimeout(
            function() {
              callback(currTime + timeToCall);
            },
            timeToCall
          );

      lastTime = currTime + timeToCall;
      return id;
    };

  if (!global.cancelAnimationFrame)
    global.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };

  /**
   * Function.prototype.bind polyfill found on MDN.
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility
   * Public domain
   */
  if (!Function.prototype.bind)
    Function.prototype.bind = function(oThis) {
      if (typeof this !== 'function')
        // Closest thing possible to the ECMAScript 5 internal IsCallable
        // function:
        throw new TypeError(
          'Function.prototype.bind - what is trying to be bound is not callable'
        );

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP,
          fBound;

      fNOP = function() {};
      fBound = function() {
        return fToBind.apply(
          this instanceof fNOP && oThis ?
            this :
            oThis,
          aArgs.concat(Array.prototype.slice.call(arguments))
        );
      };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
})(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Packages initialization:
  sigma.utils.pkg('sigma.settings');

  var settings = {
    /**
     * GRAPH SETTINGS:
     * ***************
     */
    // {boolean} Indicates if the data have to be cloned in methods to add
    //           nodes or edges.
    clone: true,
    // {boolean} Indicates if nodes "id" values and edges "id", "source" and
    //           "target" values must be set as immutable.
    immutable: true,
    // {boolean} Indicates if sigma can log its errors and warnings.
    verbose: false,


    /**
     * RENDERERS SETTINGS:
     * *******************
     */
    // {string}
    classPrefix: 'sigma',
    // {string}
    defaultNodeType: 'def',
    // {string}
    defaultEdgeType: 'def',
    // {string}
    defaultLabelColor: '#000',
    // {string}
    defaultEdgeColor: '#000',
    // {string}
    defaultNodeColor: '#000',
    // {string}
    defaultLabelSize: 14,
    // {string} Indicates how to choose the edges color. Available values:
    //          "source", "target", "default"
    edgeColor: 'source',
    // {number} Defines the minimal edge's arrow display size.
    minArrowSize: 0,
    // {string}
    font: 'arial',
    // {string} Example: 'bold'
    fontStyle: '',
    // {string} Indicates how to choose the labels color. Available values:
    //          "node", "default"
    labelColor: 'default',
    // {string} Indicates how to choose the labels size. Available values:
    //          "fixed", "proportional"
    labelSize: 'fixed',
    // {string} The ratio between the font size of the label and the node size.
    labelSizeRatio: 1,
    // {number} The minimum size a node must have to see its label displayed.
    labelThreshold: 8,
    // {number} The oversampling factor used in WebGL renderer.
    webglOversamplingRatio: 2,
    // {number} The size of the border of hovered nodes.
    borderSize: 0,
    // {number} The default hovered node border's color.
    defaultNodeBorderColor: '#000',
    // {number} The hovered node's label font. If not specified, will heritate
    //          the "font" value.
    hoverFont: '',
    // {boolean} If true, then only one node can be hovered at a time.
    singleHover: true,
    // {string} Example: 'bold'
    hoverFontStyle: '',
    // {string} Indicates how to choose the hovered nodes shadow color.
    //          Available values: "node", "default"
    labelHoverShadow: 'default',
    // {string}
    labelHoverShadowColor: '#000',
    // {string} Indicates how to choose the hovered nodes color.
    //          Available values: "node", "default"
    nodeHoverColor: 'node',
    // {string}
    defaultNodeHoverColor: '#000',
    // {string} Indicates how to choose the hovered nodes background color.
    //          Available values: "node", "default"
    labelHoverBGColor: 'default',
    // {string}
    defaultHoverLabelBGColor: '#fff',
    // {string} Indicates how to choose the hovered labels color.
    //          Available values: "node", "default"
    labelHoverColor: 'default',
    // {string}
    defaultLabelHoverColor: '#000',
    // {string} Indicates how to choose the edges hover color. Available values:
    //          "edge", "default"
    edgeHoverColor: 'edge',
    // {number} The size multiplicator of hovered edges.
    edgeHoverSizeRatio: 1,
    // {string}
    defaultEdgeHoverColor: '#000',
    // {boolean} Indicates if the edge extremities must be hovered when the
    //           edge is hovered.
    edgeHoverExtremities: false,
    // {booleans} The different drawing modes:
    //           false: Layered not displayed.
    //           true: Layered displayed.
    drawEdges: true,
    drawNodes: true,
    drawLabels: true,
    drawEdgeLabels: false,
    // {boolean} Indicates if the edges must be drawn in several frames or in
    //           one frame, as the nodes and labels are drawn.
    batchEdgesDrawing: false,
    // {boolean} Indicates if the edges must be hidden during dragging and
    //           animations.
    hideEdgesOnMove: false,
    // {numbers} The different batch sizes, when elements are displayed in
    //           several frames.
    canvasEdgesBatchSize: 500,
    webglEdgesBatchSize: 1000,




    /**
     * RESCALE SETTINGS:
     * *****************
     */
    // {string} Indicates of to scale the graph relatively to its container.
    //          Available values: "inside", "outside"
    scalingMode: 'inside',
    // {number} The margin to keep around the graph.
    sideMargin: 0,
    // {number} Determine the size of the smallest and the biggest node / edges
    //          on the screen. This mapping makes easier to display the graph,
    //          avoiding too big nodes that take half of the screen, or too
    //          small ones that are not readable. If the two parameters are
    //          equals, then the minimal display size will be 0. And if they
    //          are both equal to 0, then there is no mapping, and the radius
    //          of the nodes will be their size.
    minEdgeSize: 0.5,
    maxEdgeSize: 1,
    minNodeSize: 1,
    maxNodeSize: 8,




    /**
     * CAPTORS SETTINGS:
     * *****************
     */
    // {boolean}
    touchEnabled: true,
    // {boolean}
    mouseEnabled: true,
    // {boolean}
    mouseWheelEnabled: true,
    // {boolean}
    doubleClickEnabled: true,
    // {boolean} Defines whether the custom events such as "clickNode" can be
    //           used.
    eventsEnabled: true,
    // {number} Defines by how much multiplicating the zooming level when the
    //          user zooms with the mouse-wheel.
    zoomingRatio: 1.7,
    // {number} Defines by how much multiplicating the zooming level when the
    //          user zooms by double clicking.
    doubleClickZoomingRatio: 2.2,
    // {number} The minimum zooming level.
    zoomMin: 0.0625,
    // {number} The maximum zooming level.
    zoomMax: 2,
    // {number} The duration of animations following a mouse scrolling.
    mouseZoomDuration: 200,
    // {number} The duration of animations following a mouse double click.
    doubleClickZoomDuration: 200,
    // {number} The duration of animations following a mouse dropping.
    mouseInertiaDuration: 200,
    // {number} The inertia power (mouse captor).
    mouseInertiaRatio: 3,
    // {number} The duration of animations following a touch dropping.
    touchInertiaDuration: 200,
    // {number} The inertia power (touch captor).
    touchInertiaRatio: 3,
    // {number} The maximum time between two clicks to make it a double click.
    doubleClickTimeout: 300,
    // {number} The maximum time between two taps to make it a double tap.
    doubleTapTimeout: 300,
    // {number} The maximum time of dragging to trigger intertia.
    dragTimeout: 200,




    /**
     * GLOBAL SETTINGS:
     * ****************
     */
    // {boolean} Determines whether the instance has to refresh itself
    //           automatically when a "resize" event is dispatched from the
    //           window object.
    autoResize: true,
    // {boolean} Determines whether the "rescale" middleware has to be called
    //           automatically for each camera on refresh.
    autoRescale: true,
    // {boolean} If set to false, the camera method "goTo" will basically do
    //           nothing.
    enableCamera: true,
    // {boolean} If set to false, the nodes cannot be hovered.
    enableHovering: true,
    // {boolean} If set to true, the edges can be hovered.
    enableEdgeHovering: false,
    // {number} The size of the area around the edges to activate hovering.
    edgeHoverPrecision: 5,
    // {boolean} If set to true, the rescale middleware will ignore node sizes
    //           to determine the graphs boundings.
    rescaleIgnoreSize: false,
    // {boolean} Determines if the core has to try to catch errors on
    //           rendering.
    skipErrors: false,




    /**
     * CAMERA SETTINGS:
     * ****************
     */
    // {number} The power degrees applied to the nodes/edges size relatively to
    //          the zooming level. Basically:
    //           > onScreenR = Math.pow(zoom, nodesPowRatio) * R
    //           > onScreenT = Math.pow(zoom, edgesPowRatio) * T
    nodesPowRatio: 0.5,
    edgesPowRatio: 0.5,




    /**
     * ANIMATIONS SETTINGS:
     * ********************
     */
    // {number} The default animation time.
    animationsTime: 200
  };

  // Export the previously designed settings:
  sigma.settings = sigma.utils.extend(sigma.settings || {}, settings);
}).call(this);

;(function() {
  'use strict';

  /**
   * Dispatcher constructor.
   *
   * @return {dispatcher} The new dispatcher instance.
   */
  var dispatcher = function() {
    Object.defineProperty(this, '_handlers', {
      value: {}
    });
  };




  /**
   * Will execute the handler everytime that the indicated event (or the
   * indicated events) will be triggered.
   *
   * @param  {string}           events  The name of the event (or the events
   *                                    separated by spaces).
   * @param  {function(Object)} handler The handler to bind.
   * @return {dispatcher}               Returns the instance itself.
   */
  dispatcher.prototype.bind = function(events, handler) {
    var i,
        l,
        event,
        eArray;

    if (
      arguments.length === 1 &&
      typeof arguments[0] === 'object'
    )
      for (events in arguments[0])
        this.bind(events, arguments[0][events]);
    else if (
      arguments.length === 2 &&
      typeof arguments[1] === 'function'
    ) {
      eArray = typeof events === 'string' ? events.split(' ') : events;

      for (i = 0, l = eArray.length; i !== l; i += 1) {
        event = eArray[i];

        // Check that event is not '':
        if (!event)
          continue;

        if (!this._handlers[event])
          this._handlers[event] = [];

        // Using an object instead of directly the handler will make possible
        // later to add flags
        this._handlers[event].push({
          handler: handler
        });
      }
    } else
      throw 'bind: Wrong arguments.';

    return this;
  };

  /**
   * Removes the handler from a specified event (or specified events).
   *
   * @param  {?string}           events  The name of the event (or the events
   *                                     separated by spaces). If undefined,
   *                                     then all handlers are removed.
   * @param  {?function(object)} handler The handler to unbind. If undefined,
   *                                     each handler bound to the event or the
   *                                     events will be removed.
   * @return {dispatcher}                Returns the instance itself.
   */
  dispatcher.prototype.unbind = function(events, handler) {
    var i,
        n,
        j,
        m,
        k,
        a,
        event,
        eArray = typeof events === 'string' ? events.split(' ') : events;

    if (!arguments.length) {
      for (k in this._handlers)
        delete this._handlers[k];
      return this;
    }

    if (handler) {
      for (i = 0, n = eArray.length; i !== n; i += 1) {
        event = eArray[i];
        if (this._handlers[event]) {
          a = [];
          for (j = 0, m = this._handlers[event].length; j !== m; j += 1)
            if (this._handlers[event][j].handler !== handler)
              a.push(this._handlers[event][j]);

          this._handlers[event] = a;
        }

        if (this._handlers[event] && this._handlers[event].length === 0)
          delete this._handlers[event];
      }
    } else
      for (i = 0, n = eArray.length; i !== n; i += 1)
        delete this._handlers[eArray[i]];

    return this;
  };

  /**
   * Executes each handler bound to the event
   *
   * @param  {string}     events The name of the event (or the events separated
   *                             by spaces).
   * @param  {?object}    data   The content of the event (optional).
   * @return {dispatcher}        Returns the instance itself.
   */
  dispatcher.prototype.dispatchEvent = function(events, data) {
    var i,
        n,
        j,
        m,
        a,
        event,
        eventName,
        self = this,
        eArray = typeof events === 'string' ? events.split(' ') : events;

    data = data === undefined ? {} : data;

    for (i = 0, n = eArray.length; i !== n; i += 1) {
      eventName = eArray[i];

      if (this._handlers[eventName]) {
        event = self.getEvent(eventName, data);
        a = [];

        for (j = 0, m = this._handlers[eventName].length; j !== m; j += 1) {
          this._handlers[eventName][j].handler(event);
          if (!this._handlers[eventName][j].one)
            a.push(this._handlers[eventName][j]);
        }

        this._handlers[eventName] = a;
      }
    }

    return this;
  };

  /**
   * Return an event object.
   *
   * @param  {string}  events The name of the event.
   * @param  {?object} data   The content of the event (optional).
   * @return {object}         Returns the instance itself.
   */
  dispatcher.prototype.getEvent = function(event, data) {
    return {
      type: event,
      data: data || {},
      target: this
    };
  };

  /**
   * A useful function to deal with inheritance. It will make the target
   * inherit the prototype of the class dispatcher as well as its constructor.
   *
   * @param {object} target The target.
   */
  dispatcher.extend = function(target, args) {
    var k;

    for (k in dispatcher.prototype)
      if (dispatcher.prototype.hasOwnProperty(k))
        target[k] = dispatcher.prototype[k];

    dispatcher.apply(target, args);
  };




  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.dispatcher = dispatcher;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = dispatcher;
    exports.dispatcher = dispatcher;
  } else
    this.dispatcher = dispatcher;
}).call(this);

;(function() {
  'use strict';

  /**
   * This utils aims to facilitate the manipulation of each instance setting.
   * Using a function instead of an object brings two main advantages: First,
   * it will be easier in the future to catch settings updates through a
   * function than an object. Second, giving it a full object will "merge" it
   * to the settings object properly, keeping us to have to always add a loop.
   *
   * @return {configurable} The "settings" function.
   */
  var configurable = function() {
    var i,
        l,
        data = {},
        datas = Array.prototype.slice.call(arguments, 0);

    /**
     * The method to use to set or get any property of this instance.
     *
     * @param  {string|object}    a1 If it is a string and if a2 is undefined,
     *                               then it will return the corresponding
     *                               property. If it is a string and if a2 is
     *                               set, then it will set a2 as the property
     *                               corresponding to a1, and return this. If
     *                               it is an object, then each pair string +
     *                               object(or any other type) will be set as a
     *                               property.
     * @param  {*?}               a2 The new property corresponding to a1 if a1
     *                               is a string.
     * @return {*|configurable}      Returns itself or the corresponding
     *                               property.
     *
     * Polymorphism:
     * *************
     * Here are some basic use examples:
     *
     *  > settings = new configurable();
     *  > settings('mySetting', 42);
     *  > settings('mySetting'); // Logs: 42
     *  > settings('mySetting', 123);
     *  > settings('mySetting'); // Logs: 123
     *  > settings({mySetting: 456});
     *  > settings('mySetting'); // Logs: 456
     *
     * Also, it is possible to use the function as a fallback:
     *  > settings({mySetting: 'abc'}, 'mySetting');  // Logs: 'abc'
     *  > settings({hisSetting: 'abc'}, 'mySetting'); // Logs: 456
     */
    var settings = function(a1, a2) {
      var o,
          i,
          l,
          k;

      if (arguments.length === 1 && typeof a1 === 'string') {
        if (data[a1] !== undefined)
          return data[a1];
        for (i = 0, l = datas.length; i < l; i++)
          if (datas[i][a1] !== undefined)
            return datas[i][a1];
        return undefined;
      } else if (typeof a1 === 'object' && typeof a2 === 'string') {
        return (a1 || {})[a2] !== undefined ? a1[a2] : settings(a2);
      } else {
        o = (typeof a1 === 'object' && a2 === undefined) ? a1 : {};

        if (typeof a1 === 'string')
          o[a1] = a2;

        for (i = 0, k = Object.keys(o), l = k.length; i < l; i++)
          data[k[i]] = o[k[i]];

        return this;
      }
    };

    /**
     * This method returns a new configurable function, with new objects
     *
     * @param  {object*}  Any number of objects to search in.
     * @return {function} Returns the function. Check its documentation to know
     *                    more about how it works.
     */
    settings.embedObjects = function() {
      var args = datas.concat(
        data
      ).concat(
        Array.prototype.splice.call(arguments, 0)
      );

      return configurable.apply({}, args);
    };

    // Initialize
    for (i = 0, l = arguments.length; i < l; i++)
      settings(arguments[i]);

    return settings;
  };

  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.configurable = configurable;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = configurable;
    exports.configurable = configurable;
  } else
    this.configurable = configurable;
}).call(this);

;(function(undefined) {
  'use strict';

  var _methods = Object.create(null),
      _indexes = Object.create(null),
      _initBindings = Object.create(null),
      _methodBindings = Object.create(null),
      _methodBeforeBindings = Object.create(null),
      _defaultSettings = {
        immutable: true,
        clone: true
      },
      _defaultSettingsFunction = function(key) {
        return _defaultSettings[key];
      };

  /**
   * The graph constructor. It initializes the data and the indexes, and binds
   * the custom indexes and methods to its own scope.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the settings
   * object:
   *
   *   {boolean} clone     Indicates if the data have to be cloned in methods
   *                       to add nodes or edges.
   *   {boolean} immutable Indicates if nodes "id" values and edges "id",
   *                       "source" and "target" values must be set as
   *                       immutable.
   *
   * @param  {?configurable} settings Eventually a settings function.
   * @return {graph}                  The new graph instance.
   */
  var graph = function(settings) {
    var k,
        fn,
        data;

    /**
     * DATA:
     * *****
     * Every data that is callable from graph methods are stored in this "data"
     * object. This object will be served as context for all these methods,
     * and it is possible to add other type of data in it.
     */
    data = {
      /**
       * SETTINGS FUNCTION:
       * ******************
       */
      settings: settings || _defaultSettingsFunction,

      /**
       * MAIN DATA:
       * **********
       */
      nodesArray: [],
      edgesArray: [],

      /**
       * GLOBAL INDEXES:
       * ***************
       * These indexes just index data by ids.
       */
      nodesIndex: Object.create(null),
      edgesIndex: Object.create(null),

      /**
       * LOCAL INDEXES:
       * **************
       * These indexes refer from node to nodes. Each key is an id, and each
       * value is the array of the ids of related nodes.
       */
      inNeighborsIndex: Object.create(null),
      outNeighborsIndex: Object.create(null),
      allNeighborsIndex: Object.create(null),

      inNeighborsCount: Object.create(null),
      outNeighborsCount: Object.create(null),
      allNeighborsCount: Object.create(null)
    };

    // Execute bindings:
    for (k in _initBindings)
      _initBindings[k].call(data);

    // Add methods to both the scope and the data objects:
    for (k in _methods) {
      fn = __bindGraphMethod(k, data, _methods[k]);
      this[k] = fn;
      data[k] = fn;
    }
  };




  /**
   * A custom tool to bind methods such that function that are bound to it will
   * be executed anytime the method is called.
   *
   * @param  {string}   methodName The name of the method to bind.
   * @param  {object}   scope      The scope where the method must be executed.
   * @param  {function} fn         The method itself.
   * @return {function}            The new method.
   */
  function __bindGraphMethod(methodName, scope, fn) {
    var result = function() {
      var k,
          res;

      // Execute "before" bound functions:
      for (k in _methodBeforeBindings[methodName])
        _methodBeforeBindings[methodName][k].apply(scope, arguments);

      // Apply the method:
      res = fn.apply(scope, arguments);

      // Execute bound functions:
      for (k in _methodBindings[methodName])
        _methodBindings[methodName][k].apply(scope, arguments);

      // Return res:
      return res;
    };

    return result;
  }

  /**
   * This custom tool function removes every pair key/value from an hash. The
   * goal is to avoid creating a new object while some other references are
   * still hanging in some scopes...
   *
   * @param  {object} obj The object to empty.
   * @return {object}     The empty object.
   */
  function __emptyObject(obj) {
    var k;

    for (k in obj)
      if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k))
        delete obj[k];

    return obj;
  }




  /**
   * This global method adds a method that will be bound to the futurly created
   * graph instances.
   *
   * Since these methods will be bound to their scope when the instances are
   * created, it does not use the prototype. Because of that, methods have to
   * be added before instances are created to make them available.
   *
   * Here is an example:
   *
   *  > graph.addMethod('getNodesCount', function() {
   *  >   return this.nodesArray.length;
   *  > });
   *  >
   *  > var myGraph = new graph();
   *  > console.log(myGraph.getNodesCount()); // outputs 0
   *
   * @param  {string}   methodName The name of the method.
   * @param  {function} fn         The method itself.
   * @return {object}              The global graph constructor.
   */
  graph.addMethod = function(methodName, fn) {
    if (
      typeof methodName !== 'string' ||
      typeof fn !== 'function' ||
      arguments.length !== 2
    )
      throw 'addMethod: Wrong arguments.';

    if (_methods[methodName] || graph[methodName])
      throw 'The method "' + methodName + '" already exists.';

    _methods[methodName] = fn;
    _methodBindings[methodName] = Object.create(null);
    _methodBeforeBindings[methodName] = Object.create(null);

    return this;
  };

  /**
   * This global method returns true if the method has already been added, and
   * false else.
   *
   * Here are some examples:
   *
   *  > graph.hasMethod('addNode'); // returns true
   *  > graph.hasMethod('hasMethod'); // returns true
   *  > graph.hasMethod('unexistingMethod'); // returns false
   *
   * @param  {string}  methodName The name of the method.
   * @return {boolean}            The result.
   */
  graph.hasMethod = function(methodName) {
    return !!(_methods[methodName] || graph[methodName]);
  };

  /**
   * This global methods attaches a function to a method. Anytime the specified
   * method is called, the attached function is called right after, with the
   * same arguments and in the same scope. The attached function is called
   * right before if the last argument is true, unless the method is the graph
   * constructor.
   *
   * To attach a function to the graph constructor, use 'constructor' as the
   * method name (first argument).
   *
   * The main idea is to have a clean way to keep custom indexes up to date,
   * for instance:
   *
   *  > var timesAddNodeCalled = 0;
   *  > graph.attach('addNode', 'timesAddNodeCalledInc', function() {
   *  >   timesAddNodeCalled++;
   *  > });
   *  >
   *  > var myGraph = new graph();
   *  > console.log(timesAddNodeCalled); // outputs 0
   *  >
   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });
   *  > console.log(timesAddNodeCalled); // outputs 2
   *
   * The idea for calling a function before is to provide pre-processors, for
   * instance:
   *
   *  > var colorPalette = { Person: '#C3CBE1', Place: '#9BDEBD' };
   *  > graph.attach('addNode', 'applyNodeColorPalette', function(n) {
   *  >   n.color = colorPalette[n.category];
   *  > }, true);
   *  >
   *  > var myGraph = new graph();
   *  > myGraph.addNode({ id: 'n0', category: 'Person' });
   *  > console.log(myGraph.nodes('n0').color); // outputs '#C3CBE1'
   *
   * @param  {string}   methodName The name of the related method or
   *                               "constructor".
   * @param  {string}   key        The key to identify the function to attach.
   * @param  {function} fn         The function to bind.
   * @param  {boolean}  before     If true the function is called right before.
   * @return {object}              The global graph constructor.
   */
  graph.attach = function(methodName, key, fn, before) {
    if (
      typeof methodName !== 'string' ||
      typeof key !== 'string' ||
      typeof fn !== 'function' ||
      arguments.length < 3 ||
      arguments.length > 4
    )
      throw 'attach: Wrong arguments.';

    var bindings;

    if (methodName === 'constructor')
      bindings = _initBindings;
    else {
      if (before) {
        if (!_methodBeforeBindings[methodName])
        throw 'The method "' + methodName + '" does not exist.';

        bindings = _methodBeforeBindings[methodName];
      }
      else {
        if (!_methodBindings[methodName])
          throw 'The method "' + methodName + '" does not exist.';

        bindings = _methodBindings[methodName];
      }
    }

    if (bindings[key])
      throw 'A function "' + key + '" is already attached ' +
            'to the method "' + methodName + '".';

    bindings[key] = fn;

    return this;
  };

  /**
   * Alias of attach(methodName, key, fn, true).
   */
  graph.attachBefore = function(methodName, key, fn) {
    return this.attach(methodName, key, fn, true);
  };

  /**
   * This methods is just an helper to deal with custom indexes. It takes as
   * arguments the name of the index and an object containing all the different
   * functions to bind to the methods.
   *
   * Here is a basic example, that creates an index to keep the number of nodes
   * in the current graph. It also adds a method to provide a getter on that
   * new index:
   *
   *  > sigma.classes.graph.addIndex('nodesCount', {
   *  >   constructor: function() {
   *  >     this.nodesCount = 0;
   *  >   },
   *  >   addNode: function() {
   *  >     this.nodesCount++;
   *  >   },
   *  >   dropNode: function() {
   *  >     this.nodesCount--;
   *  >   }
   *  > });
   *  >
   *  > sigma.classes.graph.addMethod('getNodesCount', function() {
   *  >   return this.nodesCount;
   *  > });
   *  >
   *  > var myGraph = new sigma.classes.graph();
   *  > console.log(myGraph.getNodesCount()); // outputs 0
   *  >
   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });
   *  > console.log(myGraph.getNodesCount()); // outputs 2
   *
   * @param  {string} name     The name of the index.
   * @param  {object} bindings The object containing the functions to bind.
   * @return {object}          The global graph constructor.
   */
  graph.addIndex = function(name, bindings) {
    if (
      typeof name !== 'string' ||
      Object(bindings) !== bindings ||
      arguments.length !== 2
    )
      throw 'addIndex: Wrong arguments.';

    if (_indexes[name])
      throw 'The index "' + name + '" already exists.';

    var k;

    // Store the bindings:
    _indexes[name] = bindings;

    // Attach the bindings:
    for (k in bindings)
      if (typeof bindings[k] !== 'function')
        throw 'The bindings must be functions.';
      else
        graph.attach(k, name, bindings[k]);

    return this;
  };




  /**
   * This method adds a node to the graph. The node must be an object, with a
   * string under the key "id". Except for this, it is possible to add any
   * other attribute, that will be preserved all along the manipulations.
   *
   * If the graph option "clone" has a truthy value, the node will be cloned
   * when added to the graph. Also, if the graph option "immutable" has a
   * truthy value, its id will be defined as immutable.
   *
   * @param  {object} node The node to add.
   * @return {object}      The graph instance.
   */
  graph.addMethod('addNode', function(node) {
    // Check that the node is an object and has an id:
    if (Object(node) !== node || arguments.length !== 1)
      throw 'addNode: Wrong arguments.';

    if (typeof node.id !== 'string' && typeof node.id !== 'number')
      throw 'The node must have a string or number id.';

    if (this.nodesIndex[node.id])
      throw 'The node "' + node.id + '" already exists.';

    var k,
        id = node.id,
        validNode = Object.create(null);

    // Check the "clone" option:
    if (this.settings('clone')) {
      for (k in node)
        if (k !== 'id')
          validNode[k] = node[k];
    } else
      validNode = node;

    // Check the "immutable" option:
    if (this.settings('immutable'))
      Object.defineProperty(validNode, 'id', {
        value: id,
        enumerable: true
      });
    else
      validNode.id = id;

    // Add empty containers for edges indexes:
    this.inNeighborsIndex[id] = Object.create(null);
    this.outNeighborsIndex[id] = Object.create(null);
    this.allNeighborsIndex[id] = Object.create(null);

    this.inNeighborsCount[id] = 0;
    this.outNeighborsCount[id] = 0;
    this.allNeighborsCount[id] = 0;

    // Add the node to indexes:
    this.nodesArray.push(validNode);
    this.nodesIndex[validNode.id] = validNode;

    // Return the current instance:
    return this;
  });

  /**
   * This method adds an edge to the graph. The edge must be an object, with a
   * string under the key "id", and strings under the keys "source" and
   * "target" that design existing nodes. Except for this, it is possible to
   * add any other attribute, that will be preserved all along the
   * manipulations.
   *
   * If the graph option "clone" has a truthy value, the edge will be cloned
   * when added to the graph. Also, if the graph option "immutable" has a
   * truthy value, its id, source and target will be defined as immutable.
   *
   * @param  {object} edge The edge to add.
   * @return {object}      The graph instance.
   */
  graph.addMethod('addEdge', function(edge) {
    // Check that the edge is an object and has an id:
    if (Object(edge) !== edge || arguments.length !== 1)
      throw 'addEdge: Wrong arguments.';

    if (typeof edge.id !== 'string' && typeof edge.id !== 'number')
      throw 'The edge must have a string or number id.';

    if ((typeof edge.source !== 'string' && typeof edge.source !== 'number') ||
        !this.nodesIndex[edge.source])
      throw 'The edge source must have an existing node id.';

    if ((typeof edge.target !== 'string' && typeof edge.target !== 'number') ||
        !this.nodesIndex[edge.target])
      throw 'The edge target must have an existing node id.';

    if (this.edgesIndex[edge.id])
      throw 'The edge "' + edge.id + '" already exists.';

    var k,
        validEdge = Object.create(null);

    // Check the "clone" option:
    if (this.settings('clone')) {
      for (k in edge)
        if (k !== 'id' && k !== 'source' && k !== 'target')
          validEdge[k] = edge[k];
    } else
      validEdge = edge;

    // Check the "immutable" option:
    if (this.settings('immutable')) {
      Object.defineProperty(validEdge, 'id', {
        value: edge.id,
        enumerable: true
      });

      Object.defineProperty(validEdge, 'source', {
        value: edge.source,
        enumerable: true
      });

      Object.defineProperty(validEdge, 'target', {
        value: edge.target,
        enumerable: true
      });
    } else {
      validEdge.id = edge.id;
      validEdge.source = edge.source;
      validEdge.target = edge.target;
    }

    // Add the edge to indexes:
    this.edgesArray.push(validEdge);
    this.edgesIndex[validEdge.id] = validEdge;

    if (!this.inNeighborsIndex[validEdge.target][validEdge.source])
      this.inNeighborsIndex[validEdge.target][validEdge.source] =
        Object.create(null);
    this.inNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =
      validEdge;

    if (!this.outNeighborsIndex[validEdge.source][validEdge.target])
      this.outNeighborsIndex[validEdge.source][validEdge.target] =
        Object.create(null);
    this.outNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =
      validEdge;

    if (!this.allNeighborsIndex[validEdge.source][validEdge.target])
      this.allNeighborsIndex[validEdge.source][validEdge.target] =
        Object.create(null);
    this.allNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =
      validEdge;

    if (validEdge.target !== validEdge.source) {
      if (!this.allNeighborsIndex[validEdge.target][validEdge.source])
        this.allNeighborsIndex[validEdge.target][validEdge.source] =
          Object.create(null);
      this.allNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =
        validEdge;
    }

    // Keep counts up to date:
    this.inNeighborsCount[validEdge.target]++;
    this.outNeighborsCount[validEdge.source]++;
    this.allNeighborsCount[validEdge.target]++;
    this.allNeighborsCount[validEdge.source]++;

    return this;
  });

  /**
   * This method drops a node from the graph. It also removes each edge that is
   * bound to it, through the dropEdge method. An error is thrown if the node
   * does not exist.
   *
   * @param  {string} id The node id.
   * @return {object}    The graph instance.
   */
  graph.addMethod('dropNode', function(id) {
    // Check that the arguments are valid:
    if ((typeof id !== 'string' && typeof id !== 'number') ||
        arguments.length !== 1)
      throw 'dropNode: Wrong arguments.';

    if (!this.nodesIndex[id])
      throw 'The node "' + id + '" does not exist.';

    var i, k, l;

    // Remove the node from indexes:
    delete this.nodesIndex[id];
    for (i = 0, l = this.nodesArray.length; i < l; i++)
      if (this.nodesArray[i].id === id) {
        this.nodesArray.splice(i, 1);
        break;
      }

    // Remove related edges:
    for (i = this.edgesArray.length - 1; i >= 0; i--)
      if (this.edgesArray[i].source === id || this.edgesArray[i].target === id)
        this.dropEdge(this.edgesArray[i].id);

    // Remove related edge indexes:
    delete this.inNeighborsIndex[id];
    delete this.outNeighborsIndex[id];
    delete this.allNeighborsIndex[id];

    delete this.inNeighborsCount[id];
    delete this.outNeighborsCount[id];
    delete this.allNeighborsCount[id];

    for (k in this.nodesIndex) {
      delete this.inNeighborsIndex[k][id];
      delete this.outNeighborsIndex[k][id];
      delete this.allNeighborsIndex[k][id];
    }

    return this;
  });

  /**
   * This method drops an edge from the graph. An error is thrown if the edge
   * does not exist.
   *
   * @param  {string} id The edge id.
   * @return {object}    The graph instance.
   */
  graph.addMethod('dropEdge', function(id) {
    // Check that the arguments are valid:
    if ((typeof id !== 'string' && typeof id !== 'number') ||
        arguments.length !== 1)
      throw 'dropEdge: Wrong arguments.';

    if (!this.edgesIndex[id])
      throw 'The edge "' + id + '" does not exist.';

    var i, l, edge;

    // Remove the edge from indexes:
    edge = this.edgesIndex[id];
    delete this.edgesIndex[id];
    for (i = 0, l = this.edgesArray.length; i < l; i++)
      if (this.edgesArray[i].id === id) {
        this.edgesArray.splice(i, 1);
        break;
      }

    delete this.inNeighborsIndex[edge.target][edge.source][edge.id];
    if (!Object.keys(this.inNeighborsIndex[edge.target][edge.source]).length)
      delete this.inNeighborsIndex[edge.target][edge.source];

    delete this.outNeighborsIndex[edge.source][edge.target][edge.id];
    if (!Object.keys(this.outNeighborsIndex[edge.source][edge.target]).length)
      delete this.outNeighborsIndex[edge.source][edge.target];

    delete this.allNeighborsIndex[edge.source][edge.target][edge.id];
    if (!Object.keys(this.allNeighborsIndex[edge.source][edge.target]).length)
      delete this.allNeighborsIndex[edge.source][edge.target];

    if (edge.target !== edge.source) {
      delete this.allNeighborsIndex[edge.target][edge.source][edge.id];
      if (!Object.keys(this.allNeighborsIndex[edge.target][edge.source]).length)
        delete this.allNeighborsIndex[edge.target][edge.source];
    }

    this.inNeighborsCount[edge.target]--;
    this.outNeighborsCount[edge.source]--;
    this.allNeighborsCount[edge.source]--;
    this.allNeighborsCount[edge.target]--;

    return this;
  });

  /**
   * This method destroys the current instance. It basically empties each index
   * and methods attached to the graph.
   */
  graph.addMethod('kill', function() {
    // Delete arrays:
    this.nodesArray.length = 0;
    this.edgesArray.length = 0;
    delete this.nodesArray;
    delete this.edgesArray;

    // Delete indexes:
    delete this.nodesIndex;
    delete this.edgesIndex;
    delete this.inNeighborsIndex;
    delete this.outNeighborsIndex;
    delete this.allNeighborsIndex;
    delete this.inNeighborsCount;
    delete this.outNeighborsCount;
    delete this.allNeighborsCount;
  });

  /**
   * This method empties the nodes and edges arrays, as well as the different
   * indexes.
   *
   * @return {object} The graph instance.
   */
  graph.addMethod('clear', function() {
    this.nodesArray.length = 0;
    this.edgesArray.length = 0;

    // Due to GC issues, I prefer not to create new object. These objects are
    // only available from the methods and attached functions, but still, it is
    // better to prevent ghost references to unrelevant data...
    __emptyObject(this.nodesIndex);
    __emptyObject(this.edgesIndex);
    __emptyObject(this.nodesIndex);
    __emptyObject(this.inNeighborsIndex);
    __emptyObject(this.outNeighborsIndex);
    __emptyObject(this.allNeighborsIndex);
    __emptyObject(this.inNeighborsCount);
    __emptyObject(this.outNeighborsCount);
    __emptyObject(this.allNeighborsCount);

    return this;
  });

  /**
   * This method reads an object and adds the nodes and edges, through the
   * proper methods "addNode" and "addEdge".
   *
   * Here is an example:
   *
   *  > var myGraph = new graph();
   *  > myGraph.read({
   *  >   nodes: [
   *  >     { id: 'n0' },
   *  >     { id: 'n1' }
   *  >   ],
   *  >   edges: [
   *  >     {
   *  >       id: 'e0',
   *  >       source: 'n0',
   *  >       target: 'n1'
   *  >     }
   *  >   ]
   *  > });
   *  >
   *  > console.log(
   *  >   myGraph.nodes().length,
   *  >   myGraph.edges().length
   *  > ); // outputs 2 1
   *
   * @param  {object} g The graph object.
   * @return {object}   The graph instance.
   */
  graph.addMethod('read', function(g) {
    var i,
        a,
        l;

    a = g.nodes || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addNode(a[i]);

    a = g.edges || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addEdge(a[i]);

    return this;
  });

  /**
   * This methods returns one or several nodes, depending on how it is called.
   *
   * To get the array of nodes, call "nodes" without argument. To get a
   * specific node, call it with the id of the node. The get multiple node,
   * call it with an array of ids, and it will return the array of nodes, in
   * the same order.
   *
   * @param  {?(string|array)} v Eventually one id, an array of ids.
   * @return {object|array}      The related node or array of nodes.
   */
  graph.addMethod('nodes', function(v) {
    // Clone the array of nodes and return it:
    if (!arguments.length)
      return this.nodesArray.slice(0);

    // Return the related node:
    if (arguments.length === 1 &&
        (typeof v === 'string' || typeof v === 'number'))
      return this.nodesIndex[v];

    // Return an array of the related node:
    if (
      arguments.length === 1 &&
      Object.prototype.toString.call(v) === '[object Array]'
    ) {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(this.nodesIndex[v[i]]);
        else
          throw 'nodes: Wrong arguments.';

      return a;
    }

    throw 'nodes: Wrong arguments.';
  });

  /**
   * This methods returns the degree of one or several nodes, depending on how
   * it is called. It is also possible to get incoming or outcoming degrees
   * instead by specifying 'in' or 'out' as a second argument.
   *
   * @param  {string|array} v     One id, an array of ids.
   * @param  {?string}      which Which degree is required. Values are 'in',
   *                              'out', and by default the normal degree.
   * @return {number|array}       The related degree or array of degrees.
   */
  graph.addMethod('degree', function(v, which) {
    // Check which degree is required:
    which = {
      'in': this.inNeighborsCount,
      'out': this.outNeighborsCount
    }[which || ''] || this.allNeighborsCount;

    // Return the related node:
    if (typeof v === 'string' || typeof v === 'number')
      return which[v];

    // Return an array of the related node:
    if (Object.prototype.toString.call(v) === '[object Array]') {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(which[v[i]]);
        else
          throw 'degree: Wrong arguments.';

      return a;
    }

    throw 'degree: Wrong arguments.';
  });

  /**
   * This methods returns one or several edges, depending on how it is called.
   *
   * To get the array of edges, call "edges" without argument. To get a
   * specific edge, call it with the id of the edge. The get multiple edge,
   * call it with an array of ids, and it will return the array of edges, in
   * the same order.
   *
   * @param  {?(string|array)} v Eventually one id, an array of ids.
   * @return {object|array}      The related edge or array of edges.
   */
  graph.addMethod('edges', function(v) {
    // Clone the array of edges and return it:
    if (!arguments.length)
      return this.edgesArray.slice(0);

    // Return the related edge:
    if (arguments.length === 1 &&
        (typeof v === 'string' || typeof v === 'number'))
      return this.edgesIndex[v];

    // Return an array of the related edge:
    if (
      arguments.length === 1 &&
      Object.prototype.toString.call(v) === '[object Array]'
    ) {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(this.edgesIndex[v[i]]);
        else
          throw 'edges: Wrong arguments.';

      return a;
    }

    throw 'edges: Wrong arguments.';
  });


  /**
   * EXPORT:
   * *******
   */
  if (typeof sigma !== 'undefined') {
    sigma.classes = sigma.classes || Object.create(null);
    sigma.classes.graph = graph;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = graph;
    exports.graph = graph;
  } else
    this.graph = graph;
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.classes');

  /**
   * The camera constructor. It just initializes its attributes and methods.
   *
   * @param  {string}       id       The id.
   * @param  {sigma.classes.graph}  graph    The graph.
   * @param  {configurable} settings The settings function.
   * @param  {?object}      options  Eventually some overriding options.
   * @return {camera}                Returns the fresh new camera instance.
   */
  sigma.classes.camera = function(id, graph, settings, options) {
    sigma.classes.dispatcher.extend(this);

    Object.defineProperty(this, 'graph', {
      value: graph
    });
    Object.defineProperty(this, 'id', {
      value: id
    });
    Object.defineProperty(this, 'readPrefix', {
      value: 'read_cam' + id + ':'
    });
    Object.defineProperty(this, 'prefix', {
      value: 'cam' + id + ':'
    });

    this.x = 0;
    this.y = 0;
    this.ratio = 1;
    this.angle = 0;
    this.isAnimated = false;
    this.settings = (typeof options === 'object' && options) ?
      settings.embedObject(options) :
      settings;
  };

  /**
   * Updates the camera position.
   *
   * @param  {object} coordinates The new coordinates object.
   * @return {camera}             Returns the camera.
   */
  sigma.classes.camera.prototype.goTo = function(coordinates) {
    if (!this.settings('enableCamera'))
      return this;

    var i,
        l,
        c = coordinates || {},
        keys = ['x', 'y', 'ratio', 'angle'];

    for (i = 0, l = keys.length; i < l; i++)
      if (c[keys[i]] !== undefined) {
        if (typeof c[keys[i]] === 'number' && !isNaN(c[keys[i]]))
          this[keys[i]] = c[keys[i]];
        else
          throw 'Value for "' + keys[i] + '" is not a number.';
      }

    this.dispatchEvent('coordinatesUpdated');
    return this;
  };

  /**
   * This method takes a graph and computes for each node and edges its
   * coordinates relatively to the center of the camera. Basically, it will
   * compute the coordinates that will be used by the graphic renderers.
   *
   * Since it should be possible to use different cameras and different
   * renderers, it is possible to specify a prefix to put before the new
   * coordinates (to get something like "node.camera1_x")
   *
   * @param  {?string} read    The prefix of the coordinates to read.
   * @param  {?string} write   The prefix of the coordinates to write.
   * @param  {?object} options Eventually an object of options. Those can be:
   *                           - A restricted nodes array.
   *                           - A restricted edges array.
   *                           - A width.
   *                           - A height.
   * @return {camera}        Returns the camera.
   */
  sigma.classes.camera.prototype.applyView = function(read, write, options) {
    options = options || {};
    write = write !== undefined ? write : this.prefix;
    read = read !== undefined ? read : this.readPrefix;

    var nodes = options.nodes || this.graph.nodes(),
        edges = options.edges || this.graph.edges();

    var i,
        l,
        node,
        relCos = Math.cos(this.angle) / this.ratio,
        relSin = Math.sin(this.angle) / this.ratio,
        nodeRatio = Math.pow(this.ratio, this.settings('nodesPowRatio')),
        edgeRatio = Math.pow(this.ratio, this.settings('edgesPowRatio')),
        xOffset = (options.width || 0) / 2 - this.x * relCos - this.y * relSin,
        yOffset = (options.height || 0) / 2 - this.y * relCos + this.x * relSin;

    for (i = 0, l = nodes.length; i < l; i++) {
      node = nodes[i];
      node[write + 'x'] =
        (node[read + 'x'] || 0) * relCos +
        (node[read + 'y'] || 0) * relSin +
        xOffset;
      node[write + 'y'] =
        (node[read + 'y'] || 0) * relCos -
        (node[read + 'x'] || 0) * relSin +
        yOffset;
      node[write + 'size'] =
        (node[read + 'size'] || 0) /
        nodeRatio;
    }

    for (i = 0, l = edges.length; i < l; i++) {
      edges[i][write + 'size'] =
        (edges[i][read + 'size'] || 0) /
        edgeRatio;
    }

    return this;
  };

  /**
   * This function converts the coordinates of a point from the frame of the
   * camera to the frame of the graph.
   *
   * @param  {number} x The X coordinate of the point in the frame of the
   *                    camera.
   * @param  {number} y The Y coordinate of the point in the frame of the
   *                    camera.
   * @return {object}   The point coordinates in the frame of the graph.
   */
  sigma.classes.camera.prototype.graphPosition = function(x, y, vector) {
    var X = 0,
        Y = 0,
        cos = Math.cos(this.angle),
        sin = Math.sin(this.angle);

    // Revert the origin differential vector:
    if (!vector) {
      X = - (this.x * cos + this.y * sin) / this.ratio;
      Y = - (this.y * cos - this.x * sin) / this.ratio;
    }

    return {
      x: (x * cos + y * sin) / this.ratio + X,
      y: (y * cos - x * sin) / this.ratio + Y
    };
  };

  /**
   * This function converts the coordinates of a point from the frame of the
   * graph to the frame of the camera.
   *
   * @param  {number} x The X coordinate of the point in the frame of the
   *                    graph.
   * @param  {number} y The Y coordinate of the point in the frame of the
   *                    graph.
   * @return {object}   The point coordinates in the frame of the camera.
   */
  sigma.classes.camera.prototype.cameraPosition = function(x, y, vector) {
    var X = 0,
        Y = 0,
        cos = Math.cos(this.angle),
        sin = Math.sin(this.angle);

    // Revert the origin differential vector:
    if (!vector) {
      X = - (this.x * cos + this.y * sin) / this.ratio;
      Y = - (this.y * cos - this.x * sin) / this.ratio;
    }

    return {
      x: ((x - X) * cos - (y - Y) * sin) * this.ratio,
      y: ((y - Y) * cos + (x - X) * sin) * this.ratio
    };
  };

  /**
   * This method returns the transformation matrix of the camera. This is
   * especially useful to apply the camera view directly in shaders, in case of
   * WebGL rendering.
   *
   * @return {array} The transformation matrix.
   */
  sigma.classes.camera.prototype.getMatrix = function() {
    var scale = sigma.utils.matrices.scale(1 / this.ratio),
        rotation = sigma.utils.matrices.rotation(this.angle),
        translation = sigma.utils.matrices.translation(-this.x, -this.y),
        matrix = sigma.utils.matrices.multiply(
          translation,
          sigma.utils.matrices.multiply(
            rotation,
            scale
          )
        );

    return matrix;
  };

  /**
   * Taking a width and a height as parameters, this method returns the
   * coordinates of the rectangle representing the camera on screen, in the
   * graph's referentiel.
   *
   * To keep displaying labels of nodes going out of the screen, the method
   * keeps a margin around the screen in the returned rectangle.
   *
   * @param  {number} width  The width of the screen.
   * @param  {number} height The height of the screen.
   * @return {object}        The rectangle as x1, y1, x2 and y2, representing
   *                         two opposite points.
   */
  sigma.classes.camera.prototype.getRectangle = function(width, height) {
    var widthVect = this.cameraPosition(width, 0, true),
        heightVect = this.cameraPosition(0, height, true),
        centerVect = this.cameraPosition(width / 2, height / 2, true),
        marginX = this.cameraPosition(width / 4, 0, true).x,
        marginY = this.cameraPosition(0, height / 4, true).y;

    return {
      x1: this.x - centerVect.x - marginX,
      y1: this.y - centerVect.y - marginY,
      x2: this.x - centerVect.x + marginX + widthVect.x,
      y2: this.y - centerVect.y - marginY + widthVect.y,
      height: Math.sqrt(
        Math.pow(heightVect.x, 2) +
        Math.pow(heightVect.y + 2 * marginY, 2)
      )
    };
  };
}).call(this);

;(function(undefined) {
  'use strict';

  /**
   * Sigma Quadtree Module
   * =====================
   *
   * Author: Guillaume Plique (Yomguithereal)
   * Version: 0.2
   */



  /**
   * Quad Geometric Operations
   * -------------------------
   *
   * A useful batch of geometric operations used by the quadtree.
   */

  var _geom = {

    /**
     * Transforms a graph node with x, y and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph node with at least a point (x, y) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    pointToSquare: function(n) {
      return {
        x1: n.x - n.size,
        y1: n.y - n.size,
        x2: n.x + n.size,
        y2: n.y - n.size,
        height: n.size * 2
      };
    },

    /**
     * Checks whether a rectangle is axis-aligned.
     *
     * @param  {object}  A rectangle defined by two points
     *                   (x1, y1) and (x2, y2).
     * @return {boolean} True if the rectangle is axis-aligned.
     */
    isAxisAligned: function(r) {
      return r.x1 === r.x2 || r.y1 === r.y2;
    },

    /**
     * Compute top points of an axis-aligned rectangle. This is useful in
     * cases when the rectangle has been rotated (left, right or bottom up) and
     * later operations need to know the top points.
     *
     * @param  {object} An axis-aligned rectangle defined by two points
     *                  (x1, y1), (x2, y2) and height.
     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.
     */
    axisAlignedTopPoints: function(r) {

      // Basic
      if (r.y1 === r.y2 && r.x1 < r.x2)
        return r;

      // Rotated to right
      if (r.x1 === r.x2 && r.y2 > r.y1)
        return {
          x1: r.x1 - r.height, y1: r.y1,
          x2: r.x1, y2: r.y1,
          height: r.height
        };

      // Rotated to left
      if (r.x1 === r.x2 && r.y2 < r.y1)
        return {
          x1: r.x1, y1: r.y2,
          x2: r.x2 + r.height, y2: r.y2,
          height: r.height
        };

      // Bottom's up
      return {
        x1: r.x2, y1: r.y1 - r.height,
        x2: r.x1, y2: r.y1 - r.height,
        height: r.height
      };
    },

    /**
     * Get coordinates of a rectangle's lower left corner from its top points.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerLeftCoor: function(r) {
      var width = (
        Math.sqrt(
          Math.pow(r.x2 - r.x1, 2) +
          Math.pow(r.y2 - r.y1, 2)
        )
      );

      return {
        x: r.x1 - (r.y2 - r.y1) * r.height / width,
        y: r.y1 + (r.x2 - r.x1) * r.height / width
      };
    },

    /**
     * Get coordinates of a rectangle's lower right corner from its top points
     * and its lower left corner.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @param  {object} A corner's coordinates (x, y).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerRightCoor: function(r, llc) {
      return {
        x: llc.x - r.x1 + r.x2,
        y: llc.y - r.y1 + r.y2
      };
    },

    /**
     * Get the coordinates of all the corners of a rectangle from its top point.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {array}  An array of the four corners' coordinates (x, y).
     */
    rectangleCorners: function(r) {
      var llc = this.lowerLeftCoor(r),
          lrc = this.lowerRightCoor(r, llc);

      return [
        {x: r.x1, y: r.y1},
        {x: r.x2, y: r.y2},
        {x: llc.x, y: llc.y},
        {x: lrc.x, y: lrc.y}
      ];
    },

    /**
     * Split a square defined by its boundaries into four.
     *
     * @param  {object} Boundaries of the square (x, y, width, height).
     * @return {array}  An array containing the four new squares, themselves
     *                  defined by an array of their four corners (x, y).
     */
    splitSquare: function(b) {
      return [
        [
          {x: b.x, y: b.y},
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2}
        ],
        [
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x + b.width, y: b.y},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2}
        ],
        [
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x, y: b.y + b.height},
          {x: b.x + b.width / 2, y: b.y + b.height}
        ],
        [
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height},
          {x: b.x + b.width, y: b.y + b.height}
        ]
      ];
    },

    /**
     * Compute the four axis between corners of rectangle A and corners of
     * rectangle B. This is needed later to check an eventual collision.
     *
     * @param  {array} An array of rectangle A's four corners (x, y).
     * @param  {array} An array of rectangle B's four corners (x, y).
     * @return {array} An array of four axis defined by their coordinates (x,y).
     */
    axis: function(c1, c2) {
      return [
        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},
        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},
        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},
        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}
      ];
    },

    /**
     * Project a rectangle's corner on an axis.
     *
     * @param  {object} Coordinates of a corner (x, y).
     * @param  {object} Coordinates of an axis (x, y).
     * @return {object} The projection defined by coordinates (x, y).
     */
    projection: function(c, a) {
      var l = (
        (c.x * a.x + c.y * a.y) /
        (Math.pow(a.x, 2) + Math.pow(a.y, 2))
      );

      return {
        x: l * a.x,
        y: l * a.y
      };
    },

    /**
     * Check whether two rectangles collide on one particular axis.
     *
     * @param  {object}   An axis' coordinates (x, y).
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide on the axis.
     */
    axisCollision: function(a, c1, c2) {
      var sc1 = [],
          sc2 = [];

      for (var ci = 0; ci < 4; ci++) {
        var p1 = this.projection(c1[ci], a),
            p2 = this.projection(c2[ci], a);

        sc1.push(p1.x * a.x + p1.y * a.y);
        sc2.push(p2.x * a.x + p2.y * a.y);
      }

      var maxc1 = Math.max.apply(Math, sc1),
          maxc2 = Math.max.apply(Math, sc2),
          minc1 = Math.min.apply(Math, sc1),
          minc2 = Math.min.apply(Math, sc2);

      return (minc2 <= maxc1 && maxc2 >= minc1);
    },

    /**
     * Check whether two rectangles collide on each one of their four axis. If
     * all axis collide, then the two rectangles do collide on the plane.
     *
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide.
     */
    collision: function(c1, c2) {
      var axis = this.axis(c1, c2),
          col = true;

      for (var i = 0; i < 4; i++)
        col = col && this.axisCollision(axis[i], c1, c2);

      return col;
    }
  };


  /**
   * Quad Functions
   * ------------
   *
   * The Quadtree functions themselves.
   * For each of those functions, we consider that in a splitted quad, the
   * index of each node is the following:
   * 0: top left
   * 1: top right
   * 2: bottom left
   * 3: bottom right
   *
   * Moreover, the hereafter quad's philosophy is to consider that if an element
   * collides with more than one nodes, this element belongs to each of the
   * nodes it collides with where other would let it lie on a higher node.
   */

  /**
   * Get the index of the node containing the point in the quad
   *
   * @param  {object}  point      A point defined by coordinates (x, y).
   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).
   * @return {integer}            The index of the node containing the point.
   */
  function _quadIndex(point, quadBounds) {
    var xmp = quadBounds.x + quadBounds.width / 2,
        ymp = quadBounds.y + quadBounds.height / 2,
        top = (point.y < ymp),
        left = (point.x < xmp);

    if (top) {
      if (left)
        return 0;
      else
        return 1;
    }
    else {
      if (left)
        return 2;
      else
        return 3;
    }
  }

  /**
   * Get a list of indexes of nodes containing an axis-aligned rectangle
   *
   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),
   *                               (x2, y2) and height.
   * @param  {array}   quadCorners An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadIndexes(rectangle, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if ((rectangle.x2 >= quadCorners[i][0].x) &&
          (rectangle.x1 <= quadCorners[i][1].x) &&
          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&
          (rectangle.y1 <= quadCorners[i][2].y))
        indexes.push(i);

    return indexes;
  }

  /**
   * Get a list of indexes of nodes containing a non-axis-aligned rectangle
   *
   * @param  {array}  corners      An array containing each corner of the
   *                               rectangle defined by its coordinates (x, y).
   * @param  {array}  quadCorners  An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadCollision(corners, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if (_geom.collision(corners, quadCorners[i]))
        indexes.push(i);

    return indexes;
  }

  /**
   * Subdivide a quad by creating a node at a precise index. The function does
   * not generate all four nodes not to potentially create unused nodes.
   *
   * @param  {integer}  index The index of the node to create.
   * @param  {object}   quad  The quad object to subdivide.
   * @return {object}         A new quad representing the node created.
   */
  function _quadSubdivide(index, quad) {
    var next = quad.level + 1,
        subw = Math.round(quad.bounds.width / 2),
        subh = Math.round(quad.bounds.height / 2),
        qx = Math.round(quad.bounds.x),
        qy = Math.round(quad.bounds.y),
        x,
        y;

    switch (index) {
      case 0:
        x = qx;
        y = qy;
        break;
      case 1:
        x = qx + subw;
        y = qy;
        break;
      case 2:
        x = qx;
        y = qy + subh;
        break;
      case 3:
        x = qx + subw;
        y = qy + subh;
        break;
    }

    return _quadTree(
      {x: x, y: y, width: subw, height: subh},
      next,
      quad.maxElements,
      quad.maxLevel
    );
  }

  /**
   * Recursively insert an element into the quadtree. Only points
   * with size, i.e. axis-aligned squares, may be inserted with this
   * method.
   *
   * @param  {object}  el         The element to insert in the quadtree.
   * @param  {object}  sizedPoint A sized point defined by two top points
   *                              (x1, y1), (x2, y2) and height.
   * @param  {object}  quad       The quad in which to insert the element.
   * @return {undefined}          The function does not return anything.
   */
  function _quadInsert(el, sizedPoint, quad) {
    if (quad.level < quad.maxLevel) {

      // Searching appropriate quads
      var indexes = _quadIndexes(sizedPoint, quad.corners);

      // Iterating
      for (var i = 0, l = indexes.length; i < l; i++) {

        // Subdividing if necessary
        if (quad.nodes[indexes[i]] === undefined)
          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);

        // Recursion
        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);
      }
    }
    else {

      // Pushing the element in a leaf node
      quad.elements.push(el);
    }
  }

  /**
   * Recursively retrieve every elements held by the node containing the
   * searched point.
   *
   * @param  {object}  point The searched point (x, y).
   * @param  {object}  quad  The searched quad.
   * @return {array}         An array of elements contained in the relevant
   *                         node.
   */
  function _quadRetrievePoint(point, quad) {
    if (quad.level < quad.maxLevel) {
      var index = _quadIndex(point, quad.bounds);

      // If node does not exist we return an empty list
      if (quad.nodes[index] !== undefined) {
        return _quadRetrievePoint(point, quad.nodes[index]);
      }
      else {
        return [];
      }
    }
    else {
      return quad.elements;
    }
  }

  /**
   * Recursively retrieve every elements contained within an rectangular area
   * that may or may not be axis-aligned.
   *
   * @param  {object|array} rectData       The searched area defined either by
   *                                       an array of four corners (x, y) in
   *                                       the case of a non-axis-aligned
   *                                       rectangle or an object with two top
   *                                       points (x1, y1), (x2, y2) and height.
   * @param  {object}       quad           The searched quad.
   * @param  {function}     collisionFunc  The collision function used to search
   *                                       for node indexes.
   * @param  {array?}       els            The retrieved elements.
   * @return {array}                       An array of elements contained in the
   *                                       area.
   */
  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {
    els = els || {};

    if (quad.level < quad.maxLevel) {
      var indexes = collisionFunc(rectData, quad.corners);

      for (var i = 0, l = indexes.length; i < l; i++)
        if (quad.nodes[indexes[i]] !== undefined)
          _quadRetrieveArea(
            rectData,
            quad.nodes[indexes[i]],
            collisionFunc,
            els
          );
    } else
      for (var j = 0, m = quad.elements.length; j < m; j++)
        if (els[quad.elements[j].id] === undefined)
          els[quad.elements[j].id] = quad.elements[j];

    return els;
  }

  /**
   * Creates the quadtree object itself.
   *
   * @param  {object}   bounds       The boundaries of the quad defined by an
   *                                 origin (x, y), width and heigth.
   * @param  {integer}  level        The level of the quad in the tree.
   * @param  {integer}  maxElements  The max number of element in a leaf node.
   * @param  {integer}  maxLevel     The max recursion level of the tree.
   * @return {object}                The quadtree object.
   */
  function _quadTree(bounds, level, maxElements, maxLevel) {
    return {
      level: level || 0,
      bounds: bounds,
      corners: _geom.splitSquare(bounds),
      maxElements: maxElements || 20,
      maxLevel: maxLevel || 4,
      elements: [],
      nodes: []
    };
  }


  /**
   * Sigma Quad Constructor
   * ----------------------
   *
   * The quad API as exposed to sigma.
   */

  /**
   * The quad core that will become the sigma interface with the quadtree.
   *
   * property {object} _tree  Property holding the quadtree object.
   * property {object} _geom  Exposition of the _geom namespace for testing.
   * property {object} _cache Cache for the area method.
   */
  var quad = function() {
    this._geom = _geom;
    this._tree = null;
    this._cache = {
      query: false,
      result: false
    };
  };

  /**
   * Index a graph by inserting its nodes into the quadtree.
   *
   * @param  {array}  nodes   An array of nodes to index.
   * @param  {object} params  An object of parameters with at least the quad
   *                          bounds.
   * @return {object}         The quadtree object.
   *
   * Parameters:
   * ----------
   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)
   *                         width and heigth.
   * prefix:      {string?}  a prefix for node geometric attributes.
   * maxElements: {integer?} the max number of elements in a leaf node.
   * maxLevel:    {integer?} the max recursion level of the tree.
   */
  quad.prototype.index = function(nodes, params) {

    // Enforcing presence of boundaries
    if (!params.bounds)
      throw 'sigma.classes.quad.index: bounds information not given.';

    // Prefix
    var prefix = params.prefix || '';

    // Building the tree
    this._tree = _quadTree(
      params.bounds,
      0,
      params.maxElements,
      params.maxLevel
    );

    // Inserting graph nodes into the tree
    for (var i = 0, l = nodes.length; i < l; i++) {

      // Inserting node
      _quadInsert(
        nodes[i],
        _geom.pointToSquare({
          x: nodes[i][prefix + 'x'],
          y: nodes[i][prefix + 'y'],
          size: nodes[i][prefix + 'size']
        }),
        this._tree
      );
    }

    // Reset cache:
    this._cache = {
      query: false,
      result: false
    };

    // remove?
    return this._tree;
  };

  /**
   * Retrieve every graph nodes held by the quadtree node containing the
   * searched point.
   *
   * @param  {number} x of the point.
   * @param  {number} y of the point.
   * @return {array}  An array of nodes retrieved.
   */
  quad.prototype.point = function(x, y) {
    return this._tree ?
      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :
      [];
  };

  /**
   * Retrieve every graph nodes within a rectangular area. The methods keep the
   * last area queried in cache for optimization reason and will act differently
   * for the same reason if the area is axis-aligned or not.
   *
   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)
   *                  and height.
   * @return {array}  An array of nodes retrieved.
   */
  quad.prototype.area = function(rect) {
    var serialized = JSON.stringify(rect),
        collisionFunc,
        rectData;

    // Returning cache?
    if (this._cache.query === serialized)
      return this._cache.result;

    // Axis aligned ?
    if (_geom.isAxisAligned(rect)) {
      collisionFunc = _quadIndexes;
      rectData = _geom.axisAlignedTopPoints(rect);
    }
    else {
      collisionFunc = _quadCollision;
      rectData = _geom.rectangleCorners(rect);
    }

    // Retrieving nodes
    var nodes = this._tree ?
      _quadRetrieveArea(
        rectData,
        this._tree,
        collisionFunc
      ) :
      [];

    // Object to array
    var nodesArray = [];
    for (var i in nodes)
      nodesArray.push(nodes[i]);

    // Caching
    this._cache.query = serialized;
    this._cache.result = nodesArray;

    return nodesArray;
  };


  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.quad = quad;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = quad;
    exports.quad = quad;
  } else
    this.quad = quad;
}).call(this);

;(function(undefined) {
  'use strict';

  /**
   * Sigma Quadtree Module for edges
   * ===============================
   *
   * Author: SÃ©bastien Heymann,
   *   from the quad of Guillaume Plique (Yomguithereal)
   * Version: 0.2
   */



  /**
   * Quad Geometric Operations
   * -------------------------
   *
   * A useful batch of geometric operations used by the quadtree.
   */

  var _geom = {

    /**
     * Transforms a graph node with x, y and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph node with at least a point (x, y) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    pointToSquare: function(n) {
      return {
        x1: n.x - n.size,
        y1: n.y - n.size,
        x2: n.x + n.size,
        y2: n.y - n.size,
        height: n.size * 2
      };
    },

    /**
     * Transforms a graph edge with x1, y1, x2, y2 and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph edge with at least two points
     *                  (x1, y1), (x2, y2) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    lineToSquare: function(e) {
      if (e.y1 < e.y2) {
        // (e.x1, e.y1) on top
        if (e.x1 < e.x2) {
          // (e.x1, e.y1) on left
          return {
            x1: e.x1 - e.size,
            y1: e.y1 - e.size,
            x2: e.x2 + e.size,
            y2: e.y1 - e.size,
            height: e.y2 - e.y1 + e.size * 2
          };
        }
        // (e.x1, e.y1) on right
        return {
          x1: e.x2 - e.size,
          y1: e.y1 - e.size,
          x2: e.x1 + e.size,
          y2: e.y1 - e.size,
          height: e.y2 - e.y1 + e.size * 2
        };
      }

      // (e.x2, e.y2) on top
      if (e.x1 < e.x2) {
        // (e.x1, e.y1) on left
        return {
          x1: e.x1 - e.size,
          y1: e.y2 - e.size,
          x2: e.x2 + e.size,
          y2: e.y2 - e.size,
          height: e.y1 - e.y2 + e.size * 2
        };
      }
      // (e.x2, e.y2) on right
      return {
        x1: e.x2 - e.size,
        y1: e.y2 - e.size,
        x2: e.x1 + e.size,
        y2: e.y2 - e.size,
        height: e.y1 - e.y2 + e.size * 2
      };
    },

    /**
     * Transforms a graph edge of type 'curve' with x1, y1, x2, y2,
     * control point and size into an axis-aligned square.
     *
     * @param  {object} e  A graph edge with at least two points
     *                     (x1, y1), (x2, y2) and a size.
     * @param  {object} cp A control point (x,y).
     * @return {object}    A square: two points (x1, y1), (x2, y2) and height.
     */
    quadraticCurveToSquare: function(e, cp) {
      var pt = sigma.utils.getPointOnQuadraticCurve(
        0.5,
        e.x1,
        e.y1,
        e.x2,
        e.y2,
        cp.x,
        cp.y
      );

      // Bounding box of the two points and the point at the middle of the
      // curve:
      var minX = Math.min(e.x1, e.x2, pt.x),
          maxX = Math.max(e.x1, e.x2, pt.x),
          minY = Math.min(e.y1, e.y2, pt.y),
          maxY = Math.max(e.y1, e.y2, pt.y);

      return {
        x1: minX - e.size,
        y1: minY - e.size,
        x2: maxX + e.size,
        y2: minY - e.size,
        height: maxY - minY + e.size * 2
      };
    },

    /**
     * Transforms a graph self loop into an axis-aligned square.
     *
     * @param  {object} n A graph node with a point (x, y) and a size.
     * @return {object}   A square: two points (x1, y1), (x2, y2) and height.
     */
    selfLoopToSquare: function(n) {
      // Fitting to the curve is too costly, we compute a larger bounding box
      // using the control points:
      var cp = sigma.utils.getSelfLoopControlPoints(n.x, n.y, n.size);

      // Bounding box of the point and the two control points:
      var minX = Math.min(n.x, cp.x1, cp.x2),
          maxX = Math.max(n.x, cp.x1, cp.x2),
          minY = Math.min(n.y, cp.y1, cp.y2),
          maxY = Math.max(n.y, cp.y1, cp.y2);

      return {
        x1: minX - n.size,
        y1: minY - n.size,
        x2: maxX + n.size,
        y2: minY - n.size,
        height: maxY - minY + n.size * 2
      };
    },

    /**
     * Checks whether a rectangle is axis-aligned.
     *
     * @param  {object}  A rectangle defined by two points
     *                   (x1, y1) and (x2, y2).
     * @return {boolean} True if the rectangle is axis-aligned.
     */
    isAxisAligned: function(r) {
      return r.x1 === r.x2 || r.y1 === r.y2;
    },

    /**
     * Compute top points of an axis-aligned rectangle. This is useful in
     * cases when the rectangle has been rotated (left, right or bottom up) and
     * later operations need to know the top points.
     *
     * @param  {object} An axis-aligned rectangle defined by two points
     *                  (x1, y1), (x2, y2) and height.
     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.
     */
    axisAlignedTopPoints: function(r) {

      // Basic
      if (r.y1 === r.y2 && r.x1 < r.x2)
        return r;

      // Rotated to right
      if (r.x1 === r.x2 && r.y2 > r.y1)
        return {
          x1: r.x1 - r.height, y1: r.y1,
          x2: r.x1, y2: r.y1,
          height: r.height
        };

      // Rotated to left
      if (r.x1 === r.x2 && r.y2 < r.y1)
        return {
          x1: r.x1, y1: r.y2,
          x2: r.x2 + r.height, y2: r.y2,
          height: r.height
        };

      // Bottom's up
      return {
        x1: r.x2, y1: r.y1 - r.height,
        x2: r.x1, y2: r.y1 - r.height,
        height: r.height
      };
    },

    /**
     * Get coordinates of a rectangle's lower left corner from its top points.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerLeftCoor: function(r) {
      var width = (
        Math.sqrt(
          Math.pow(r.x2 - r.x1, 2) +
          Math.pow(r.y2 - r.y1, 2)
        )
      );

      return {
        x: r.x1 - (r.y2 - r.y1) * r.height / width,
        y: r.y1 + (r.x2 - r.x1) * r.height / width
      };
    },

    /**
     * Get coordinates of a rectangle's lower right corner from its top points
     * and its lower left corner.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @param  {object} A corner's coordinates (x, y).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerRightCoor: function(r, llc) {
      return {
        x: llc.x - r.x1 + r.x2,
        y: llc.y - r.y1 + r.y2
      };
    },

    /**
     * Get the coordinates of all the corners of a rectangle from its top point.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {array}  An array of the four corners' coordinates (x, y).
     */
    rectangleCorners: function(r) {
      var llc = this.lowerLeftCoor(r),
          lrc = this.lowerRightCoor(r, llc);

      return [
        {x: r.x1, y: r.y1},
        {x: r.x2, y: r.y2},
        {x: llc.x, y: llc.y},
        {x: lrc.x, y: lrc.y}
      ];
    },

    /**
     * Split a square defined by its boundaries into four.
     *
     * @param  {object} Boundaries of the square (x, y, width, height).
     * @return {array}  An array containing the four new squares, themselves
     *                  defined by an array of their four corners (x, y).
     */
    splitSquare: function(b) {
      return [
        [
          {x: b.x, y: b.y},
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2}
        ],
        [
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x + b.width, y: b.y},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2}
        ],
        [
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x, y: b.y + b.height},
          {x: b.x + b.width / 2, y: b.y + b.height}
        ],
        [
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height},
          {x: b.x + b.width, y: b.y + b.height}
        ]
      ];
    },

    /**
     * Compute the four axis between corners of rectangle A and corners of
     * rectangle B. This is needed later to check an eventual collision.
     *
     * @param  {array} An array of rectangle A's four corners (x, y).
     * @param  {array} An array of rectangle B's four corners (x, y).
     * @return {array} An array of four axis defined by their coordinates (x,y).
     */
    axis: function(c1, c2) {
      return [
        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},
        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},
        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},
        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}
      ];
    },

    /**
     * Project a rectangle's corner on an axis.
     *
     * @param  {object} Coordinates of a corner (x, y).
     * @param  {object} Coordinates of an axis (x, y).
     * @return {object} The projection defined by coordinates (x, y).
     */
    projection: function(c, a) {
      var l = (
        (c.x * a.x + c.y * a.y) /
        (Math.pow(a.x, 2) + Math.pow(a.y, 2))
      );

      return {
        x: l * a.x,
        y: l * a.y
      };
    },

    /**
     * Check whether two rectangles collide on one particular axis.
     *
     * @param  {object}   An axis' coordinates (x, y).
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide on the axis.
     */
    axisCollision: function(a, c1, c2) {
      var sc1 = [],
          sc2 = [];

      for (var ci = 0; ci < 4; ci++) {
        var p1 = this.projection(c1[ci], a),
            p2 = this.projection(c2[ci], a);

        sc1.push(p1.x * a.x + p1.y * a.y);
        sc2.push(p2.x * a.x + p2.y * a.y);
      }

      var maxc1 = Math.max.apply(Math, sc1),
          maxc2 = Math.max.apply(Math, sc2),
          minc1 = Math.min.apply(Math, sc1),
          minc2 = Math.min.apply(Math, sc2);

      return (minc2 <= maxc1 && maxc2 >= minc1);
    },

    /**
     * Check whether two rectangles collide on each one of their four axis. If
     * all axis collide, then the two rectangles do collide on the plane.
     *
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide.
     */
    collision: function(c1, c2) {
      var axis = this.axis(c1, c2),
          col = true;

      for (var i = 0; i < 4; i++)
        col = col && this.axisCollision(axis[i], c1, c2);

      return col;
    }
  };


  /**
   * Quad Functions
   * ------------
   *
   * The Quadtree functions themselves.
   * For each of those functions, we consider that in a splitted quad, the
   * index of each node is the following:
   * 0: top left
   * 1: top right
   * 2: bottom left
   * 3: bottom right
   *
   * Moreover, the hereafter quad's philosophy is to consider that if an element
   * collides with more than one nodes, this element belongs to each of the
   * nodes it collides with where other would let it lie on a higher node.
   */

  /**
   * Get the index of the node containing the point in the quad
   *
   * @param  {object}  point      A point defined by coordinates (x, y).
   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).
   * @return {integer}            The index of the node containing the point.
   */
  function _quadIndex(point, quadBounds) {
    var xmp = quadBounds.x + quadBounds.width / 2,
        ymp = quadBounds.y + quadBounds.height / 2,
        top = (point.y < ymp),
        left = (point.x < xmp);

    if (top) {
      if (left)
        return 0;
      else
        return 1;
    }
    else {
      if (left)
        return 2;
      else
        return 3;
    }
  }

  /**
   * Get a list of indexes of nodes containing an axis-aligned rectangle
   *
   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),
   *                               (x2, y2) and height.
   * @param  {array}   quadCorners An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadIndexes(rectangle, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if ((rectangle.x2 >= quadCorners[i][0].x) &&
          (rectangle.x1 <= quadCorners[i][1].x) &&
          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&
          (rectangle.y1 <= quadCorners[i][2].y))
        indexes.push(i);

    return indexes;
  }

  /**
   * Get a list of indexes of nodes containing a non-axis-aligned rectangle
   *
   * @param  {array}  corners      An array containing each corner of the
   *                               rectangle defined by its coordinates (x, y).
   * @param  {array}  quadCorners  An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadCollision(corners, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if (_geom.collision(corners, quadCorners[i]))
        indexes.push(i);

    return indexes;
  }

  /**
   * Subdivide a quad by creating a node at a precise index. The function does
   * not generate all four nodes not to potentially create unused nodes.
   *
   * @param  {integer}  index The index of the node to create.
   * @param  {object}   quad  The quad object to subdivide.
   * @return {object}         A new quad representing the node created.
   */
  function _quadSubdivide(index, quad) {
    var next = quad.level + 1,
        subw = Math.round(quad.bounds.width / 2),
        subh = Math.round(quad.bounds.height / 2),
        qx = Math.round(quad.bounds.x),
        qy = Math.round(quad.bounds.y),
        x,
        y;

    switch (index) {
      case 0:
        x = qx;
        y = qy;
        break;
      case 1:
        x = qx + subw;
        y = qy;
        break;
      case 2:
        x = qx;
        y = qy + subh;
        break;
      case 3:
        x = qx + subw;
        y = qy + subh;
        break;
    }

    return _quadTree(
      {x: x, y: y, width: subw, height: subh},
      next,
      quad.maxElements,
      quad.maxLevel
    );
  }

  /**
   * Recursively insert an element into the quadtree. Only points
   * with size, i.e. axis-aligned squares, may be inserted with this
   * method.
   *
   * @param  {object}  el         The element to insert in the quadtree.
   * @param  {object}  sizedPoint A sized point defined by two top points
   *                              (x1, y1), (x2, y2) and height.
   * @param  {object}  quad       The quad in which to insert the element.
   * @return {undefined}          The function does not return anything.
   */
  function _quadInsert(el, sizedPoint, quad) {
    if (quad.level < quad.maxLevel) {

      // Searching appropriate quads
      var indexes = _quadIndexes(sizedPoint, quad.corners);

      // Iterating
      for (var i = 0, l = indexes.length; i < l; i++) {

        // Subdividing if necessary
        if (quad.nodes[indexes[i]] === undefined)
          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);

        // Recursion
        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);
      }
    }
    else {

      // Pushing the element in a leaf node
      quad.elements.push(el);
    }
  }

  /**
   * Recursively retrieve every elements held by the node containing the
   * searched point.
   *
   * @param  {object}  point The searched point (x, y).
   * @param  {object}  quad  The searched quad.
   * @return {array}         An array of elements contained in the relevant
   *                         node.
   */
  function _quadRetrievePoint(point, quad) {
    if (quad.level < quad.maxLevel) {
      var index = _quadIndex(point, quad.bounds);

      // If node does not exist we return an empty list
      if (quad.nodes[index] !== undefined) {
        return _quadRetrievePoint(point, quad.nodes[index]);
      }
      else {
        return [];
      }
    }
    else {
      return quad.elements;
    }
  }

  /**
   * Recursively retrieve every elements contained within an rectangular area
   * that may or may not be axis-aligned.
   *
   * @param  {object|array} rectData       The searched area defined either by
   *                                       an array of four corners (x, y) in
   *                                       the case of a non-axis-aligned
   *                                       rectangle or an object with two top
   *                                       points (x1, y1), (x2, y2) and height.
   * @param  {object}       quad           The searched quad.
   * @param  {function}     collisionFunc  The collision function used to search
   *                                       for node indexes.
   * @param  {array?}       els            The retrieved elements.
   * @return {array}                       An array of elements contained in the
   *                                       area.
   */
  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {
    els = els || {};

    if (quad.level < quad.maxLevel) {
      var indexes = collisionFunc(rectData, quad.corners);

      for (var i = 0, l = indexes.length; i < l; i++)
        if (quad.nodes[indexes[i]] !== undefined)
          _quadRetrieveArea(
            rectData,
            quad.nodes[indexes[i]],
            collisionFunc,
            els
          );
    } else
      for (var j = 0, m = quad.elements.length; j < m; j++)
        if (els[quad.elements[j].id] === undefined)
          els[quad.elements[j].id] = quad.elements[j];

    return els;
  }

  /**
   * Creates the quadtree object itself.
   *
   * @param  {object}   bounds       The boundaries of the quad defined by an
   *                                 origin (x, y), width and heigth.
   * @param  {integer}  level        The level of the quad in the tree.
   * @param  {integer}  maxElements  The max number of element in a leaf node.
   * @param  {integer}  maxLevel     The max recursion level of the tree.
   * @return {object}                The quadtree object.
   */
  function _quadTree(bounds, level, maxElements, maxLevel) {
    return {
      level: level || 0,
      bounds: bounds,
      corners: _geom.splitSquare(bounds),
      maxElements: maxElements || 40,
      maxLevel: maxLevel || 8,
      elements: [],
      nodes: []
    };
  }


  /**
   * Sigma Quad Constructor
   * ----------------------
   *
   * The edgequad API as exposed to sigma.
   */

  /**
   * The edgequad core that will become the sigma interface with the quadtree.
   *
   * property {object} _tree     Property holding the quadtree object.
   * property {object} _geom     Exposition of the _geom namespace for testing.
   * property {object} _cache    Cache for the area method.
   * property {boolean} _enabled Can index and retreive elements.
   */
  var edgequad = function() {
    this._geom = _geom;
    this._tree = null;
    this._cache = {
      query: false,
      result: false
    };
    this._enabled = true;
  };

  /**
   * Index a graph by inserting its edges into the quadtree.
   *
   * @param  {object} graph   A graph instance.
   * @param  {object} params  An object of parameters with at least the quad
   *                          bounds.
   * @return {object}         The quadtree object.
   *
   * Parameters:
   * ----------
   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)
   *                         width and heigth.
   * prefix:      {string?}  a prefix for edge geometric attributes.
   * maxElements: {integer?} the max number of elements in a leaf node.
   * maxLevel:    {integer?} the max recursion level of the tree.
   */
  edgequad.prototype.index = function(graph, params) {
    if (!this._enabled)
      return this._tree;

    // Enforcing presence of boundaries
    if (!params.bounds)
      throw 'sigma.classes.edgequad.index: bounds information not given.';

    // Prefix
    var prefix = params.prefix || '',
        cp,
        source,
        target,
        n,
        e;

    // Building the tree
    this._tree = _quadTree(
      params.bounds,
      0,
      params.maxElements,
      params.maxLevel
    );

    var edges = graph.edges();

    // Inserting graph edges into the tree
    for (var i = 0, l = edges.length; i < l; i++) {
      source = graph.nodes(edges[i].source);
      target = graph.nodes(edges[i].target);
      e = {
        x1: source[prefix + 'x'],
        y1: source[prefix + 'y'],
        x2: target[prefix + 'x'],
        y2: target[prefix + 'y'],
        size: edges[i][prefix + 'size'] || 0
      };

      // Inserting edge
      if (edges[i].type === 'curve' || edges[i].type === 'curvedArrow') {
        if (source.id === target.id) {
          n = {
            x: source[prefix + 'x'],
            y: source[prefix + 'y'],
            size: source[prefix + 'size'] || 0
          };
          _quadInsert(
            edges[i],
            _geom.selfLoopToSquare(n),
            this._tree);
        }
        else {
          cp = sigma.utils.getQuadraticControlPoint(e.x1, e.y1, e.x2, e.y2);
          _quadInsert(
            edges[i],
            _geom.quadraticCurveToSquare(e, cp),
            this._tree);
        }
      }
      else {
        _quadInsert(
          edges[i],
          _geom.lineToSquare(e),
          this._tree);
      }
    }

    // Reset cache:
    this._cache = {
      query: false,
      result: false
    };

    // remove?
    return this._tree;
  };

  /**
   * Retrieve every graph edges held by the quadtree node containing the
   * searched point.
   *
   * @param  {number} x of the point.
   * @param  {number} y of the point.
   * @return {array}  An array of edges retrieved.
   */
  edgequad.prototype.point = function(x, y) {
    if (!this._enabled)
      return [];

    return this._tree ?
      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :
      [];
  };

  /**
   * Retrieve every graph edges within a rectangular area. The methods keep the
   * last area queried in cache for optimization reason and will act differently
   * for the same reason if the area is axis-aligned or not.
   *
   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)
   *                  and height.
   * @return {array}  An array of edges retrieved.
   */
  edgequad.prototype.area = function(rect) {
    if (!this._enabled)
      return [];

    var serialized = JSON.stringify(rect),
        collisionFunc,
        rectData;

    // Returning cache?
    if (this._cache.query === serialized)
      return this._cache.result;

    // Axis aligned ?
    if (_geom.isAxisAligned(rect)) {
      collisionFunc = _quadIndexes;
      rectData = _geom.axisAlignedTopPoints(rect);
    }
    else {
      collisionFunc = _quadCollision;
      rectData = _geom.rectangleCorners(rect);
    }

    // Retrieving edges
    var edges = this._tree ?
      _quadRetrieveArea(
        rectData,
        this._tree,
        collisionFunc
      ) :
      [];

    // Object to array
    var edgesArray = [];
    for (var i in edges)
      edgesArray.push(edges[i]);

    // Caching
    this._cache.query = serialized;
    this._cache.result = edgesArray;

    return edgesArray;
  };


  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.edgequad = edgequad;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = edgequad;
    exports.edgequad = edgequad;
  } else
    this.edgequad = edgequad;
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.captors');

  /**
   * The user inputs default captor. It deals with mouse events, keyboards
   * events and touch events.
   *
   * @param  {DOMElement}   target   The DOM element where the listeners will be
   *                                 bound.
   * @param  {camera}       camera   The camera related to the target.
   * @param  {configurable} settings The settings function.
   * @return {sigma.captor}          The fresh new captor instance.
   */
  sigma.captors.mouse = function(target, camera, settings) {
    var _self = this,
        _target = target,
        _camera = camera,
        _settings = settings,

        // CAMERA MANAGEMENT:
        // ******************
        // The camera position when the user starts dragging:
        _startCameraX,
        _startCameraY,
        _startCameraAngle,

        // The latest stage position:
        _lastCameraX,
        _lastCameraY,
        _lastCameraAngle,
        _lastCameraRatio,

        // MOUSE MANAGEMENT:
        // *****************
        // The mouse position when the user starts dragging:
        _startMouseX,
        _startMouseY,

        _isMouseDown,
        _isMoving,
        _hasDragged,
        _downStartTime,
        _movingTimeoutId;

    sigma.classes.dispatcher.extend(this);

    sigma.utils.doubleClick(_target, 'click', _doubleClickHandler);
    _target.addEventListener('DOMMouseScroll', _wheelHandler, false);
    _target.addEventListener('mousewheel', _wheelHandler, false);
    _target.addEventListener('mousemove', _moveHandler, false);
    _target.addEventListener('mousedown', _downHandler, false);
    _target.addEventListener('click', _clickHandler, false);
    _target.addEventListener('mouseout', _outHandler, false);
    document.addEventListener('mouseup', _upHandler, false);




    /**
     * This method unbinds every handlers that makes the captor work.
     */
    this.kill = function() {
      sigma.utils.unbindDoubleClick(_target, 'click');
      _target.removeEventListener('DOMMouseScroll', _wheelHandler);
      _target.removeEventListener('mousewheel', _wheelHandler);
      _target.removeEventListener('mousemove', _moveHandler);
      _target.removeEventListener('mousedown', _downHandler);
      _target.removeEventListener('click', _clickHandler);
      _target.removeEventListener('mouseout', _outHandler);
      document.removeEventListener('mouseup', _upHandler);
    };




    // MOUSE EVENTS:
    // *************

    /**
     * The handler listening to the 'move' mouse event. It will effectively
     * drag the graph.
     *
     * @param {event} e A mouse event.
     */
    function _moveHandler(e) {
      var x,
          y,
          pos;

      // Dispatch event:
      if (_settings('mouseEnabled')) {
        _self.dispatchEvent('mousemove',
          sigma.utils.mouseCoords(e));

        if (_isMouseDown) {
          _isMoving = true;
          _hasDragged = true;

          if (_movingTimeoutId)
            clearTimeout(_movingTimeoutId);

          _movingTimeoutId = setTimeout(function() {
            _isMoving = false;
          }, _settings('dragTimeout'));

          sigma.misc.animation.killAll(_camera);

          _camera.isMoving = true;
          pos = _camera.cameraPosition(
            sigma.utils.getX(e) - _startMouseX,
            sigma.utils.getY(e) - _startMouseY,
            true
          );

          x = _startCameraX - pos.x;
          y = _startCameraY - pos.y;

          if (x !== _camera.x || y !== _camera.y) {
            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            _camera.goTo({
              x: x,
              y: y
            });
          }

          if (e.preventDefault)
            e.preventDefault();
          else
            e.returnValue = false;

          e.stopPropagation();
          return false;
        }
      }
    }

    /**
     * The handler listening to the 'up' mouse event. It will stop dragging the
     * graph.
     *
     * @param {event} e A mouse event.
     */
    function _upHandler(e) {
      if (_settings('mouseEnabled') && _isMouseDown) {
        _isMouseDown = false;
        if (_movingTimeoutId)
          clearTimeout(_movingTimeoutId);

        _camera.isMoving = false;

        var x = sigma.utils.getX(e),
            y = sigma.utils.getY(e);

        if (_isMoving) {
          sigma.misc.animation.killAll(_camera);
          sigma.misc.animation.camera(
            _camera,
            {
              x: _camera.x +
                _settings('mouseInertiaRatio') * (_camera.x - _lastCameraX),
              y: _camera.y +
                _settings('mouseInertiaRatio') * (_camera.y - _lastCameraY)
            },
            {
              easing: 'quadraticOut',
              duration: _settings('mouseInertiaDuration')
            }
          );
        } else if (
          _startMouseX !== x ||
          _startMouseY !== y
        )
          _camera.goTo({
            x: _camera.x,
            y: _camera.y
          });

        _self.dispatchEvent('mouseup',
          sigma.utils.mouseCoords(e));

        // Update _isMoving flag:
        _isMoving = false;
      }
    }

    /**
     * The handler listening to the 'down' mouse event. It will start observing
     * the mouse position for dragging the graph.
     *
     * @param {event} e A mouse event.
     */
    function _downHandler(e) {
      if (_settings('mouseEnabled')) {
        _startCameraX = _camera.x;
        _startCameraY = _camera.y;

        _lastCameraX = _camera.x;
        _lastCameraY = _camera.y;

        _startMouseX = sigma.utils.getX(e);
        _startMouseY = sigma.utils.getY(e);

        _hasDragged = false;
        _downStartTime = (new Date()).getTime();

        switch (e.which) {
          case 2:
            // Middle mouse button pressed
            // Do nothing.
            break;
          case 3:
            // Right mouse button pressed
            _self.dispatchEvent('rightclick',
              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));
            break;
          // case 1:
          default:
            // Left mouse button pressed
            _isMouseDown = true;

            _self.dispatchEvent('mousedown',
              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));
        }
      }
    }

    /**
     * The handler listening to the 'out' mouse event. It will just redispatch
     * the event.
     *
     * @param {event} e A mouse event.
     */
    function _outHandler(e) {
      if (_settings('mouseEnabled'))
        _self.dispatchEvent('mouseout');
    }

    /**
     * The handler listening to the 'click' mouse event. It will redispatch the
     * click event, but with normalized X and Y coordinates.
     *
     * @param {event} e A mouse event.
     */
    function _clickHandler(e) {
      if (_settings('mouseEnabled')) {
        var event = sigma.utils.mouseCoords(e);
        event.isDragging =
          (((new Date()).getTime() - _downStartTime) > 100) && _hasDragged;
        _self.dispatchEvent('click', event);
      }

      if (e.preventDefault)
        e.preventDefault();
      else
        e.returnValue = false;

      e.stopPropagation();
      return false;
    }

    /**
     * The handler listening to the double click custom event. It will
     * basically zoom into the graph.
     *
     * @param {event} e A mouse event.
     */
    function _doubleClickHandler(e) {
      var pos,
          ratio,
          animation;

      if (_settings('mouseEnabled')) {
        ratio = 1 / _settings('doubleClickZoomingRatio');

        _self.dispatchEvent('doubleclick',
            sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));

        if (_settings('doubleClickEnabled')) {
          pos = _camera.cameraPosition(
            sigma.utils.getX(e) - sigma.utils.getCenter(e).x,
            sigma.utils.getY(e) - sigma.utils.getCenter(e).y,
            true
          );

          animation = {
            duration: _settings('doubleClickZoomDuration')
          };

          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);
        }

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }

    /**
     * The handler listening to the 'wheel' mouse event. It will basically zoom
     * in or not into the graph.
     *
     * @param {event} e A mouse event.
     */
    function _wheelHandler(e) {
      var pos,
          ratio,
          animation,
          wheelDelta = sigma.utils.getDelta(e);

      if (_settings('mouseEnabled') && _settings('mouseWheelEnabled') && wheelDelta !== 0) {
        ratio = wheelDelta > 0 ?
          1 / _settings('zoomingRatio') :
          _settings('zoomingRatio');

        pos = _camera.cameraPosition(
          sigma.utils.getX(e) - sigma.utils.getCenter(e).x,
          sigma.utils.getY(e) - sigma.utils.getCenter(e).y,
          true
        );

        animation = {
          duration: _settings('mouseZoomDuration')
        };

        sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.captors');

  /**
   * The user inputs default captor. It deals with mouse events, keyboards
   * events and touch events.
   *
   * @param  {DOMElement}   target   The DOM element where the listeners will be
   *                                 bound.
   * @param  {camera}       camera   The camera related to the target.
   * @param  {configurable} settings The settings function.
   * @return {sigma.captor}          The fresh new captor instance.
   */
  sigma.captors.touch = function(target, camera, settings) {
    var _self = this,
        _target = target,
        _camera = camera,
        _settings = settings,

        // CAMERA MANAGEMENT:
        // ******************
        // The camera position when the user starts dragging:
        _startCameraX,
        _startCameraY,
        _startCameraAngle,
        _startCameraRatio,

        // The latest stage position:
        _lastCameraX,
        _lastCameraY,
        _lastCameraAngle,
        _lastCameraRatio,

        // TOUCH MANAGEMENT:
        // *****************
        // Touches that are down:
        _downTouches = [],

        _startTouchX0,
        _startTouchY0,
        _startTouchX1,
        _startTouchY1,
        _startTouchAngle,
        _startTouchDistance,

        _touchMode,

        _isMoving,
        _doubleTap,
        _movingTimeoutId;

    sigma.classes.dispatcher.extend(this);

    sigma.utils.doubleClick(_target, 'touchstart', _doubleTapHandler);
    _target.addEventListener('touchstart', _handleStart, false);
    _target.addEventListener('touchend', _handleLeave, false);
    _target.addEventListener('touchcancel', _handleLeave, false);
    _target.addEventListener('touchleave', _handleLeave, false);
    _target.addEventListener('touchmove', _handleMove, false);

    function position(e) {
      var offset = sigma.utils.getOffset(_target);

      return {
        x: e.pageX - offset.left,
        y: e.pageY - offset.top
      };
    }

    /**
     * This method unbinds every handlers that makes the captor work.
     */
    this.kill = function() {
      sigma.utils.unbindDoubleClick(_target, 'touchstart');
      _target.addEventListener('touchstart', _handleStart);
      _target.addEventListener('touchend', _handleLeave);
      _target.addEventListener('touchcancel', _handleLeave);
      _target.addEventListener('touchleave', _handleLeave);
      _target.addEventListener('touchmove', _handleMove);
    };

    // TOUCH EVENTS:
    // *************
    /**
     * The handler listening to the 'touchstart' event. It will set the touch
     * mode ("_touchMode") and start observing the user touch moves.
     *
     * @param {event} e A touch event.
     */
    function _handleStart(e) {
      if (_settings('touchEnabled')) {
        var x0,
            x1,
            y0,
            y1,
            pos0,
            pos1;

        _downTouches = e.touches;

        switch (_downTouches.length) {
          case 1:
            _camera.isMoving = true;
            _touchMode = 1;

            _startCameraX = _camera.x;
            _startCameraY = _camera.y;

            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            pos0 = position(_downTouches[0]);
            _startTouchX0 = pos0.x;
            _startTouchY0 = pos0.y;

            break;
          case 2:
            _camera.isMoving = true;
            _touchMode = 2;

            pos0 = position(_downTouches[0]);
            pos1 = position(_downTouches[1]);
            x0 = pos0.x;
            y0 = pos0.y;
            x1 = pos1.x;
            y1 = pos1.y;

            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            _startCameraAngle = _camera.angle;
            _startCameraRatio = _camera.ratio;

            _startCameraX = _camera.x;
            _startCameraY = _camera.y;

            _startTouchX0 = x0;
            _startTouchY0 = y0;
            _startTouchX1 = x1;
            _startTouchY1 = y1;

            _startTouchAngle = Math.atan2(
              _startTouchY1 - _startTouchY0,
              _startTouchX1 - _startTouchX0
            );
            _startTouchDistance = Math.sqrt(
              (_startTouchY1 - _startTouchY0) *
                (_startTouchY1 - _startTouchY0) +
              (_startTouchX1 - _startTouchX0) *
                (_startTouchX1 - _startTouchX0)
            );

            e.preventDefault();
            return false;
        }
      }
    }

    /**
     * The handler listening to the 'touchend', 'touchcancel' and 'touchleave'
     * event. It will update the touch mode if there are still at least one
     * finger, and stop dragging else.
     *
     * @param {event} e A touch event.
     */
    function _handleLeave(e) {
      if (_settings('touchEnabled')) {
        _downTouches = e.touches;
        var inertiaRatio = _settings('touchInertiaRatio');

        if (_movingTimeoutId) {
          _isMoving = false;
          clearTimeout(_movingTimeoutId);
        }

        switch (_touchMode) {
          case 2:
            if (e.touches.length === 1) {
              _handleStart(e);

              e.preventDefault();
              break;
            }
            /* falls through */
          case 1:
            _camera.isMoving = false;
            _self.dispatchEvent('stopDrag');

            if (_isMoving) {
              _doubleTap = false;
              sigma.misc.animation.camera(
                _camera,
                {
                  x: _camera.x +
                    inertiaRatio * (_camera.x - _lastCameraX),
                  y: _camera.y +
                    inertiaRatio * (_camera.y - _lastCameraY)
                },
                {
                  easing: 'quadraticOut',
                  duration: _settings('touchInertiaDuration')
                }
              );
            }

            _isMoving = false;
            _touchMode = 0;
            break;
        }
      }
    }

    /**
     * The handler listening to the 'touchmove' event. It will effectively drag
     * the graph, and eventually zooms and turn it if the user is using two
     * fingers.
     *
     * @param {event} e A touch event.
     */
    function _handleMove(e) {
      if (!_doubleTap && _settings('touchEnabled')) {
        var x0,
            x1,
            y0,
            y1,
            cos,
            sin,
            end,
            pos0,
            pos1,
            diff,
            start,
            dAngle,
            dRatio,
            newStageX,
            newStageY,
            newStageRatio,
            newStageAngle;

        _downTouches = e.touches;
        _isMoving = true;

        if (_movingTimeoutId)
          clearTimeout(_movingTimeoutId);

        _movingTimeoutId = setTimeout(function() {
          _isMoving = false;
        }, _settings('dragTimeout'));

        switch (_touchMode) {
          case 1:
            pos0 = position(_downTouches[0]);
            x0 = pos0.x;
            y0 = pos0.y;

            diff = _camera.cameraPosition(
              x0 - _startTouchX0,
              y0 - _startTouchY0,
              true
            );

            newStageX = _startCameraX - diff.x;
            newStageY = _startCameraY - diff.y;

            if (newStageX !== _camera.x || newStageY !== _camera.y) {
              _lastCameraX = _camera.x;
              _lastCameraY = _camera.y;

              _camera.goTo({
                x: newStageX,
                y: newStageY
              });

              _self.dispatchEvent('mousemove',
                sigma.utils.mouseCoords(e, pos0.x, pos0.y));

              _self.dispatchEvent('drag');
            }
            break;
          case 2:
            pos0 = position(_downTouches[0]);
            pos1 = position(_downTouches[1]);
            x0 = pos0.x;
            y0 = pos0.y;
            x1 = pos1.x;
            y1 = pos1.y;

            start = _camera.cameraPosition(
              (_startTouchX0 + _startTouchX1) / 2 -
                sigma.utils.getCenter(e).x,
              (_startTouchY0 + _startTouchY1) / 2 -
                sigma.utils.getCenter(e).y,
              true
            );
            end = _camera.cameraPosition(
              (x0 + x1) / 2 - sigma.utils.getCenter(e).x,
              (y0 + y1) / 2 - sigma.utils.getCenter(e).y,
              true
            );

            dAngle = Math.atan2(y1 - y0, x1 - x0) - _startTouchAngle;
            dRatio = Math.sqrt(
              (y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0)
            ) / _startTouchDistance;

            // Translation:
            x0 = start.x;
            y0 = start.y;

            // Homothetic transformation:
            newStageRatio = _startCameraRatio / dRatio;
            x0 = x0 * dRatio;
            y0 = y0 * dRatio;

            // Rotation:
            newStageAngle = _startCameraAngle - dAngle;
            cos = Math.cos(-dAngle);
            sin = Math.sin(-dAngle);
            x1 = x0 * cos + y0 * sin;
            y1 = y0 * cos - x0 * sin;
            x0 = x1;
            y0 = y1;

            // Finalize:
            newStageX = x0 - end.x + _startCameraX;
            newStageY = y0 - end.y + _startCameraY;

            if (
              newStageRatio !== _camera.ratio ||
              newStageAngle !== _camera.angle ||
              newStageX !== _camera.x ||
              newStageY !== _camera.y
            ) {
              _lastCameraX = _camera.x;
              _lastCameraY = _camera.y;
              _lastCameraAngle = _camera.angle;
              _lastCameraRatio = _camera.ratio;

              _camera.goTo({
                x: newStageX,
                y: newStageY,
                angle: newStageAngle,
                ratio: newStageRatio
              });

              _self.dispatchEvent('drag');
            }

            break;
        }

        e.preventDefault();
        return false;
      }
    }

    /**
     * The handler listening to the double tap custom event. It will
     * basically zoom into the graph.
     *
     * @param {event} e A touch event.
     */
    function _doubleTapHandler(e) {
      var pos,
          ratio,
          animation;

      if (e.touches && e.touches.length === 1 && _settings('touchEnabled')) {
        _doubleTap = true;

        ratio = 1 / _settings('doubleClickZoomingRatio');

        pos = position(e.touches[0]);
        _self.dispatchEvent('doubleclick',
          sigma.utils.mouseCoords(e, pos.x, pos.y));

        if (_settings('doubleClickEnabled')) {
          pos = _camera.cameraPosition(
            pos.x - sigma.utils.getCenter(e).x,
            pos.y - sigma.utils.getCenter(e).y,
            true
          );

          animation = {
            duration: _settings('doubleClickZoomDuration'),
            onComplete: function() {
              _doubleTap = false;
            }
          };

          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);
        }

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  if (typeof conrad === 'undefined')
    throw 'conrad is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the canvas sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.canvas}          The renderer instance.
   */
  sigma.renderers.canvas = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.canvas: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var k,
        i,
        l,
        a,
        fn,
        self = this;

    sigma.classes.dispatcher.extend(this);

    // Initialize main attributes:
    Object.defineProperty(this, 'conradId', {
      value: sigma.utils.id()
    });
    this.graph = graph;
    this.camera = camera;
    this.contexts = {};
    this.domElements = {};
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Node indexes:
    this.nodesOnScreen = [];
    this.edgesOnScreen = [];

    // Conrad related attributes:
    this.jobs = {};

    // Find the prefix:
    this.options.prefix = 'renderer' + this.conradId + ':';

    // Initialize the DOM elements:
    if (
      !this.settings('batchEdgesDrawing')
    ) {
      this.initDOM('canvas', 'scene');
      this.contexts.edges = this.contexts.scene;
      this.contexts.nodes = this.contexts.scene;
      this.contexts.labels = this.contexts.scene;
    } else {
      this.initDOM('canvas', 'edges');
      this.initDOM('canvas', 'scene');
      this.contexts.nodes = this.contexts.scene;
      this.contexts.labels = this.contexts.scene;
    }

    this.initDOM('canvas', 'mouse');
    this.contexts.hover = this.contexts.mouse;

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.mouse,
          this.camera,
          this.settings
        )
      );
    }

    // Deal with sigma events:
    sigma.misc.bindEvents.call(this, this.options.prefix);
    sigma.misc.drawHovers.call(this, this.options.prefix);

    this.resize(false);
  };




  /**
   * This method renders the graph on the canvases.
   *
   * @param  {?object}                options Eventually an object of options.
   * @return {sigma.renderers.canvas}         Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.render = function(options) {
    options = options || {};

    var a,
        i,
        k,
        l,
        o,
        id,
        end,
        job,
        start,
        edges,
        renderers,
        rendererType,
        batchSize,
        tempGCO,
        index = {},
        graph = this.graph,
        nodes = this.graph.nodes,
        prefix = this.options.prefix || '',
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes'),
        drawLabels = this.settings(options, 'drawLabels'),
        drawEdgeLabels = this.settings(options, 'drawEdgeLabels'),
        embedSettings = this.settings.embedObjects(options, {
          prefix: this.options.prefix
        });

    // Call the resize function:
    this.resize(false);

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Apply the camera's view:
    this.camera.applyView(
      undefined,
      this.options.prefix,
      {
        width: this.width,
        height: this.height
      }
    );

    // Clear canvases:
    this.clear();

    // Kill running jobs:
    for (k in this.jobs)
      if (conrad.hasJob(k))
        conrad.killJob(k);

    // Find which nodes are on screen:
    this.edgesOnScreen = [];
    this.nodesOnScreen = this.camera.quadtree.area(
      this.camera.getRectangle(this.width, this.height)
    );

    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
      index[a[i].id] = a[i];

    // Draw edges:
    // - If settings('batchEdgesDrawing') is true, the edges are displayed per
    //   batches. If not, they are drawn in one frame.
    if (drawEdges) {
      // First, let's identify which edges to draw. To do this, we just keep
      // every edges that have at least one extremity displayed according to
      // the quadtree and the "hidden" attribute. We also do not keep hidden
      // edges.
      for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
        o = a[i];
        if (
          (index[o.source] || index[o.target]) &&
          (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)
        )
          this.edgesOnScreen.push(o);
      }

      // If the "batchEdgesDrawing" settings is true, edges are batched:
      if (this.settings(options, 'batchEdgesDrawing')) {
        id = 'edges_' + this.conradId;
        batchSize = embedSettings('canvasEdgesBatchSize');

        edges = this.edgesOnScreen;
        l = edges.length;

        start = 0;
        end = Math.min(edges.length, start + batchSize);

        job = function() {
          tempGCO = this.contexts.edges.globalCompositeOperation;
          this.contexts.edges.globalCompositeOperation = 'destination-over';

          renderers = sigma.canvas.edges;
          for (i = start; i < end; i++) {
            o = edges[i];
            (renderers[
              o.type || this.settings(options, 'defaultEdgeType')
            ] || renderers.def)(
              o,
              graph.nodes(o.source),
              graph.nodes(o.target),
              this.contexts.edges,
              embedSettings
            );
          }

          // Draw edge labels:
          if (drawEdgeLabels) {
            renderers = sigma.canvas.edges.labels;
            for (i = start; i < end; i++) {
              o = edges[i];
              if (!o.hidden)
                (renderers[
                  o.type || this.settings(options, 'defaultEdgeType')
                ] || renderers.def)(
                  o,
                  graph.nodes(o.source),
                  graph.nodes(o.target),
                  this.contexts.labels,
                  embedSettings
                );
            }
          }

          // Restore original globalCompositeOperation:
          this.contexts.edges.globalCompositeOperation = tempGCO;

          // Catch job's end:
          if (end === edges.length) {
            delete this.jobs[id];
            return false;
          }

          start = end + 1;
          end = Math.min(edges.length, start + batchSize);
          return true;
        };

        this.jobs[id] = job;
        conrad.addJob(id, job.bind(this));

      // If not, they are drawn in one frame:
      } else {
        renderers = sigma.canvas.edges;
        for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
          o = a[i];
          (renderers[
            o.type || this.settings(options, 'defaultEdgeType')
          ] || renderers.def)(
            o,
            graph.nodes(o.source),
            graph.nodes(o.target),
            this.contexts.edges,
            embedSettings
          );
        }

        // Draw edge labels:
        // - No batching
        if (drawEdgeLabels) {
          renderers = sigma.canvas.edges.labels;
          for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++)
            if (!a[i].hidden)
              (renderers[
                a[i].type || this.settings(options, 'defaultEdgeType')
              ] || renderers.def)(
                a[i],
                graph.nodes(a[i].source),
                graph.nodes(a[i].target),
                this.contexts.labels,
                embedSettings
              );
        }
      }
    }

    // Draw nodes:
    // - No batching
    if (drawNodes) {
      renderers = sigma.canvas.nodes;
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (renderers[
            a[i].type || this.settings(options, 'defaultNodeType')
          ] || renderers.def)(
            a[i],
            this.contexts.nodes,
            embedSettings
          );
    }

    // Draw labels:
    // - No batching
    if (drawLabels) {
      renderers = sigma.canvas.labels;
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (renderers[
            a[i].type || this.settings(options, 'defaultNodeType')
          ] || renderers.def)(
            a[i],
            this.contexts.labels,
            embedSettings
          );
    }

    this.dispatchEvent('render');

    return this;
  };

  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string} tag The label tag.
   * @param  {string} id  The id of the element (to store it in "domElements").
   */
  sigma.renderers.canvas.prototype.initDOM = function(tag, id) {
    var dom = document.createElement(tag);

    dom.style.position = 'absolute';
    dom.setAttribute('class', 'sigma-' + id);

    this.domElements[id] = dom;
    this.container.appendChild(dom);

    if (tag.toLowerCase() === 'canvas')
      this.contexts[id] = dom.getContext('2d');
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}                width  The new width of the container.
   * @param  {?number}                height The new height of the container.
   * @return {sigma.renderers.canvas}        Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.resize = function(w, h) {
    var k,
        oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = sigma.utils.getPixelRatio();

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      for (k in this.domElements) {
        this.domElements[k].style.width = w + 'px';
        this.domElements[k].style.height = h + 'px';

        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {
          this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');
          this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');

          if (pixelRatio !== 1)
            this.contexts[k].scale(pixelRatio, pixelRatio);
        }
      }
    }

    return this;
  };

  /**
   * This method clears each canvas.
   *
   * @return {sigma.renderers.canvas} Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.clear = function() {
    for (var k in this.contexts) {
      this.contexts[k].clearRect(0, 0, this.width, this.height);
    }

    return this;
  };

  /**
   * This method kills contexts and other attributes.
   */
  sigma.renderers.canvas.prototype.kill = function() {
    var k,
        captor;

    // Kill captors:
    while ((captor = this.captors.pop()))
      captor.kill();
    delete this.captors;

    // Kill contexts:
    for (k in this.domElements) {
      this.domElements[k].parentNode.removeChild(this.domElements[k]);
      delete this.domElements[k];
      delete this.contexts[k];
    }
    delete this.domElements;
    delete this.contexts;
  };




  /**
   * The labels, nodes and edges renderers are stored in the three following
   * objects. When an element is drawn, its type will be checked and if a
   * renderer with the same name exists, it will be used. If not found, the
   * default renderer will be used instead.
   *
   * They are stored in different files, in the "./canvas" folder.
   */
  sigma.utils.pkg('sigma.canvas.nodes');
  sigma.utils.pkg('sigma.canvas.edges');
  sigma.utils.pkg('sigma.canvas.labels');
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the canvas sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.canvas}          The renderer instance.
   */
  sigma.renderers.webgl = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.webgl: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var k,
        i,
        l,
        a,
        fn,
        _self = this;

    sigma.classes.dispatcher.extend(this);

    // Conrad related attributes:
    this.jobs = {};

    Object.defineProperty(this, 'conradId', {
      value: sigma.utils.id()
    });

    // Initialize main attributes:
    this.graph = graph;
    this.camera = camera;
    this.contexts = {};
    this.domElements = {};
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Find the prefix:
    this.options.prefix = this.camera.readPrefix;

    // Initialize programs hash
    Object.defineProperty(this, 'nodePrograms', {
      value: {}
    });
    Object.defineProperty(this, 'edgePrograms', {
      value: {}
    });
    Object.defineProperty(this, 'nodeFloatArrays', {
      value: {}
    });
    Object.defineProperty(this, 'edgeFloatArrays', {
      value: {}
    });
    Object.defineProperty(this, 'edgeIndicesArrays', {
      value: {}
    });

    // Initialize the DOM elements:
    if (this.settings(options, 'batchEdgesDrawing')) {
      this.initDOM('canvas', 'edges', true);
      this.initDOM('canvas', 'nodes', true);
    } else {
      this.initDOM('canvas', 'scene', true);
      this.contexts.nodes = this.contexts.scene;
      this.contexts.edges = this.contexts.scene;
    }

    this.initDOM('canvas', 'labels');
    this.initDOM('canvas', 'mouse');
    this.contexts.hover = this.contexts.mouse;

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.mouse,
          this.camera,
          this.settings
        )
      );
    }

    // Deal with sigma events:
    sigma.misc.bindEvents.call(this, this.camera.prefix);
    sigma.misc.drawHovers.call(this, this.camera.prefix);

    this.resize();
  };




  /**
   * This method will generate the nodes and edges float arrays. This step is
   * separated from the "render" method, because to keep WebGL efficient, since
   * all the camera and middlewares are modelised as matrices and they do not
   * require the float arrays to be regenerated.
   *
   * Basically, when the user moves the camera or applies some specific linear
   * transformations, this process step will be skipped, and the "render"
   * method will efficiently refresh the rendering.
   *
   * And when the user modifies the graph colors or positions (applying a new
   * layout or filtering the colors, for instance), this "process" step will be
   * required to regenerate the float arrays.
   *
   * @return {sigma.renderers.webgl} Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.process = function() {
    var a,
        i,
        l,
        k,
        type,
        renderer,
        graph = this.graph,
        options = sigma.utils.extend(options, this.options),
        defaultEdgeType = this.settings(options, 'defaultEdgeType'),
        defaultNodeType = this.settings(options, 'defaultNodeType');

    // Empty float arrays:
    for (k in this.nodeFloatArrays)
      delete this.nodeFloatArrays[k];

    for (k in this.edgeFloatArrays)
      delete this.edgeFloatArrays[k];

    for (k in this.edgeIndicesArrays)
      delete this.edgeIndicesArrays[k];

    // Sort edges and nodes per types:
    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
      type = a[i].type || defaultEdgeType;
      k = (type && sigma.webgl.edges[type]) ? type : 'def';

      if (!this.edgeFloatArrays[k])
        this.edgeFloatArrays[k] = {
          edges: []
        };

      this.edgeFloatArrays[k].edges.push(a[i]);
    }

    for (a = graph.nodes(), i = 0, l = a.length; i < l; i++) {
      type = a[i].type || defaultNodeType;
      k = (type && sigma.webgl.nodes[type]) ? type : 'def';

      if (!this.nodeFloatArrays[k])
        this.nodeFloatArrays[k] = {
          nodes: []
        };

      this.nodeFloatArrays[k].nodes.push(a[i]);
    }

    // Push edges:
    for (k in this.edgeFloatArrays) {
      renderer = sigma.webgl.edges[k];
      a = this.edgeFloatArrays[k].edges;

      // Creating the necessary arrays
      this.edgeFloatArrays[k].array = new Float32Array(
        a.length * renderer.POINTS * renderer.ATTRIBUTES
      );

      for (i = 0, l = a.length; i < l; i++) {

        // Just check that the edge and both its extremities are visible:
        if (
          !a[i].hidden &&
          !graph.nodes(a[i].source).hidden &&
          !graph.nodes(a[i].target).hidden
        )
          renderer.addEdge(
            a[i],
            graph.nodes(a[i].source),
            graph.nodes(a[i].target),
            this.edgeFloatArrays[k].array,
            i * renderer.POINTS * renderer.ATTRIBUTES,
            options.prefix,
            this.settings
          );
      }

      if (typeof renderer.computeIndices === 'function')
        this.edgeIndicesArrays[k] = renderer.computeIndices(
          this.edgeFloatArrays[k].array
        );
    }

    // Push nodes:
    for (k in this.nodeFloatArrays) {
      renderer = sigma.webgl.nodes[k];
      a = this.nodeFloatArrays[k].nodes;

      // Creating the necessary arrays
      this.nodeFloatArrays[k].array = new Float32Array(
        a.length * renderer.POINTS * renderer.ATTRIBUTES
      );

      for (i = 0, l = a.length; i < l; i++) {
        if (!this.nodeFloatArrays[k].array)
          this.nodeFloatArrays[k].array = new Float32Array(
            a.length * renderer.POINTS * renderer.ATTRIBUTES
          );

        // Just check that the edge and both its extremities are visible:
        if (
          !a[i].hidden
        )
          renderer.addNode(
            a[i],
            this.nodeFloatArrays[k].array,
            i * renderer.POINTS * renderer.ATTRIBUTES,
            options.prefix,
            this.settings
          );
      }
    }

    return this;
  };




  /**
   * This method renders the graph. It basically calls each program (and
   * generate them if they do not exist yet) to render nodes and edges, batched
   * per renderer.
   *
   * As in the canvas renderer, it is possible to display edges, nodes and / or
   * labels in batches, to make the whole thing way more scalable.
   *
   * @param  {?object}               params Eventually an object of options.
   * @return {sigma.renderers.webgl}        Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.render = function(params) {
    var a,
        i,
        l,
        k,
        o,
        program,
        renderer,
        self = this,
        graph = this.graph,
        nodesGl = this.contexts.nodes,
        edgesGl = this.contexts.edges,
        matrix = this.camera.getMatrix(),
        options = sigma.utils.extend(params, this.options),
        drawLabels = this.settings(options, 'drawLabels'),
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes');

    // Call the resize function:
    this.resize(false);

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Clear canvases:
    this.clear();

    // Translate matrix to [width/2, height/2]:
    matrix = sigma.utils.matrices.multiply(
      matrix,
      sigma.utils.matrices.translation(this.width / 2, this.height / 2)
    );

    // Kill running jobs:
    for (k in this.jobs)
      if (conrad.hasJob(k))
        conrad.killJob(k);

    if (drawEdges) {
      if (this.settings(options, 'batchEdgesDrawing'))
        (function() {
          var a,
              k,
              i,
              id,
              job,
              arr,
              end,
              start,
              indices,
              renderer,
              batchSize,
              currentProgram;

          id = 'edges_' + this.conradId;
          batchSize = this.settings(options, 'webglEdgesBatchSize');
          a = Object.keys(this.edgeFloatArrays);

          if (!a.length)
            return;
          i = 0;
          renderer = sigma.webgl.edges[a[i]];
          arr = this.edgeFloatArrays[a[i]].array;
          indices = this.edgeIndicesArrays[a[i]];
          start = 0;
          end = Math.min(
            start + batchSize * renderer.POINTS,
            arr.length / renderer.ATTRIBUTES
          );

          job = function() {
            // Check program:
            if (!this.edgePrograms[a[i]])
              this.edgePrograms[a[i]] = renderer.initProgram(edgesGl);

            if (start < end) {
              edgesGl.useProgram(this.edgePrograms[a[i]]);
              renderer.render(
                edgesGl,
                this.edgePrograms[a[i]],
                arr,
                {
                  settings: this.settings,
                  matrix: matrix,
                  width: this.width,
                  height: this.height,
                  ratio: this.camera.ratio,
                  scalingRatio: this.settings(
                    options,
                    'webglOversamplingRatio'
                  ),
                  start: start,
                  count: end - start,
                  indicesData: indices
                }
              );
            }

            // Catch job's end:
            if (
              end >= arr.length / renderer.ATTRIBUTES &&
              i === a.length - 1
            ) {
              delete this.jobs[id];
              return false;
            }

            if (end >= arr.length / renderer.ATTRIBUTES) {
              i++;
              arr = this.edgeFloatArrays[a[i]].array;
              renderer = sigma.webgl.edges[a[i]];
              start = 0;
              end = Math.min(
                start + batchSize * renderer.POINTS,
                arr.length / renderer.ATTRIBUTES
              );
            } else {
              start = end;
              end = Math.min(
                start + batchSize * renderer.POINTS,
                arr.length / renderer.ATTRIBUTES
              );
            }

            return true;
          };

          this.jobs[id] = job;
          conrad.addJob(id, job.bind(this));
        }).call(this);
      else {
        for (k in this.edgeFloatArrays) {
          renderer = sigma.webgl.edges[k];

          // Check program:
          if (!this.edgePrograms[k])
            this.edgePrograms[k] = renderer.initProgram(edgesGl);

          // Render
          if (this.edgeFloatArrays[k]) {
            edgesGl.useProgram(this.edgePrograms[k]);
            renderer.render(
              edgesGl,
              this.edgePrograms[k],
              this.edgeFloatArrays[k].array,
              {
                settings: this.settings,
                matrix: matrix,
                width: this.width,
                height: this.height,
                ratio: this.camera.ratio,
                scalingRatio: this.settings(options, 'webglOversamplingRatio'),
                indicesData: this.edgeIndicesArrays[k]
              }
            );
          }
        }
      }
    }

    if (drawNodes) {
      // Enable blending:
      nodesGl.blendFunc(nodesGl.SRC_ALPHA, nodesGl.ONE_MINUS_SRC_ALPHA);
      nodesGl.enable(nodesGl.BLEND);

      for (k in this.nodeFloatArrays) {
        renderer = sigma.webgl.nodes[k];

        // Check program:
        if (!this.nodePrograms[k])
          this.nodePrograms[k] = renderer.initProgram(nodesGl);

        // Render
        if (this.nodeFloatArrays[k]) {
          nodesGl.useProgram(this.nodePrograms[k]);
          renderer.render(
            nodesGl,
            this.nodePrograms[k],
            this.nodeFloatArrays[k].array,
            {
              settings: this.settings,
              matrix: matrix,
              width: this.width,
              height: this.height,
              ratio: this.camera.ratio,
              scalingRatio: this.settings(options, 'webglOversamplingRatio')
            }
          );
        }
      }
    }

    if (drawLabels) {
      a = this.camera.quadtree.area(
        this.camera.getRectangle(this.width, this.height)
      );

      // Apply camera view to these nodes:
      this.camera.applyView(
        undefined,
        undefined,
        {
          nodes: a,
          edges: [],
          width: this.width,
          height: this.height
        }
      );

      o = function(key) {
        return self.settings({
          prefix: self.camera.prefix
        }, key);
      };

      for (i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (
            sigma.canvas.labels[
              a[i].type ||
              this.settings(options, 'defaultNodeType')
            ] || sigma.canvas.labels.def
          )(a[i], this.contexts.labels, o);
    }

    this.dispatchEvent('render');

    return this;
  };




  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string}   tag   The label tag.
   * @param  {string}   id    The id of the element (to store it in
   *                          "domElements").
   * @param  {?boolean} webgl Will init the WebGL context if true.
   */
  sigma.renderers.webgl.prototype.initDOM = function(tag, id, webgl) {
    var gl,
        dom = document.createElement(tag),
        self = this;

    dom.style.position = 'absolute';
    dom.setAttribute('class', 'sigma-' + id);

    this.domElements[id] = dom;
    this.container.appendChild(dom);

    if (tag.toLowerCase() === 'canvas') {
      this.contexts[id] = dom.getContext(webgl ? 'experimental-webgl' : '2d', {
        preserveDrawingBuffer: true
      });

      // Adding webgl context loss listeners
      if (webgl) {
        dom.addEventListener('webglcontextlost', function(e) {
          e.preventDefault();
        }, false);

        dom.addEventListener('webglcontextrestored', function(e) {
          self.render();
        }, false);
      }
    }
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}               width  The new width of the container.
   * @param  {?number}               height The new height of the container.
   * @return {sigma.renderers.webgl}        Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.resize = function(w, h) {
    var k,
        oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = sigma.utils.getPixelRatio();

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      for (k in this.domElements) {
        this.domElements[k].style.width = w + 'px';
        this.domElements[k].style.height = h + 'px';

        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {
          // If simple 2D canvas:
          if (this.contexts[k] && this.contexts[k].scale) {
            this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');
            this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');

            if (pixelRatio !== 1)
              this.contexts[k].scale(pixelRatio, pixelRatio);
          } else {
            this.domElements[k].setAttribute(
              'width',
              (w * this.settings('webglOversamplingRatio')) + 'px'
            );
            this.domElements[k].setAttribute(
              'height',
              (h * this.settings('webglOversamplingRatio')) + 'px'
            );
          }
        }
      }
    }

    // Scale:
    for (k in this.contexts)
      if (this.contexts[k] && this.contexts[k].viewport)
        this.contexts[k].viewport(
          0,
          0,
          this.width * this.settings('webglOversamplingRatio'),
          this.height * this.settings('webglOversamplingRatio')
        );

    return this;
  };

  /**
   * This method clears each canvas.
   *
   * @return {sigma.renderers.webgl} Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.clear = function() {
    this.contexts.labels.clearRect(0, 0, this.width, this.height);
    this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);
    this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);

    return this;
  };

  /**
   * This method kills contexts and other attributes.
   */
  sigma.renderers.webgl.prototype.kill = function() {
    var k,
        captor;

    // Kill captors:
    while ((captor = this.captors.pop()))
      captor.kill();
    delete this.captors;

    // Kill contexts:
    for (k in this.domElements) {
      this.domElements[k].parentNode.removeChild(this.domElements[k]);
      delete this.domElements[k];
      delete this.contexts[k];
    }
    delete this.domElements;
    delete this.contexts;
  };




  /**
   * The object "sigma.webgl.nodes" contains the different WebGL node
   * renderers. The default one draw nodes as discs. Here are the attributes
   * any node renderer must have:
   *
   * {number}   POINTS      The number of points required to draw a node.
   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.
   * {function} addNode     A function that adds a node to the data stack that
   *                        will be given to the buffer. Here is the arguments:
   *                        > {object}       node
   *                        > {number}       index   The node index in the
   *                                                 nodes array.
   *                        > {Float32Array} data    The stack.
   *                        > {object}       options Some options.
   * {function} render      The function that will effectively render the nodes
   *                        into the buffer.
   *                        > {WebGLRenderingContext} gl
   *                        > {WebGLProgram}          program
   *                        > {Float32Array} data    The stack to give to the
   *                                                 buffer.
   *                        > {object}       params  An object containing some
   *                                                 options, like width,
   *                                                 height, the camera ratio.
   * {function} initProgram The function that will initiate the program, with
   *                        the relevant shaders and parameters. It must return
   *                        the newly created program.
   *
   * Check sigma.webgl.nodes.def or sigma.webgl.nodes.fast to see how it
   * works more precisely.
   */
  sigma.utils.pkg('sigma.webgl.nodes');




  /**
   * The object "sigma.webgl.edges" contains the different WebGL edge
   * renderers. The default one draw edges as direct lines. Here are the
   * attributes any edge renderer must have:
   *
   * {number}   POINTS      The number of points required to draw an edge.
   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.
   * {function} addEdge     A function that adds an edge to the data stack that
   *                        will be given to the buffer. Here is the arguments:
   *                        > {object}       edge
   *                        > {object}       source
   *                        > {object}       target
   *                        > {Float32Array} data    The stack.
   *                        > {object}       options Some options.
   * {function} render      The function that will effectively render the edges
   *                        into the buffer.
   *                        > {WebGLRenderingContext} gl
   *                        > {WebGLProgram}          program
   *                        > {Float32Array} data    The stack to give to the
   *                                                 buffer.
   *                        > {object}       params  An object containing some
   *                                                 options, like width,
   *                                                 height, the camera ratio.
   * {function} initProgram The function that will initiate the program, with
   *                        the relevant shaders and parameters. It must return
   *                        the newly created program.
   *
   * Check sigma.webgl.edges.def or sigma.webgl.edges.fast to see how it
   * works more precisely.
   */
  sigma.utils.pkg('sigma.webgl.edges');




  /**
   * The object "sigma.canvas.labels" contains the different
   * label renderers for the WebGL renderer. Since displaying texts in WebGL is
   * definitely painful and since there a way less labels to display than nodes
   * or edges, the default renderer simply renders them in a canvas.
   *
   * A labels renderer is a simple function, taking as arguments the related
   * node, the renderer and a settings function.
   */
  sigma.utils.pkg('sigma.canvas.labels');
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  if (typeof conrad === 'undefined')
    throw 'conrad is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the svg sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.svg}             The renderer instance.
   */
  sigma.renderers.svg = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.svg: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var i,
        l,
        a,
        fn,
        self = this;

    sigma.classes.dispatcher.extend(this);

    // Initialize main attributes:
    this.graph = graph;
    this.camera = camera;
    this.domElements = {
      graph: null,
      groups: {},
      nodes: {},
      edges: {},
      labels: {},
      hovers: {}
    };
    this.measurementCanvas = null;
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Is the renderer meant to be freestyle?
    this.settings('freeStyle', !!this.options.freeStyle);

    // SVG xmlns
    this.settings('xmlns', 'http://www.w3.org/2000/svg');

    // Indexes:
    this.nodesOnScreen = [];
    this.edgesOnScreen = [];

    // Find the prefix:
    this.options.prefix = 'renderer' + sigma.utils.id() + ':';

    // Initialize the DOM elements
    this.initDOM('svg');

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.graph,
          this.camera,
          this.settings
        )
      );
    }

    // Bind resize:
    window.addEventListener('resize', function() {
      self.resize();
    });

    // Deal with sigma events:
    // TODO: keep an option to override the DOM events?
    sigma.misc.bindDOMEvents.call(this, this.domElements.graph);
    this.bindHovers(this.options.prefix);

    // Resize
    this.resize(false);
  };

  /**
   * This method renders the graph on the svg scene.
   *
   * @param  {?object}                options Eventually an object of options.
   * @return {sigma.renderers.svg}            Returns the instance itself.
   */
  sigma.renderers.svg.prototype.render = function(options) {
    options = options || {};

    var a,
        i,
        k,
        e,
        l,
        o,
        source,
        target,
        start,
        edges,
        renderers,
        subrenderers,
        index = {},
        graph = this.graph,
        nodes = this.graph.nodes,
        prefix = this.options.prefix || '',
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes'),
        drawLabels = this.settings(options, 'drawLabels'),
        embedSettings = this.settings.embedObjects(options, {
          prefix: this.options.prefix,
          forceLabels: this.options.forceLabels
        });

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Apply the camera's view:
    this.camera.applyView(
      undefined,
      this.options.prefix,
      {
        width: this.width,
        height: this.height
      }
    );

    // Hiding everything
    // TODO: find a more sensible way to perform this operation
    this.hideDOMElements(this.domElements.nodes);
    this.hideDOMElements(this.domElements.edges);
    this.hideDOMElements(this.domElements.labels);

    // Find which nodes are on screen
    this.edgesOnScreen = [];
    this.nodesOnScreen = this.camera.quadtree.area(
      this.camera.getRectangle(this.width, this.height)
    );

    // Node index
    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
      index[a[i].id] = a[i];

    // Find which edges are on screen
    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
      o = a[i];
      if (
        (index[o.source] || index[o.target]) &&
        (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)
      )
        this.edgesOnScreen.push(o);
    }

    // Display nodes
    //---------------
    renderers = sigma.svg.nodes;
    subrenderers = sigma.svg.labels;

    //-- First we create the nodes which are not already created
    if (drawNodes)
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {
        if (!a[i].hidden && !this.domElements.nodes[a[i].id]) {

          // Node
          e = (renderers[a[i].type] || renderers.def).create(
            a[i],
            embedSettings
          );

          this.domElements.nodes[a[i].id] = e;
          this.domElements.groups.nodes.appendChild(e);

          // Label
          e = (subrenderers[a[i].type] || subrenderers.def).create(
            a[i],
            embedSettings
          );

          this.domElements.labels[a[i].id] = e;
          this.domElements.groups.labels.appendChild(e);
        }
      }

    //-- Second we update the nodes
    if (drawNodes)
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {

        if (a[i].hidden)
          continue;

        // Node
        (renderers[a[i].type] || renderers.def).update(
          a[i],
          this.domElements.nodes[a[i].id],
          embedSettings
        );

        // Label
        (subrenderers[a[i].type] || subrenderers.def).update(
          a[i],
          this.domElements.labels[a[i].id],
          embedSettings
        );
      }

    // Display edges
    //---------------
    renderers = sigma.svg.edges;

    //-- First we create the edges which are not already created
    if (drawEdges)
      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
        if (!this.domElements.edges[a[i].id]) {
          source = nodes(a[i].source);
          target = nodes(a[i].target);

          e = (renderers[a[i].type] || renderers.def).create(
            a[i],
            source,
            target,
            embedSettings
          );

          this.domElements.edges[a[i].id] = e;
          this.domElements.groups.edges.appendChild(e);
        }
       }

    //-- Second we update the edges
    if (drawEdges)
      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
        source = nodes(a[i].source);
        target = nodes(a[i].target);

        (renderers[a[i].type] || renderers.def).update(
          a[i],
          this.domElements.edges[a[i].id],
          source,
          target,
          embedSettings
        );
       }

    this.dispatchEvent('render');

    return this;
  };

  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string} tag The label tag.
   * @param  {string} id  The id of the element (to store it in "domElements").
   */
  sigma.renderers.svg.prototype.initDOM = function(tag) {
    var dom = document.createElementNS(this.settings('xmlns'), tag),
        c = this.settings('classPrefix'),
        g,
        l,
        i;

    dom.style.position = 'absolute';
    dom.setAttribute('class', c + '-svg');

    // Setting SVG namespace
    dom.setAttribute('xmlns', this.settings('xmlns'));
    dom.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
    dom.setAttribute('version', '1.1');

    // Creating the measurement canvas
    var canvas = document.createElement('canvas');
    canvas.setAttribute('class', c + '-measurement-canvas');

    // Appending elements
    this.domElements.graph = this.container.appendChild(dom);

    // Creating groups
    var groups = ['edges', 'nodes', 'labels', 'hovers'];
    for (i = 0, l = groups.length; i < l; i++) {
      g = document.createElementNS(this.settings('xmlns'), 'g');

      g.setAttributeNS(null, 'id', c + '-group-' + groups[i]);
      g.setAttributeNS(null, 'class', c + '-group');

      this.domElements.groups[groups[i]] =
        this.domElements.graph.appendChild(g);
    }

    // Appending measurement canvas
    this.container.appendChild(canvas);
    this.measurementCanvas = canvas.getContext('2d');
  };

  /**
   * This method hides a batch of SVG DOM elements.
   *
   * @param  {array}                  elements  An array of elements to hide.
   * @param  {object}                 renderer  The renderer to use.
   * @return {sigma.renderers.svg}              Returns the instance itself.
   */
  sigma.renderers.svg.prototype.hideDOMElements = function(elements) {
    var o,
        i;

    for (i in elements) {
      o = elements[i];
      sigma.svg.utils.hide(o);
    }

    return this;
  };

  /**
   * This method binds the hover events to the renderer.
   *
   * @param  {string} prefix The renderer prefix.
   */
  // TODO: add option about whether to display hovers or not
  sigma.renderers.svg.prototype.bindHovers = function(prefix) {
    var renderers = sigma.svg.hovers,
        self = this,
        hoveredNode;

    function overNode(e) {
      var node = e.data.node,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      if (!embedSettings('enableHovering'))
        return;

      var hover = (renderers[node.type] || renderers.def).create(
        node,
        self.domElements.nodes[node.id],
        self.measurementCanvas,
        embedSettings
      );

      self.domElements.hovers[node.id] = hover;

      // Inserting the hover in the dom
      self.domElements.groups.hovers.appendChild(hover);
      hoveredNode = node;
    }

    function outNode(e) {
      var node = e.data.node,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      if (!embedSettings('enableHovering'))
        return;

      // Deleting element
      self.domElements.groups.hovers.removeChild(
        self.domElements.hovers[node.id]
      );
      hoveredNode = null;
      delete self.domElements.hovers[node.id];

      // Reinstate
      self.domElements.groups.nodes.appendChild(
        self.domElements.nodes[node.id]
      );
    }

    // OPTIMIZE: perform a real update rather than a deletion
    function update() {
      if (!hoveredNode)
        return;

      var embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      // Deleting element before update
      self.domElements.groups.hovers.removeChild(
        self.domElements.hovers[hoveredNode.id]
      );
      delete self.domElements.hovers[hoveredNode.id];

      var hover = (renderers[hoveredNode.type] || renderers.def).create(
        hoveredNode,
        self.domElements.nodes[hoveredNode.id],
        self.measurementCanvas,
        embedSettings
      );

      self.domElements.hovers[hoveredNode.id] = hover;

      // Inserting the hover in the dom
      self.domElements.groups.hovers.appendChild(hover);
    }

    // Binding events
    this.bind('overNode', overNode);
    this.bind('outNode', outNode);

    // Update on render
    this.bind('render', update);
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}                width  The new width of the container.
   * @param  {?number}                height The new height of the container.
   * @return {sigma.renderers.svg}           Returns the instance itself.
   */
  sigma.renderers.svg.prototype.resize = function(w, h) {
    var oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = 1;

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      this.domElements.graph.style.width = w + 'px';
      this.domElements.graph.style.height = h + 'px';

      if (this.domElements.graph.tagName.toLowerCase() === 'svg') {
        this.domElements.graph.setAttribute('width', (w * pixelRatio));
        this.domElements.graph.setAttribute('height', (h * pixelRatio));
      }
    }

    return this;
  };


  /**
   * The labels, nodes and edges renderers are stored in the three following
   * objects. When an element is drawn, its type will be checked and if a
   * renderer with the same name exists, it will be used. If not found, the
   * default renderer will be used instead.
   *
   * They are stored in different files, in the "./svg" folder.
   */
  sigma.utils.pkg('sigma.svg.nodes');
  sigma.utils.pkg('sigma.svg.edges');
  sigma.utils.pkg('sigma.svg.labels');
}).call(this);

;(function(global) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  // Check if WebGL is enabled:
  var canvas,
      webgl = !!global.WebGLRenderingContext;
  if (webgl) {
    canvas = document.createElement('canvas');
    try {
      webgl = !!(
        canvas.getContext('webgl') ||
        canvas.getContext('experimental-webgl')
      );
    } catch (e) {
      webgl = false;
    }
  }

  // Copy the good renderer:
  sigma.renderers.def = webgl ?
    sigma.renderers.webgl :
    sigma.renderers.canvas;
})(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.nodes');

  /**
   * This node renderer will display nodes as discs, shaped in triangles with
   * the gl.TRIANGLES display mode. So, to be more precise, to draw one node,
   * it will store three times the center of node, with the color and the size,
   * and an angle indicating which "corner" of the triangle to draw.
   *
   * The fragment shader does not deal with anti-aliasing, so make sure that
   * you deal with it somewhere else in the code (by default, the WebGL
   * renderer will oversample the rendering through the webglOversamplingRatio
   * value).
   */
  sigma.webgl.nodes.def = {
    POINTS: 3,
    ATTRIBUTES: 5,
    addNode: function(node, data, i, prefix, settings) {
      var color = sigma.utils.floatColor(
        node.color || settings('defaultNodeColor')
      );

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 0;

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 2 * Math.PI / 3;

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 4 * Math.PI / 3;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          sizeLocation =
            gl.getAttribLocation(program, 'a_size'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          angleLocation =
            gl.getAttribLocation(program, 'a_angle'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(sizeLocation);
      gl.enableVertexAttribArray(colorLocation);
      gl.enableVertexAttribArray(angleLocation);

      gl.vertexAttribPointer(
        positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(
        sizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(
        colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        12
      );
      gl.vertexAttribPointer(
        angleLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_size;',
          'attribute float a_color;',
          'attribute float a_angle;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',
          'varying vec2 center;',
          'varying float radius;',

          'void main() {',
            // Multiply the point size twice:
            'radius = a_size * u_ratio;',

            // Scale from [[-1 1] [-1 1]] to the container:
            'vec2 position = (u_matrix * vec3(a_position, 1)).xy;',
            // 'center = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',
            'center = position * u_scale;',
            'center = vec2(center.x, u_scale * u_resolution.y - center.y);',

            'position = position +',
              '2.0 * radius * vec2(cos(a_angle), sin(a_angle));',
            'position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',

            'radius = radius * u_scale;',

            'gl_Position = vec4(position, 0, 1);',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',
          'varying vec2 center;',
          'varying float radius;',

          'void main(void) {',
            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',

            'vec2 m = gl_FragCoord.xy - center;',
            'float diff = radius - sqrt(m.x * m.x + m.y * m.y);',

            // Here is how we draw a disc instead of a square:
            'if (diff > 0.0)',
              'gl_FragColor = color;',
            'else',
              'gl_FragColor = color0;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.nodes');

  /**
   * This node renderer will display nodes in the fastest way: Nodes are basic
   * squares, drawn through the gl.POINTS drawing method. The size of the nodes
   * are represented with the "gl_PointSize" value in the vertex shader.
   *
   * It is the fastest node renderer here since the buffer just takes one line
   * to draw each node (with attributes "x", "y", "size" and "color").
   *
   * Nevertheless, this method has some problems, especially due to some issues
   * with the gl.POINTS:
   *  - First, if the center of a node is outside the scene, the point will not
   *    be drawn, even if it should be partly on screen.
   *  - I tried applying a fragment shader similar to the one in the default
   *    node renderer to display them as discs, but it did not work fine on
   *    some computers settings, filling the discs with weird gradients not
   *    depending on the actual color.
   */
  sigma.webgl.nodes.fast = {
    POINTS: 1,
    ATTRIBUTES: 4,
    addNode: function(node, data, i, prefix, settings) {
      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = sigma.utils.floatColor(
        node.color || settings('defaultNodeColor')
      );
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          sizeLocation =
            gl.getAttribLocation(program, 'a_size'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(sizeLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(
        positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(
        sizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(
        colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        12
      );

      gl.drawArrays(
        gl.POINTS,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_size;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',

          'void main() {',
            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(a_position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Multiply the point size twice:
            //  - x SCALING_RATIO to correct the canvas scaling
            //  - x 2 to correct the formulae
            'gl_PointSize = a_size * u_ratio * u_scale * 2.0;',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'float border = 0.01;',
            'float radius = 0.5;',

            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',
            'vec2 m = gl_PointCoord - vec2(0.5, 0.5);',
            'float dist = radius - sqrt(m.x * m.x + m.y * m.y);',

            'float t = 0.0;',
            'if (dist > border)',
              't = 1.0;',
            'else if (dist > 0.0)',
              't = dist / border;',

            'gl_FragColor = mix(color0, color, t);',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as lines going from the source node
   * to the target node. To deal with edge thicknesses, the lines are made of
   * two triangles forming rectangles, with the gl.TRIANGLES drawing mode.
   *
   * It is expensive, since drawing a single edge requires 6 points, each
   * having 7 attributes (source position, target position, thickness, color
   * and a flag indicating which vertice of the rectangle it is).
   */
  sigma.webgl.edges.def = {
    POINTS: 6,
    ATTRIBUTES: 7,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 1.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 1.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          positionLocation1 =
            gl.getAttribLocation(program, 'a_position1'),
          positionLocation2 =
            gl.getAttribLocation(program, 'a_position2'),
          thicknessLocation =
            gl.getAttribLocation(program, 'a_thickness'),
          minusLocation =
            gl.getAttribLocation(program, 'a_minus'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          matrixHalfPiLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPi'),
          matrixHalfPiMinusLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);
      gl.uniformMatrix2fv(
        matrixHalfPiLocation,
        false,
        sigma.utils.matrices.rotation(Math.PI / 2, true)
      );
      gl.uniformMatrix2fv(
        matrixHalfPiMinusLocation,
        false,
        sigma.utils.matrices.rotation(-Math.PI / 2, true)
      );

      gl.enableVertexAttribArray(colorLocation);
      gl.enableVertexAttribArray(positionLocation1);
      gl.enableVertexAttribArray(positionLocation2);
      gl.enableVertexAttribArray(thicknessLocation);
      gl.enableVertexAttribArray(minusLocation);

      gl.vertexAttribPointer(positionLocation1,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(positionLocation2,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(thicknessLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );
      gl.vertexAttribPointer(minusLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        20
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        24
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position1;',
          'attribute vec2 a_position2;',
          'attribute float a_thickness;',
          'attribute float a_minus;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',
          'uniform mat2 u_matrixHalfPi;',
          'uniform mat2 u_matrixHalfPiMinus;',

          'varying vec4 color;',

          'void main() {',
            // Find the good point:
            'vec2 position = a_thickness * u_ratio *',
              'normalize(a_position2 - a_position1);',

            'mat2 matrix = a_minus * u_matrixHalfPiMinus +',
              '(1.0 - a_minus) * u_matrixHalfPi;',

            'position = matrix * position + a_position1;',

            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as lines with the gl.LINES display
   * mode. Since this mode does not support well thickness, edges are all drawn
   * with the same thickness (3px), independantly of the edge attributes or the
   * zooming ratio.
   */
  sigma.webgl.edges.fast = {
    POINTS: 2,
    ATTRIBUTES: 3,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );

      gl.lineWidth(3);
      gl.drawArrays(
        gl.LINES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',

          'void main() {',
            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(a_position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as arrows going from the source node
   * to the target node. To deal with edge thicknesses, the lines are made of
   * three triangles: two forming rectangles, with the gl.TRIANGLES drawing
   * mode.
   *
   * It is expensive, since drawing a single edge requires 9 points, each
   * having a lot of attributes.
   */
  sigma.webgl.edges.arrow = {
    POINTS: 9,
    ATTRIBUTES: 11,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          targetSize = target[prefix + 'size'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      // Arrow head:
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = -1.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 1.0;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation1 =
            gl.getAttribLocation(program, 'a_pos1'),
          positionLocation2 =
            gl.getAttribLocation(program, 'a_pos2'),
          thicknessLocation =
            gl.getAttribLocation(program, 'a_thickness'),
          targetSizeLocation =
            gl.getAttribLocation(program, 'a_tSize'),
          delayLocation =
            gl.getAttribLocation(program, 'a_delay'),
          minusLocation =
            gl.getAttribLocation(program, 'a_minus'),
          headLocation =
            gl.getAttribLocation(program, 'a_head'),
          headPositionLocation =
            gl.getAttribLocation(program, 'a_headPosition'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          matrixHalfPiLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPi'),
          matrixHalfPiMinusLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          nodeRatioLocation =
            gl.getUniformLocation(program, 'u_nodeRatio'),
          arrowHeadLocation =
            gl.getUniformLocation(program, 'u_arrowHead'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))
      );
      gl.uniform1f(
        nodeRatioLocation,
        Math.pow(params.ratio, params.settings('nodesPowRatio')) /
        params.ratio
      );
      gl.uniform1f(arrowHeadLocation, 5.0);
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);
      gl.uniformMatrix2fv(
        matrixHalfPiLocation,
        false,
        sigma.utils.matrices.rotation(Math.PI / 2, true)
      );
      gl.uniformMatrix2fv(
        matrixHalfPiMinusLocation,
        false,
        sigma.utils.matrices.rotation(-Math.PI / 2, true)
      );

      gl.enableVertexAttribArray(positionLocation1);
      gl.enableVertexAttribArray(positionLocation2);
      gl.enableVertexAttribArray(thicknessLocation);
      gl.enableVertexAttribArray(targetSizeLocation);
      gl.enableVertexAttribArray(delayLocation);
      gl.enableVertexAttribArray(minusLocation);
      gl.enableVertexAttribArray(headLocation);
      gl.enableVertexAttribArray(headPositionLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(positionLocation1,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(positionLocation2,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(thicknessLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );
      gl.vertexAttribPointer(targetSizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        20
      );
      gl.vertexAttribPointer(delayLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        24
      );
      gl.vertexAttribPointer(minusLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        28
      );
      gl.vertexAttribPointer(headLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        32
      );
      gl.vertexAttribPointer(headPositionLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        36
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        40
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_pos1;',
          'attribute vec2 a_pos2;',
          'attribute float a_thickness;',
          'attribute float a_tSize;',
          'attribute float a_delay;',
          'attribute float a_minus;',
          'attribute float a_head;',
          'attribute float a_headPosition;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_nodeRatio;',
          'uniform float u_arrowHead;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',
          'uniform mat2 u_matrixHalfPi;',
          'uniform mat2 u_matrixHalfPiMinus;',

          'varying vec4 color;',

          'void main() {',
            // Find the good point:
            'vec2 pos = normalize(a_pos2 - a_pos1);',

            'mat2 matrix = (1.0 - a_head) *',
              '(',
                'a_minus * u_matrixHalfPiMinus +',
                '(1.0 - a_minus) * u_matrixHalfPi',
              ') + a_head * (',
                'a_headPosition * u_matrixHalfPiMinus * 0.6 +',
                '(a_headPosition * a_headPosition - 1.0) * mat2(1.0)',
              ');',

            'pos = a_pos1 + (',
              // Deal with body:
              '(1.0 - a_head) * a_thickness * u_ratio * matrix * pos +',
              // Deal with head:
              'a_head * u_arrowHead * a_thickness * u_ratio * matrix * pos +',
              // Deal with delay:
              'a_delay * pos * (',
                'a_tSize / u_nodeRatio +',
                'u_arrowHead * a_thickness * u_ratio',
              ')',
            ');',

            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(pos, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.labels');

  /**
   * This label renderer will just display the label on the right of the node.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.labels.def = function(node, context, settings) {
    var fontSize,
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'];

    if (size < settings('labelThreshold'))
      return;

    if (!node.label || typeof node.label !== 'string')
      return;

    fontSize = (settings('labelSize') === 'fixed') ?
      settings('defaultLabelSize') :
      settings('labelSizeRatio') * size;

    context.font = (settings('fontStyle') ? settings('fontStyle') + ' ' : '') +
      fontSize + 'px ' + settings('font');
    context.fillStyle = (settings('labelColor') === 'node') ?
      (node.color || settings('defaultNodeColor')) :
      settings('defaultLabelColor');

    context.fillText(
      node.label,
      Math.round(node[prefix + 'x'] + size + 3),
      Math.round(node[prefix + 'y'] + fontSize / 3)
    );
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.hovers');

  /**
   * This hover renderer will basically display the label with a background.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.hovers.def = function(node, context, settings) {
    var x,
        y,
        w,
        h,
        e,
        fontStyle = settings('hoverFontStyle') || settings('fontStyle'),
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'],
        fontSize = (settings('labelSize') === 'fixed') ?
          settings('defaultLabelSize') :
          settings('labelSizeRatio') * size;

    // Label background:
    context.font = (fontStyle ? fontStyle + ' ' : '') +
      fontSize + 'px ' + (settings('hoverFont') || settings('font'));

    context.beginPath();
    context.fillStyle = settings('labelHoverBGColor') === 'node' ?
      (node.color || settings('defaultNodeColor')) :
      settings('defaultHoverLabelBGColor');

    if (node.label && settings('labelHoverShadow')) {
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 8;
      context.shadowColor = settings('labelHoverShadowColor');
    }

    if (node.label && typeof node.label === 'string') {
      x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);
      y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);
      w = Math.round(
        context.measureText(node.label).width + fontSize / 2 + size + 7
      );
      h = Math.round(fontSize + 4);
      e = Math.round(fontSize / 2 + 2);

      context.moveTo(x, y + e);
      context.arcTo(x, y, x + e, y, e);
      context.lineTo(x + w, y);
      context.lineTo(x + w, y + h);
      context.lineTo(x + e, y + h);
      context.arcTo(x, y + h, x, y + h - e, e);
      context.lineTo(x, y + e);

      context.closePath();
      context.fill();

      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 0;
    }

    // Node border:
    if (settings('borderSize') > 0) {
      context.beginPath();
      context.fillStyle = settings('nodeBorderColor') === 'node' ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultNodeBorderColor');
      context.arc(
        node[prefix + 'x'],
        node[prefix + 'y'],
        size + settings('borderSize'),
        0,
        Math.PI * 2,
        true
      );
      context.closePath();
      context.fill();
    }

    // Node:
    var nodeRenderer = sigma.canvas.nodes[node.type] || sigma.canvas.nodes.def;
    nodeRenderer(node, context, settings);

    // Display the label:
    if (node.label && typeof node.label === 'string') {
      context.fillStyle = (settings('labelHoverColor') === 'node') ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultLabelHoverColor');

      context.fillText(
        node.label,
        Math.round(node[prefix + 'x'] + size + 3),
        Math.round(node[prefix + 'y'] + fontSize / 3)
      );
    }
  };
}).call(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.nodes');

  /**
   * The default node renderer. It renders the node as a simple disc.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.nodes.def = function(node, context, settings) {
    var prefix = settings('prefix') || '';

    context.fillStyle = node.color || settings('defaultNodeColor');
    context.beginPath();
    context.arc(
      node[prefix + 'x'],
      node[prefix + 'y'],
      node[prefix + 'size'],
      0,
      Math.PI * 2,
      true
    );

    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * The default edge renderer. It renders the edge as a simple line.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.def = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor');

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(
      source[prefix + 'x'],
      source[prefix + 'y']
    );
    context.lineTo(
      target[prefix + 'x'],
      target[prefix + 'y']
    );
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * This edge renderer will display edges as arrows going from the source node
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.arrow = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        aSize = Math.max(size * 2.5, settings('minArrowSize')),
        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),
        aX = sX + (tX - sX) * (d - aSize - tSize) / d,
        aY = sY + (tY - sY) * (d - aSize - tSize) / d,
        vX = (tX - sX) * aSize / d,
        vY = (tY - sY) * aSize / d;

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(
      aX,
      aY
    );
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.def =
    function(edge, source, target, context, settings) {
      var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor');

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }
    size *= settings('edgeHoverSizeRatio');

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(
      source[prefix + 'x'],
      source[prefix + 'y']
    );
    context.lineTo(
      target[prefix + 'x'],
      target[prefix + 'y']
    );
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.curve =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        sSize = source[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, tX, tY);
    }
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.arrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    size = (edge.hover) ?
      settings('edgeHoverSizeRatio') * size : size;
    var aSize = size * 2.5,
        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),
        aX = sX + (tX - sX) * (d - aSize - tSize) / d,
        aY = sY + (tY - sY) * (d - aSize - tSize) / d,
        vX = (tX - sX) * aSize / d,
        vY = (tY - sY) * aSize / d;

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(
      aX,
      aY
    );
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.curvedArrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        d,
        aSize,
        aX,
        aY,
        vX,
        vY;

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);

    if (source.id === target.id) {
      d = Math.sqrt(Math.pow(tX - cp.x1, 2) + Math.pow(tY - cp.y1, 2));
      aSize = size * 2.5;
      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;
      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;
      vX = (tX - cp.x1) * aSize / d;
      vY = (tY - cp.y1) * aSize / d;
    }
    else {
      d = Math.sqrt(Math.pow(tX - cp.x, 2) + Math.pow(tY - cp.y, 2));
      aSize = size * 2.5;
      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;
      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;
      vX = (tX - cp.x) * aSize / d;
      vY = (tY - cp.y) * aSize / d;
    }

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, aX, aY);
    }
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.extremities');

  /**
   * The default renderer for hovered edge extremities. It renders the edge
   * extremities as hovered.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.extremities.def =
    function(edge, source, target, context, settings) {
    // Source Node:
    (
      sigma.canvas.hovers[source.type] ||
      sigma.canvas.hovers.def
    ) (
      source, context, settings
    );

    // Target Node:
    (
      sigma.canvas.hovers[target.type] ||
      sigma.canvas.hovers.def
    ) (
      target, context, settings
    );
  };
}).call(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.utils');

  /**
   * Some useful functions used by sigma's SVG renderer.
   */
  sigma.svg.utils = {

    /**
     * SVG Element show.
     *
     * @param  {DOMElement}               element   The DOM element to show.
     */
    show: function(element) {
      element.style.display = '';
      return this;
    },

    /**
     * SVG Element hide.
     *
     * @param  {DOMElement}               element   The DOM element to hide.
     */
    hide: function(element) {
      element.style.display = 'none';
      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.nodes');

  /**
   * The default node renderer. It renders the node as a simple disc.
   */
  sigma.svg.nodes.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   node     The node object.
     * @param  {configurable}             settings The settings function.
     */
    create: function(node, settings) {
      var prefix = settings('prefix') || '',
          circle = document.createElementNS(settings('xmlns'), 'circle');

      // Defining the node's circle
      circle.setAttributeNS(null, 'data-node-id', node.id);
      circle.setAttributeNS(null, 'class', settings('classPrefix') + '-node');
      circle.setAttributeNS(
        null, 'fill', node.color || settings('defaultNodeColor'));

      // Returning the DOM Element
      return circle;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   node     The node object.
     * @param  {DOMElement}               circle   The node DOM element.
     * @param  {configurable}             settings The settings function.
     */
    update: function(node, circle, settings) {
      var prefix = settings('prefix') || '';

      // Applying changes
      // TODO: optimize - check if necessary
      circle.setAttributeNS(null, 'cx', node[prefix + 'x']);
      circle.setAttributeNS(null, 'cy', node[prefix + 'y']);
      circle.setAttributeNS(null, 'r', node[prefix + 'size']);

      // Updating only if not freestyle
      if (!settings('freeStyle'))
        circle.setAttributeNS(
          null, 'fill', node.color || settings('defaultNodeColor'));

      // Showing
      circle.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * The default edge renderer. It renders the node as a simple line.
   */
  sigma.svg.edges.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var line = document.createElementNS(settings('xmlns'), 'line');

      // Attributes
      line.setAttributeNS(null, 'data-edge-id', edge.id);
      line.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      line.setAttributeNS(null, 'stroke', color);

      return line;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               line       The line DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, line, source, target, settings) {
      var prefix = settings('prefix') || '';

      line.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);
      line.setAttributeNS(null, 'x1', source[prefix + 'x']);
      line.setAttributeNS(null, 'y1', source[prefix + 'y']);
      line.setAttributeNS(null, 'x2', target[prefix + 'x']);
      line.setAttributeNS(null, 'y2', target[prefix + 'y']);

      // Showing
      line.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * The curve edge renderer. It renders the node as a bezier curve.
   */
  sigma.svg.edges.curve = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var path = document.createElementNS(settings('xmlns'), 'path');

      // Attributes
      path.setAttributeNS(null, 'data-edge-id', edge.id);
      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      path.setAttributeNS(null, 'stroke', color);

      return path;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               line       The line DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, path, source, target, settings) {
      var prefix = settings('prefix') || '';

      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);

      // Control point
      var cx = (source[prefix + 'x'] + target[prefix + 'x']) / 2 +
        (target[prefix + 'y'] - source[prefix + 'y']) / 4,
          cy = (source[prefix + 'y'] + target[prefix + 'y']) / 2 +
        (source[prefix + 'x'] - target[prefix + 'x']) / 4;

      // Path
      var p = 'M' + source[prefix + 'x'] + ',' + source[prefix + 'y'] + ' ' +
              'Q' + cx + ',' + cy + ' ' +
              target[prefix + 'x'] + ',' + target[prefix + 'y'];

      // Updating attributes
      path.setAttributeNS(null, 'd', p);
      path.setAttributeNS(null, 'fill', 'none');

      // Showing
      path.style.display = '';

      return this;
    }
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.svg.labels');

  /**
   * The default label renderer. It renders the label as a simple text.
   */
  sigma.svg.labels.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   node       The node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(node, settings) {
      var prefix = settings('prefix') || '',
          size = node[prefix + 'size'],
          text = document.createElementNS(settings('xmlns'), 'text');

      var fontSize = (settings('labelSize') === 'fixed') ?
        settings('defaultLabelSize') :
        settings('labelSizeRatio') * size;

      var fontColor = (settings('labelColor') === 'node') ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultLabelColor');

      text.setAttributeNS(null, 'data-label-target', node.id);
      text.setAttributeNS(null, 'class', settings('classPrefix') + '-label');
      text.setAttributeNS(null, 'font-size', fontSize);
      text.setAttributeNS(null, 'font-family', settings('font'));
      text.setAttributeNS(null, 'fill', fontColor);

      text.innerHTML = node.label;
      text.textContent = node.label;

      return text;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   node     The node object.
     * @param  {DOMElement}               text     The label DOM element.
     * @param  {configurable}             settings The settings function.
     */
    update: function(node, text, settings) {
      var prefix = settings('prefix') || '',
          size = node[prefix + 'size'];

      var fontSize = (settings('labelSize') === 'fixed') ?
        settings('defaultLabelSize') :
        settings('labelSizeRatio') * size;

      // Case when we don't want to display the label
      if (!settings('forceLabels') && size < settings('labelThreshold'))
        return;

      if (typeof node.label !== 'string')
        return;

      // Updating
      text.setAttributeNS(null, 'x',
        Math.round(node[prefix + 'x'] + size + 3));
      text.setAttributeNS(null, 'y',
        Math.round(node[prefix + 'y'] + fontSize / 3));

      // Showing
      text.style.display = '';

      return this;
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.svg.hovers');

  /**
   * The default hover renderer.
   */
  sigma.svg.hovers.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}           node               The node object.
     * @param  {CanvasElement}    measurementCanvas  A fake canvas handled by
     *                            the svg to perform some measurements and
     *                            passed by the renderer.
     * @param  {DOMElement}       nodeCircle         The node DOM Element.
     * @param  {configurable}     settings           The settings function.
     */
    create: function(node, nodeCircle, measurementCanvas, settings) {

      // Defining visual properties
      var x,
          y,
          w,
          h,
          e,
          d,
          fontStyle = settings('hoverFontStyle') || settings('fontStyle'),
          prefix = settings('prefix') || '',
          size = node[prefix + 'size'],
          fontSize = (settings('labelSize') === 'fixed') ?
            settings('defaultLabelSize') :
            settings('labelSizeRatio') * size,
          fontColor = (settings('labelHoverColor') === 'node') ?
                        (node.color || settings('defaultNodeColor')) :
                        settings('defaultLabelHoverColor');

      // Creating elements
      var group = document.createElementNS(settings('xmlns'), 'g'),
          rectangle = document.createElementNS(settings('xmlns'), 'rect'),
          circle = document.createElementNS(settings('xmlns'), 'circle'),
          text = document.createElementNS(settings('xmlns'), 'text');

      // Defining properties
      group.setAttributeNS(null, 'class', settings('classPrefix') + '-hover');
      group.setAttributeNS(null, 'data-node-id', node.id);

      if (typeof node.label === 'string') {

        // Text
        text.innerHTML = node.label;
        text.textContent = node.label;
        text.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-label');
        text.setAttributeNS(null, 'font-size', fontSize);
        text.setAttributeNS(null, 'font-family', settings('font'));
        text.setAttributeNS(null, 'fill', fontColor);
        text.setAttributeNS(null, 'x',
          Math.round(node[prefix + 'x'] + size + 3));
        text.setAttributeNS(null, 'y',
          Math.round(node[prefix + 'y'] + fontSize / 3));

        // Measures
        // OPTIMIZE: Find a better way than a measurement canvas
        x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);
        y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);
        w = Math.round(
          measurementCanvas.measureText(node.label).width +
            fontSize / 2 + size + 9
        );
        h = Math.round(fontSize + 4);
        e = Math.round(fontSize / 2 + 2);

        // Circle
        circle.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-area');
        circle.setAttributeNS(null, 'fill', '#fff');
        circle.setAttributeNS(null, 'cx', node[prefix + 'x']);
        circle.setAttributeNS(null, 'cy', node[prefix + 'y']);
        circle.setAttributeNS(null, 'r', e);

        // Rectangle
        rectangle.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-area');
        rectangle.setAttributeNS(null, 'fill', '#fff');
        rectangle.setAttributeNS(null, 'x', node[prefix + 'x'] + e / 4);
        rectangle.setAttributeNS(null, 'y', node[prefix + 'y'] - e);
        rectangle.setAttributeNS(null, 'width', w);
        rectangle.setAttributeNS(null, 'height', h);
      }

      // Appending childs
      group.appendChild(circle);
      group.appendChild(rectangle);
      group.appendChild(text);
      group.appendChild(nodeCircle);

      return group;
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');
  sigma.utils.pkg('sigma.utils');

  /**
   * This middleware will rescale the graph such that it takes an optimal space
   * on the renderer.
   *
   * As each middleware, this function is executed in the scope of the sigma
   * instance.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   * @param {object}  options     The parameters.
   */
  sigma.middlewares.rescale = function(readPrefix, writePrefix, options) {
    var i,
        l,
        a,
        b,
        c,
        d,
        scale,
        margin,
        n = this.graph.nodes(),
        e = this.graph.edges(),
        settings = this.settings.embedObjects(options || {}),
        bounds = settings('bounds') || sigma.utils.getBoundaries(
          this.graph,
          readPrefix,
          true
        ),
        minX = bounds.minX,
        minY = bounds.minY,
        maxX = bounds.maxX,
        maxY = bounds.maxY,
        sizeMax = bounds.sizeMax,
        weightMax = bounds.weightMax,
        w = settings('width') || 1,
        h = settings('height') || 1,
        rescaleSettings = settings('autoRescale'),
        validSettings = {
          nodePosition: 1,
          nodeSize: 1,
          edgeSize: 1
        };

    /**
     * What elements should we rescale?
     */
    if (!(rescaleSettings instanceof Array))
      rescaleSettings = ['nodePosition', 'nodeSize', 'edgeSize'];

    for (i = 0, l = rescaleSettings.length; i < l; i++)
      if (!validSettings[rescaleSettings[i]])
        throw new Error(
          'The rescale setting "' + rescaleSettings[i] + '" is not recognized.'
        );

    var np = ~rescaleSettings.indexOf('nodePosition'),
        ns = ~rescaleSettings.indexOf('nodeSize'),
        es = ~rescaleSettings.indexOf('edgeSize');

    /**
     * First, we compute the scaling ratio, without considering the sizes
     * of the nodes : Each node will have its center in the canvas, but might
     * be partially out of it.
     */
    scale = settings('scalingMode') === 'outside' ?
      Math.max(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      ) :
      Math.min(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      );

    /**
     * Then, we correct that scaling ratio considering a margin, which is
     * basically the size of the biggest node.
     * This has to be done as a correction since to compare the size of the
     * biggest node to the X and Y values, we have to first get an
     * approximation of the scaling ratio.
     **/
    margin =
      (
        settings('rescaleIgnoreSize') ?
          0 :
          (settings('maxNodeSize') || sizeMax) / scale
      ) +
      (settings('sideMargin') || 0);
    maxX += margin;
    minX -= margin;
    maxY += margin;
    minY -= margin;

    // Fix the scaling with the new extrema:
    scale = settings('scalingMode') === 'outside' ?
      Math.max(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      ) :
      Math.min(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      );

    // Size homothetic parameters:
    if (!settings('maxNodeSize') && !settings('minNodeSize')) {
      a = 1;
      b = 0;
    } else if (settings('maxNodeSize') === settings('minNodeSize')) {
      a = 0;
      b = +settings('maxNodeSize');
    } else {
      a = (settings('maxNodeSize') - settings('minNodeSize')) / sizeMax;
      b = +settings('minNodeSize');
    }

    if (!settings('maxEdgeSize') && !settings('minEdgeSize')) {
      c = 1;
      d = 0;
    } else if (settings('maxEdgeSize') === settings('minEdgeSize')) {
      c = 0;
      d = +settings('minEdgeSize');
    } else {
      c = (settings('maxEdgeSize') - settings('minEdgeSize')) / weightMax;
      d = +settings('minEdgeSize');
    }

    // Rescale the nodes and edges:
    for (i = 0, l = e.length; i < l; i++)
      e[i][writePrefix + 'size'] =
        e[i][readPrefix + 'size'] * (es ? c : 1) + (es ? d : 0);

    for (i = 0, l = n.length; i < l; i++) {
      n[i][writePrefix + 'size'] =
        n[i][readPrefix + 'size'] * (ns ? a : 1) + (ns ? b : 0);
      n[i][writePrefix + 'x'] =
        (n[i][readPrefix + 'x'] - (maxX + minX) / 2) * (np ? scale : 1);
      n[i][writePrefix + 'y'] =
        (n[i][readPrefix + 'y'] - (maxY + minY) / 2) * (np ? scale : 1);
    }
  };

  sigma.utils.getBoundaries = function(graph, prefix, doEdges) {
    var i,
        l,
        e = graph.edges(),
        n = graph.nodes(),
        weightMax = -Infinity,
        sizeMax = -Infinity,
        minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;

    if (doEdges)
      for (i = 0, l = e.length; i < l; i++)
        weightMax = Math.max(e[i][prefix + 'size'], weightMax);

    for (i = 0, l = n.length; i < l; i++) {
      sizeMax = Math.max(n[i][prefix + 'size'], sizeMax);
      maxX = Math.max(n[i][prefix + 'x'], maxX);
      minX = Math.min(n[i][prefix + 'x'], minX);
      maxY = Math.max(n[i][prefix + 'y'], maxY);
      minY = Math.min(n[i][prefix + 'y'], minY);
    }

    weightMax = weightMax || 1;
    sizeMax = sizeMax || 1;

    return {
      weightMax: weightMax,
      sizeMax: sizeMax,
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    };
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');

  /**
   * This middleware will just copy the graphic properties.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   */
  sigma.middlewares.copy = function(readPrefix, writePrefix) {
    var i,
        l,
        a;

    if (writePrefix + '' === readPrefix + '')
      return;

    a = this.graph.nodes();
    for (i = 0, l = a.length; i < l; i++) {
      a[i][writePrefix + 'x'] = a[i][readPrefix + 'x'];
      a[i][writePrefix + 'y'] = a[i][readPrefix + 'y'];
      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];
    }

    a = this.graph.edges();
    for (i = 0, l = a.length; i < l; i++)
      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc.animation.running');

  /**
   * Generates a unique ID for the animation.
   *
   * @return {string} Returns the new ID.
   */
  var _getID = (function() {
    var id = 0;
    return function() {
      return '' + (++id);
    };
  })();

  /**
   * This function animates a camera. It has to be called with the camera to
   * animate, the values of the coordinates to reach and eventually some
   * options. It returns a number id, that you can use to kill the animation,
   * with the method sigma.misc.animation.kill(id).
   *
   * The available options are:
   *
   *   {?number}            duration   The duration of the animation.
   *   {?function}          onNewFrame A callback to execute when the animation
   *                                   enter a new frame.
   *   {?function}          onComplete A callback to execute when the animation
   *                                   is completed or killed.
   *   {?(string|function)} easing     The name of a function from the package
   *                                   sigma.utils.easings, or a custom easing
   *                                   function.
   *
   * @param  {camera}  camera  The camera to animate.
   * @param  {object}  target  The coordinates to reach.
   * @param  {?object} options Eventually an object to specify some options to
   *                           the function. The available options are
   *                           presented in the description of the function.
   * @return {number}          The animation id, to make it easy to kill
   *                           through the method "sigma.misc.animation.kill".
   */
  sigma.misc.animation.camera = function(camera, val, options) {
    if (
      !(camera instanceof sigma.classes.camera) ||
      typeof val !== 'object' ||
      !val
    )
      throw 'animation.camera: Wrong arguments.';

    if (
      typeof val.x !== 'number' &&
      typeof val.y !== 'number' &&
      typeof val.ratio !== 'number' &&
      typeof val.angle !== 'number'
    )
      throw 'There must be at least one valid coordinate in the given val.';

    var fn,
        id,
        anim,
        easing,
        duration,
        initialVal,
        o = options || {},
        start = sigma.utils.dateNow();

    // Store initial values:
    initialVal = {
      x: camera.x,
      y: camera.y,
      ratio: camera.ratio,
      angle: camera.angle
    };

    duration = o.duration;
    easing = typeof o.easing !== 'function' ?
      sigma.utils.easings[o.easing || 'quadraticInOut'] :
      o.easing;

    fn = function() {
      var coef,
          t = o.duration ? (sigma.utils.dateNow() - start) / o.duration : 1;

      // If the animation is over:
      if (t >= 1) {
        camera.isAnimated = false;
        camera.goTo({
          x: val.x !== undefined ? val.x : initialVal.x,
          y: val.y !== undefined ? val.y : initialVal.y,
          ratio: val.ratio !== undefined ? val.ratio : initialVal.ratio,
          angle: val.angle !== undefined ? val.angle : initialVal.angle
        });

        cancelAnimationFrame(id);
        delete sigma.misc.animation.running[id];

        // Check callbacks:
        if (typeof o.onComplete === 'function')
          o.onComplete();

      // Else, let's keep going:
      } else {
        coef = easing(t);
        camera.isAnimated = true;
        camera.goTo({
          x: val.x !== undefined ?
            initialVal.x + (val.x - initialVal.x) * coef :
            initialVal.x,
          y: val.y !== undefined ?
            initialVal.y + (val.y - initialVal.y) * coef :
            initialVal.y,
          ratio: val.ratio !== undefined ?
            initialVal.ratio + (val.ratio - initialVal.ratio) * coef :
            initialVal.ratio,
          angle: val.angle !== undefined ?
            initialVal.angle + (val.angle - initialVal.angle) * coef :
            initialVal.angle
        });

        // Check callbacks:
        if (typeof o.onNewFrame === 'function')
          o.onNewFrame();

        anim.frameId = requestAnimationFrame(fn);
      }
    };

    id = _getID();
    anim = {
      frameId: requestAnimationFrame(fn),
      target: camera,
      type: 'camera',
      options: o,
      fn: fn
    };
    sigma.misc.animation.running[id] = anim;

    return id;
  };

  /**
   * Kills a running animation. It triggers the eventual onComplete callback.
   *
   * @param  {number} id  The id of the animation to kill.
   * @return {object}     Returns the sigma.misc.animation package.
   */
  sigma.misc.animation.kill = function(id) {
    if (arguments.length !== 1 || typeof id !== 'number')
      throw 'animation.kill: Wrong arguments.';

    var o = sigma.misc.animation.running[id];

    if (o) {
      cancelAnimationFrame(id);
      delete sigma.misc.animation.running[o.frameId];

      if (o.type === 'camera')
        o.target.isAnimated = false;

      // Check callbacks:
      if (typeof (o.options || {}).onComplete === 'function')
        o.options.onComplete();
    }

    return this;
  };

  /**
   * Kills every running animations, or only the one with the specified type,
   * if a string parameter is given.
   *
   * @param  {?(string|object)} filter A string to filter the animations to kill
   *                                   on their type (example: "camera"), or an
   *                                   object to filter on their target.
   * @return {number}                  Returns the number of animations killed
   *                                   that way.
   */
  sigma.misc.animation.killAll = function(filter) {
    var o,
        id,
        count = 0,
        type = typeof filter === 'string' ? filter : null,
        target = typeof filter === 'object' ? filter : null,
        running = sigma.misc.animation.running;

    for (id in running)
      if (
        (!type || running[id].type === type) &&
        (!target || running[id].target === target)
      ) {
        o = sigma.misc.animation.running[id];
        cancelAnimationFrame(o.frameId);
        delete sigma.misc.animation.running[id];

        if (o.type === 'camera')
          o.target.isAnimated = false;

        // Increment counter:
        count++;

        // Check callbacks:
        if (typeof (o.options || {}).onComplete === 'function')
          o.options.onComplete();
      }

    return count;
  };

  /**
   * Returns "true" if any animation that is currently still running matches
   * the filter given to the function.
   *
   * @param  {string|object} filter A string to filter the animations to kill
   *                                on their type (example: "camera"), or an
   *                                object to filter on their target.
   * @return {boolean}              Returns true if any running animation
   *                                matches.
   */
  sigma.misc.animation.has = function(filter) {
    var id,
        type = typeof filter === 'string' ? filter : null,
        target = typeof filter === 'object' ? filter : null,
        running = sigma.misc.animation.running;

    for (id in running)
      if (
        (!type || running[id].type === type) &&
        (!target || running[id].target === target)
      )
        return true;

    return false;
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This helper will bind any no-DOM renderer (for instance canvas or WebGL)
   * to its captors, to properly dispatch the good events to the sigma instance
   * to manage clicking, hovering etc...
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.bindEvents = function(prefix) {
    var i,
        l,
        mX,
        mY,
        captor,
        self = this;

    function getNodes(e) {
      if (e) {
        mX = 'x' in e.data ? e.data.x : mX;
        mY = 'y' in e.data ? e.data.y : mY;
      }

      var i,
          j,
          l,
          n,
          x,
          y,
          s,
          inserted,
          selected = [],
          modifiedX = mX + self.width / 2,
          modifiedY = mY + self.height / 2,
          point = self.camera.cameraPosition(
            mX,
            mY
          ),
          nodes = self.camera.quadtree.point(
            point.x,
            point.y
          );

      if (nodes.length)
        for (i = 0, l = nodes.length; i < l; i++) {
          n = nodes[i];
          x = n[prefix + 'x'];
          y = n[prefix + 'y'];
          s = n[prefix + 'size'];

          if (
            !n.hidden &&
            modifiedX > x - s &&
            modifiedX < x + s &&
            modifiedY > y - s &&
            modifiedY < y + s &&
            Math.sqrt(
              Math.pow(modifiedX - x, 2) +
              Math.pow(modifiedY - y, 2)
            ) < s
          ) {
            // Insert the node:
            inserted = false;

            for (j = 0; j < selected.length; j++)
              if (n.size > selected[j].size) {
                selected.splice(j, 0, n);
                inserted = true;
                break;
              }

            if (!inserted)
              selected.push(n);
          }
        }

      return selected;
    }


    function getEdges(e) {
      if (!self.settings('enableEdgeHovering')) {
        // No event if the setting is off:
        return [];
      }

      var isCanvas = (
        sigma.renderers.canvas && self instanceof sigma.renderers.canvas);

      if (!isCanvas) {
        // A quick hardcoded rule to prevent people from using this feature
        // with the WebGL renderer (which is not good enough at the moment):
        throw new Error(
          'The edge events feature is not compatible with the WebGL renderer'
        );
      }

      if (e) {
        mX = 'x' in e.data ? e.data.x : mX;
        mY = 'y' in e.data ? e.data.y : mY;
      }

      var i,
          j,
          l,
          a,
          edge,
          s,
          maxEpsilon = self.settings('edgeHoverPrecision'),
          source,
          target,
          cp,
          nodeIndex = {},
          inserted,
          selected = [],
          modifiedX = mX + self.width / 2,
          modifiedY = mY + self.height / 2,
          point = self.camera.cameraPosition(
            mX,
            mY
          ),
          edges = [];

      if (isCanvas) {
        var nodesOnScreen = self.camera.quadtree.area(
          self.camera.getRectangle(self.width, self.height)
        );
        for (a = nodesOnScreen, i = 0, l = a.length; i < l; i++)
          nodeIndex[a[i].id] = a[i];
      }

      if (self.camera.edgequadtree !== undefined) {
        edges = self.camera.edgequadtree.point(
          point.x,
          point.y
        );
      }

      function insertEdge(selected, edge) {
        inserted = false;

        for (j = 0; j < selected.length; j++)
          if (edge.size > selected[j].size) {
            selected.splice(j, 0, edge);
            inserted = true;
            break;
          }

        if (!inserted)
          selected.push(edge);
      }

      if (edges.length)
        for (i = 0, l = edges.length; i < l; i++) {
          edge = edges[i];
          source = self.graph.nodes(edge.source);
          target = self.graph.nodes(edge.target);
          // (HACK) we can't get edge[prefix + 'size'] on WebGL renderer:
          s = edge[prefix + 'size'] ||
              edge['read_' + prefix + 'size'];

          // First, let's identify which edges are drawn. To do this, we keep
          // every edges that have at least one extremity displayed according to
          // the quadtree and the "hidden" attribute. We also do not keep hidden
          // edges.
          // Then, let's check if the mouse is on the edge (we suppose that it
          // is a line segment).

          if (
            !edge.hidden &&
            !source.hidden && !target.hidden &&
            (!isCanvas ||
              (nodeIndex[edge.source] || nodeIndex[edge.target])) &&
            sigma.utils.getDistance(
              source[prefix + 'x'],
              source[prefix + 'y'],
              modifiedX,
              modifiedY) > source[prefix + 'size'] &&
            sigma.utils.getDistance(
              target[prefix + 'x'],
              target[prefix + 'y'],
              modifiedX,
              modifiedY) > target[prefix + 'size']
          ) {
            if (edge.type == 'curve' || edge.type == 'curvedArrow') {
              if (source.id === target.id) {
                cp = sigma.utils.getSelfLoopControlPoints(
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  source[prefix + 'size']
                );
                if (
                  sigma.utils.isPointOnBezierCurve(
                  modifiedX,
                  modifiedY,
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  cp.x1,
                  cp.y1,
                  cp.x2,
                  cp.y2,
                  Math.max(s, maxEpsilon)
                )) {
                  insertEdge(selected, edge);
                }
              }
              else {
                cp = sigma.utils.getQuadraticControlPoint(
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y']);
                if (
                  sigma.utils.isPointOnQuadraticCurve(
                  modifiedX,
                  modifiedY,
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  cp.x,
                  cp.y,
                  Math.max(s, maxEpsilon)
                )) {
                  insertEdge(selected, edge);
                }
              }
            } else if (
                sigma.utils.isPointOnSegment(
                modifiedX,
                modifiedY,
                source[prefix + 'x'],
                source[prefix + 'y'],
                target[prefix + 'x'],
                target[prefix + 'y'],
                Math.max(s, maxEpsilon)
              )) {
              insertEdge(selected, edge);
            }
          }
        }

      return selected;
    }


    function bindCaptor(captor) {
      var nodes,
          edges,
          overNodes = {},
          overEdges = {};

      function onClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('click', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('clickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('clickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('clickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('clickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('clickStage', {captor: e.data});
      }

      function onDoubleClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('doubleClick', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('doubleClickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('doubleClickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('doubleClickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('doubleClickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('doubleClickStage', {captor: e.data});
      }

      function onRightClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('rightClick', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('rightClickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('rightClickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('rightClickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('rightClickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('rightClickStage', {captor: e.data});
      }

      function onOut(e) {
        if (!self.settings('eventsEnabled'))
          return;

        var k,
            i,
            l,
            le,
            outNodes = [],
            outEdges = [];

        for (k in overNodes)
          outNodes.push(overNodes[k]);

        overNodes = {};
        // Dispatch both single and multi events:
        for (i = 0, l = outNodes.length; i < l; i++)
          self.dispatchEvent('outNode', {
            node: outNodes[i],
            captor: e.data
          });
        if (outNodes.length)
          self.dispatchEvent('outNodes', {
            nodes: outNodes,
            captor: e.data
          });

        overEdges = {};
        // Dispatch both single and multi events:
        for (i = 0, le = outEdges.length; i < le; i++)
          self.dispatchEvent('outEdge', {
            edge: outEdges[i],
            captor: e.data
          });
        if (outEdges.length)
          self.dispatchEvent('outEdges', {
            edges: outEdges,
            captor: e.data
          });
      }

      function onMove(e) {
        if (!self.settings('eventsEnabled'))
          return;

        nodes = getNodes(e);
        edges = getEdges(e);

        var i,
            k,
            node,
            edge,
            newOutNodes = [],
            newOverNodes = [],
            currentOverNodes = {},
            l = nodes.length,
            newOutEdges = [],
            newOverEdges = [],
            currentOverEdges = {},
            le = edges.length;

        // Check newly overred nodes:
        for (i = 0; i < l; i++) {
          node = nodes[i];
          currentOverNodes[node.id] = node;
          if (!overNodes[node.id]) {
            newOverNodes.push(node);
            overNodes[node.id] = node;
          }
        }

        // Check no more overred nodes:
        for (k in overNodes)
          if (!currentOverNodes[k]) {
            newOutNodes.push(overNodes[k]);
            delete overNodes[k];
          }

        // Dispatch both single and multi events:
        for (i = 0, l = newOverNodes.length; i < l; i++)
          self.dispatchEvent('overNode', {
            node: newOverNodes[i],
            captor: e.data
          });
        for (i = 0, l = newOutNodes.length; i < l; i++)
          self.dispatchEvent('outNode', {
            node: newOutNodes[i],
            captor: e.data
          });
        if (newOverNodes.length)
          self.dispatchEvent('overNodes', {
            nodes: newOverNodes,
            captor: e.data
          });
        if (newOutNodes.length)
          self.dispatchEvent('outNodes', {
            nodes: newOutNodes,
            captor: e.data
          });

        // Check newly overred edges:
        for (i = 0; i < le; i++) {
          edge = edges[i];
          currentOverEdges[edge.id] = edge;
          if (!overEdges[edge.id]) {
            newOverEdges.push(edge);
            overEdges[edge.id] = edge;
          }
        }

        // Check no more overred edges:
        for (k in overEdges)
          if (!currentOverEdges[k]) {
            newOutEdges.push(overEdges[k]);
            delete overEdges[k];
          }

        // Dispatch both single and multi events:
        for (i = 0, le = newOverEdges.length; i < le; i++)
          self.dispatchEvent('overEdge', {
            edge: newOverEdges[i],
            captor: e.data
          });
        for (i = 0, le = newOutEdges.length; i < le; i++)
          self.dispatchEvent('outEdge', {
            edge: newOutEdges[i],
            captor: e.data
          });
        if (newOverEdges.length)
          self.dispatchEvent('overEdges', {
            edges: newOverEdges,
            captor: e.data
          });
        if (newOutEdges.length)
          self.dispatchEvent('outEdges', {
            edges: newOutEdges,
            captor: e.data
          });
      }

      // Bind events:
      captor.bind('click', onClick);
      captor.bind('mousedown', onMove);
      captor.bind('mouseup', onMove);
      captor.bind('mousemove', onMove);
      captor.bind('mouseout', onOut);
      captor.bind('doubleclick', onDoubleClick);
      captor.bind('rightclick', onRightClick);
      self.bind('render', onMove);
    }

    for (i = 0, l = this.captors.length; i < l; i++)
      bindCaptor(this.captors[i]);
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This helper will bind any DOM renderer (for instance svg)
   * to its captors, to properly dispatch the good events to the sigma instance
   * to manage clicking, hovering etc...
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.bindDOMEvents = function(container) {
    var self = this,
        graph = this.graph;

    // DOMElement abstraction
    function Element(domElement) {

      // Helpers
      this.attr = function(attrName) {
        return domElement.getAttributeNS(null, attrName);
      };

      // Properties
      this.tag = domElement.tagName;
      this.class = this.attr('class');
      this.id = this.attr('id');

      // Methods
      this.isNode = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-node');
      };

      this.isEdge = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-edge');
      };

      this.isHover = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-hover');
      };
    }

    // Click
    function click(e) {
      if (!self.settings('eventsEnabled'))
        return;

      // Generic event
      self.dispatchEvent('click', e);

      // Are we on a node?
      var element = new Element(e.target);

      if (element.isNode())
        self.dispatchEvent('clickNode', {
          node: graph.nodes(element.attr('data-node-id'))
        });
      else
        self.dispatchEvent('clickStage');

      e.preventDefault();
      e.stopPropagation();
    }

    // Double click
    function doubleClick(e) {
      if (!self.settings('eventsEnabled'))
        return;

      // Generic event
      self.dispatchEvent('doubleClick', e);

      // Are we on a node?
      var element = new Element(e.target);

      if (element.isNode())
        self.dispatchEvent('doubleClickNode', {
          node: graph.nodes(element.attr('data-node-id'))
        });
      else
        self.dispatchEvent('doubleClickStage');

      e.preventDefault();
      e.stopPropagation();
    }

    // On over
    function onOver(e) {
      var target = e.toElement || e.target;

      if (!self.settings('eventsEnabled') || !target)
        return;

      var el = new Element(target);

      if (el.isNode()) {
        self.dispatchEvent('overNode', {
          node: graph.nodes(el.attr('data-node-id'))
        });
      }
      else if (el.isEdge()) {
        var edge = graph.edges(el.attr('data-edge-id'));
        self.dispatchEvent('overEdge', {
          edge: edge,
          source: graph.nodes(edge.source),
          target: graph.nodes(edge.target)
        });
      }
    }

    // On out
    function onOut(e) {
      var target = e.fromElement || e.originalTarget;

      if (!self.settings('eventsEnabled'))
        return;

      var el = new Element(target);

      if (el.isNode()) {
        self.dispatchEvent('outNode', {
          node: graph.nodes(el.attr('data-node-id'))
        });
      }
      else if (el.isEdge()) {
        var edge = graph.edges(el.attr('data-edge-id'));
        self.dispatchEvent('outEdge', {
          edge: edge,
          source: graph.nodes(edge.source),
          target: graph.nodes(edge.target)
        });
      }
    }

    // Registering Events:

    // Click
    container.addEventListener('click', click, false);
    sigma.utils.doubleClick(container, 'click', doubleClick);

    // Touch counterparts
    container.addEventListener('touchstart', click, false);
    sigma.utils.doubleClick(container, 'touchstart', doubleClick);

    // Mouseover
    container.addEventListener('mouseover', onOver, true);

    // Mouseout
    container.addEventListener('mouseout', onOut, true);
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This method listens to "overNode", "outNode", "overEdge" and "outEdge"
   * events from a renderer and renders the nodes differently on the top layer.
   * The goal is to make any node label readable with the mouse, and to
   * highlight hovered nodes and edges.
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.drawHovers = function(prefix) {
    var self = this,
        hoveredNodes = {},
        hoveredEdges = {};

    this.bind('overNode', function(event) {
      var node = event.data.node;
      if (!node.hidden) {
        hoveredNodes[node.id] = node;
        draw();
      }
    });

    this.bind('outNode', function(event) {
      delete hoveredNodes[event.data.node.id];
      draw();
    });

    this.bind('overEdge', function(event) {
      var edge = event.data.edge;
      if (!edge.hidden) {
        hoveredEdges[edge.id] = edge;
        draw();
      }
    });

    this.bind('outEdge', function(event) {
      delete hoveredEdges[event.data.edge.id];
      draw();
    });

    this.bind('render', function(event) {
      draw();
    });

    function draw() {

      var k,
          source,
          target,
          hoveredNode,
          hoveredEdge,
          c = self.contexts.hover.canvas,
          defaultNodeType = self.settings('defaultNodeType'),
          defaultEdgeType = self.settings('defaultEdgeType'),
          nodeRenderers = sigma.canvas.hovers,
          edgeRenderers = sigma.canvas.edgehovers,
          extremitiesRenderers = sigma.canvas.extremities,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      // Clear self.contexts.hover:
      self.contexts.hover.clearRect(0, 0, c.width, c.height);

      // Node render: single hover
      if (
        embedSettings('enableHovering') &&
        embedSettings('singleHover') &&
        Object.keys(hoveredNodes).length
      ) {
        hoveredNode = hoveredNodes[Object.keys(hoveredNodes)[0]];
        (
          nodeRenderers[hoveredNode.type] ||
          nodeRenderers[defaultNodeType] ||
          nodeRenderers.def
        )(
          hoveredNode,
          self.contexts.hover,
          embedSettings
        );
      }

      // Node render: multiple hover
      if (
        embedSettings('enableHovering') &&
        !embedSettings('singleHover')
      )
        for (k in hoveredNodes)
          (
            nodeRenderers[hoveredNodes[k].type] ||
            nodeRenderers[defaultNodeType] ||
            nodeRenderers.def
          )(
            hoveredNodes[k],
            self.contexts.hover,
            embedSettings
          );

      // Edge render: single hover
      if (
        embedSettings('enableEdgeHovering') &&
        embedSettings('singleHover') &&
        Object.keys(hoveredEdges).length
      ) {
        hoveredEdge = hoveredEdges[Object.keys(hoveredEdges)[0]];
        source = self.graph.nodes(hoveredEdge.source);
        target = self.graph.nodes(hoveredEdge.target);

        if (! hoveredEdge.hidden) {
          (
            edgeRenderers[hoveredEdge.type] ||
            edgeRenderers[defaultEdgeType] ||
            edgeRenderers.def
          ) (
            hoveredEdge,
            source,
            target,
            self.contexts.hover,
            embedSettings
          );

          if (embedSettings('edgeHoverExtremities')) {
            (
              extremitiesRenderers[hoveredEdge.type] ||
              extremitiesRenderers.def
            )(
              hoveredEdge,
              source,
              target,
              self.contexts.hover,
              embedSettings
            );

          } else {
            // Avoid edges rendered over nodes:
            (
              sigma.canvas.nodes[source.type] ||
              sigma.canvas.nodes.def
            ) (
              source,
              self.contexts.hover,
              embedSettings
            );
            (
              sigma.canvas.nodes[target.type] ||
              sigma.canvas.nodes.def
            ) (
              target,
              self.contexts.hover,
              embedSettings
            );
          }
        }
      }

      // Edge render: multiple hover
      if (
        embedSettings('enableEdgeHovering') &&
        !embedSettings('singleHover')
      ) {
        for (k in hoveredEdges) {
          hoveredEdge = hoveredEdges[k];
          source = self.graph.nodes(hoveredEdge.source);
          target = self.graph.nodes(hoveredEdge.target);

          if (!hoveredEdge.hidden) {
            (
              edgeRenderers[hoveredEdge.type] ||
              edgeRenderers[defaultEdgeType] ||
              edgeRenderers.def
            ) (
              hoveredEdge,
              source,
              target,
              self.contexts.hover,
              embedSettings
            );

            if (embedSettings('edgeHoverExtremities')) {
              (
                extremitiesRenderers[hoveredEdge.type] ||
                extremitiesRenderers.def
              )(
                hoveredEdge,
                source,
                target,
                self.contexts.hover,
                embedSettings
              );
            } else {
              // Avoid edges rendered over nodes:
              (
                sigma.canvas.nodes[source.type] ||
                sigma.canvas.nodes.def
              ) (
                source,
                self.contexts.hover,
                embedSettings
              );
              (
                sigma.canvas.nodes[target.type] ||
                sigma.canvas.nodes.def
              ) (
                target,
                self.contexts.hover,
                embedSettings
              );
            }
          }
        }
      }
    }
  };
}).call(this);

},{}],5:[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var t;t="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,t.TQGramUI=e()}}(function(){return function(){function e(t,n,o){function i(l,a){if(!n[l]){if(!t[l]){var s="function"==typeof require&&require;if(!a&&s)return s(l,!0);if(r)return r(l,!0);var u=new Error("Cannot find module '"+l+"'");throw u.code="MODULE_NOT_FOUND",u}var d=n[l]={exports:{}};t[l][0].call(d.exports,function(e){var n=t[l][1][e];return i(n?n:e)},d,d.exports,e,t,n,o)}return n[l].exports}for(var r="function"==typeof require&&require,l=0;l<o.length;l++)i(o[l]);return i}return e}()({1:[function(e,t,n){"use strict";function o(e){function t(){r.rootHtml.innerHTML="",r.rootHtml.style.borderTop=0!==r.buttons.length?"1px solid #cccccc":null,r.rootHtml.style.borderBottom=0!==r.buttons.length?"1px solid #cccccc":null,r.buttons.forEach(function(e){var t=document.createElement("BUTTON");t.title=e.label,t.className="tq-ui-toolbar__button tq-ui-colored-button",t.innerHTML='<span style="color: '+e.borderColor+'">'+n(e.label)+"</span>",t.style.backgroundColor=e.backgroundColor||"white",t.style.borderColor=e.borderColor||"black",t.onclick=function(t){e.callback(e,t)},r.rootHtml.appendChild(t)})}function n(e){if(e){var t=e.match(/[a-z'\-]+/gi);return t.filter(function(e){return"and"!==e.toLowerCase()&&"&"!==e}).map(function(e){return e[0]}).join("")}}function o(){var e=document.createElement("DIV");return e.className="tq-ui-colored-buttons-list",e.innerHTML="",e}var r=this;e||(e={}),r.rootHtml=o(),r.id=e.id||"coloredButtons-"+i++,r.rootHtml.id=r.id,r.buttons=e.buttons||[],t(),r.removeAll=function(){r.buttons=[],t()},r.addButton=function(e){r.buttons.map(function(e){return e.id}).indexOf(e.id)===-1&&(r.buttons.push(e),t())},r.removeButton=function(e){r.buttons.splice(r.buttons.indexOf(e),1),t()}}Object.defineProperty(n,"__esModule",{value:!0}),n.ColoredButtonsList=o;var i=0;n["default"]=o},{}],2:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function i(e){function t(){if(e.body instanceof Object){var t=i.rootHtml.querySelector(".tq-ui-body_container");t.appendChild(e.body.rootHtml)}var a=i.rootHtml.querySelector(".tq-ui-flying-panel_header");a.addEventListener("mousedown",o);var s=i.rootHtml.querySelector(".tq-ui-windows-collapse-button");if(s.onclick=i.hide,e.resizable){var u=i.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-top-border");u.addEventListener("mousedown",function(e){o(e,"n")});var d=i.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-right-border");d.addEventListener("mousedown",function(e){o(e,"e")});var c=i.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-bottom-border");c.addEventListener("mousedown",function(e){o(e,"s")});var f=i.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-left-border");f.addEventListener("mousedown",function(e){o(e,"w")});var p=i.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-top-right-border");p.addEventListener("mousedown",function(e){o(e,"ne")});var b=i.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-top-left-border");b.addEventListener("mousedown",function(e){o(e,"nw")});var m=i.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-bottom-right-border");m.addEventListener("mousedown",function(e){o(e,"se")});var y=i.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-bottom-left-border");y.addEventListener("mousedown",function(e){o(e,"sw")})}i._triggerButton=r(e.triggerButton),n(),i._triggerButton&&(i._triggerButton.onclick=function(){l?i.show():i.hide()})}function n(){l?(i._triggerButton&&(i._triggerButton.className=i._triggerButton.className.replace(/ tq-ui-selected/gi,"")),i.rootHtml.className=i.rootHtml.className+" tq-ui-collapsed"):(i._triggerButton&&(i._triggerButton.className=i._triggerButton.className+" tq-ui-selected"),i.rootHtml.className=i.rootHtml.className.replace(/ tq-ui-collapsed/gi,""))}function o(e,t){function n(e){i._mouseMove=!0;var n=0;e.pageX?n=e.pageX:e.clientX&&(n=e.clientX);var o=n-l;l=n,t||(i.rootHtml.style.left=i.rootHtml.offsetLeft+o+"px");var s=0;e.pageY?s=e.pageY:e.clientY&&(s=e.clientY);var u=s-a;a=s,t||(i.rootHtml.style.top=i.rootHtml.offsetTop+u+"px"),t?(r(o,u,t),i.trigger("size-changed",{width:i.rootHtml.offsetWidth,height:i.rootHtml.offsetHeight}),t.indexOf("n")===-1&&t.indexOf("w")===-1||i.trigger("position-changed",{x:i.rootHtml.offsetLeft,y:i.rootHtml.offsetTop})):i.trigger("position-changed",{x:i.rootHtml.offsetLeft,y:i.rootHtml.offsetTop})}function o(e){i._mouseMove&&(n(e,!0),i._mouseMove=!1),document.body.onmousemove=document.body.onmouseup=null,document.body.removeEventListener("mousemove",n),document.body.removeEventListener("mouseup",o)}function r(e,t,n){switch(n){case"n":i.rootHtml.style.height=i.rootHtml.offsetHeight-t+"px",i.rootHtml.style.top=i.rootHtml.offsetTop+t+"px";break;case"e":i.rootHtml.style.width=i.rootHtml.offsetWidth+e+"px";break;case"s":i.rootHtml.style.height=i.rootHtml.offsetHeight+t+"px";break;case"w":i.rootHtml.style.width=i.rootHtml.offsetWidth-e+"px",i.rootHtml.style.left=i.rootHtml.offsetLeft+e+"px";break;case"ne":i.rootHtml.style.width=i.rootHtml.offsetWidth+e+"px",i.rootHtml.style.height=i.rootHtml.offsetHeight-t+"px",i.rootHtml.style.top=i.rootHtml.offsetTop+t+"px";break;case"nw":i.rootHtml.style.height=i.rootHtml.offsetHeight-t+"px",i.rootHtml.style.top=i.rootHtml.offsetTop+t+"px",i.rootHtml.style.width=i.rootHtml.offsetWidth-e+"px",i.rootHtml.style.left=i.rootHtml.offsetLeft+e+"px";break;case"se":i.rootHtml.style.width=i.rootHtml.offsetWidth+e+"px",i.rootHtml.style.height=i.rootHtml.offsetHeight+t+"px";break;case"sw":i.rootHtml.style.height=i.rootHtml.offsetHeight+t+"px",i.rootHtml.style.width=i.rootHtml.offsetWidth-e+"px",i.rootHtml.style.left=i.rootHtml.offsetLeft+e+"px"}}var l=0,a=0;e.pageX?l=e.pageX:e.clientX&&(l=e.clientX),e.pageY?a=e.pageY:e.clientY&&(a=e.clientY),window.getSelection().removeAllRanges(),document.body.addEventListener("mousemove",n),document.body.addEventListener("mouseup",o)}s["default"].apply(this);var i=this;e||(e={});var l=!e.active;i.markup='\n        <div class="tq-ui-flying-panel"\n            style="\n                width: '+(e.size?e.size.width:"")+";\n                height: "+(e.size?e.size.height:"")+";\n                left: "+(e.position?e.position.x:"")+";\n                top: "+(e.position?e.position.y:"")+';\n            "\n        >\n            <div class="tq-ui-flying-panel_header">\n                <div class="tq-ui-flying-panel_header__header">\n                    <label class="tq-ui-window-header-label">'+(e.header?e.header:"")+'</label>\n                    <img class="tq-ui-windows-collapse-button"/>\n                </div>\n            </div>\n            <div class="tq-ui-body">\n                <div class="tq-ui-body_container '+(e.removeBackground?"tq-ui-body_empty-container":"tq-ui-body_default-container")+'">\n                    '+(e.body&&"string"==typeof e.body?e.body:"")+"\n                </div>\n            </div>\n            "+(e.resizable?'\n                <div class="tq-ui-flying-panel__border tq-ui-top-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-right-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-bottom-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-left-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-top-left-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-top-right-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-bottom-left-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-bottom-right-border"></div>\n            ':"")+"\n        </div>";var a=r(e.baseElement);a.innerHTML=i.markup,i.rootHtml=a.querySelector(".tq-ui-flying-panel"),i.id=e.id||"flyingPanel-"+u++,i.rootHtml.id=i.id,i.show=function(e){e&&e.stopPropagation(),l&&(l=!1,n())},i.hide=function(e){e&&e.stopPropagation(),l||(l=!0,n())},t()}function r(e){var t=void 0;return"string"==typeof e?t=document.getElementById(e):"object"===("undefined"==typeof e?"undefined":l(e))&&(t=e),t}Object.defineProperty(n,"__esModule",{value:!0});var l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};n.FlyingPanel=i;var a=e("./subscriptionAPI/subscribeable"),s=o(a),u=0;n["default"]=i},{"./subscriptionAPI/subscribeable":8}],3:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function i(e){function t(e){function t(e){var t=e.label,n=e.label+" ("+e.id+")",o=document.createElement("LI");return o.className="tq-ui-property-button",o.title=n,o.innerText=t,o.onclick=function(){i.trigger("selected-element-changed",e.id)},o}var n=i.rootHtml.querySelector("#relatedElements");n.innerHTML="";var o=e.incomings||[];if(o.length){var r=document.createElement("LABEL");r.className="tq-label",r.innerText="Incoming nodes:",n.appendChild(r);var l=document.createElement("UL");l.className="tq-ui-info-panel_related-elements_list",n.appendChild(l),o.forEach(function(e){l.appendChild(t(e))})}var a=e.outgoings||[];if(a.length){var s=document.createElement("LABEL");s.className="tq-label",s.innerText="Outgoing nodes:",n.appendChild(s);var u=document.createElement("UL");u.className="tq-ui-info-panel_related-elements_list",n.appendChild(u),a.forEach(function(e){u.appendChild(t(e))})}}function n(e){var t="";return Object.keys(e).forEach(function(n){t+='<label for="'+n+'" class="tq-label">'+n+'</label>\n                        <input id="'+n+'" type="text" class="tq-ui-property" value="'+e[n]+'" disabled></input>'}),t}function o(){var e=document.createElement("DIV");return e.className="tq-ui-info-panel",e.innerHTML=i.markup,e}l["default"].apply(this),e||(e={});var i=this,r=e.placeholder||"Select a diagram element",s='<div class="tq-ui-info-panel_empty-stuff">'+r+"</div>";i.rootHtml=o(),i.rootHtml.innerHTML=s,i.id=e.id||"infoPanel-"+a++,i.rootHtml.id=i.id,i.setSelectedElement=function(o){if(o){if(i.rootHtml.innerHTML=""+(e.launchExternal&&"node"===o.diagramType?'<div class="tq-ui-group">\n                      <button id="tqLaunchExternalBtn" class="tq-button" title="View more in new tab.">\n                        More &nbsp;\n                      <span class="glyphicon glyphicon-new-window"></span></button>\n                     </div>':"")+(o.id?'\n                    <label class="tq-label">ID</label>\n                    <input value="'+o.id+'" type="text" class="tq-ui-property" disabled></input>\n                ':"")+(o.label?'\n                    <label class="tq-label">Label</label>\n                    <input value="'+o.label+'" type="text" class="tq-ui-property" disabled></input>\n                ':"")+(o.types?'\n                    <label class="tq-label">Types</label>\n                    <input value="'+o.types+'" type="text" class="tq-ui-property" disabled></input>\n                ':"")+(o.source?'\n                    <label for="linkFrom" class="tq-label">Source</label>\n                    <div id="linkFrom" type="text" class="tq-ui-property-button"></div>\n                ':"")+(o.target?'\n                    <label for="linkTo" class="tq-label">Target</label>\n                    <div id="linkTo" type="text" class="tq-ui-property-button"></div>\n                ':"")+(o.thickness?'\n                    <label for="thickness" class="tq-label">Thickness</label>\n                    <input value="'+o.thickness+'" type="text" class="tq-ui-property" disabled></input>\n                ':"")+(o.data?n(o.data):"")+(o.relations?'\n                    <label for="relatedElements" class="tq-label">Related elements</label>\n                    <div   id="relatedElements" class="tq-ui-info-panel_related-elements"></div>\n                ':""),e.launchExternal&&"node"===o.diagramType){var r=document.getElementById("tqLaunchExternalBtn");r.onclick=function(){e.launchExternal(o)}}if(o.relations&&t(o.relations),o.source){var l=document.getElementById("linkFrom");l.innerText=o.source.label,l.title=o.source.label+"(ID: "+o.source.id+")",l.onclick=function(){i.trigger("selected-element-changed",o.source.id)}}if(o.target){var a=document.getElementById("linkTo");a.innerText=o.target.label,a.title=o.target.label+"(ID: "+o.target.id+")",a.onclick=function(){i.trigger("selected-element-changed",o.target.id)}}}else i.rootHtml.innerHTML=s},e.selectedElement&&i.setSelectedElement(e.selectedElement)}Object.defineProperty(n,"__esModule",{value:!0}),n.InfoPanel=i;var r=e("./subscriptionAPI/subscribeable"),l=o(r),a=0;n["default"]=i},{"./subscriptionAPI/subscribeable":8}],4:[function(e,t,n){"use strict";function o(e){function t(){var e=document.createElement("DIV");return e.innerHTML=n.markup,e.querySelector(".tq-ui-legend-panel_body_legends")}var n=this;e||(e={});var o=e.legends||[];n.markup='\n        <div class="tq-ui-legend-panel_body_legends">\n        '+o.map(function(e){return'\n                <div class="tq-ui-legend-panel_body_legends_legend" title="'+e.description+'">\n                    <div class="tq-ui-legend-panel_body_legends_legend_img"><img src="'+e.image+'"></div>\n                    <label class="tq-label">'+e.label+"</label>\n                </div>\n            "}).join("")+"\n        </div>\n    ",n.rootHtml=t(),n.id=e.id||"legends-"+i++,n.rootHtml.id=n.id}Object.defineProperty(n,"__esModule",{value:!0}),n.Legends=o;var i=0;n["default"]=o},{}],5:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}var i=e("./coloredButtonsList"),r=o(i),l=e("./flyingPanel"),a=o(l),s=e("./infoPanel"),u=o(s),d=e("./legends"),c=o(d),f=e("./progressScreen"),p=o(f),b=e("./searchPanel"),m=o(b),y=e("./switcher"),v=o(y),g=e("./tabPanel"),h=o(g),H=e("./toolbar"),q=o(H);t.exports={ColoredButtonsList:r["default"],FlyingPanel:a["default"],InfoPanel:u["default"],Legends:c["default"],ProgressScreen:p["default"],SearchPanel:m["default"],Switcher:v["default"],TabPanel:h["default"],Toolbar:q["default"]}},{"./coloredButtonsList":1,"./flyingPanel":2,"./infoPanel":3,"./legends":4,"./progressScreen":6,"./searchPanel":7,"./switcher":9,"./tabPanel":10,"./toolbar":11}],6:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function i(e){function t(){var e=document.createElement("DIV");return e.className="tq-ui-progress-screen",e.innerHTML=o.markup,e}function n(e){var t=void 0;return"string"==typeof e?t=document.getElementById(e):"object"===("undefined"==typeof e?"undefined":r(e))&&(t=e),t}a["default"].apply(this);var o=this;e||(e={}),o.markup="",o.state="completed",o.rootHtml=t(),o.id=e.id||"tabPanel-"+s++,o.rootHtml.id=o.id;var i=n(e.baseElement);i.appendChild(o.rootHtml),o.setState=function(e,t){e&&(o.state=e,"active"===e?(o.rootHtml.innerHTML="<h1>"+(t||u)+'</h1><div class="tq-ui-progress-screen__progress"></div>',o.rootHtml.style.display=null):"completed"===e?(o.rootHtml.innerHTML="",o.rootHtml.style.display="none"):"error"===e&&(o.rootHtml.innerHTML="<h1>"+(t||d)+"</h1>",o.rootHtml.style.display=null),o.trigger("diagram-state-changed",e))},o.setState(e.state,e.text)}Object.defineProperty(n,"__esModule",{value:!0});var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};n.ProgressScreen=i;var l=e("./subscriptionAPI/subscribeable"),a=o(l),s=0,u="Loading",d="Error has occurred!";n["default"]=i},{"./subscriptionAPI/subscribeable":8}],7:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function i(e){l["default"].apply(this),e||(e={});var t=e.searchButtonId||"tqLgSearchButton",n=e.searchId||"search";s["default"].apply(this,[{id:e.id,baseElement:e.baseElement,active:e.active,header:e.header||"Search panel",triggerButton:e.triggerButton,body:"\n            <span id= "+t+' class="tq-ui-search-icon glyphicon glyphicon-search" aria-hidden="true"></span>\n            <input id="'+n+'" placeHolder="Search..." class="tq-ui-search-input"></input>\n        ',removeBackground:!0,size:{width:"260px",height:"70px"}}])}Object.defineProperty(n,"__esModule",{value:!0}),n.SearchPanel=i;var r=e("./subscriptionAPI/subscribeable"),l=o(r),a=e("./flyingPanel"),s=o(a);n["default"]=i},{"./flyingPanel":2,"./subscriptionAPI/subscribeable":8}],8:[function(e,t,n){"use strict";function o(){var e=this;e._subscribtions={},e.on=function(t,n){e._subscribtions[t]||(e._subscribtions[t]=[]),e._subscribtions[t].push(n)},e.unsubscribe=function(t){Object.keys(e._subscribtions).map(function(t){return e._subscribtions[t]}).forEach(function(e){var n=e.indexOf(t);n!==-1&&e.splice(n,1)})},e.trigger=function(t,n){var o=this;n instanceof Array||(n=[n]),e._subscribtions&&e._subscribtions[t]&&e._subscribtions[t].forEach(function(e){e.apply(o,n)})}}Object.defineProperty(n,"__esModule",{value:!0}),n.Subscribable=o,n["default"]=o},{}],9:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function i(e){function t(){var t=document.createElement("DIV");return t.className="tq-ui-switch-buttons"+(e.verticalOrientation?"-vertical":""),t.innerHTML=n.markup,t}l["default"].apply(this),e||(e={});var n=this,o=e.states||[];n.markup=o.map(function(t,n){return'<button id="'+t.id+'" '+(0!==n?"":"disabled")+' title="'+(t.label||t.id)+'">\n            '+(e.verticalOrientation&&t.icon?'<span class="'+t.icon+'" aria-hidden="true"></span>':t.label||t.id)+"\n        </button>"}).join(""),n.rootHtml=t(),n.id=e.id||"switcher-"+a++,n.rootHtml.id=n.id;var i=null;o.forEach(function(e,t){var o=n.rootHtml.querySelector("#"+e.id);0===t&&(i=o),o.onclick=function(){o.disabled=!0,i.disabled=!1,i=o,n.trigger("state-changed",e.id)}}),n.setState=function(e){var t=n.rootHtml.querySelector("#"+e);t&&e!==i.id&&(t.disabled=!0,i.disabled=!1,i=t)}}Object.defineProperty(n,"__esModule",{value:!0}),n.Switcher=i;var r=e("./subscriptionAPI/subscribeable"),l=o(r),a=0;n["default"]=i},{"./subscriptionAPI/subscribeable":8}],10:[function(e,t,n){"use strict";function o(e){function t(){var e=document.createElement("DIV");return e.className="tq-ui-tab-panel",e.innerHTML=n.markup,e}var n=this;e||(e={});var o=e.tabs||[];n.markup='\n        <div class="tq-ui-tab-switcher tq-ui-switch-buttons">'+o.map(function(e,t){return'\n            <button id="'+e.id+'" '+(0!==t?"":"disabled")+">\n                "+(e.label||e.id)+"\n            </button>  \n        "}).join("")+"</div>"+o.map(function(e,t){return'\n            <div id="'+e.id+'Panel" class="tq-ui-tab-panel_page" style="display: '+(0===t?"":"none")+'">\n                <div class="tq-ui-tab-panel_page_body">\n                    '+("string"==typeof e.body?e.body:"")+"\n                </div>\n            </div>\n        "}).join(""),n.rootHtml=t(),n.id=e.id||"tabPanel-"+i++,n.rootHtml.id=n.id,o.map(function(e){if(e.body instanceof Object&&e.body.rootHtml){var t=n.rootHtml.querySelector("#"+e.id+"Panel .tq-ui-tab-panel_page_body");t.appendChild(e.body.rootHtml)}});var r=null;o.forEach(function(e,t){var o=n.rootHtml.querySelector("#"+e.id),i=n.rootHtml.querySelector("#"+e.id+"Panel");0===t&&(r={tabBtn:o,tabPanel:i}),o.onclick=function(){o.disabled=!0,i.style.display="",r.tabBtn.disabled=!1,r.tabPanel.style.display="none",r={tabBtn:o,tabPanel:i}}})}Object.defineProperty(n,"__esModule",{value:!0}),n.TabPanel=o;var i=0;n["default"]=o},{}],11:[function(e,t,n){"use strict";function o(e){function t(e){var t=void 0;if("string"==typeof e){var n=document.createElement("DIV");n.innerHTML=e,t=n.firstChild}else if(e.id&&e.icon){var o=document.createElement("DIV");if(o.innerHTML='<button id="'+e.id+'" title="'+(e.label||e.id)+'" class="tq-ui-toolbar__button">\n                <span class="'+e.icon+'" aria-hidden="true"></span>\n            </button>',t=o.firstChild,e.icon2){var i=!0;t.onclick=function(n){t.innerHTML='<span class="'+(i?e.icon2:e.icon)+'" aria-hidden="true"></span>',e.callback(n),i=!i}}else t.onclick=e.callback}else e.rootHtml&&(t=e.rootHtml);return t}function n(){var t=void 0;return"string"==typeof e.baseElement?t=document.getElementById(e.baseElement):"object"===i(e.baseElement)&&(t=e.baseElement),t?(t.innerHTML=o.markup,t):null}var o=this;if(e||(e={}),o.markup='\n        <div id="toolbarRootElement" class="tq-ui-toolbar">\n        </div>\n    ',o.rootHtml=n(),o.id=e.id||"toolbar-"+r++,o.rootHtml.id=o.id,!o.rootHtml)throw new Error("The root element is not specified!");o.container=o.rootHtml.querySelector("#toolbarRootElement"),o.pushTool=function(e){var n=t(e);n&&("string"!=typeof n?l.push(e):l.push({id:"customhtml"+r++,markup:e,rootHtml:n}),o.container.appendChild(n))},o.insertTool=function(e,n){var i=Math.min(Math.max(n,0),l.length-1),r=o.container.querySelector("#"+l[i].id);if(r){var a=t(e);a&&(l.splice(i,0,e),o.container.insertBefore(a,r))}else o.pushTool(e)},o.removeTool=function(e){var t="string"==typeof e?e:e.id;l.splice(l.indexOf(e),1);var n=o.container.querySelector("#"+t);o.container.removeChild(n)};var l=[];e.tools.forEach(function(e){o.pushTool(e)})}Object.defineProperty(n,"__esModule",{value:!0});var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};n.Toolbar=o;var r=0;n["default"]=o},{}]},{},[5])(5)});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],6:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./src/adaptor"));
__export(require("./src/d3adaptor"));
__export(require("./src/descent"));
__export(require("./src/geom"));
__export(require("./src/gridrouter"));
__export(require("./src/handledisconnected"));
__export(require("./src/layout"));
__export(require("./src/layout3d"));
__export(require("./src/linklengths"));
__export(require("./src/powergraph"));
__export(require("./src/pqueue"));
__export(require("./src/rbtree"));
__export(require("./src/rectangle"));
__export(require("./src/shortestpaths"));
__export(require("./src/vpsc"));
__export(require("./src/batch"));

},{"./src/adaptor":7,"./src/batch":8,"./src/d3adaptor":9,"./src/descent":12,"./src/geom":13,"./src/gridrouter":14,"./src/handledisconnected":15,"./src/layout":16,"./src/layout3d":17,"./src/linklengths":18,"./src/powergraph":19,"./src/pqueue":20,"./src/rbtree":21,"./src/rectangle":22,"./src/shortestpaths":23,"./src/vpsc":24}],7:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var layout_1 = require("./layout");
var LayoutAdaptor = (function (_super) {
    __extends(LayoutAdaptor, _super);
    function LayoutAdaptor(options) {
        var _this = _super.call(this) || this;
        var self = _this;
        var o = options;
        if (o.trigger) {
            _this.trigger = o.trigger;
        }
        if (o.kick) {
            _this.kick = o.kick;
        }
        if (o.drag) {
            _this.drag = o.drag;
        }
        if (o.on) {
            _this.on = o.on;
        }
        _this.dragstart = _this.dragStart = layout_1.Layout.dragStart;
        _this.dragend = _this.dragEnd = layout_1.Layout.dragEnd;
        return _this;
    }
    LayoutAdaptor.prototype.trigger = function (e) { };
    ;
    LayoutAdaptor.prototype.kick = function () { };
    ;
    LayoutAdaptor.prototype.drag = function () { };
    ;
    LayoutAdaptor.prototype.on = function (eventType, listener) { return this; };
    ;
    return LayoutAdaptor;
}(layout_1.Layout));
exports.LayoutAdaptor = LayoutAdaptor;
function adaptor(options) {
    return new LayoutAdaptor(options);
}
exports.adaptor = adaptor;

},{"./layout":16}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var layout_1 = require("./layout");
var gridrouter_1 = require("./gridrouter");
function gridify(pgLayout, nudgeGap, margin, groupMargin) {
    pgLayout.cola.start(0, 0, 0, 10, false);
    var gridrouter = route(pgLayout.cola.nodes(), pgLayout.cola.groups(), margin, groupMargin);
    return gridrouter.routeEdges(pgLayout.powerGraph.powerEdges, nudgeGap, function (e) { return e.source.routerNode.id; }, function (e) { return e.target.routerNode.id; });
}
exports.gridify = gridify;
function route(nodes, groups, margin, groupMargin) {
    nodes.forEach(function (d) {
        d.routerNode = {
            name: d.name,
            bounds: d.bounds.inflate(-margin)
        };
    });
    groups.forEach(function (d) {
        d.routerNode = {
            bounds: d.bounds.inflate(-groupMargin),
            children: (typeof d.groups !== 'undefined' ? d.groups.map(function (c) { return nodes.length + c.id; }) : [])
                .concat(typeof d.leaves !== 'undefined' ? d.leaves.map(function (c) { return c.index; }) : [])
        };
    });
    var gridRouterNodes = nodes.concat(groups).map(function (d, i) {
        d.routerNode.id = i;
        return d.routerNode;
    });
    return new gridrouter_1.GridRouter(gridRouterNodes, {
        getChildren: function (v) { return v.children; },
        getBounds: function (v) { return v.bounds; }
    }, margin - groupMargin);
}
function powerGraphGridLayout(graph, size, grouppadding) {
    var powerGraph;
    graph.nodes.forEach(function (v, i) { return v.index = i; });
    new layout_1.Layout()
        .avoidOverlaps(false)
        .nodes(graph.nodes)
        .links(graph.links)
        .powerGraphGroups(function (d) {
        powerGraph = d;
        powerGraph.groups.forEach(function (v) { return v.padding = grouppadding; });
    });
    var n = graph.nodes.length;
    var edges = [];
    var vs = graph.nodes.slice(0);
    vs.forEach(function (v, i) { return v.index = i; });
    powerGraph.groups.forEach(function (g) {
        var sourceInd = g.index = g.id + n;
        vs.push(g);
        if (typeof g.leaves !== 'undefined')
            g.leaves.forEach(function (v) { return edges.push({ source: sourceInd, target: v.index }); });
        if (typeof g.groups !== 'undefined')
            g.groups.forEach(function (gg) { return edges.push({ source: sourceInd, target: gg.id + n }); });
    });
    powerGraph.powerEdges.forEach(function (e) {
        edges.push({ source: e.source.index, target: e.target.index });
    });
    new layout_1.Layout()
        .size(size)
        .nodes(vs)
        .links(edges)
        .avoidOverlaps(false)
        .linkDistance(30)
        .symmetricDiffLinkLengths(5)
        .convergenceThreshold(1e-4)
        .start(100, 0, 0, 0, false);
    return {
        cola: new layout_1.Layout()
            .convergenceThreshold(1e-3)
            .size(size)
            .avoidOverlaps(true)
            .nodes(graph.nodes)
            .links(graph.links)
            .groupCompactness(1e-4)
            .linkDistance(30)
            .symmetricDiffLinkLengths(5)
            .powerGraphGroups(function (d) {
            powerGraph = d;
            powerGraph.groups.forEach(function (v) {
                v.padding = grouppadding;
            });
        }).start(50, 0, 100, 0, false),
        powerGraph: powerGraph
    };
}
exports.powerGraphGridLayout = powerGraphGridLayout;

},{"./gridrouter":14,"./layout":16}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var d3v3 = require("./d3v3adaptor");
var d3v4 = require("./d3v4adaptor");
;
function d3adaptor(d3Context) {
    if (!d3Context || isD3V3(d3Context)) {
        return new d3v3.D3StyleLayoutAdaptor();
    }
    return new d3v4.D3StyleLayoutAdaptor(d3Context);
}
exports.d3adaptor = d3adaptor;
function isD3V3(d3Context) {
    var v3exp = /^3\./;
    return d3Context.version && d3Context.version.match(v3exp) !== null;
}

},{"./d3v3adaptor":10,"./d3v4adaptor":11}],10:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var layout_1 = require("./layout");
var D3StyleLayoutAdaptor = (function (_super) {
    __extends(D3StyleLayoutAdaptor, _super);
    function D3StyleLayoutAdaptor() {
        var _this = _super.call(this) || this;
        _this.event = d3.dispatch(layout_1.EventType[layout_1.EventType.start], layout_1.EventType[layout_1.EventType.tick], layout_1.EventType[layout_1.EventType.end]);
        var d3layout = _this;
        var drag;
        _this.drag = function () {
            if (!drag) {
                var drag = d3.behavior.drag()
                    .origin(layout_1.Layout.dragOrigin)
                    .on("dragstart.d3adaptor", layout_1.Layout.dragStart)
                    .on("drag.d3adaptor", function (d) {
                    layout_1.Layout.drag(d, d3.event);
                    d3layout.resume();
                })
                    .on("dragend.d3adaptor", layout_1.Layout.dragEnd);
            }
            if (!arguments.length)
                return drag;
            this
                .call(drag);
        };
        return _this;
    }
    D3StyleLayoutAdaptor.prototype.trigger = function (e) {
        var d3event = { type: layout_1.EventType[e.type], alpha: e.alpha, stress: e.stress };
        this.event[d3event.type](d3event);
    };
    D3StyleLayoutAdaptor.prototype.kick = function () {
        var _this = this;
        d3.timer(function () { return _super.prototype.tick.call(_this); });
    };
    D3StyleLayoutAdaptor.prototype.on = function (eventType, listener) {
        if (typeof eventType === 'string') {
            this.event.on(eventType, listener);
        }
        else {
            this.event.on(layout_1.EventType[eventType], listener);
        }
        return this;
    };
    return D3StyleLayoutAdaptor;
}(layout_1.Layout));
exports.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;
function d3adaptor() {
    return new D3StyleLayoutAdaptor();
}
exports.d3adaptor = d3adaptor;

},{"./layout":16}],11:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var layout_1 = require("./layout");
var D3StyleLayoutAdaptor = (function (_super) {
    __extends(D3StyleLayoutAdaptor, _super);
    function D3StyleLayoutAdaptor(d3Context) {
        var _this = _super.call(this) || this;
        _this.d3Context = d3Context;
        _this.event = d3Context.dispatch(layout_1.EventType[layout_1.EventType.start], layout_1.EventType[layout_1.EventType.tick], layout_1.EventType[layout_1.EventType.end]);
        var d3layout = _this;
        var drag;
        _this.drag = function () {
            if (!drag) {
                var drag = d3Context.drag()
                    .subject(layout_1.Layout.dragOrigin)
                    .on("start.d3adaptor", layout_1.Layout.dragStart)
                    .on("drag.d3adaptor", function (d) {
                    layout_1.Layout.drag(d, d3Context.event);
                    d3layout.resume();
                })
                    .on("end.d3adaptor", layout_1.Layout.dragEnd);
            }
            if (!arguments.length)
                return drag;
            arguments[0].call(drag);
        };
        return _this;
    }
    D3StyleLayoutAdaptor.prototype.trigger = function (e) {
        var d3event = { type: layout_1.EventType[e.type], alpha: e.alpha, stress: e.stress };
        this.event.call(d3event.type, d3event);
    };
    D3StyleLayoutAdaptor.prototype.kick = function () {
        var _this = this;
        var t = this.d3Context.timer(function () { return _super.prototype.tick.call(_this) && t.stop(); });
    };
    D3StyleLayoutAdaptor.prototype.on = function (eventType, listener) {
        if (typeof eventType === 'string') {
            this.event.on(eventType, listener);
        }
        else {
            this.event.on(layout_1.EventType[eventType], listener);
        }
        return this;
    };
    return D3StyleLayoutAdaptor;
}(layout_1.Layout));
exports.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;

},{"./layout":16}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Locks = (function () {
    function Locks() {
        this.locks = {};
    }
    Locks.prototype.add = function (id, x) {
        this.locks[id] = x;
    };
    Locks.prototype.clear = function () {
        this.locks = {};
    };
    Locks.prototype.isEmpty = function () {
        for (var l in this.locks)
            return false;
        return true;
    };
    Locks.prototype.apply = function (f) {
        for (var l in this.locks) {
            f(Number(l), this.locks[l]);
        }
    };
    return Locks;
}());
exports.Locks = Locks;
var Descent = (function () {
    function Descent(x, D, G) {
        if (G === void 0) { G = null; }
        this.D = D;
        this.G = G;
        this.threshold = 0.0001;
        this.numGridSnapNodes = 0;
        this.snapGridSize = 100;
        this.snapStrength = 1000;
        this.scaleSnapByMaxH = false;
        this.random = new PseudoRandom();
        this.project = null;
        this.x = x;
        this.k = x.length;
        var n = this.n = x[0].length;
        this.H = new Array(this.k);
        this.g = new Array(this.k);
        this.Hd = new Array(this.k);
        this.a = new Array(this.k);
        this.b = new Array(this.k);
        this.c = new Array(this.k);
        this.d = new Array(this.k);
        this.e = new Array(this.k);
        this.ia = new Array(this.k);
        this.ib = new Array(this.k);
        this.xtmp = new Array(this.k);
        this.locks = new Locks();
        this.minD = Number.MAX_VALUE;
        var i = n, j;
        while (i--) {
            j = n;
            while (--j > i) {
                var d = D[i][j];
                if (d > 0 && d < this.minD) {
                    this.minD = d;
                }
            }
        }
        if (this.minD === Number.MAX_VALUE)
            this.minD = 1;
        i = this.k;
        while (i--) {
            this.g[i] = new Array(n);
            this.H[i] = new Array(n);
            j = n;
            while (j--) {
                this.H[i][j] = new Array(n);
            }
            this.Hd[i] = new Array(n);
            this.a[i] = new Array(n);
            this.b[i] = new Array(n);
            this.c[i] = new Array(n);
            this.d[i] = new Array(n);
            this.e[i] = new Array(n);
            this.ia[i] = new Array(n);
            this.ib[i] = new Array(n);
            this.xtmp[i] = new Array(n);
        }
    }
    Descent.createSquareMatrix = function (n, f) {
        var M = new Array(n);
        for (var i = 0; i < n; ++i) {
            M[i] = new Array(n);
            for (var j = 0; j < n; ++j) {
                M[i][j] = f(i, j);
            }
        }
        return M;
    };
    Descent.prototype.offsetDir = function () {
        var _this = this;
        var u = new Array(this.k);
        var l = 0;
        for (var i = 0; i < this.k; ++i) {
            var x = u[i] = this.random.getNextBetween(0.01, 1) - 0.5;
            l += x * x;
        }
        l = Math.sqrt(l);
        return u.map(function (x) { return x *= _this.minD / l; });
    };
    Descent.prototype.computeDerivatives = function (x) {
        var _this = this;
        var n = this.n;
        if (n < 1)
            return;
        var i;
        var d = new Array(this.k);
        var d2 = new Array(this.k);
        var Huu = new Array(this.k);
        var maxH = 0;
        for (var u = 0; u < n; ++u) {
            for (i = 0; i < this.k; ++i)
                Huu[i] = this.g[i][u] = 0;
            for (var v = 0; v < n; ++v) {
                if (u === v)
                    continue;
                var maxDisplaces = n;
                while (maxDisplaces--) {
                    var sd2 = 0;
                    for (i = 0; i < this.k; ++i) {
                        var dx = d[i] = x[i][u] - x[i][v];
                        sd2 += d2[i] = dx * dx;
                    }
                    if (sd2 > 1e-9)
                        break;
                    var rd = this.offsetDir();
                    for (i = 0; i < this.k; ++i)
                        x[i][v] += rd[i];
                }
                var l = Math.sqrt(sd2);
                var D = this.D[u][v];
                var weight = this.G != null ? this.G[u][v] : 1;
                if (weight > 1 && l > D || !isFinite(D)) {
                    for (i = 0; i < this.k; ++i)
                        this.H[i][u][v] = 0;
                    continue;
                }
                if (weight > 1) {
                    weight = 1;
                }
                var D2 = D * D;
                var gs = 2 * weight * (l - D) / (D2 * l);
                var l3 = l * l * l;
                var hs = 2 * -weight / (D2 * l3);
                if (!isFinite(gs))
                    console.log(gs);
                for (i = 0; i < this.k; ++i) {
                    this.g[i][u] += d[i] * gs;
                    Huu[i] -= this.H[i][u][v] = hs * (l3 + D * (d2[i] - sd2) + l * sd2);
                }
            }
            for (i = 0; i < this.k; ++i)
                maxH = Math.max(maxH, this.H[i][u][u] = Huu[i]);
        }
        var r = this.snapGridSize / 2;
        var g = this.snapGridSize;
        var w = this.snapStrength;
        var k = w / (r * r);
        var numNodes = this.numGridSnapNodes;
        for (var u = 0; u < numNodes; ++u) {
            for (i = 0; i < this.k; ++i) {
                var xiu = this.x[i][u];
                var m = xiu / g;
                var f = m % 1;
                var q = m - f;
                var a = Math.abs(f);
                var dx = (a <= 0.5) ? xiu - q * g :
                    (xiu > 0) ? xiu - (q + 1) * g : xiu - (q - 1) * g;
                if (-r < dx && dx <= r) {
                    if (this.scaleSnapByMaxH) {
                        this.g[i][u] += maxH * k * dx;
                        this.H[i][u][u] += maxH * k;
                    }
                    else {
                        this.g[i][u] += k * dx;
                        this.H[i][u][u] += k;
                    }
                }
            }
        }
        if (!this.locks.isEmpty()) {
            this.locks.apply(function (u, p) {
                for (i = 0; i < _this.k; ++i) {
                    _this.H[i][u][u] += maxH;
                    _this.g[i][u] -= maxH * (p[i] - x[i][u]);
                }
            });
        }
    };
    Descent.dotProd = function (a, b) {
        var x = 0, i = a.length;
        while (i--)
            x += a[i] * b[i];
        return x;
    };
    Descent.rightMultiply = function (m, v, r) {
        var i = m.length;
        while (i--)
            r[i] = Descent.dotProd(m[i], v);
    };
    Descent.prototype.computeStepSize = function (d) {
        var numerator = 0, denominator = 0;
        for (var i = 0; i < this.k; ++i) {
            numerator += Descent.dotProd(this.g[i], d[i]);
            Descent.rightMultiply(this.H[i], d[i], this.Hd[i]);
            denominator += Descent.dotProd(d[i], this.Hd[i]);
        }
        if (denominator === 0 || !isFinite(denominator))
            return 0;
        return 1 * numerator / denominator;
    };
    Descent.prototype.reduceStress = function () {
        this.computeDerivatives(this.x);
        var alpha = this.computeStepSize(this.g);
        for (var i = 0; i < this.k; ++i) {
            this.takeDescentStep(this.x[i], this.g[i], alpha);
        }
        return this.computeStress();
    };
    Descent.copy = function (a, b) {
        var m = a.length, n = b[0].length;
        for (var i = 0; i < m; ++i) {
            for (var j = 0; j < n; ++j) {
                b[i][j] = a[i][j];
            }
        }
    };
    Descent.prototype.stepAndProject = function (x0, r, d, stepSize) {
        Descent.copy(x0, r);
        this.takeDescentStep(r[0], d[0], stepSize);
        if (this.project)
            this.project[0](x0[0], x0[1], r[0]);
        this.takeDescentStep(r[1], d[1], stepSize);
        if (this.project)
            this.project[1](r[0], x0[1], r[1]);
        for (var i = 2; i < this.k; i++)
            this.takeDescentStep(r[i], d[i], stepSize);
    };
    Descent.mApply = function (m, n, f) {
        var i = m;
        while (i-- > 0) {
            var j = n;
            while (j-- > 0)
                f(i, j);
        }
    };
    Descent.prototype.matrixApply = function (f) {
        Descent.mApply(this.k, this.n, f);
    };
    Descent.prototype.computeNextPosition = function (x0, r) {
        var _this = this;
        this.computeDerivatives(x0);
        var alpha = this.computeStepSize(this.g);
        this.stepAndProject(x0, r, this.g, alpha);
        if (this.project) {
            this.matrixApply(function (i, j) { return _this.e[i][j] = x0[i][j] - r[i][j]; });
            var beta = this.computeStepSize(this.e);
            beta = Math.max(0.2, Math.min(beta, 1));
            this.stepAndProject(x0, r, this.e, beta);
        }
    };
    Descent.prototype.run = function (iterations) {
        var stress = Number.MAX_VALUE, converged = false;
        while (!converged && iterations-- > 0) {
            var s = this.rungeKutta();
            converged = Math.abs(stress / s - 1) < this.threshold;
            stress = s;
        }
        return stress;
    };
    Descent.prototype.rungeKutta = function () {
        var _this = this;
        this.computeNextPosition(this.x, this.a);
        Descent.mid(this.x, this.a, this.ia);
        this.computeNextPosition(this.ia, this.b);
        Descent.mid(this.x, this.b, this.ib);
        this.computeNextPosition(this.ib, this.c);
        this.computeNextPosition(this.c, this.d);
        var disp = 0;
        this.matrixApply(function (i, j) {
            var x = (_this.a[i][j] + 2.0 * _this.b[i][j] + 2.0 * _this.c[i][j] + _this.d[i][j]) / 6.0, d = _this.x[i][j] - x;
            disp += d * d;
            _this.x[i][j] = x;
        });
        return disp;
    };
    Descent.mid = function (a, b, m) {
        Descent.mApply(a.length, a[0].length, function (i, j) {
            return m[i][j] = a[i][j] + (b[i][j] - a[i][j]) / 2.0;
        });
    };
    Descent.prototype.takeDescentStep = function (x, d, stepSize) {
        for (var i = 0; i < this.n; ++i) {
            x[i] = x[i] - stepSize * d[i];
        }
    };
    Descent.prototype.computeStress = function () {
        var stress = 0;
        for (var u = 0, nMinus1 = this.n - 1; u < nMinus1; ++u) {
            for (var v = u + 1, n = this.n; v < n; ++v) {
                var l = 0;
                for (var i = 0; i < this.k; ++i) {
                    var dx = this.x[i][u] - this.x[i][v];
                    l += dx * dx;
                }
                l = Math.sqrt(l);
                var d = this.D[u][v];
                if (!isFinite(d))
                    continue;
                var rl = d - l;
                var d2 = d * d;
                stress += rl * rl / d2;
            }
        }
        return stress;
    };
    Descent.zeroDistance = 1e-10;
    return Descent;
}());
exports.Descent = Descent;
var PseudoRandom = (function () {
    function PseudoRandom(seed) {
        if (seed === void 0) { seed = 1; }
        this.seed = seed;
        this.a = 214013;
        this.c = 2531011;
        this.m = 2147483648;
        this.range = 32767;
    }
    PseudoRandom.prototype.getNext = function () {
        this.seed = (this.seed * this.a + this.c) % this.m;
        return (this.seed >> 16) / this.range;
    };
    PseudoRandom.prototype.getNextBetween = function (min, max) {
        return min + this.getNext() * (max - min);
    };
    return PseudoRandom;
}());
exports.PseudoRandom = PseudoRandom;

},{}],13:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var rectangle_1 = require("./rectangle");
var Point = (function () {
    function Point() {
    }
    return Point;
}());
exports.Point = Point;
var LineSegment = (function () {
    function LineSegment(x1, y1, x2, y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }
    return LineSegment;
}());
exports.LineSegment = LineSegment;
var PolyPoint = (function (_super) {
    __extends(PolyPoint, _super);
    function PolyPoint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PolyPoint;
}(Point));
exports.PolyPoint = PolyPoint;
function isLeft(P0, P1, P2) {
    return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);
}
exports.isLeft = isLeft;
function above(p, vi, vj) {
    return isLeft(p, vi, vj) > 0;
}
function below(p, vi, vj) {
    return isLeft(p, vi, vj) < 0;
}
function ConvexHull(S) {
    var P = S.slice(0).sort(function (a, b) { return a.x !== b.x ? b.x - a.x : b.y - a.y; });
    var n = S.length, i;
    var minmin = 0;
    var xmin = P[0].x;
    for (i = 1; i < n; ++i) {
        if (P[i].x !== xmin)
            break;
    }
    var minmax = i - 1;
    var H = [];
    H.push(P[minmin]);
    if (minmax === n - 1) {
        if (P[minmax].y !== P[minmin].y)
            H.push(P[minmax]);
    }
    else {
        var maxmin, maxmax = n - 1;
        var xmax = P[n - 1].x;
        for (i = n - 2; i >= 0; i--)
            if (P[i].x !== xmax)
                break;
        maxmin = i + 1;
        i = minmax;
        while (++i <= maxmin) {
            if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin)
                continue;
            while (H.length > 1) {
                if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)
                    break;
                else
                    H.length -= 1;
            }
            if (i != minmin)
                H.push(P[i]);
        }
        if (maxmax != maxmin)
            H.push(P[maxmax]);
        var bot = H.length;
        i = maxmin;
        while (--i >= minmax) {
            if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax)
                continue;
            while (H.length > bot) {
                if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)
                    break;
                else
                    H.length -= 1;
            }
            if (i != minmin)
                H.push(P[i]);
        }
    }
    return H;
}
exports.ConvexHull = ConvexHull;
function clockwiseRadialSweep(p, P, f) {
    P.slice(0).sort(function (a, b) { return Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x); }).forEach(f);
}
exports.clockwiseRadialSweep = clockwiseRadialSweep;
function nextPolyPoint(p, ps) {
    if (p.polyIndex === ps.length - 1)
        return ps[0];
    return ps[p.polyIndex + 1];
}
function prevPolyPoint(p, ps) {
    if (p.polyIndex === 0)
        return ps[ps.length - 1];
    return ps[p.polyIndex - 1];
}
function tangent_PointPolyC(P, V) {
    var Vclosed = V.slice(0);
    Vclosed.push(V[0]);
    return { rtan: Rtangent_PointPolyC(P, Vclosed), ltan: Ltangent_PointPolyC(P, Vclosed) };
}
function Rtangent_PointPolyC(P, V) {
    var n = V.length - 1;
    var a, b, c;
    var upA, dnC;
    if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0]))
        return 0;
    for (a = 0, b = n;;) {
        if (b - a === 1)
            if (above(P, V[a], V[b]))
                return a;
            else
                return b;
        c = Math.floor((a + b) / 2);
        dnC = below(P, V[c + 1], V[c]);
        if (dnC && !above(P, V[c - 1], V[c]))
            return c;
        upA = above(P, V[a + 1], V[a]);
        if (upA) {
            if (dnC)
                b = c;
            else {
                if (above(P, V[a], V[c]))
                    b = c;
                else
                    a = c;
            }
        }
        else {
            if (!dnC)
                a = c;
            else {
                if (below(P, V[a], V[c]))
                    b = c;
                else
                    a = c;
            }
        }
    }
}
function Ltangent_PointPolyC(P, V) {
    var n = V.length - 1;
    var a, b, c;
    var dnA, dnC;
    if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0]))
        return 0;
    for (a = 0, b = n;;) {
        if (b - a === 1)
            if (below(P, V[a], V[b]))
                return a;
            else
                return b;
        c = Math.floor((a + b) / 2);
        dnC = below(P, V[c + 1], V[c]);
        if (above(P, V[c - 1], V[c]) && !dnC)
            return c;
        dnA = below(P, V[a + 1], V[a]);
        if (dnA) {
            if (!dnC)
                b = c;
            else {
                if (below(P, V[a], V[c]))
                    b = c;
                else
                    a = c;
            }
        }
        else {
            if (dnC)
                a = c;
            else {
                if (above(P, V[a], V[c]))
                    b = c;
                else
                    a = c;
            }
        }
    }
}
function tangent_PolyPolyC(V, W, t1, t2, cmp1, cmp2) {
    var ix1, ix2;
    ix1 = t1(W[0], V);
    ix2 = t2(V[ix1], W);
    var done = false;
    while (!done) {
        done = true;
        while (true) {
            if (ix1 === V.length - 1)
                ix1 = 0;
            if (cmp1(W[ix2], V[ix1], V[ix1 + 1]))
                break;
            ++ix1;
        }
        while (true) {
            if (ix2 === 0)
                ix2 = W.length - 1;
            if (cmp2(V[ix1], W[ix2], W[ix2 - 1]))
                break;
            --ix2;
            done = false;
        }
    }
    return { t1: ix1, t2: ix2 };
}
exports.tangent_PolyPolyC = tangent_PolyPolyC;
function LRtangent_PolyPolyC(V, W) {
    var rl = RLtangent_PolyPolyC(W, V);
    return { t1: rl.t2, t2: rl.t1 };
}
exports.LRtangent_PolyPolyC = LRtangent_PolyPolyC;
function RLtangent_PolyPolyC(V, W) {
    return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);
}
exports.RLtangent_PolyPolyC = RLtangent_PolyPolyC;
function LLtangent_PolyPolyC(V, W) {
    return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);
}
exports.LLtangent_PolyPolyC = LLtangent_PolyPolyC;
function RRtangent_PolyPolyC(V, W) {
    return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);
}
exports.RRtangent_PolyPolyC = RRtangent_PolyPolyC;
var BiTangent = (function () {
    function BiTangent(t1, t2) {
        this.t1 = t1;
        this.t2 = t2;
    }
    return BiTangent;
}());
exports.BiTangent = BiTangent;
var BiTangents = (function () {
    function BiTangents() {
    }
    return BiTangents;
}());
exports.BiTangents = BiTangents;
var TVGPoint = (function (_super) {
    __extends(TVGPoint, _super);
    function TVGPoint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TVGPoint;
}(Point));
exports.TVGPoint = TVGPoint;
var VisibilityVertex = (function () {
    function VisibilityVertex(id, polyid, polyvertid, p) {
        this.id = id;
        this.polyid = polyid;
        this.polyvertid = polyvertid;
        this.p = p;
        p.vv = this;
    }
    return VisibilityVertex;
}());
exports.VisibilityVertex = VisibilityVertex;
var VisibilityEdge = (function () {
    function VisibilityEdge(source, target) {
        this.source = source;
        this.target = target;
    }
    VisibilityEdge.prototype.length = function () {
        var dx = this.source.p.x - this.target.p.x;
        var dy = this.source.p.y - this.target.p.y;
        return Math.sqrt(dx * dx + dy * dy);
    };
    return VisibilityEdge;
}());
exports.VisibilityEdge = VisibilityEdge;
var TangentVisibilityGraph = (function () {
    function TangentVisibilityGraph(P, g0) {
        this.P = P;
        this.V = [];
        this.E = [];
        if (!g0) {
            var n = P.length;
            for (var i = 0; i < n; i++) {
                var p = P[i];
                for (var j = 0; j < p.length; ++j) {
                    var pj = p[j], vv = new VisibilityVertex(this.V.length, i, j, pj);
                    this.V.push(vv);
                    if (j > 0)
                        this.E.push(new VisibilityEdge(p[j - 1].vv, vv));
                }
                if (p.length > 1)
                    this.E.push(new VisibilityEdge(p[0].vv, p[p.length - 1].vv));
            }
            for (var i = 0; i < n - 1; i++) {
                var Pi = P[i];
                for (var j = i + 1; j < n; j++) {
                    var Pj = P[j], t = tangents(Pi, Pj);
                    for (var q in t) {
                        var c = t[q], source = Pi[c.t1], target = Pj[c.t2];
                        this.addEdgeIfVisible(source, target, i, j);
                    }
                }
            }
        }
        else {
            this.V = g0.V.slice(0);
            this.E = g0.E.slice(0);
        }
    }
    TangentVisibilityGraph.prototype.addEdgeIfVisible = function (u, v, i1, i2) {
        if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {
            this.E.push(new VisibilityEdge(u.vv, v.vv));
        }
    };
    TangentVisibilityGraph.prototype.addPoint = function (p, i1) {
        var n = this.P.length;
        this.V.push(new VisibilityVertex(this.V.length, n, 0, p));
        for (var i = 0; i < n; ++i) {
            if (i === i1)
                continue;
            var poly = this.P[i], t = tangent_PointPolyC(p, poly);
            this.addEdgeIfVisible(p, poly[t.ltan], i1, i);
            this.addEdgeIfVisible(p, poly[t.rtan], i1, i);
        }
        return p.vv;
    };
    TangentVisibilityGraph.prototype.intersectsPolys = function (l, i1, i2) {
        for (var i = 0, n = this.P.length; i < n; ++i) {
            if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {
                return true;
            }
        }
        return false;
    };
    return TangentVisibilityGraph;
}());
exports.TangentVisibilityGraph = TangentVisibilityGraph;
function intersects(l, P) {
    var ints = [];
    for (var i = 1, n = P.length; i < n; ++i) {
        var int = rectangle_1.Rectangle.lineIntersection(l.x1, l.y1, l.x2, l.y2, P[i - 1].x, P[i - 1].y, P[i].x, P[i].y);
        if (int)
            ints.push(int);
    }
    return ints;
}
function tangents(V, W) {
    var m = V.length - 1, n = W.length - 1;
    var bt = new BiTangents();
    for (var i = 0; i < m; ++i) {
        for (var j = 0; j < n; ++j) {
            var v1 = V[i == 0 ? m - 1 : i - 1];
            var v2 = V[i];
            var v3 = V[i + 1];
            var w1 = W[j == 0 ? n - 1 : j - 1];
            var w2 = W[j];
            var w3 = W[j + 1];
            var v1v2w2 = isLeft(v1, v2, w2);
            var v2w1w2 = isLeft(v2, w1, w2);
            var v2w2w3 = isLeft(v2, w2, w3);
            var w1w2v2 = isLeft(w1, w2, v2);
            var w2v1v2 = isLeft(w2, v1, v2);
            var w2v2v3 = isLeft(w2, v2, v3);
            if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0
                && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {
                bt.ll = new BiTangent(i, j);
            }
            else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0
                && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {
                bt.rr = new BiTangent(i, j);
            }
            else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0
                && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {
                bt.rl = new BiTangent(i, j);
            }
            else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0
                && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {
                bt.lr = new BiTangent(i, j);
            }
        }
    }
    return bt;
}
exports.tangents = tangents;
function isPointInsidePoly(p, poly) {
    for (var i = 1, n = poly.length; i < n; ++i)
        if (below(poly[i - 1], poly[i], p))
            return false;
    return true;
}
function isAnyPInQ(p, q) {
    return !p.every(function (v) { return !isPointInsidePoly(v, q); });
}
function polysOverlap(p, q) {
    if (isAnyPInQ(p, q))
        return true;
    if (isAnyPInQ(q, p))
        return true;
    for (var i = 1, n = p.length; i < n; ++i) {
        var v = p[i], u = p[i - 1];
        if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0)
            return true;
    }
    return false;
}
exports.polysOverlap = polysOverlap;

},{"./rectangle":22}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var rectangle_1 = require("./rectangle");
var vpsc_1 = require("./vpsc");
var shortestpaths_1 = require("./shortestpaths");
var NodeWrapper = (function () {
    function NodeWrapper(id, rect, children) {
        this.id = id;
        this.rect = rect;
        this.children = children;
        this.leaf = typeof children === 'undefined' || children.length === 0;
    }
    return NodeWrapper;
}());
exports.NodeWrapper = NodeWrapper;
var Vert = (function () {
    function Vert(id, x, y, node, line) {
        if (node === void 0) { node = null; }
        if (line === void 0) { line = null; }
        this.id = id;
        this.x = x;
        this.y = y;
        this.node = node;
        this.line = line;
    }
    return Vert;
}());
exports.Vert = Vert;
var LongestCommonSubsequence = (function () {
    function LongestCommonSubsequence(s, t) {
        this.s = s;
        this.t = t;
        var mf = LongestCommonSubsequence.findMatch(s, t);
        var tr = t.slice(0).reverse();
        var mr = LongestCommonSubsequence.findMatch(s, tr);
        if (mf.length >= mr.length) {
            this.length = mf.length;
            this.si = mf.si;
            this.ti = mf.ti;
            this.reversed = false;
        }
        else {
            this.length = mr.length;
            this.si = mr.si;
            this.ti = t.length - mr.ti - mr.length;
            this.reversed = true;
        }
    }
    LongestCommonSubsequence.findMatch = function (s, t) {
        var m = s.length;
        var n = t.length;
        var match = { length: 0, si: -1, ti: -1 };
        var l = new Array(m);
        for (var i = 0; i < m; i++) {
            l[i] = new Array(n);
            for (var j = 0; j < n; j++)
                if (s[i] === t[j]) {
                    var v = l[i][j] = (i === 0 || j === 0) ? 1 : l[i - 1][j - 1] + 1;
                    if (v > match.length) {
                        match.length = v;
                        match.si = i - v + 1;
                        match.ti = j - v + 1;
                    }
                    ;
                }
                else
                    l[i][j] = 0;
        }
        return match;
    };
    LongestCommonSubsequence.prototype.getSequence = function () {
        return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];
    };
    return LongestCommonSubsequence;
}());
exports.LongestCommonSubsequence = LongestCommonSubsequence;
var GridRouter = (function () {
    function GridRouter(originalnodes, accessor, groupPadding) {
        if (groupPadding === void 0) { groupPadding = 12; }
        var _this = this;
        this.originalnodes = originalnodes;
        this.groupPadding = groupPadding;
        this.leaves = null;
        this.nodes = originalnodes.map(function (v, i) { return new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v)); });
        this.leaves = this.nodes.filter(function (v) { return v.leaf; });
        this.groups = this.nodes.filter(function (g) { return !g.leaf; });
        this.cols = this.getGridLines('x');
        this.rows = this.getGridLines('y');
        this.groups.forEach(function (v) {
            return v.children.forEach(function (c) { return _this.nodes[c].parent = v; });
        });
        this.root = { children: [] };
        this.nodes.forEach(function (v) {
            if (typeof v.parent === 'undefined') {
                v.parent = _this.root;
                _this.root.children.push(v.id);
            }
            v.ports = [];
        });
        this.backToFront = this.nodes.slice(0);
        this.backToFront.sort(function (x, y) { return _this.getDepth(x) - _this.getDepth(y); });
        var frontToBackGroups = this.backToFront.slice(0).reverse().filter(function (g) { return !g.leaf; });
        frontToBackGroups.forEach(function (v) {
            var r = rectangle_1.Rectangle.empty();
            v.children.forEach(function (c) { return r = r.union(_this.nodes[c].rect); });
            v.rect = r.inflate(_this.groupPadding);
        });
        var colMids = this.midPoints(this.cols.map(function (r) { return r.pos; }));
        var rowMids = this.midPoints(this.rows.map(function (r) { return r.pos; }));
        var rowx = colMids[0], rowX = colMids[colMids.length - 1];
        var coly = rowMids[0], colY = rowMids[rowMids.length - 1];
        var hlines = this.rows.map(function (r) { return ({ x1: rowx, x2: rowX, y1: r.pos, y2: r.pos }); })
            .concat(rowMids.map(function (m) { return ({ x1: rowx, x2: rowX, y1: m, y2: m }); }));
        var vlines = this.cols.map(function (c) { return ({ x1: c.pos, x2: c.pos, y1: coly, y2: colY }); })
            .concat(colMids.map(function (m) { return ({ x1: m, x2: m, y1: coly, y2: colY }); }));
        var lines = hlines.concat(vlines);
        lines.forEach(function (l) { return l.verts = []; });
        this.verts = [];
        this.edges = [];
        hlines.forEach(function (h) {
            return vlines.forEach(function (v) {
                var p = new Vert(_this.verts.length, v.x1, h.y1);
                h.verts.push(p);
                v.verts.push(p);
                _this.verts.push(p);
                var i = _this.backToFront.length;
                while (i-- > 0) {
                    var node = _this.backToFront[i], r = node.rect;
                    var dx = Math.abs(p.x - r.cx()), dy = Math.abs(p.y - r.cy());
                    if (dx < r.width() / 2 && dy < r.height() / 2) {
                        p.node = node;
                        break;
                    }
                }
            });
        });
        lines.forEach(function (l, li) {
            _this.nodes.forEach(function (v, i) {
                v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach(function (intersect, j) {
                    var p = new Vert(_this.verts.length, intersect.x, intersect.y, v, l);
                    _this.verts.push(p);
                    l.verts.push(p);
                    v.ports.push(p);
                });
            });
            var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;
            var delta = function (a, b) { return isHoriz ? b.x - a.x : b.y - a.y; };
            l.verts.sort(delta);
            for (var i = 1; i < l.verts.length; i++) {
                var u = l.verts[i - 1], v = l.verts[i];
                if (u.node && u.node === v.node && u.node.leaf)
                    continue;
                _this.edges.push({ source: u.id, target: v.id, length: Math.abs(delta(u, v)) });
            }
        });
    }
    GridRouter.prototype.avg = function (a) { return a.reduce(function (x, y) { return x + y; }) / a.length; };
    GridRouter.prototype.getGridLines = function (axis) {
        var columns = [];
        var ls = this.leaves.slice(0, this.leaves.length);
        while (ls.length > 0) {
            var overlapping = ls.filter(function (v) { return v.rect['overlap' + axis.toUpperCase()](ls[0].rect); });
            var col = {
                nodes: overlapping,
                pos: this.avg(overlapping.map(function (v) { return v.rect['c' + axis](); }))
            };
            columns.push(col);
            col.nodes.forEach(function (v) { return ls.splice(ls.indexOf(v), 1); });
        }
        columns.sort(function (a, b) { return a.pos - b.pos; });
        return columns;
    };
    GridRouter.prototype.getDepth = function (v) {
        var depth = 0;
        while (v.parent !== this.root) {
            depth++;
            v = v.parent;
        }
        return depth;
    };
    GridRouter.prototype.midPoints = function (a) {
        var gap = a[1] - a[0];
        var mids = [a[0] - gap / 2];
        for (var i = 1; i < a.length; i++) {
            mids.push((a[i] + a[i - 1]) / 2);
        }
        mids.push(a[a.length - 1] + gap / 2);
        return mids;
    };
    GridRouter.prototype.findLineage = function (v) {
        var lineage = [v];
        do {
            v = v.parent;
            lineage.push(v);
        } while (v !== this.root);
        return lineage.reverse();
    };
    GridRouter.prototype.findAncestorPathBetween = function (a, b) {
        var aa = this.findLineage(a), ba = this.findLineage(b), i = 0;
        while (aa[i] === ba[i])
            i++;
        return { commonAncestor: aa[i - 1], lineages: aa.slice(i).concat(ba.slice(i)) };
    };
    GridRouter.prototype.siblingObstacles = function (a, b) {
        var _this = this;
        var path = this.findAncestorPathBetween(a, b);
        var lineageLookup = {};
        path.lineages.forEach(function (v) { return lineageLookup[v.id] = {}; });
        var obstacles = path.commonAncestor.children.filter(function (v) { return !(v in lineageLookup); });
        path.lineages
            .filter(function (v) { return v.parent !== path.commonAncestor; })
            .forEach(function (v) { return obstacles = obstacles.concat(v.parent.children.filter(function (c) { return c !== v.id; })); });
        return obstacles.map(function (v) { return _this.nodes[v]; });
    };
    GridRouter.getSegmentSets = function (routes, x, y) {
        var vsegments = [];
        for (var ei = 0; ei < routes.length; ei++) {
            var route = routes[ei];
            for (var si = 0; si < route.length; si++) {
                var s = route[si];
                s.edgeid = ei;
                s.i = si;
                var sdx = s[1][x] - s[0][x];
                if (Math.abs(sdx) < 0.1) {
                    vsegments.push(s);
                }
            }
        }
        vsegments.sort(function (a, b) { return a[0][x] - b[0][x]; });
        var vsegmentsets = [];
        var segmentset = null;
        for (var i = 0; i < vsegments.length; i++) {
            var s = vsegments[i];
            if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {
                segmentset = { pos: s[0][x], segments: [] };
                vsegmentsets.push(segmentset);
            }
            segmentset.segments.push(s);
        }
        return vsegmentsets;
    };
    GridRouter.nudgeSegs = function (x, y, routes, segments, leftOf, gap) {
        var n = segments.length;
        if (n <= 1)
            return;
        var vs = segments.map(function (s) { return new vpsc_1.Variable(s[0][x]); });
        var cs = [];
        for (var i = 0; i < n; i++) {
            for (var j = 0; j < n; j++) {
                if (i === j)
                    continue;
                var s1 = segments[i], s2 = segments[j], e1 = s1.edgeid, e2 = s2.edgeid, lind = -1, rind = -1;
                if (x == 'x') {
                    if (leftOf(e1, e2)) {
                        if (s1[0][y] < s1[1][y]) {
                            lind = j, rind = i;
                        }
                        else {
                            lind = i, rind = j;
                        }
                    }
                }
                else {
                    if (leftOf(e1, e2)) {
                        if (s1[0][y] < s1[1][y]) {
                            lind = i, rind = j;
                        }
                        else {
                            lind = j, rind = i;
                        }
                    }
                }
                if (lind >= 0) {
                    cs.push(new vpsc_1.Constraint(vs[lind], vs[rind], gap));
                }
            }
        }
        var solver = new vpsc_1.Solver(vs, cs);
        solver.solve();
        vs.forEach(function (v, i) {
            var s = segments[i];
            var pos = v.position();
            s[0][x] = s[1][x] = pos;
            var route = routes[s.edgeid];
            if (s.i > 0)
                route[s.i - 1][1][x] = pos;
            if (s.i < route.length - 1)
                route[s.i + 1][0][x] = pos;
        });
    };
    GridRouter.nudgeSegments = function (routes, x, y, leftOf, gap) {
        var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);
        for (var i = 0; i < vsegmentsets.length; i++) {
            var ss = vsegmentsets[i];
            var events = [];
            for (var j = 0; j < ss.segments.length; j++) {
                var s = ss.segments[j];
                events.push({ type: 0, s: s, pos: Math.min(s[0][y], s[1][y]) });
                events.push({ type: 1, s: s, pos: Math.max(s[0][y], s[1][y]) });
            }
            events.sort(function (a, b) { return a.pos - b.pos + a.type - b.type; });
            var open = [];
            var openCount = 0;
            events.forEach(function (e) {
                if (e.type === 0) {
                    open.push(e.s);
                    openCount++;
                }
                else {
                    openCount--;
                }
                if (openCount == 0) {
                    GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);
                    open = [];
                }
            });
        }
    };
    GridRouter.prototype.routeEdges = function (edges, nudgeGap, source, target) {
        var _this = this;
        var routePaths = edges.map(function (e) { return _this.route(source(e), target(e)); });
        var order = GridRouter.orderEdges(routePaths);
        var routes = routePaths.map(function (e) { return GridRouter.makeSegments(e); });
        GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);
        GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);
        GridRouter.unreverseEdges(routes, routePaths);
        return routes;
    };
    GridRouter.unreverseEdges = function (routes, routePaths) {
        routes.forEach(function (segments, i) {
            var path = routePaths[i];
            if (path.reversed) {
                segments.reverse();
                segments.forEach(function (segment) {
                    segment.reverse();
                });
            }
        });
    };
    GridRouter.angleBetween2Lines = function (line1, line2) {
        var angle1 = Math.atan2(line1[0].y - line1[1].y, line1[0].x - line1[1].x);
        var angle2 = Math.atan2(line2[0].y - line2[1].y, line2[0].x - line2[1].x);
        var diff = angle1 - angle2;
        if (diff > Math.PI || diff < -Math.PI) {
            diff = angle2 - angle1;
        }
        return diff;
    };
    GridRouter.isLeft = function (a, b, c) {
        return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) <= 0;
    };
    GridRouter.getOrder = function (pairs) {
        var outgoing = {};
        for (var i = 0; i < pairs.length; i++) {
            var p = pairs[i];
            if (typeof outgoing[p.l] === 'undefined')
                outgoing[p.l] = {};
            outgoing[p.l][p.r] = true;
        }
        return function (l, r) { return typeof outgoing[l] !== 'undefined' && outgoing[l][r]; };
    };
    GridRouter.orderEdges = function (edges) {
        var edgeOrder = [];
        for (var i = 0; i < edges.length - 1; i++) {
            for (var j = i + 1; j < edges.length; j++) {
                var e = edges[i], f = edges[j], lcs = new LongestCommonSubsequence(e, f);
                var u, vi, vj;
                if (lcs.length === 0)
                    continue;
                if (lcs.reversed) {
                    f.reverse();
                    f.reversed = true;
                    lcs = new LongestCommonSubsequence(e, f);
                }
                if ((lcs.si <= 0 || lcs.ti <= 0) &&
                    (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {
                    edgeOrder.push({ l: i, r: j });
                    continue;
                }
                if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {
                    u = e[lcs.si + 1];
                    vj = e[lcs.si - 1];
                    vi = f[lcs.ti - 1];
                }
                else {
                    u = e[lcs.si + lcs.length - 2];
                    vi = e[lcs.si + lcs.length];
                    vj = f[lcs.ti + lcs.length];
                }
                if (GridRouter.isLeft(u, vi, vj)) {
                    edgeOrder.push({ l: j, r: i });
                }
                else {
                    edgeOrder.push({ l: i, r: j });
                }
            }
        }
        return GridRouter.getOrder(edgeOrder);
    };
    GridRouter.makeSegments = function (path) {
        function copyPoint(p) {
            return { x: p.x, y: p.y };
        }
        var isStraight = function (a, b, c) { return Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001; };
        var segments = [];
        var a = copyPoint(path[0]);
        for (var i = 1; i < path.length; i++) {
            var b = copyPoint(path[i]), c = i < path.length - 1 ? path[i + 1] : null;
            if (!c || !isStraight(a, b, c)) {
                segments.push([a, b]);
                a = b;
            }
        }
        return segments;
    };
    GridRouter.prototype.route = function (s, t) {
        var _this = this;
        var source = this.nodes[s], target = this.nodes[t];
        this.obstacles = this.siblingObstacles(source, target);
        var obstacleLookup = {};
        this.obstacles.forEach(function (o) { return obstacleLookup[o.id] = o; });
        this.passableEdges = this.edges.filter(function (e) {
            var u = _this.verts[e.source], v = _this.verts[e.target];
            return !(u.node && u.node.id in obstacleLookup
                || v.node && v.node.id in obstacleLookup);
        });
        for (var i = 1; i < source.ports.length; i++) {
            var u = source.ports[0].id;
            var v = source.ports[i].id;
            this.passableEdges.push({
                source: u,
                target: v,
                length: 0
            });
        }
        for (var i = 1; i < target.ports.length; i++) {
            var u = target.ports[0].id;
            var v = target.ports[i].id;
            this.passableEdges.push({
                source: u,
                target: v,
                length: 0
            });
        }
        var getSource = function (e) { return e.source; }, getTarget = function (e) { return e.target; }, getLength = function (e) { return e.length; };
        var shortestPathCalculator = new shortestpaths_1.Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);
        var bendPenalty = function (u, v, w) {
            var a = _this.verts[u], b = _this.verts[v], c = _this.verts[w];
            var dx = Math.abs(c.x - a.x), dy = Math.abs(c.y - a.y);
            if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)
                return 0;
            return dx > 1 && dy > 1 ? 1000 : 0;
        };
        var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(source.ports[0].id, target.ports[0].id, bendPenalty);
        var pathPoints = shortestPath.reverse().map(function (vi) { return _this.verts[vi]; });
        pathPoints.push(this.nodes[target.id].ports[0]);
        return pathPoints.filter(function (v, i) {
            return !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source
                || i > 0 && v.node === target && pathPoints[i - 1].node === target);
        });
    };
    GridRouter.getRoutePath = function (route, cornerradius, arrowwidth, arrowheight) {
        var result = {
            routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',
            arrowpath: ''
        };
        if (route.length > 1) {
            for (var i = 0; i < route.length; i++) {
                var li = route[i];
                var x = li[1].x, y = li[1].y;
                var dx = x - li[0].x;
                var dy = y - li[0].y;
                if (i < route.length - 1) {
                    if (Math.abs(dx) > 0) {
                        x -= dx / Math.abs(dx) * cornerradius;
                    }
                    else {
                        y -= dy / Math.abs(dy) * cornerradius;
                    }
                    result.routepath += 'L ' + x + ' ' + y + ' ';
                    var l = route[i + 1];
                    var x0 = l[0].x, y0 = l[0].y;
                    var x1 = l[1].x;
                    var y1 = l[1].y;
                    dx = x1 - x0;
                    dy = y1 - y0;
                    var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;
                    var x2, y2;
                    if (Math.abs(dx) > 0) {
                        x2 = x0 + dx / Math.abs(dx) * cornerradius;
                        y2 = y0;
                    }
                    else {
                        x2 = x0;
                        y2 = y0 + dy / Math.abs(dy) * cornerradius;
                    }
                    var cx = Math.abs(x2 - x);
                    var cy = Math.abs(y2 - y);
                    result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';
                }
                else {
                    var arrowtip = [x, y];
                    var arrowcorner1, arrowcorner2;
                    if (Math.abs(dx) > 0) {
                        x -= dx / Math.abs(dx) * arrowheight;
                        arrowcorner1 = [x, y + arrowwidth];
                        arrowcorner2 = [x, y - arrowwidth];
                    }
                    else {
                        y -= dy / Math.abs(dy) * arrowheight;
                        arrowcorner1 = [x + arrowwidth, y];
                        arrowcorner2 = [x - arrowwidth, y];
                    }
                    result.routepath += 'L ' + x + ' ' + y + ' ';
                    if (arrowheight > 0) {
                        result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]
                            + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];
                    }
                }
            }
        }
        else {
            var li = route[0];
            var x = li[1].x, y = li[1].y;
            var dx = x - li[0].x;
            var dy = y - li[0].y;
            var arrowtip = [x, y];
            var arrowcorner1, arrowcorner2;
            if (Math.abs(dx) > 0) {
                x -= dx / Math.abs(dx) * arrowheight;
                arrowcorner1 = [x, y + arrowwidth];
                arrowcorner2 = [x, y - arrowwidth];
            }
            else {
                y -= dy / Math.abs(dy) * arrowheight;
                arrowcorner1 = [x + arrowwidth, y];
                arrowcorner2 = [x - arrowwidth, y];
            }
            result.routepath += 'L ' + x + ' ' + y + ' ';
            if (arrowheight > 0) {
                result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]
                    + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];
            }
        }
        return result;
    };
    return GridRouter;
}());
exports.GridRouter = GridRouter;

},{"./rectangle":22,"./shortestpaths":23,"./vpsc":24}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var packingOptions = {
    PADDING: 10,
    GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,
    FLOAT_EPSILON: 0.0001,
    MAX_INERATIONS: 100
};
function applyPacking(graphs, w, h, node_size, desired_ratio) {
    if (desired_ratio === void 0) { desired_ratio = 1; }
    var init_x = 0, init_y = 0, svg_width = w, svg_height = h, desired_ratio = typeof desired_ratio !== 'undefined' ? desired_ratio : 1, node_size = typeof node_size !== 'undefined' ? node_size : 0, real_width = 0, real_height = 0, min_width = 0, global_bottom = 0, line = [];
    if (graphs.length == 0)
        return;
    calculate_bb(graphs);
    apply(graphs, desired_ratio);
    put_nodes_to_right_positions(graphs);
    function calculate_bb(graphs) {
        graphs.forEach(function (g) {
            calculate_single_bb(g);
        });
        function calculate_single_bb(graph) {
            var min_x = Number.MAX_VALUE, min_y = Number.MAX_VALUE, max_x = 0, max_y = 0;
            graph.array.forEach(function (v) {
                var w = typeof v.width !== 'undefined' ? v.width : node_size;
                var h = typeof v.height !== 'undefined' ? v.height : node_size;
                w /= 2;
                h /= 2;
                max_x = Math.max(v.x + w, max_x);
                min_x = Math.min(v.x - w, min_x);
                max_y = Math.max(v.y + h, max_y);
                min_y = Math.min(v.y - h, min_y);
            });
            graph.width = max_x - min_x;
            graph.height = max_y - min_y;
        }
    }
    function put_nodes_to_right_positions(graphs) {
        graphs.forEach(function (g) {
            var center = { x: 0, y: 0 };
            g.array.forEach(function (node) {
                center.x += node.x;
                center.y += node.y;
            });
            center.x /= g.array.length;
            center.y /= g.array.length;
            var corner = { x: center.x - g.width / 2, y: center.y - g.height / 2 };
            var offset = { x: g.x - corner.x + svg_width / 2 - real_width / 2, y: g.y - corner.y + svg_height / 2 - real_height / 2 };
            g.array.forEach(function (node) {
                node.x += offset.x;
                node.y += offset.y;
            });
        });
    }
    function apply(data, desired_ratio) {
        var curr_best_f = Number.POSITIVE_INFINITY;
        var curr_best = 0;
        data.sort(function (a, b) { return b.height - a.height; });
        min_width = data.reduce(function (a, b) {
            return a.width < b.width ? a.width : b.width;
        });
        var left = x1 = min_width;
        var right = x2 = get_entire_width(data);
        var iterationCounter = 0;
        var f_x1 = Number.MAX_VALUE;
        var f_x2 = Number.MAX_VALUE;
        var flag = -1;
        var dx = Number.MAX_VALUE;
        var df = Number.MAX_VALUE;
        while ((dx > min_width) || df > packingOptions.FLOAT_EPSILON) {
            if (flag != 1) {
                var x1 = right - (right - left) / packingOptions.GOLDEN_SECTION;
                var f_x1 = step(data, x1);
            }
            if (flag != 0) {
                var x2 = left + (right - left) / packingOptions.GOLDEN_SECTION;
                var f_x2 = step(data, x2);
            }
            dx = Math.abs(x1 - x2);
            df = Math.abs(f_x1 - f_x2);
            if (f_x1 < curr_best_f) {
                curr_best_f = f_x1;
                curr_best = x1;
            }
            if (f_x2 < curr_best_f) {
                curr_best_f = f_x2;
                curr_best = x2;
            }
            if (f_x1 > f_x2) {
                left = x1;
                x1 = x2;
                f_x1 = f_x2;
                flag = 1;
            }
            else {
                right = x2;
                x2 = x1;
                f_x2 = f_x1;
                flag = 0;
            }
            if (iterationCounter++ > 100) {
                break;
            }
        }
        step(data, curr_best);
    }
    function step(data, max_width) {
        line = [];
        real_width = 0;
        real_height = 0;
        global_bottom = init_y;
        for (var i = 0; i < data.length; i++) {
            var o = data[i];
            put_rect(o, max_width);
        }
        return Math.abs(get_real_ratio() - desired_ratio);
    }
    function put_rect(rect, max_width) {
        var parent = undefined;
        for (var i = 0; i < line.length; i++) {
            if ((line[i].space_left >= rect.height) && (line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width) <= packingOptions.FLOAT_EPSILON) {
                parent = line[i];
                break;
            }
        }
        line.push(rect);
        if (parent !== undefined) {
            rect.x = parent.x + parent.width + packingOptions.PADDING;
            rect.y = parent.bottom;
            rect.space_left = rect.height;
            rect.bottom = rect.y;
            parent.space_left -= rect.height + packingOptions.PADDING;
            parent.bottom += rect.height + packingOptions.PADDING;
        }
        else {
            rect.y = global_bottom;
            global_bottom += rect.height + packingOptions.PADDING;
            rect.x = init_x;
            rect.bottom = rect.y;
            rect.space_left = rect.height;
        }
        if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON)
            real_height = rect.y + rect.height - init_y;
        if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON)
            real_width = rect.x + rect.width - init_x;
    }
    ;
    function get_entire_width(data) {
        var width = 0;
        data.forEach(function (d) { return width += d.width + packingOptions.PADDING; });
        return width;
    }
    function get_real_ratio() {
        return (real_width / real_height);
    }
}
exports.applyPacking = applyPacking;
function separateGraphs(nodes, links) {
    var marks = {};
    var ways = {};
    var graphs = [];
    var clusters = 0;
    for (var i = 0; i < links.length; i++) {
        var link = links[i];
        var n1 = link.source;
        var n2 = link.target;
        if (ways[n1.index])
            ways[n1.index].push(n2);
        else
            ways[n1.index] = [n2];
        if (ways[n2.index])
            ways[n2.index].push(n1);
        else
            ways[n2.index] = [n1];
    }
    for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (marks[node.index])
            continue;
        explore_node(node, true);
    }
    function explore_node(n, is_new) {
        if (marks[n.index] !== undefined)
            return;
        if (is_new) {
            clusters++;
            graphs.push({ array: [] });
        }
        marks[n.index] = clusters;
        graphs[clusters - 1].array.push(n);
        var adjacent = ways[n.index];
        if (!adjacent)
            return;
        for (var j = 0; j < adjacent.length; j++) {
            explore_node(adjacent[j], false);
        }
    }
    return graphs;
}
exports.separateGraphs = separateGraphs;

},{}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var powergraph = require("./powergraph");
var linklengths_1 = require("./linklengths");
var descent_1 = require("./descent");
var rectangle_1 = require("./rectangle");
var shortestpaths_1 = require("./shortestpaths");
var geom_1 = require("./geom");
var handledisconnected_1 = require("./handledisconnected");
var EventType;
(function (EventType) {
    EventType[EventType["start"] = 0] = "start";
    EventType[EventType["tick"] = 1] = "tick";
    EventType[EventType["end"] = 2] = "end";
})(EventType = exports.EventType || (exports.EventType = {}));
;
function isGroup(g) {
    return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';
}
var Layout = (function () {
    function Layout() {
        var _this = this;
        this._canvasSize = [1, 1];
        this._linkDistance = 20;
        this._defaultNodeSize = 10;
        this._linkLengthCalculator = null;
        this._linkType = null;
        this._avoidOverlaps = false;
        this._handleDisconnected = true;
        this._running = false;
        this._nodes = [];
        this._groups = [];
        this._rootGroup = null;
        this._links = [];
        this._constraints = [];
        this._distanceMatrix = null;
        this._descent = null;
        this._directedLinkConstraints = null;
        this._threshold = 0.01;
        this._visibilityGraph = null;
        this._groupCompactness = 1e-6;
        this.event = null;
        this.linkAccessor = {
            getSourceIndex: Layout.getSourceIndex,
            getTargetIndex: Layout.getTargetIndex,
            setLength: Layout.setLinkLength,
            getType: function (l) { return typeof _this._linkType === "function" ? _this._linkType(l) : 0; }
        };
    }
    Layout.prototype.on = function (e, listener) {
        if (!this.event)
            this.event = {};
        if (typeof e === 'string') {
            this.event[EventType[e]] = listener;
        }
        else {
            this.event[e] = listener;
        }
        return this;
    };
    Layout.prototype.trigger = function (e) {
        if (this.event && typeof this.event[e.type] !== 'undefined') {
            this.event[e.type](e);
        }
    };
    Layout.prototype.kick = function () {
        while (!this.tick())
            ;
    };
    Layout.prototype.tick = function () {
        if (this._alpha < this._threshold) {
            this._running = false;
            this.trigger({ type: EventType.end, alpha: this._alpha = 0, stress: this._lastStress });
            return true;
        }
        var n = this._nodes.length, m = this._links.length;
        var o, i;
        this._descent.locks.clear();
        for (i = 0; i < n; ++i) {
            o = this._nodes[i];
            if (o.fixed) {
                if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {
                    o.px = o.x;
                    o.py = o.y;
                }
                var p = [o.px, o.py];
                this._descent.locks.add(i, p);
            }
        }
        var s1 = this._descent.rungeKutta();
        if (s1 === 0) {
            this._alpha = 0;
        }
        else if (typeof this._lastStress !== 'undefined') {
            this._alpha = s1;
        }
        this._lastStress = s1;
        this.updateNodePositions();
        this.trigger({ type: EventType.tick, alpha: this._alpha, stress: this._lastStress });
        return false;
    };
    Layout.prototype.updateNodePositions = function () {
        var x = this._descent.x[0], y = this._descent.x[1];
        var o, i = this._nodes.length;
        while (i--) {
            o = this._nodes[i];
            o.x = x[i];
            o.y = y[i];
        }
    };
    Layout.prototype.nodes = function (v) {
        if (!v) {
            if (this._nodes.length === 0 && this._links.length > 0) {
                var n = 0;
                this._links.forEach(function (l) {
                    n = Math.max(n, l.source, l.target);
                });
                this._nodes = new Array(++n);
                for (var i = 0; i < n; ++i) {
                    this._nodes[i] = {};
                }
            }
            return this._nodes;
        }
        this._nodes = v;
        return this;
    };
    Layout.prototype.groups = function (x) {
        var _this = this;
        if (!x)
            return this._groups;
        this._groups = x;
        this._rootGroup = {};
        this._groups.forEach(function (g) {
            if (typeof g.padding === "undefined")
                g.padding = 1;
            if (typeof g.leaves !== "undefined") {
                g.leaves.forEach(function (v, i) {
                    if (typeof v === 'number')
                        (g.leaves[i] = _this._nodes[v]).parent = g;
                });
            }
            if (typeof g.groups !== "undefined") {
                g.groups.forEach(function (gi, i) {
                    if (typeof gi === 'number')
                        (g.groups[i] = _this._groups[gi]).parent = g;
                });
            }
        });
        this._rootGroup.leaves = this._nodes.filter(function (v) { return typeof v.parent === 'undefined'; });
        this._rootGroup.groups = this._groups.filter(function (g) { return typeof g.parent === 'undefined'; });
        return this;
    };
    Layout.prototype.powerGraphGroups = function (f) {
        var g = powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);
        this.groups(g.groups);
        f(g);
        return this;
    };
    Layout.prototype.avoidOverlaps = function (v) {
        if (!arguments.length)
            return this._avoidOverlaps;
        this._avoidOverlaps = v;
        return this;
    };
    Layout.prototype.handleDisconnected = function (v) {
        if (!arguments.length)
            return this._handleDisconnected;
        this._handleDisconnected = v;
        return this;
    };
    Layout.prototype.flowLayout = function (axis, minSeparation) {
        if (!arguments.length)
            axis = 'y';
        this._directedLinkConstraints = {
            axis: axis,
            getMinSeparation: typeof minSeparation === 'number' ? function () { return minSeparation; } : minSeparation
        };
        return this;
    };
    Layout.prototype.links = function (x) {
        if (!arguments.length)
            return this._links;
        this._links = x;
        return this;
    };
    Layout.prototype.constraints = function (c) {
        if (!arguments.length)
            return this._constraints;
        this._constraints = c;
        return this;
    };
    Layout.prototype.distanceMatrix = function (d) {
        if (!arguments.length)
            return this._distanceMatrix;
        this._distanceMatrix = d;
        return this;
    };
    Layout.prototype.size = function (x) {
        if (!x)
            return this._canvasSize;
        this._canvasSize = x;
        return this;
    };
    Layout.prototype.defaultNodeSize = function (x) {
        if (!x)
            return this._defaultNodeSize;
        this._defaultNodeSize = x;
        return this;
    };
    Layout.prototype.groupCompactness = function (x) {
        if (!x)
            return this._groupCompactness;
        this._groupCompactness = x;
        return this;
    };
    Layout.prototype.linkDistance = function (x) {
        if (!x) {
            return this._linkDistance;
        }
        this._linkDistance = typeof x === "function" ? x : +x;
        this._linkLengthCalculator = null;
        return this;
    };
    Layout.prototype.linkType = function (f) {
        this._linkType = f;
        return this;
    };
    Layout.prototype.convergenceThreshold = function (x) {
        if (!x)
            return this._threshold;
        this._threshold = typeof x === "function" ? x : +x;
        return this;
    };
    Layout.prototype.alpha = function (x) {
        if (!arguments.length)
            return this._alpha;
        else {
            x = +x;
            if (this._alpha) {
                if (x > 0)
                    this._alpha = x;
                else
                    this._alpha = 0;
            }
            else if (x > 0) {
                if (!this._running) {
                    this._running = true;
                    this.trigger({ type: EventType.start, alpha: this._alpha = x });
                    this.kick();
                }
            }
            return this;
        }
    };
    Layout.prototype.getLinkLength = function (link) {
        return typeof this._linkDistance === "function" ? +(this._linkDistance(link)) : this._linkDistance;
    };
    Layout.setLinkLength = function (link, length) {
        link.length = length;
    };
    Layout.prototype.getLinkType = function (link) {
        return typeof this._linkType === "function" ? this._linkType(link) : 0;
    };
    Layout.prototype.symmetricDiffLinkLengths = function (idealLength, w) {
        var _this = this;
        if (w === void 0) { w = 1; }
        this.linkDistance(function (l) { return idealLength * l.length; });
        this._linkLengthCalculator = function () { return linklengths_1.symmetricDiffLinkLengths(_this._links, _this.linkAccessor, w); };
        return this;
    };
    Layout.prototype.jaccardLinkLengths = function (idealLength, w) {
        var _this = this;
        if (w === void 0) { w = 1; }
        this.linkDistance(function (l) { return idealLength * l.length; });
        this._linkLengthCalculator = function () { return linklengths_1.jaccardLinkLengths(_this._links, _this.linkAccessor, w); };
        return this;
    };
    Layout.prototype.start = function (initialUnconstrainedIterations, initialUserConstraintIterations, initialAllConstraintsIterations, gridSnapIterations, keepRunning) {
        var _this = this;
        if (initialUnconstrainedIterations === void 0) { initialUnconstrainedIterations = 0; }
        if (initialUserConstraintIterations === void 0) { initialUserConstraintIterations = 0; }
        if (initialAllConstraintsIterations === void 0) { initialAllConstraintsIterations = 0; }
        if (gridSnapIterations === void 0) { gridSnapIterations = 0; }
        if (keepRunning === void 0) { keepRunning = true; }
        var i, j, n = this.nodes().length, N = n + 2 * this._groups.length, m = this._links.length, w = this._canvasSize[0], h = this._canvasSize[1];
        var x = new Array(N), y = new Array(N);
        var G = null;
        var ao = this._avoidOverlaps;
        this._nodes.forEach(function (v, i) {
            v.index = i;
            if (typeof v.x === 'undefined') {
                v.x = w / 2, v.y = h / 2;
            }
            x[i] = v.x, y[i] = v.y;
        });
        if (this._linkLengthCalculator)
            this._linkLengthCalculator();
        var distances;
        if (this._distanceMatrix) {
            distances = this._distanceMatrix;
        }
        else {
            distances = (new shortestpaths_1.Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, function (l) { return _this.getLinkLength(l); })).DistanceMatrix();
            G = descent_1.Descent.createSquareMatrix(N, function () { return 2; });
            this._links.forEach(function (l) {
                if (typeof l.source == "number")
                    l.source = _this._nodes[l.source];
                if (typeof l.target == "number")
                    l.target = _this._nodes[l.target];
            });
            this._links.forEach(function (e) {
                var u = Layout.getSourceIndex(e), v = Layout.getTargetIndex(e);
                G[u][v] = G[v][u] = e.weight || 1;
            });
        }
        var D = descent_1.Descent.createSquareMatrix(N, function (i, j) {
            return distances[i][j];
        });
        if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {
            var i = n;
            var addAttraction = function (i, j, strength, idealDistance) {
                G[i][j] = G[j][i] = strength;
                D[i][j] = D[j][i] = idealDistance;
            };
            this._groups.forEach(function (g) {
                addAttraction(i, i + 1, _this._groupCompactness, 0.1);
                x[i] = 0, y[i++] = 0;
                x[i] = 0, y[i++] = 0;
            });
        }
        else
            this._rootGroup = { leaves: this._nodes, groups: [] };
        var curConstraints = this._constraints || [];
        if (this._directedLinkConstraints) {
            this.linkAccessor.getMinSeparation = this._directedLinkConstraints.getMinSeparation;
            curConstraints = curConstraints.concat(linklengths_1.generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, (this.linkAccessor)));
        }
        this.avoidOverlaps(false);
        this._descent = new descent_1.Descent([x, y], D);
        this._descent.locks.clear();
        for (var i = 0; i < n; ++i) {
            var o = this._nodes[i];
            if (o.fixed) {
                o.px = o.x;
                o.py = o.y;
                var p = [o.x, o.y];
                this._descent.locks.add(i, p);
            }
        }
        this._descent.threshold = this._threshold;
        this.initialLayout(initialUnconstrainedIterations, x, y);
        if (curConstraints.length > 0)
            this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();
        this._descent.run(initialUserConstraintIterations);
        this.separateOverlappingComponents(w, h);
        this.avoidOverlaps(ao);
        if (ao) {
            this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });
            this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();
            this._nodes.forEach(function (v, i) { x[i] = v.x, y[i] = v.y; });
        }
        this._descent.G = G;
        this._descent.run(initialAllConstraintsIterations);
        if (gridSnapIterations) {
            this._descent.snapStrength = 1000;
            this._descent.snapGridSize = this._nodes[0].width;
            this._descent.numGridSnapNodes = n;
            this._descent.scaleSnapByMaxH = n != N;
            var G0 = descent_1.Descent.createSquareMatrix(N, function (i, j) {
                if (i >= n || j >= n)
                    return G[i][j];
                return 0;
            });
            this._descent.G = G0;
            this._descent.run(gridSnapIterations);
        }
        this.updateNodePositions();
        this.separateOverlappingComponents(w, h);
        return keepRunning ? this.resume() : this;
    };
    Layout.prototype.initialLayout = function (iterations, x, y) {
        if (this._groups.length > 0 && iterations > 0) {
            var n = this._nodes.length;
            var edges = this._links.map(function (e) { return ({ source: e.source.index, target: e.target.index }); });
            var vs = this._nodes.map(function (v) { return ({ index: v.index }); });
            this._groups.forEach(function (g, i) {
                vs.push({ index: g.index = n + i });
            });
            this._groups.forEach(function (g, i) {
                if (typeof g.leaves !== 'undefined')
                    g.leaves.forEach(function (v) { return edges.push({ source: g.index, target: v.index }); });
                if (typeof g.groups !== 'undefined')
                    g.groups.forEach(function (gg) { return edges.push({ source: g.index, target: gg.index }); });
            });
            new Layout()
                .size(this.size())
                .nodes(vs)
                .links(edges)
                .avoidOverlaps(false)
                .linkDistance(this.linkDistance())
                .symmetricDiffLinkLengths(5)
                .convergenceThreshold(1e-4)
                .start(iterations, 0, 0, 0, false);
            this._nodes.forEach(function (v) {
                x[v.index] = vs[v.index].x;
                y[v.index] = vs[v.index].y;
            });
        }
        else {
            this._descent.run(iterations);
        }
    };
    Layout.prototype.separateOverlappingComponents = function (width, height) {
        var _this = this;
        if (!this._distanceMatrix && this._handleDisconnected) {
            var x_1 = this._descent.x[0], y_1 = this._descent.x[1];
            this._nodes.forEach(function (v, i) { v.x = x_1[i], v.y = y_1[i]; });
            var graphs = handledisconnected_1.separateGraphs(this._nodes, this._links);
            handledisconnected_1.applyPacking(graphs, width, height, this._defaultNodeSize);
            this._nodes.forEach(function (v, i) {
                _this._descent.x[0][i] = v.x, _this._descent.x[1][i] = v.y;
                if (v.bounds) {
                    v.bounds.setXCentre(v.x);
                    v.bounds.setYCentre(v.y);
                }
            });
        }
    };
    Layout.prototype.resume = function () {
        return this.alpha(0.1);
    };
    Layout.prototype.stop = function () {
        return this.alpha(0);
    };
    Layout.prototype.prepareEdgeRouting = function (nodeMargin) {
        if (nodeMargin === void 0) { nodeMargin = 0; }
        this._visibilityGraph = new geom_1.TangentVisibilityGraph(this._nodes.map(function (v) {
            return v.bounds.inflate(-nodeMargin).vertices();
        }));
    };
    Layout.prototype.routeEdge = function (edge, ah, draw) {
        if (ah === void 0) { ah = 5; }
        var lineData = [];
        var vg2 = new geom_1.TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }), port1 = { x: edge.source.x, y: edge.source.y }, port2 = { x: edge.target.x, y: edge.target.y }, start = vg2.addPoint(port1, edge.source.index), end = vg2.addPoint(port2, edge.target.index);
        vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);
        if (typeof draw !== 'undefined') {
            draw(vg2);
        }
        var sourceInd = function (e) { return e.source.id; }, targetInd = function (e) { return e.target.id; }, length = function (e) { return e.length(); }, spCalc = new shortestpaths_1.Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length), shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);
        if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {
            var route = rectangle_1.makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, ah);
            lineData = [route.sourceIntersection, route.arrowStart];
        }
        else {
            var n = shortestPath.length - 2, p = vg2.V[shortestPath[n]].p, q = vg2.V[shortestPath[0]].p, lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];
            for (var i = n; i >= 0; --i)
                lineData.push(vg2.V[shortestPath[i]].p);
            lineData.push(rectangle_1.makeEdgeTo(q, edge.target.innerBounds, ah));
        }
        return lineData;
    };
    Layout.getSourceIndex = function (e) {
        return typeof e.source === 'number' ? e.source : e.source.index;
    };
    Layout.getTargetIndex = function (e) {
        return typeof e.target === 'number' ? e.target : e.target.index;
    };
    Layout.linkId = function (e) {
        return Layout.getSourceIndex(e) + "-" + Layout.getTargetIndex(e);
    };
    Layout.dragStart = function (d) {
        if (isGroup(d)) {
            Layout.storeOffset(d, Layout.dragOrigin(d));
        }
        else {
            Layout.stopNode(d);
            d.fixed |= 2;
        }
    };
    Layout.stopNode = function (v) {
        v.px = v.x;
        v.py = v.y;
    };
    Layout.storeOffset = function (d, origin) {
        if (typeof d.leaves !== 'undefined') {
            d.leaves.forEach(function (v) {
                v.fixed |= 2;
                Layout.stopNode(v);
                v._dragGroupOffsetX = v.x - origin.x;
                v._dragGroupOffsetY = v.y - origin.y;
            });
        }
        if (typeof d.groups !== 'undefined') {
            d.groups.forEach(function (g) { return Layout.storeOffset(g, origin); });
        }
    };
    Layout.dragOrigin = function (d) {
        if (isGroup(d)) {
            return {
                x: d.bounds.cx(),
                y: d.bounds.cy()
            };
        }
        else {
            return d;
        }
    };
    Layout.drag = function (d, position) {
        if (isGroup(d)) {
            if (typeof d.leaves !== 'undefined') {
                d.leaves.forEach(function (v) {
                    d.bounds.setXCentre(position.x);
                    d.bounds.setYCentre(position.y);
                    v.px = v._dragGroupOffsetX + position.x;
                    v.py = v._dragGroupOffsetY + position.y;
                });
            }
            if (typeof d.groups !== 'undefined') {
                d.groups.forEach(function (g) { return Layout.drag(g, position); });
            }
        }
        else {
            d.px = position.x;
            d.py = position.y;
        }
    };
    Layout.dragEnd = function (d) {
        if (isGroup(d)) {
            if (typeof d.leaves !== 'undefined') {
                d.leaves.forEach(function (v) {
                    Layout.dragEnd(v);
                    delete v._dragGroupOffsetX;
                    delete v._dragGroupOffsetY;
                });
            }
            if (typeof d.groups !== 'undefined') {
                d.groups.forEach(Layout.dragEnd);
            }
        }
        else {
            d.fixed &= ~6;
        }
    };
    Layout.mouseOver = function (d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
    };
    Layout.mouseOut = function (d) {
        d.fixed &= ~4;
    };
    return Layout;
}());
exports.Layout = Layout;

},{"./descent":12,"./geom":13,"./handledisconnected":15,"./linklengths":18,"./powergraph":19,"./rectangle":22,"./shortestpaths":23}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shortestpaths_1 = require("./shortestpaths");
var descent_1 = require("./descent");
var rectangle_1 = require("./rectangle");
var linklengths_1 = require("./linklengths");
var Link3D = (function () {
    function Link3D(source, target) {
        this.source = source;
        this.target = target;
    }
    Link3D.prototype.actualLength = function (x) {
        var _this = this;
        return Math.sqrt(x.reduce(function (c, v) {
            var dx = v[_this.target] - v[_this.source];
            return c + dx * dx;
        }, 0));
    };
    return Link3D;
}());
exports.Link3D = Link3D;
var Node3D = (function () {
    function Node3D(x, y, z) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        this.x = x;
        this.y = y;
        this.z = z;
    }
    return Node3D;
}());
exports.Node3D = Node3D;
var Layout3D = (function () {
    function Layout3D(nodes, links, idealLinkLength) {
        if (idealLinkLength === void 0) { idealLinkLength = 1; }
        var _this = this;
        this.nodes = nodes;
        this.links = links;
        this.idealLinkLength = idealLinkLength;
        this.constraints = null;
        this.useJaccardLinkLengths = true;
        this.result = new Array(Layout3D.k);
        for (var i = 0; i < Layout3D.k; ++i) {
            this.result[i] = new Array(nodes.length);
        }
        nodes.forEach(function (v, i) {
            for (var _i = 0, _a = Layout3D.dims; _i < _a.length; _i++) {
                var dim = _a[_i];
                if (typeof v[dim] == 'undefined')
                    v[dim] = Math.random();
            }
            _this.result[0][i] = v.x;
            _this.result[1][i] = v.y;
            _this.result[2][i] = v.z;
        });
    }
    ;
    Layout3D.prototype.linkLength = function (l) {
        return l.actualLength(this.result);
    };
    Layout3D.prototype.start = function (iterations) {
        var _this = this;
        if (iterations === void 0) { iterations = 100; }
        var n = this.nodes.length;
        var linkAccessor = new LinkAccessor();
        if (this.useJaccardLinkLengths)
            linklengths_1.jaccardLinkLengths(this.links, linkAccessor, 1.5);
        this.links.forEach(function (e) { return e.length *= _this.idealLinkLength; });
        var distanceMatrix = (new shortestpaths_1.Calculator(n, this.links, function (e) { return e.source; }, function (e) { return e.target; }, function (e) { return e.length; })).DistanceMatrix();
        var D = descent_1.Descent.createSquareMatrix(n, function (i, j) { return distanceMatrix[i][j]; });
        var G = descent_1.Descent.createSquareMatrix(n, function () { return 2; });
        this.links.forEach(function (_a) {
            var source = _a.source, target = _a.target;
            return G[source][target] = G[target][source] = 1;
        });
        this.descent = new descent_1.Descent(this.result, D);
        this.descent.threshold = 1e-3;
        this.descent.G = G;
        if (this.constraints)
            this.descent.project = new rectangle_1.Projection(this.nodes, null, null, this.constraints).projectFunctions();
        for (var i = 0; i < this.nodes.length; i++) {
            var v = this.nodes[i];
            if (v.fixed) {
                this.descent.locks.add(i, [v.x, v.y, v.z]);
            }
        }
        this.descent.run(iterations);
        return this;
    };
    Layout3D.prototype.tick = function () {
        this.descent.locks.clear();
        for (var i = 0; i < this.nodes.length; i++) {
            var v = this.nodes[i];
            if (v.fixed) {
                this.descent.locks.add(i, [v.x, v.y, v.z]);
            }
        }
        return this.descent.rungeKutta();
    };
    Layout3D.dims = ['x', 'y', 'z'];
    Layout3D.k = Layout3D.dims.length;
    return Layout3D;
}());
exports.Layout3D = Layout3D;
var LinkAccessor = (function () {
    function LinkAccessor() {
    }
    LinkAccessor.prototype.getSourceIndex = function (e) { return e.source; };
    LinkAccessor.prototype.getTargetIndex = function (e) { return e.target; };
    LinkAccessor.prototype.getLength = function (e) { return e.length; };
    LinkAccessor.prototype.setLength = function (e, l) { e.length = l; };
    return LinkAccessor;
}());

},{"./descent":12,"./linklengths":18,"./rectangle":22,"./shortestpaths":23}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function unionCount(a, b) {
    var u = {};
    for (var i in a)
        u[i] = {};
    for (var i in b)
        u[i] = {};
    return Object.keys(u).length;
}
function intersectionCount(a, b) {
    var n = 0;
    for (var i in a)
        if (typeof b[i] !== 'undefined')
            ++n;
    return n;
}
function getNeighbours(links, la) {
    var neighbours = {};
    var addNeighbours = function (u, v) {
        if (typeof neighbours[u] === 'undefined')
            neighbours[u] = {};
        neighbours[u][v] = {};
    };
    links.forEach(function (e) {
        var u = la.getSourceIndex(e), v = la.getTargetIndex(e);
        addNeighbours(u, v);
        addNeighbours(v, u);
    });
    return neighbours;
}
function computeLinkLengths(links, w, f, la) {
    var neighbours = getNeighbours(links, la);
    links.forEach(function (l) {
        var a = neighbours[la.getSourceIndex(l)];
        var b = neighbours[la.getTargetIndex(l)];
        la.setLength(l, 1 + w * f(a, b));
    });
}
function symmetricDiffLinkLengths(links, la, w) {
    if (w === void 0) { w = 1; }
    computeLinkLengths(links, w, function (a, b) { return Math.sqrt(unionCount(a, b) - intersectionCount(a, b)); }, la);
}
exports.symmetricDiffLinkLengths = symmetricDiffLinkLengths;
function jaccardLinkLengths(links, la, w) {
    if (w === void 0) { w = 1; }
    computeLinkLengths(links, w, function (a, b) {
        return Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b);
    }, la);
}
exports.jaccardLinkLengths = jaccardLinkLengths;
function generateDirectedEdgeConstraints(n, links, axis, la) {
    var components = stronglyConnectedComponents(n, links, la);
    var nodes = {};
    components.forEach(function (c, i) {
        return c.forEach(function (v) { return nodes[v] = i; });
    });
    var constraints = [];
    links.forEach(function (l) {
        var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l), u = nodes[ui], v = nodes[vi];
        if (u !== v) {
            constraints.push({
                axis: axis,
                left: ui,
                right: vi,
                gap: la.getMinSeparation(l)
            });
        }
    });
    return constraints;
}
exports.generateDirectedEdgeConstraints = generateDirectedEdgeConstraints;
function stronglyConnectedComponents(numVertices, edges, la) {
    var nodes = [];
    var index = 0;
    var stack = [];
    var components = [];
    function strongConnect(v) {
        v.index = v.lowlink = index++;
        stack.push(v);
        v.onStack = true;
        for (var _i = 0, _a = v.out; _i < _a.length; _i++) {
            var w = _a[_i];
            if (typeof w.index === 'undefined') {
                strongConnect(w);
                v.lowlink = Math.min(v.lowlink, w.lowlink);
            }
            else if (w.onStack) {
                v.lowlink = Math.min(v.lowlink, w.index);
            }
        }
        if (v.lowlink === v.index) {
            var component = [];
            while (stack.length) {
                w = stack.pop();
                w.onStack = false;
                component.push(w);
                if (w === v)
                    break;
            }
            components.push(component.map(function (v) { return v.id; }));
        }
    }
    for (var i = 0; i < numVertices; i++) {
        nodes.push({ id: i, out: [] });
    }
    for (var _i = 0, edges_1 = edges; _i < edges_1.length; _i++) {
        var e = edges_1[_i];
        var v_1 = nodes[la.getSourceIndex(e)], w = nodes[la.getTargetIndex(e)];
        v_1.out.push(w);
    }
    for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {
        var v = nodes_1[_a];
        if (typeof v.index === 'undefined')
            strongConnect(v);
    }
    return components;
}
exports.stronglyConnectedComponents = stronglyConnectedComponents;

},{}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var PowerEdge = (function () {
    function PowerEdge(source, target, type) {
        this.source = source;
        this.target = target;
        this.type = type;
    }
    return PowerEdge;
}());
exports.PowerEdge = PowerEdge;
var Configuration = (function () {
    function Configuration(n, edges, linkAccessor, rootGroup) {
        var _this = this;
        this.linkAccessor = linkAccessor;
        this.modules = new Array(n);
        this.roots = [];
        if (rootGroup) {
            this.initModulesFromGroup(rootGroup);
        }
        else {
            this.roots.push(new ModuleSet());
            for (var i = 0; i < n; ++i)
                this.roots[0].add(this.modules[i] = new Module(i));
        }
        this.R = edges.length;
        edges.forEach(function (e) {
            var s = _this.modules[linkAccessor.getSourceIndex(e)], t = _this.modules[linkAccessor.getTargetIndex(e)], type = linkAccessor.getType(e);
            s.outgoing.add(type, t);
            t.incoming.add(type, s);
        });
    }
    Configuration.prototype.initModulesFromGroup = function (group) {
        var moduleSet = new ModuleSet();
        this.roots.push(moduleSet);
        for (var i = 0; i < group.leaves.length; ++i) {
            var node = group.leaves[i];
            var module = new Module(node.id);
            this.modules[node.id] = module;
            moduleSet.add(module);
        }
        if (group.groups) {
            for (var j = 0; j < group.groups.length; ++j) {
                var child = group.groups[j];
                var definition = {};
                for (var prop in child)
                    if (prop !== "leaves" && prop !== "groups" && child.hasOwnProperty(prop))
                        definition[prop] = child[prop];
                moduleSet.add(new Module(-1 - j, new LinkSets(), new LinkSets(), this.initModulesFromGroup(child), definition));
            }
        }
        return moduleSet;
    };
    Configuration.prototype.merge = function (a, b, k) {
        if (k === void 0) { k = 0; }
        var inInt = a.incoming.intersection(b.incoming), outInt = a.outgoing.intersection(b.outgoing);
        var children = new ModuleSet();
        children.add(a);
        children.add(b);
        var m = new Module(this.modules.length, outInt, inInt, children);
        this.modules.push(m);
        var update = function (s, i, o) {
            s.forAll(function (ms, linktype) {
                ms.forAll(function (n) {
                    var nls = n[i];
                    nls.add(linktype, m);
                    nls.remove(linktype, a);
                    nls.remove(linktype, b);
                    a[o].remove(linktype, n);
                    b[o].remove(linktype, n);
                });
            });
        };
        update(outInt, "incoming", "outgoing");
        update(inInt, "outgoing", "incoming");
        this.R -= inInt.count() + outInt.count();
        this.roots[k].remove(a);
        this.roots[k].remove(b);
        this.roots[k].add(m);
        return m;
    };
    Configuration.prototype.rootMerges = function (k) {
        if (k === void 0) { k = 0; }
        var rs = this.roots[k].modules();
        var n = rs.length;
        var merges = new Array(n * (n - 1));
        var ctr = 0;
        for (var i = 0, i_ = n - 1; i < i_; ++i) {
            for (var j = i + 1; j < n; ++j) {
                var a = rs[i], b = rs[j];
                merges[ctr] = { id: ctr, nEdges: this.nEdges(a, b), a: a, b: b };
                ctr++;
            }
        }
        return merges;
    };
    Configuration.prototype.greedyMerge = function () {
        for (var i = 0; i < this.roots.length; ++i) {
            if (this.roots[i].modules().length < 2)
                continue;
            var ms = this.rootMerges(i).sort(function (a, b) { return a.nEdges == b.nEdges ? a.id - b.id : a.nEdges - b.nEdges; });
            var m = ms[0];
            if (m.nEdges >= this.R)
                continue;
            this.merge(m.a, m.b, i);
            return true;
        }
    };
    Configuration.prototype.nEdges = function (a, b) {
        var inInt = a.incoming.intersection(b.incoming), outInt = a.outgoing.intersection(b.outgoing);
        return this.R - inInt.count() - outInt.count();
    };
    Configuration.prototype.getGroupHierarchy = function (retargetedEdges) {
        var _this = this;
        var groups = [];
        var root = {};
        toGroups(this.roots[0], root, groups);
        var es = this.allEdges();
        es.forEach(function (e) {
            var a = _this.modules[e.source];
            var b = _this.modules[e.target];
            retargetedEdges.push(new PowerEdge(typeof a.gid === "undefined" ? e.source : groups[a.gid], typeof b.gid === "undefined" ? e.target : groups[b.gid], e.type));
        });
        return groups;
    };
    Configuration.prototype.allEdges = function () {
        var es = [];
        Configuration.getEdges(this.roots[0], es);
        return es;
    };
    Configuration.getEdges = function (modules, es) {
        modules.forAll(function (m) {
            m.getEdges(es);
            Configuration.getEdges(m.children, es);
        });
    };
    return Configuration;
}());
exports.Configuration = Configuration;
function toGroups(modules, group, groups) {
    modules.forAll(function (m) {
        if (m.isLeaf()) {
            if (!group.leaves)
                group.leaves = [];
            group.leaves.push(m.id);
        }
        else {
            var g = group;
            m.gid = groups.length;
            if (!m.isIsland() || m.isPredefined()) {
                g = { id: m.gid };
                if (m.isPredefined())
                    for (var prop in m.definition)
                        g[prop] = m.definition[prop];
                if (!group.groups)
                    group.groups = [];
                group.groups.push(m.gid);
                groups.push(g);
            }
            toGroups(m.children, g, groups);
        }
    });
}
var Module = (function () {
    function Module(id, outgoing, incoming, children, definition) {
        if (outgoing === void 0) { outgoing = new LinkSets(); }
        if (incoming === void 0) { incoming = new LinkSets(); }
        if (children === void 0) { children = new ModuleSet(); }
        this.id = id;
        this.outgoing = outgoing;
        this.incoming = incoming;
        this.children = children;
        this.definition = definition;
    }
    Module.prototype.getEdges = function (es) {
        var _this = this;
        this.outgoing.forAll(function (ms, edgetype) {
            ms.forAll(function (target) {
                es.push(new PowerEdge(_this.id, target.id, edgetype));
            });
        });
    };
    Module.prototype.isLeaf = function () {
        return this.children.count() === 0;
    };
    Module.prototype.isIsland = function () {
        return this.outgoing.count() === 0 && this.incoming.count() === 0;
    };
    Module.prototype.isPredefined = function () {
        return typeof this.definition !== "undefined";
    };
    return Module;
}());
exports.Module = Module;
function intersection(m, n) {
    var i = {};
    for (var v in m)
        if (v in n)
            i[v] = m[v];
    return i;
}
var ModuleSet = (function () {
    function ModuleSet() {
        this.table = {};
    }
    ModuleSet.prototype.count = function () {
        return Object.keys(this.table).length;
    };
    ModuleSet.prototype.intersection = function (other) {
        var result = new ModuleSet();
        result.table = intersection(this.table, other.table);
        return result;
    };
    ModuleSet.prototype.intersectionCount = function (other) {
        return this.intersection(other).count();
    };
    ModuleSet.prototype.contains = function (id) {
        return id in this.table;
    };
    ModuleSet.prototype.add = function (m) {
        this.table[m.id] = m;
    };
    ModuleSet.prototype.remove = function (m) {
        delete this.table[m.id];
    };
    ModuleSet.prototype.forAll = function (f) {
        for (var mid in this.table) {
            f(this.table[mid]);
        }
    };
    ModuleSet.prototype.modules = function () {
        var vs = [];
        this.forAll(function (m) {
            if (!m.isPredefined())
                vs.push(m);
        });
        return vs;
    };
    return ModuleSet;
}());
exports.ModuleSet = ModuleSet;
var LinkSets = (function () {
    function LinkSets() {
        this.sets = {};
        this.n = 0;
    }
    LinkSets.prototype.count = function () {
        return this.n;
    };
    LinkSets.prototype.contains = function (id) {
        var result = false;
        this.forAllModules(function (m) {
            if (!result && m.id == id) {
                result = true;
            }
        });
        return result;
    };
    LinkSets.prototype.add = function (linktype, m) {
        var s = linktype in this.sets ? this.sets[linktype] : this.sets[linktype] = new ModuleSet();
        s.add(m);
        ++this.n;
    };
    LinkSets.prototype.remove = function (linktype, m) {
        var ms = this.sets[linktype];
        ms.remove(m);
        if (ms.count() === 0) {
            delete this.sets[linktype];
        }
        --this.n;
    };
    LinkSets.prototype.forAll = function (f) {
        for (var linktype in this.sets) {
            f(this.sets[linktype], Number(linktype));
        }
    };
    LinkSets.prototype.forAllModules = function (f) {
        this.forAll(function (ms, lt) { return ms.forAll(f); });
    };
    LinkSets.prototype.intersection = function (other) {
        var result = new LinkSets();
        this.forAll(function (ms, lt) {
            if (lt in other.sets) {
                var i = ms.intersection(other.sets[lt]), n = i.count();
                if (n > 0) {
                    result.sets[lt] = i;
                    result.n += n;
                }
            }
        });
        return result;
    };
    return LinkSets;
}());
exports.LinkSets = LinkSets;
function intersectionCount(m, n) {
    return Object.keys(intersection(m, n)).length;
}
function getGroups(nodes, links, la, rootGroup) {
    var n = nodes.length, c = new Configuration(n, links, la, rootGroup);
    while (c.greedyMerge())
        ;
    var powerEdges = [];
    var g = c.getGroupHierarchy(powerEdges);
    powerEdges.forEach(function (e) {
        var f = function (end) {
            var g = e[end];
            if (typeof g == "number")
                e[end] = nodes[g];
        };
        f("source");
        f("target");
    });
    return { groups: g, powerEdges: powerEdges };
}
exports.getGroups = getGroups;

},{}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var PairingHeap = (function () {
    function PairingHeap(elem) {
        this.elem = elem;
        this.subheaps = [];
    }
    PairingHeap.prototype.toString = function (selector) {
        var str = "", needComma = false;
        for (var i = 0; i < this.subheaps.length; ++i) {
            var subheap = this.subheaps[i];
            if (!subheap.elem) {
                needComma = false;
                continue;
            }
            if (needComma) {
                str = str + ",";
            }
            str = str + subheap.toString(selector);
            needComma = true;
        }
        if (str !== "") {
            str = "(" + str + ")";
        }
        return (this.elem ? selector(this.elem) : "") + str;
    };
    PairingHeap.prototype.forEach = function (f) {
        if (!this.empty()) {
            f(this.elem, this);
            this.subheaps.forEach(function (s) { return s.forEach(f); });
        }
    };
    PairingHeap.prototype.count = function () {
        return this.empty() ? 0 : 1 + this.subheaps.reduce(function (n, h) {
            return n + h.count();
        }, 0);
    };
    PairingHeap.prototype.min = function () {
        return this.elem;
    };
    PairingHeap.prototype.empty = function () {
        return this.elem == null;
    };
    PairingHeap.prototype.contains = function (h) {
        if (this === h)
            return true;
        for (var i = 0; i < this.subheaps.length; i++) {
            if (this.subheaps[i].contains(h))
                return true;
        }
        return false;
    };
    PairingHeap.prototype.isHeap = function (lessThan) {
        var _this = this;
        return this.subheaps.every(function (h) { return lessThan(_this.elem, h.elem) && h.isHeap(lessThan); });
    };
    PairingHeap.prototype.insert = function (obj, lessThan) {
        return this.merge(new PairingHeap(obj), lessThan);
    };
    PairingHeap.prototype.merge = function (heap2, lessThan) {
        if (this.empty())
            return heap2;
        else if (heap2.empty())
            return this;
        else if (lessThan(this.elem, heap2.elem)) {
            this.subheaps.push(heap2);
            return this;
        }
        else {
            heap2.subheaps.push(this);
            return heap2;
        }
    };
    PairingHeap.prototype.removeMin = function (lessThan) {
        if (this.empty())
            return null;
        else
            return this.mergePairs(lessThan);
    };
    PairingHeap.prototype.mergePairs = function (lessThan) {
        if (this.subheaps.length == 0)
            return new PairingHeap(null);
        else if (this.subheaps.length == 1) {
            return this.subheaps[0];
        }
        else {
            var firstPair = this.subheaps.pop().merge(this.subheaps.pop(), lessThan);
            var remaining = this.mergePairs(lessThan);
            return firstPair.merge(remaining, lessThan);
        }
    };
    PairingHeap.prototype.decreaseKey = function (subheap, newValue, setHeapNode, lessThan) {
        var newHeap = subheap.removeMin(lessThan);
        subheap.elem = newHeap.elem;
        subheap.subheaps = newHeap.subheaps;
        if (setHeapNode !== null && newHeap.elem !== null) {
            setHeapNode(subheap.elem, subheap);
        }
        var pairingNode = new PairingHeap(newValue);
        if (setHeapNode !== null) {
            setHeapNode(newValue, pairingNode);
        }
        return this.merge(pairingNode, lessThan);
    };
    return PairingHeap;
}());
exports.PairingHeap = PairingHeap;
var PriorityQueue = (function () {
    function PriorityQueue(lessThan) {
        this.lessThan = lessThan;
    }
    PriorityQueue.prototype.top = function () {
        if (this.empty()) {
            return null;
        }
        return this.root.elem;
    };
    PriorityQueue.prototype.push = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var pairingNode;
        for (var i = 0, arg; arg = args[i]; ++i) {
            pairingNode = new PairingHeap(arg);
            this.root = this.empty() ?
                pairingNode : this.root.merge(pairingNode, this.lessThan);
        }
        return pairingNode;
    };
    PriorityQueue.prototype.empty = function () {
        return !this.root || !this.root.elem;
    };
    PriorityQueue.prototype.isHeap = function () {
        return this.root.isHeap(this.lessThan);
    };
    PriorityQueue.prototype.forEach = function (f) {
        this.root.forEach(f);
    };
    PriorityQueue.prototype.pop = function () {
        if (this.empty()) {
            return null;
        }
        var obj = this.root.min();
        this.root = this.root.removeMin(this.lessThan);
        return obj;
    };
    PriorityQueue.prototype.reduceKey = function (heapNode, newKey, setHeapNode) {
        if (setHeapNode === void 0) { setHeapNode = null; }
        this.root = this.root.decreaseKey(heapNode, newKey, setHeapNode, this.lessThan);
    };
    PriorityQueue.prototype.toString = function (selector) {
        return this.root.toString(selector);
    };
    PriorityQueue.prototype.count = function () {
        return this.root.count();
    };
    return PriorityQueue;
}());
exports.PriorityQueue = PriorityQueue;

},{}],21:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var TreeBase = (function () {
    function TreeBase() {
        this.findIter = function (data) {
            var res = this._root;
            var iter = this.iterator();
            while (res !== null) {
                var c = this._comparator(data, res.data);
                if (c === 0) {
                    iter._cursor = res;
                    return iter;
                }
                else {
                    iter._ancestors.push(res);
                    res = res.get_child(c > 0);
                }
            }
            return null;
        };
    }
    TreeBase.prototype.clear = function () {
        this._root = null;
        this.size = 0;
    };
    ;
    TreeBase.prototype.find = function (data) {
        var res = this._root;
        while (res !== null) {
            var c = this._comparator(data, res.data);
            if (c === 0) {
                return res.data;
            }
            else {
                res = res.get_child(c > 0);
            }
        }
        return null;
    };
    ;
    TreeBase.prototype.lowerBound = function (data) {
        return this._bound(data, this._comparator);
    };
    ;
    TreeBase.prototype.upperBound = function (data) {
        var cmp = this._comparator;
        function reverse_cmp(a, b) {
            return cmp(b, a);
        }
        return this._bound(data, reverse_cmp);
    };
    ;
    TreeBase.prototype.min = function () {
        var res = this._root;
        if (res === null) {
            return null;
        }
        while (res.left !== null) {
            res = res.left;
        }
        return res.data;
    };
    ;
    TreeBase.prototype.max = function () {
        var res = this._root;
        if (res === null) {
            return null;
        }
        while (res.right !== null) {
            res = res.right;
        }
        return res.data;
    };
    ;
    TreeBase.prototype.iterator = function () {
        return new Iterator(this);
    };
    ;
    TreeBase.prototype.each = function (cb) {
        var it = this.iterator(), data;
        while ((data = it.next()) !== null) {
            cb(data);
        }
    };
    ;
    TreeBase.prototype.reach = function (cb) {
        var it = this.iterator(), data;
        while ((data = it.prev()) !== null) {
            cb(data);
        }
    };
    ;
    TreeBase.prototype._bound = function (data, cmp) {
        var cur = this._root;
        var iter = this.iterator();
        while (cur !== null) {
            var c = this._comparator(data, cur.data);
            if (c === 0) {
                iter._cursor = cur;
                return iter;
            }
            iter._ancestors.push(cur);
            cur = cur.get_child(c > 0);
        }
        for (var i = iter._ancestors.length - 1; i >= 0; --i) {
            cur = iter._ancestors[i];
            if (cmp(data, cur.data) > 0) {
                iter._cursor = cur;
                iter._ancestors.length = i;
                return iter;
            }
        }
        iter._ancestors.length = 0;
        return iter;
    };
    ;
    return TreeBase;
}());
exports.TreeBase = TreeBase;
var Iterator = (function () {
    function Iterator(tree) {
        this._tree = tree;
        this._ancestors = [];
        this._cursor = null;
    }
    Iterator.prototype.data = function () {
        return this._cursor !== null ? this._cursor.data : null;
    };
    ;
    Iterator.prototype.next = function () {
        if (this._cursor === null) {
            var root = this._tree._root;
            if (root !== null) {
                this._minNode(root);
            }
        }
        else {
            if (this._cursor.right === null) {
                var save;
                do {
                    save = this._cursor;
                    if (this._ancestors.length) {
                        this._cursor = this._ancestors.pop();
                    }
                    else {
                        this._cursor = null;
                        break;
                    }
                } while (this._cursor.right === save);
            }
            else {
                this._ancestors.push(this._cursor);
                this._minNode(this._cursor.right);
            }
        }
        return this._cursor !== null ? this._cursor.data : null;
    };
    ;
    Iterator.prototype.prev = function () {
        if (this._cursor === null) {
            var root = this._tree._root;
            if (root !== null) {
                this._maxNode(root);
            }
        }
        else {
            if (this._cursor.left === null) {
                var save;
                do {
                    save = this._cursor;
                    if (this._ancestors.length) {
                        this._cursor = this._ancestors.pop();
                    }
                    else {
                        this._cursor = null;
                        break;
                    }
                } while (this._cursor.left === save);
            }
            else {
                this._ancestors.push(this._cursor);
                this._maxNode(this._cursor.left);
            }
        }
        return this._cursor !== null ? this._cursor.data : null;
    };
    ;
    Iterator.prototype._minNode = function (start) {
        while (start.left !== null) {
            this._ancestors.push(start);
            start = start.left;
        }
        this._cursor = start;
    };
    ;
    Iterator.prototype._maxNode = function (start) {
        while (start.right !== null) {
            this._ancestors.push(start);
            start = start.right;
        }
        this._cursor = start;
    };
    ;
    return Iterator;
}());
exports.Iterator = Iterator;
var Node = (function () {
    function Node(data) {
        this.data = data;
        this.left = null;
        this.right = null;
        this.red = true;
    }
    Node.prototype.get_child = function (dir) {
        return dir ? this.right : this.left;
    };
    ;
    Node.prototype.set_child = function (dir, val) {
        if (dir) {
            this.right = val;
        }
        else {
            this.left = val;
        }
    };
    ;
    return Node;
}());
var RBTree = (function (_super) {
    __extends(RBTree, _super);
    function RBTree(comparator) {
        var _this = _super.call(this) || this;
        _this._root = null;
        _this._comparator = comparator;
        _this.size = 0;
        return _this;
    }
    RBTree.prototype.insert = function (data) {
        var ret = false;
        if (this._root === null) {
            this._root = new Node(data);
            ret = true;
            this.size++;
        }
        else {
            var head = new Node(undefined);
            var dir = false;
            var last = false;
            var gp = null;
            var ggp = head;
            var p = null;
            var node = this._root;
            ggp.right = this._root;
            while (true) {
                if (node === null) {
                    node = new Node(data);
                    p.set_child(dir, node);
                    ret = true;
                    this.size++;
                }
                else if (RBTree.is_red(node.left) && RBTree.is_red(node.right)) {
                    node.red = true;
                    node.left.red = false;
                    node.right.red = false;
                }
                if (RBTree.is_red(node) && RBTree.is_red(p)) {
                    var dir2 = ggp.right === gp;
                    if (node === p.get_child(last)) {
                        ggp.set_child(dir2, RBTree.single_rotate(gp, !last));
                    }
                    else {
                        ggp.set_child(dir2, RBTree.double_rotate(gp, !last));
                    }
                }
                var cmp = this._comparator(node.data, data);
                if (cmp === 0) {
                    break;
                }
                last = dir;
                dir = cmp < 0;
                if (gp !== null) {
                    ggp = gp;
                }
                gp = p;
                p = node;
                node = node.get_child(dir);
            }
            this._root = head.right;
        }
        this._root.red = false;
        return ret;
    };
    ;
    RBTree.prototype.remove = function (data) {
        if (this._root === null) {
            return false;
        }
        var head = new Node(undefined);
        var node = head;
        node.right = this._root;
        var p = null;
        var gp = null;
        var found = null;
        var dir = true;
        while (node.get_child(dir) !== null) {
            var last = dir;
            gp = p;
            p = node;
            node = node.get_child(dir);
            var cmp = this._comparator(data, node.data);
            dir = cmp > 0;
            if (cmp === 0) {
                found = node;
            }
            if (!RBTree.is_red(node) && !RBTree.is_red(node.get_child(dir))) {
                if (RBTree.is_red(node.get_child(!dir))) {
                    var sr = RBTree.single_rotate(node, dir);
                    p.set_child(last, sr);
                    p = sr;
                }
                else if (!RBTree.is_red(node.get_child(!dir))) {
                    var sibling = p.get_child(!last);
                    if (sibling !== null) {
                        if (!RBTree.is_red(sibling.get_child(!last)) && !RBTree.is_red(sibling.get_child(last))) {
                            p.red = false;
                            sibling.red = true;
                            node.red = true;
                        }
                        else {
                            var dir2 = gp.right === p;
                            if (RBTree.is_red(sibling.get_child(last))) {
                                gp.set_child(dir2, RBTree.double_rotate(p, last));
                            }
                            else if (RBTree.is_red(sibling.get_child(!last))) {
                                gp.set_child(dir2, RBTree.single_rotate(p, last));
                            }
                            var gpc = gp.get_child(dir2);
                            gpc.red = true;
                            node.red = true;
                            gpc.left.red = false;
                            gpc.right.red = false;
                        }
                    }
                }
            }
        }
        if (found !== null) {
            found.data = node.data;
            p.set_child(p.right === node, node.get_child(node.left === null));
            this.size--;
        }
        this._root = head.right;
        if (this._root !== null) {
            this._root.red = false;
        }
        return found !== null;
    };
    ;
    RBTree.is_red = function (node) {
        return node !== null && node.red;
    };
    RBTree.single_rotate = function (root, dir) {
        var save = root.get_child(!dir);
        root.set_child(!dir, save.get_child(dir));
        save.set_child(dir, root);
        root.red = true;
        save.red = false;
        return save;
    };
    RBTree.double_rotate = function (root, dir) {
        root.set_child(!dir, RBTree.single_rotate(root.get_child(!dir), !dir));
        return RBTree.single_rotate(root, dir);
    };
    return RBTree;
}(TreeBase));
exports.RBTree = RBTree;

},{}],22:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var vpsc_1 = require("./vpsc");
var rbtree_1 = require("./rbtree");
function computeGroupBounds(g) {
    g.bounds = typeof g.leaves !== "undefined" ?
        g.leaves.reduce(function (r, c) { return c.bounds.union(r); }, Rectangle.empty()) :
        Rectangle.empty();
    if (typeof g.groups !== "undefined")
        g.bounds = g.groups.reduce(function (r, c) { return computeGroupBounds(c).union(r); }, g.bounds);
    g.bounds = g.bounds.inflate(g.padding);
    return g.bounds;
}
exports.computeGroupBounds = computeGroupBounds;
var Rectangle = (function () {
    function Rectangle(x, X, y, Y) {
        this.x = x;
        this.X = X;
        this.y = y;
        this.Y = Y;
    }
    Rectangle.empty = function () { return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY); };
    Rectangle.prototype.cx = function () { return (this.x + this.X) / 2; };
    Rectangle.prototype.cy = function () { return (this.y + this.Y) / 2; };
    Rectangle.prototype.overlapX = function (r) {
        var ux = this.cx(), vx = r.cx();
        if (ux <= vx && r.x < this.X)
            return this.X - r.x;
        if (vx <= ux && this.x < r.X)
            return r.X - this.x;
        return 0;
    };
    Rectangle.prototype.overlapY = function (r) {
        var uy = this.cy(), vy = r.cy();
        if (uy <= vy && r.y < this.Y)
            return this.Y - r.y;
        if (vy <= uy && this.y < r.Y)
            return r.Y - this.y;
        return 0;
    };
    Rectangle.prototype.setXCentre = function (cx) {
        var dx = cx - this.cx();
        this.x += dx;
        this.X += dx;
    };
    Rectangle.prototype.setYCentre = function (cy) {
        var dy = cy - this.cy();
        this.y += dy;
        this.Y += dy;
    };
    Rectangle.prototype.width = function () {
        return this.X - this.x;
    };
    Rectangle.prototype.height = function () {
        return this.Y - this.y;
    };
    Rectangle.prototype.union = function (r) {
        return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));
    };
    Rectangle.prototype.lineIntersections = function (x1, y1, x2, y2) {
        var sides = [[this.x, this.y, this.X, this.y],
            [this.X, this.y, this.X, this.Y],
            [this.X, this.Y, this.x, this.Y],
            [this.x, this.Y, this.x, this.y]];
        var intersections = [];
        for (var i = 0; i < 4; ++i) {
            var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);
            if (r !== null)
                intersections.push({ x: r.x, y: r.y });
        }
        return intersections;
    };
    Rectangle.prototype.rayIntersection = function (x2, y2) {
        var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);
        return ints.length > 0 ? ints[0] : null;
    };
    Rectangle.prototype.vertices = function () {
        return [
            { x: this.x, y: this.y },
            { x: this.X, y: this.y },
            { x: this.X, y: this.Y },
            { x: this.x, y: this.Y }
        ];
    };
    Rectangle.lineIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {
        var dx12 = x2 - x1, dx34 = x4 - x3, dy12 = y2 - y1, dy34 = y4 - y3, denominator = dy34 * dx12 - dx34 * dy12;
        if (denominator == 0)
            return null;
        var dx31 = x1 - x3, dy31 = y1 - y3, numa = dx34 * dy31 - dy34 * dx31, a = numa / denominator, numb = dx12 * dy31 - dy12 * dx31, b = numb / denominator;
        if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {
            return {
                x: x1 + a * dx12,
                y: y1 + a * dy12
            };
        }
        return null;
    };
    Rectangle.prototype.inflate = function (pad) {
        return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);
    };
    return Rectangle;
}());
exports.Rectangle = Rectangle;
function makeEdgeBetween(source, target, ah) {
    var si = source.rayIntersection(target.cx(), target.cy()) || { x: source.cx(), y: source.cy() }, ti = target.rayIntersection(source.cx(), source.cy()) || { x: target.cx(), y: target.cy() }, dx = ti.x - si.x, dy = ti.y - si.y, l = Math.sqrt(dx * dx + dy * dy), al = l - ah;
    return {
        sourceIntersection: si,
        targetIntersection: ti,
        arrowStart: { x: si.x + al * dx / l, y: si.y + al * dy / l }
    };
}
exports.makeEdgeBetween = makeEdgeBetween;
function makeEdgeTo(s, target, ah) {
    var ti = target.rayIntersection(s.x, s.y);
    if (!ti)
        ti = { x: target.cx(), y: target.cy() };
    var dx = ti.x - s.x, dy = ti.y - s.y, l = Math.sqrt(dx * dx + dy * dy);
    return { x: ti.x - ah * dx / l, y: ti.y - ah * dy / l };
}
exports.makeEdgeTo = makeEdgeTo;
var Node = (function () {
    function Node(v, r, pos) {
        this.v = v;
        this.r = r;
        this.pos = pos;
        this.prev = makeRBTree();
        this.next = makeRBTree();
    }
    return Node;
}());
var Event = (function () {
    function Event(isOpen, v, pos) {
        this.isOpen = isOpen;
        this.v = v;
        this.pos = pos;
    }
    return Event;
}());
function compareEvents(a, b) {
    if (a.pos > b.pos) {
        return 1;
    }
    if (a.pos < b.pos) {
        return -1;
    }
    if (a.isOpen) {
        return -1;
    }
    if (b.isOpen) {
        return 1;
    }
    return 0;
}
function makeRBTree() {
    return new rbtree_1.RBTree(function (a, b) { return a.pos - b.pos; });
}
var xRect = {
    getCentre: function (r) { return r.cx(); },
    getOpen: function (r) { return r.y; },
    getClose: function (r) { return r.Y; },
    getSize: function (r) { return r.width(); },
    makeRect: function (open, close, center, size) { return new Rectangle(center - size / 2, center + size / 2, open, close); },
    findNeighbours: findXNeighbours
};
var yRect = {
    getCentre: function (r) { return r.cy(); },
    getOpen: function (r) { return r.x; },
    getClose: function (r) { return r.X; },
    getSize: function (r) { return r.height(); },
    makeRect: function (open, close, center, size) { return new Rectangle(open, close, center - size / 2, center + size / 2); },
    findNeighbours: findYNeighbours
};
function generateGroupConstraints(root, f, minSep, isContained) {
    if (isContained === void 0) { isContained = false; }
    var padding = root.padding, gn = typeof root.groups !== 'undefined' ? root.groups.length : 0, ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0, childConstraints = !gn ? []
        : root.groups.reduce(function (ccs, g) { return ccs.concat(generateGroupConstraints(g, f, minSep, true)); }, []), n = (isContained ? 2 : 0) + ln + gn, vs = new Array(n), rs = new Array(n), i = 0, add = function (r, v) { rs[i] = r; vs[i++] = v; };
    if (isContained) {
        var b = root.bounds, c = f.getCentre(b), s = f.getSize(b) / 2, open = f.getOpen(b), close = f.getClose(b), min = c - s + padding / 2, max = c + s - padding / 2;
        root.minVar.desiredPosition = min;
        add(f.makeRect(open, close, min, padding), root.minVar);
        root.maxVar.desiredPosition = max;
        add(f.makeRect(open, close, max, padding), root.maxVar);
    }
    if (ln)
        root.leaves.forEach(function (l) { return add(l.bounds, l.variable); });
    if (gn)
        root.groups.forEach(function (g) {
            var b = g.bounds;
            add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);
        });
    var cs = generateConstraints(rs, vs, f, minSep);
    if (gn) {
        vs.forEach(function (v) { v.cOut = [], v.cIn = []; });
        cs.forEach(function (c) { c.left.cOut.push(c), c.right.cIn.push(c); });
        root.groups.forEach(function (g) {
            var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;
            g.minVar.cIn.forEach(function (c) { return c.gap += gapAdjustment; });
            g.minVar.cOut.forEach(function (c) { c.left = g.maxVar; c.gap += gapAdjustment; });
        });
    }
    return childConstraints.concat(cs);
}
function generateConstraints(rs, vars, rect, minSep) {
    var i, n = rs.length;
    var N = 2 * n;
    console.assert(vars.length >= n);
    var events = new Array(N);
    for (i = 0; i < n; ++i) {
        var r = rs[i];
        var v = new Node(vars[i], r, rect.getCentre(r));
        events[i] = new Event(true, v, rect.getOpen(r));
        events[i + n] = new Event(false, v, rect.getClose(r));
    }
    events.sort(compareEvents);
    var cs = new Array();
    var scanline = makeRBTree();
    for (i = 0; i < N; ++i) {
        var e = events[i];
        var v = e.v;
        if (e.isOpen) {
            scanline.insert(v);
            rect.findNeighbours(v, scanline);
        }
        else {
            scanline.remove(v);
            var makeConstraint = function (l, r) {
                var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;
                cs.push(new vpsc_1.Constraint(l.v, r.v, sep));
            };
            var visitNeighbours = function (forward, reverse, mkcon) {
                var u, it = v[forward].iterator();
                while ((u = it[forward]()) !== null) {
                    mkcon(u, v);
                    u[reverse].remove(v);
                }
            };
            visitNeighbours("prev", "next", function (u, v) { return makeConstraint(u, v); });
            visitNeighbours("next", "prev", function (u, v) { return makeConstraint(v, u); });
        }
    }
    console.assert(scanline.size === 0);
    return cs;
}
function findXNeighbours(v, scanline) {
    var f = function (forward, reverse) {
        var it = scanline.findIter(v);
        var u;
        while ((u = it[forward]()) !== null) {
            var uovervX = u.r.overlapX(v.r);
            if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {
                v[forward].insert(u);
                u[reverse].insert(v);
            }
            if (uovervX <= 0) {
                break;
            }
        }
    };
    f("next", "prev");
    f("prev", "next");
}
function findYNeighbours(v, scanline) {
    var f = function (forward, reverse) {
        var u = scanline.findIter(v)[forward]();
        if (u !== null && u.r.overlapX(v.r) > 0) {
            v[forward].insert(u);
            u[reverse].insert(v);
        }
    };
    f("next", "prev");
    f("prev", "next");
}
function generateXConstraints(rs, vars) {
    return generateConstraints(rs, vars, xRect, 1e-6);
}
exports.generateXConstraints = generateXConstraints;
function generateYConstraints(rs, vars) {
    return generateConstraints(rs, vars, yRect, 1e-6);
}
exports.generateYConstraints = generateYConstraints;
function generateXGroupConstraints(root) {
    return generateGroupConstraints(root, xRect, 1e-6);
}
exports.generateXGroupConstraints = generateXGroupConstraints;
function generateYGroupConstraints(root) {
    return generateGroupConstraints(root, yRect, 1e-6);
}
exports.generateYGroupConstraints = generateYGroupConstraints;
function removeOverlaps(rs) {
    var vs = rs.map(function (r) { return new vpsc_1.Variable(r.cx()); });
    var cs = generateXConstraints(rs, vs);
    var solver = new vpsc_1.Solver(vs, cs);
    solver.solve();
    vs.forEach(function (v, i) { return rs[i].setXCentre(v.position()); });
    vs = rs.map(function (r) { return new vpsc_1.Variable(r.cy()); });
    cs = generateYConstraints(rs, vs);
    solver = new vpsc_1.Solver(vs, cs);
    solver.solve();
    vs.forEach(function (v, i) { return rs[i].setYCentre(v.position()); });
}
exports.removeOverlaps = removeOverlaps;
var IndexedVariable = (function (_super) {
    __extends(IndexedVariable, _super);
    function IndexedVariable(index, w) {
        var _this = _super.call(this, 0, w) || this;
        _this.index = index;
        return _this;
    }
    return IndexedVariable;
}(vpsc_1.Variable));
exports.IndexedVariable = IndexedVariable;
var Projection = (function () {
    function Projection(nodes, groups, rootGroup, constraints, avoidOverlaps) {
        if (rootGroup === void 0) { rootGroup = null; }
        if (constraints === void 0) { constraints = null; }
        if (avoidOverlaps === void 0) { avoidOverlaps = false; }
        var _this = this;
        this.nodes = nodes;
        this.groups = groups;
        this.rootGroup = rootGroup;
        this.avoidOverlaps = avoidOverlaps;
        this.variables = nodes.map(function (v, i) {
            return v.variable = new IndexedVariable(i, 1);
        });
        if (constraints)
            this.createConstraints(constraints);
        if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {
            nodes.forEach(function (v) {
                if (!v.width || !v.height) {
                    v.bounds = new Rectangle(v.x, v.x, v.y, v.y);
                    return;
                }
                var w2 = v.width / 2, h2 = v.height / 2;
                v.bounds = new Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);
            });
            computeGroupBounds(rootGroup);
            var i = nodes.length;
            groups.forEach(function (g) {
                _this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== "undefined" ? g.stiffness : 0.01);
                _this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== "undefined" ? g.stiffness : 0.01);
            });
        }
    }
    Projection.prototype.createSeparation = function (c) {
        return new vpsc_1.Constraint(this.nodes[c.left].variable, this.nodes[c.right].variable, c.gap, typeof c.equality !== "undefined" ? c.equality : false);
    };
    Projection.prototype.makeFeasible = function (c) {
        var _this = this;
        if (!this.avoidOverlaps)
            return;
        var axis = 'x', dim = 'width';
        if (c.axis === 'x')
            axis = 'y', dim = 'height';
        var vs = c.offsets.map(function (o) { return _this.nodes[o.node]; }).sort(function (a, b) { return a[axis] - b[axis]; });
        var p = null;
        vs.forEach(function (v) {
            if (p) {
                var nextPos = p[axis] + p[dim];
                if (nextPos > v[axis]) {
                    v[axis] = nextPos;
                }
            }
            p = v;
        });
    };
    Projection.prototype.createAlignment = function (c) {
        var _this = this;
        var u = this.nodes[c.offsets[0].node].variable;
        this.makeFeasible(c);
        var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;
        c.offsets.slice(1).forEach(function (o) {
            var v = _this.nodes[o.node].variable;
            cs.push(new vpsc_1.Constraint(u, v, o.offset, true));
        });
    };
    Projection.prototype.createConstraints = function (constraints) {
        var _this = this;
        var isSep = function (c) { return typeof c.type === 'undefined' || c.type === 'separation'; };
        this.xConstraints = constraints
            .filter(function (c) { return c.axis === "x" && isSep(c); })
            .map(function (c) { return _this.createSeparation(c); });
        this.yConstraints = constraints
            .filter(function (c) { return c.axis === "y" && isSep(c); })
            .map(function (c) { return _this.createSeparation(c); });
        constraints
            .filter(function (c) { return c.type === 'alignment'; })
            .forEach(function (c) { return _this.createAlignment(c); });
    };
    Projection.prototype.setupVariablesAndBounds = function (x0, y0, desired, getDesired) {
        this.nodes.forEach(function (v, i) {
            if (v.fixed) {
                v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;
                desired[i] = getDesired(v);
            }
            else {
                v.variable.weight = 1;
            }
            var w = (v.width || 0) / 2, h = (v.height || 0) / 2;
            var ix = x0[i], iy = y0[i];
            v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);
        });
    };
    Projection.prototype.xProject = function (x0, y0, x) {
        if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints))
            return;
        this.project(x0, y0, x0, x, function (v) { return v.px; }, this.xConstraints, generateXGroupConstraints, function (v) { return v.bounds.setXCentre(x[v.variable.index] = v.variable.position()); }, function (g) {
            var xmin = x[g.minVar.index] = g.minVar.position();
            var xmax = x[g.maxVar.index] = g.maxVar.position();
            var p2 = g.padding / 2;
            g.bounds.x = xmin - p2;
            g.bounds.X = xmax + p2;
        });
    };
    Projection.prototype.yProject = function (x0, y0, y) {
        if (!this.rootGroup && !this.yConstraints)
            return;
        this.project(x0, y0, y0, y, function (v) { return v.py; }, this.yConstraints, generateYGroupConstraints, function (v) { return v.bounds.setYCentre(y[v.variable.index] = v.variable.position()); }, function (g) {
            var ymin = y[g.minVar.index] = g.minVar.position();
            var ymax = y[g.maxVar.index] = g.maxVar.position();
            var p2 = g.padding / 2;
            g.bounds.y = ymin - p2;
            ;
            g.bounds.Y = ymax + p2;
        });
    };
    Projection.prototype.projectFunctions = function () {
        var _this = this;
        return [
            function (x0, y0, x) { return _this.xProject(x0, y0, x); },
            function (x0, y0, y) { return _this.yProject(x0, y0, y); }
        ];
    };
    Projection.prototype.project = function (x0, y0, start, desired, getDesired, cs, generateConstraints, updateNodeBounds, updateGroupBounds) {
        this.setupVariablesAndBounds(x0, y0, desired, getDesired);
        if (this.rootGroup && this.avoidOverlaps) {
            computeGroupBounds(this.rootGroup);
            cs = cs.concat(generateConstraints(this.rootGroup));
        }
        this.solve(this.variables, cs, start, desired);
        this.nodes.forEach(updateNodeBounds);
        if (this.rootGroup && this.avoidOverlaps) {
            this.groups.forEach(updateGroupBounds);
            computeGroupBounds(this.rootGroup);
        }
    };
    Projection.prototype.solve = function (vs, cs, starting, desired) {
        var solver = new vpsc_1.Solver(vs, cs);
        solver.setStartingPositions(starting);
        solver.setDesiredPositions(desired);
        solver.solve();
    };
    return Projection;
}());
exports.Projection = Projection;

},{"./rbtree":21,"./vpsc":24}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var pqueue_1 = require("./pqueue");
var Neighbour = (function () {
    function Neighbour(id, distance) {
        this.id = id;
        this.distance = distance;
    }
    return Neighbour;
}());
var Node = (function () {
    function Node(id) {
        this.id = id;
        this.neighbours = [];
    }
    return Node;
}());
var QueueEntry = (function () {
    function QueueEntry(node, prev, d) {
        this.node = node;
        this.prev = prev;
        this.d = d;
    }
    return QueueEntry;
}());
var Calculator = (function () {
    function Calculator(n, es, getSourceIndex, getTargetIndex, getLength) {
        this.n = n;
        this.es = es;
        this.neighbours = new Array(this.n);
        var i = this.n;
        while (i--)
            this.neighbours[i] = new Node(i);
        i = this.es.length;
        while (i--) {
            var e = this.es[i];
            var u = getSourceIndex(e), v = getTargetIndex(e);
            var d = getLength(e);
            this.neighbours[u].neighbours.push(new Neighbour(v, d));
            this.neighbours[v].neighbours.push(new Neighbour(u, d));
        }
    }
    Calculator.prototype.DistanceMatrix = function () {
        var D = new Array(this.n);
        for (var i = 0; i < this.n; ++i) {
            D[i] = this.dijkstraNeighbours(i);
        }
        return D;
    };
    Calculator.prototype.DistancesFromNode = function (start) {
        return this.dijkstraNeighbours(start);
    };
    Calculator.prototype.PathFromNodeToNode = function (start, end) {
        return this.dijkstraNeighbours(start, end);
    };
    Calculator.prototype.PathFromNodeToNodeWithPrevCost = function (start, end, prevCost) {
        var q = new pqueue_1.PriorityQueue(function (a, b) { return a.d <= b.d; }), u = this.neighbours[start], qu = new QueueEntry(u, null, 0), visitedFrom = {};
        q.push(qu);
        while (!q.empty()) {
            qu = q.pop();
            u = qu.node;
            if (u.id === end) {
                break;
            }
            var i = u.neighbours.length;
            while (i--) {
                var neighbour = u.neighbours[i], v = this.neighbours[neighbour.id];
                if (qu.prev && v.id === qu.prev.node.id)
                    continue;
                var viduid = v.id + ',' + u.id;
                if (viduid in visitedFrom && visitedFrom[viduid] <= qu.d)
                    continue;
                var cc = qu.prev ? prevCost(qu.prev.node.id, u.id, v.id) : 0, t = qu.d + neighbour.distance + cc;
                visitedFrom[viduid] = t;
                q.push(new QueueEntry(v, qu, t));
            }
        }
        var path = [];
        while (qu.prev) {
            qu = qu.prev;
            path.push(qu.node.id);
        }
        return path;
    };
    Calculator.prototype.dijkstraNeighbours = function (start, dest) {
        if (dest === void 0) { dest = -1; }
        var q = new pqueue_1.PriorityQueue(function (a, b) { return a.d <= b.d; }), i = this.neighbours.length, d = new Array(i);
        while (i--) {
            var node = this.neighbours[i];
            node.d = i === start ? 0 : Number.POSITIVE_INFINITY;
            node.q = q.push(node);
        }
        while (!q.empty()) {
            var u = q.pop();
            d[u.id] = u.d;
            if (u.id === dest) {
                var path = [];
                var v = u;
                while (typeof v.prev !== 'undefined') {
                    path.push(v.prev.id);
                    v = v.prev;
                }
                return path;
            }
            i = u.neighbours.length;
            while (i--) {
                var neighbour = u.neighbours[i];
                var v = this.neighbours[neighbour.id];
                var t = u.d + neighbour.distance;
                if (u.d !== Number.MAX_VALUE && v.d > t) {
                    v.d = t;
                    v.prev = u;
                    q.reduceKey(v.q, v, function (e, q) { return e.q = q; });
                }
            }
        }
        return d;
    };
    return Calculator;
}());
exports.Calculator = Calculator;

},{"./pqueue":20}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var PositionStats = (function () {
    function PositionStats(scale) {
        this.scale = scale;
        this.AB = 0;
        this.AD = 0;
        this.A2 = 0;
    }
    PositionStats.prototype.addVariable = function (v) {
        var ai = this.scale / v.scale;
        var bi = v.offset / v.scale;
        var wi = v.weight;
        this.AB += wi * ai * bi;
        this.AD += wi * ai * v.desiredPosition;
        this.A2 += wi * ai * ai;
    };
    PositionStats.prototype.getPosn = function () {
        return (this.AD - this.AB) / this.A2;
    };
    return PositionStats;
}());
exports.PositionStats = PositionStats;
var Constraint = (function () {
    function Constraint(left, right, gap, equality) {
        if (equality === void 0) { equality = false; }
        this.left = left;
        this.right = right;
        this.gap = gap;
        this.equality = equality;
        this.active = false;
        this.unsatisfiable = false;
        this.left = left;
        this.right = right;
        this.gap = gap;
        this.equality = equality;
    }
    Constraint.prototype.slack = function () {
        return this.unsatisfiable ? Number.MAX_VALUE
            : this.right.scale * this.right.position() - this.gap
                - this.left.scale * this.left.position();
    };
    return Constraint;
}());
exports.Constraint = Constraint;
var Variable = (function () {
    function Variable(desiredPosition, weight, scale) {
        if (weight === void 0) { weight = 1; }
        if (scale === void 0) { scale = 1; }
        this.desiredPosition = desiredPosition;
        this.weight = weight;
        this.scale = scale;
        this.offset = 0;
    }
    Variable.prototype.dfdv = function () {
        return 2.0 * this.weight * (this.position() - this.desiredPosition);
    };
    Variable.prototype.position = function () {
        return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;
    };
    Variable.prototype.visitNeighbours = function (prev, f) {
        var ff = function (c, next) { return c.active && prev !== next && f(c, next); };
        this.cOut.forEach(function (c) { return ff(c, c.right); });
        this.cIn.forEach(function (c) { return ff(c, c.left); });
    };
    return Variable;
}());
exports.Variable = Variable;
var Block = (function () {
    function Block(v) {
        this.vars = [];
        v.offset = 0;
        this.ps = new PositionStats(v.scale);
        this.addVariable(v);
    }
    Block.prototype.addVariable = function (v) {
        v.block = this;
        this.vars.push(v);
        this.ps.addVariable(v);
        this.posn = this.ps.getPosn();
    };
    Block.prototype.updateWeightedPosition = function () {
        this.ps.AB = this.ps.AD = this.ps.A2 = 0;
        for (var i = 0, n = this.vars.length; i < n; ++i)
            this.ps.addVariable(this.vars[i]);
        this.posn = this.ps.getPosn();
    };
    Block.prototype.compute_lm = function (v, u, postAction) {
        var _this = this;
        var dfdv = v.dfdv();
        v.visitNeighbours(u, function (c, next) {
            var _dfdv = _this.compute_lm(next, v, postAction);
            if (next === c.right) {
                dfdv += _dfdv * c.left.scale;
                c.lm = _dfdv;
            }
            else {
                dfdv += _dfdv * c.right.scale;
                c.lm = -_dfdv;
            }
            postAction(c);
        });
        return dfdv / v.scale;
    };
    Block.prototype.populateSplitBlock = function (v, prev) {
        var _this = this;
        v.visitNeighbours(prev, function (c, next) {
            next.offset = v.offset + (next === c.right ? c.gap : -c.gap);
            _this.addVariable(next);
            _this.populateSplitBlock(next, v);
        });
    };
    Block.prototype.traverse = function (visit, acc, v, prev) {
        var _this = this;
        if (v === void 0) { v = this.vars[0]; }
        if (prev === void 0) { prev = null; }
        v.visitNeighbours(prev, function (c, next) {
            acc.push(visit(c));
            _this.traverse(visit, acc, next, v);
        });
    };
    Block.prototype.findMinLM = function () {
        var m = null;
        this.compute_lm(this.vars[0], null, function (c) {
            if (!c.equality && (m === null || c.lm < m.lm))
                m = c;
        });
        return m;
    };
    Block.prototype.findMinLMBetween = function (lv, rv) {
        this.compute_lm(lv, null, function () { });
        var m = null;
        this.findPath(lv, null, rv, function (c, next) {
            if (!c.equality && c.right === next && (m === null || c.lm < m.lm))
                m = c;
        });
        return m;
    };
    Block.prototype.findPath = function (v, prev, to, visit) {
        var _this = this;
        var endFound = false;
        v.visitNeighbours(prev, function (c, next) {
            if (!endFound && (next === to || _this.findPath(next, v, to, visit))) {
                endFound = true;
                visit(c, next);
            }
        });
        return endFound;
    };
    Block.prototype.isActiveDirectedPathBetween = function (u, v) {
        if (u === v)
            return true;
        var i = u.cOut.length;
        while (i--) {
            var c = u.cOut[i];
            if (c.active && this.isActiveDirectedPathBetween(c.right, v))
                return true;
        }
        return false;
    };
    Block.split = function (c) {
        c.active = false;
        return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];
    };
    Block.createSplitBlock = function (startVar) {
        var b = new Block(startVar);
        b.populateSplitBlock(startVar, null);
        return b;
    };
    Block.prototype.splitBetween = function (vl, vr) {
        var c = this.findMinLMBetween(vl, vr);
        if (c !== null) {
            var bs = Block.split(c);
            return { constraint: c, lb: bs[0], rb: bs[1] };
        }
        return null;
    };
    Block.prototype.mergeAcross = function (b, c, dist) {
        c.active = true;
        for (var i = 0, n = b.vars.length; i < n; ++i) {
            var v = b.vars[i];
            v.offset += dist;
            this.addVariable(v);
        }
        this.posn = this.ps.getPosn();
    };
    Block.prototype.cost = function () {
        var sum = 0, i = this.vars.length;
        while (i--) {
            var v = this.vars[i], d = v.position() - v.desiredPosition;
            sum += d * d * v.weight;
        }
        return sum;
    };
    return Block;
}());
exports.Block = Block;
var Blocks = (function () {
    function Blocks(vs) {
        this.vs = vs;
        var n = vs.length;
        this.list = new Array(n);
        while (n--) {
            var b = new Block(vs[n]);
            this.list[n] = b;
            b.blockInd = n;
        }
    }
    Blocks.prototype.cost = function () {
        var sum = 0, i = this.list.length;
        while (i--)
            sum += this.list[i].cost();
        return sum;
    };
    Blocks.prototype.insert = function (b) {
        b.blockInd = this.list.length;
        this.list.push(b);
    };
    Blocks.prototype.remove = function (b) {
        var last = this.list.length - 1;
        var swapBlock = this.list[last];
        this.list.length = last;
        if (b !== swapBlock) {
            this.list[b.blockInd] = swapBlock;
            swapBlock.blockInd = b.blockInd;
        }
    };
    Blocks.prototype.merge = function (c) {
        var l = c.left.block, r = c.right.block;
        var dist = c.right.offset - c.left.offset - c.gap;
        if (l.vars.length < r.vars.length) {
            r.mergeAcross(l, c, dist);
            this.remove(l);
        }
        else {
            l.mergeAcross(r, c, -dist);
            this.remove(r);
        }
    };
    Blocks.prototype.forEach = function (f) {
        this.list.forEach(f);
    };
    Blocks.prototype.updateBlockPositions = function () {
        this.list.forEach(function (b) { return b.updateWeightedPosition(); });
    };
    Blocks.prototype.split = function (inactive) {
        var _this = this;
        this.updateBlockPositions();
        this.list.forEach(function (b) {
            var v = b.findMinLM();
            if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {
                b = v.left.block;
                Block.split(v).forEach(function (nb) { return _this.insert(nb); });
                _this.remove(b);
                inactive.push(v);
            }
        });
    };
    return Blocks;
}());
exports.Blocks = Blocks;
var Solver = (function () {
    function Solver(vs, cs) {
        this.vs = vs;
        this.cs = cs;
        this.vs = vs;
        vs.forEach(function (v) {
            v.cIn = [], v.cOut = [];
        });
        this.cs = cs;
        cs.forEach(function (c) {
            c.left.cOut.push(c);
            c.right.cIn.push(c);
        });
        this.inactive = cs.map(function (c) { c.active = false; return c; });
        this.bs = null;
    }
    Solver.prototype.cost = function () {
        return this.bs.cost();
    };
    Solver.prototype.setStartingPositions = function (ps) {
        this.inactive = this.cs.map(function (c) { c.active = false; return c; });
        this.bs = new Blocks(this.vs);
        this.bs.forEach(function (b, i) { return b.posn = ps[i]; });
    };
    Solver.prototype.setDesiredPositions = function (ps) {
        this.vs.forEach(function (v, i) { return v.desiredPosition = ps[i]; });
    };
    Solver.prototype.mostViolated = function () {
        var minSlack = Number.MAX_VALUE, v = null, l = this.inactive, n = l.length, deletePoint = n;
        for (var i = 0; i < n; ++i) {
            var c = l[i];
            if (c.unsatisfiable)
                continue;
            var slack = c.slack();
            if (c.equality || slack < minSlack) {
                minSlack = slack;
                v = c;
                deletePoint = i;
                if (c.equality)
                    break;
            }
        }
        if (deletePoint !== n &&
            (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality)) {
            l[deletePoint] = l[n - 1];
            l.length = n - 1;
        }
        return v;
    };
    Solver.prototype.satisfy = function () {
        if (this.bs == null) {
            this.bs = new Blocks(this.vs);
        }
        this.bs.split(this.inactive);
        var v = null;
        while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {
            var lb = v.left.block, rb = v.right.block;
            if (lb !== rb) {
                this.bs.merge(v);
            }
            else {
                if (lb.isActiveDirectedPathBetween(v.right, v.left)) {
                    v.unsatisfiable = true;
                    continue;
                }
                var split = lb.splitBetween(v.left, v.right);
                if (split !== null) {
                    this.bs.insert(split.lb);
                    this.bs.insert(split.rb);
                    this.bs.remove(lb);
                    this.inactive.push(split.constraint);
                }
                else {
                    v.unsatisfiable = true;
                    continue;
                }
                if (v.slack() >= 0) {
                    this.inactive.push(v);
                }
                else {
                    this.bs.merge(v);
                }
            }
        }
    };
    Solver.prototype.solve = function () {
        this.satisfy();
        var lastcost = Number.MAX_VALUE, cost = this.bs.cost();
        while (Math.abs(lastcost - cost) > 0.0001) {
            this.satisfy();
            lastcost = cost;
            cost = this.bs.cost();
        }
        return cost;
    };
    Solver.LAGRANGIAN_TOLERANCE = -1e-4;
    Solver.ZERO_UPPERBOUND = -1e-10;
    return Solver;
}());
exports.Solver = Solver;
function removeOverlapInOneDimension(spans, lowerBound, upperBound) {
    var vs = spans.map(function (s) { return new Variable(s.desiredCenter); });
    var cs = [];
    var n = spans.length;
    for (var i = 0; i < n - 1; i++) {
        var left = spans[i], right = spans[i + 1];
        cs.push(new Constraint(vs[i], vs[i + 1], (left.size + right.size) / 2));
    }
    var leftMost = vs[0], rightMost = vs[n - 1], leftMostSize = spans[0].size / 2, rightMostSize = spans[n - 1].size / 2;
    var vLower = null, vUpper = null;
    if (lowerBound) {
        vLower = new Variable(lowerBound, leftMost.weight * 1000);
        vs.push(vLower);
        cs.push(new Constraint(vLower, leftMost, leftMostSize));
    }
    if (upperBound) {
        vUpper = new Variable(upperBound, rightMost.weight * 1000);
        vs.push(vUpper);
        cs.push(new Constraint(rightMost, vUpper, rightMostSize));
    }
    var solver = new Solver(vs, cs);
    solver.solve();
    return {
        newCenters: vs.slice(0, spans.length).map(function (v) { return v.position(); }),
        lowerBound: vLower ? vLower.position() : leftMost.position() - leftMostSize,
        upperBound: vUpper ? vUpper.position() : rightMost.position() + rightMostSize
    };
}
exports.removeOverlapInOneDimension = removeOverlapInOneDimension;

},{}],25:[function(require,module,exports){
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ]

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      this.map[name].forEach(function(value) {
        callback.call(thisArg, value, name, this)
      }, this)
    }, this)
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsArrayBuffer(blob)
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsText(blob)
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf)
    var chars = new Array(view.length)

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i])
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength)
      view.set(new Uint8Array(buf))
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (!body) {
        this._bodyText = ''
      } else if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer)
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer])
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body)
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      }
    }

    this.text = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body

    if (typeof input === 'string') {
      this.url = input
    } else {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body && input._bodyInit != null) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers()
    rawHeaders.split('\r\n').forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
    return headers
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = 'status' in options ? options.status : 200
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = 'statusText' in options ? options.statusText : 'OK'
    this.headers = new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init)
      var xhr = new XMLHttpRequest()

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        }
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);

},{}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var UNKNOW_IMAGE = exports.UNKNOW_IMAGE = 'data:image/png;base64,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';
var LINK_OPTIONS = exports.LINK_OPTIONS = 'data:image/png;base64,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';
var FEED_PIPE = exports.FEED_PIPE = 'data:image/png;base64,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';

},{}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataContainer = DataContainer;
exports.GroupOfZones = GroupOfZones;
exports.NodesZone = NodesZone;
/**
 * Maps is the set of the map functions
 * @typedef {Object} Maps
 * @property {[id: string]: Node} nodeMap - map id to [Node]{@link Node} - Returns Node by id and (optional) role.
 * @property {[id: string]: Link} linkMap - map id to  [Link]{@link Link} - Returns Link by id and (optional) role.
 * @property {[id: string]: Link} sourceMap - map id to  [Link]{@link Link}[] - Returns all incoming links for the node with specified id (filters by role).
 * @property {[id: string]: Link} targetMap - map id to  [Link]{@link Link}[] - Returns all outgoing links for the node with specified id (filters by role).
*/

/**
 * End elements of the graph, which were created from {@link ServerData}.
 * @typedef {Object} GraphData
 * @property {Link[]} links - List of Links of the graph
 * @property {Node[]} nodes - List of Nodes of the graph
*/

/**
 * @private
 * DataContainer - an object which is a data model of the LinegeGram. It stores and orginizes
 * data for the views and also provides set of maps (dictionaries) for links and nodes of the graph.
 * You can get this model using a LineaGram method which is called 'getGraphModel'.
 * DataContainer implements separation and filtration mechanisms, in other words,
 * you can return different data for different roles.
 * @class
 * @param {GraphData} data - Raw data - models for links and nodes of the graph.
 * @param {Parameters} parameters - Parameters set
 * 
 * @property {Maps} maps - Set of the map functions
 */
function DataContainer(data, parameters) {
    var self = this;

    if (!data) data = {};
    if (!data.nodes) data.nodes = [];
    if (!data.links) data.links = [];

    self.nodes = data.nodes;
    self.links = data.links;
    self.maps = { sourceMap: {}, targetMap: {}, nodeMap: {}, linkMap: {}, idMap: {} };
    self.zones = [];

    var _zoneSize = parameters.dataZoneSize;
    var _elementSize = parameters.elementSize;
    var _zonesInGroup = parameters.zonesInGroup;

    // If some node dont hit any real zone it will hit this one.
    var _fakeZone = new NodesZone(null, {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        elementSize: 0,
        fakeZone: true
    });
    if (_elementSize.width >= _zoneSize.width || _elementSize.height >= _zoneSize.height) {
        _zoneSize.width = _elementSize.width * 20;
        _zoneSize.height = _elementSize.height * 20;
    }

    /**
     * Returns nodes and links which are lie near the point
     * @param {Point[]} points - Array of points
     * @return {GraphData} - Nodes and Links
     * @memberof DataContainer
     * @method
    */
    self.getElementsNearThePoints = function (points) {
        var suitableZones = _zonesForPoints(points);
        var resultNodes = [];
        var resultLinks = [];

        suitableZones.forEach(function (z) {
            z.relatedNodes.forEach(function (n) {
                if (resultNodes.indexOf(n) === -1) {
                    resultNodes.push(n);
                }
            });
            z.nodes.forEach(function (n) {
                if (resultNodes.indexOf(n) === -1) {
                    resultNodes.push(n);
                }
            });
            z.links.forEach(function (l) {
                if (resultLinks.indexOf(l) === -1) {
                    resultLinks.push(l);
                }
            });
        });

        return {
            nodes: resultNodes,
            links: resultLinks
        };
    };

    /**
     * Rectangle
     * @typedef {Object} Rectangle
     * @property {number} x - Position by x axis
     * @property {number} y - Position by y axis
     * @property {number} width - Width of the rectangle
     * @property {number} height - Height of the rectangle
    */

    /**
     * Returns nodes and links which are lie into the rectangle
     * @param {Rectangle} rect - Hit rectangle
     * @return {GraphData} - Nodes and Links
     * @memberof DataContainer
     * @method
    */
    self.getElementsForRectangle = function (rect) {

        if (!rect) return { nodes: [], links: [] };
        var points = [];
        if (rect.width <= _zoneSize.width && rect.height <= _zoneSize.height) {
            points.push({ x: rect.x, y: rect.y });
            points.push({ x: rect.x + rect.width, y: rect.y });
            points.push({ x: rect.x, y: rect.y + rect.height });
            points.push({ x: rect.x + rect.width, y: rect.y + rect.height });
        } else {
            for (var x = rect.x;; x += _zoneSize.width) {
                for (var y = rect.y;; y += _zoneSize.height) {
                    points.push({
                        x: Math.min(x, rect.x + rect.width),
                        y: Math.min(y, rect.y + rect.height)
                    });
                    if (y >= rect.y + rect.height) break;
                }
                if (x >= rect.x + rect.width) break;
            }
        }
        return self.getElementsNearThePoints(points);
    };

    /**
     * Returns nodes related with the target node
     * @param {Node} node - target node
     * @return {Node[]}
     * @memberof DataContainer
     * @method
    */
    self.getRelatedNodes = function (node) {
        var neighbors = [];
        if (self.maps.targetMap[node.id]) {
            self.maps.targetMap[node.id].forEach(function (l) {
                return neighbors.push(self.maps.nodeMap[l.model.target]);
            });
        }
        if (self.maps.sourceMap[node.id]) {
            self.maps.sourceMap[node.id].forEach(function (l) {
                return neighbors.push(self.maps.nodeMap[l.model.source]);
            });
        }
        return neighbors;
    };

    /**
     * Refreshes container. It means that all maps will
     * be updated and nodes in the container will be organized.
     * @param {Node} node - Target node (optional)
     * @memberof DataContainer
     * @method
    */
    self.refresh = function (newData) {
        if (newData) {
            if (newData.nodes) {
                self.nodes = newData.nodes;
            }
            if (newData.links) {
                self.links = newData.links;
            }
        }
        _refreshMaps();
        _refreshGrid();
    };

    /**
     * Moves node from one zone to another.
     * We are using it when node is dragged to somewhere on the paper
     * @param {Node} node - target node
     * @param {Point} oldPos - previous position of the target node
     * @memberof DataContainer
     * @method
    */
    self.updateZonesForNode = function (node, oldPos) {
        var curPos = node.model.position;
        var oldZones = _zonesForPoints([oldPos]);

        oldZones.forEach(function (zone) {
            var newNodes = zone.nodes.filter(function (n) {
                return n !== node;
            });
            _clearZone(zone);
            _fillZone(zone, newNodes);
        });

        var newZones = _zonesForPoints([curPos]);
        if (newZones) {
            newZones.forEach(function (z) {
                _fillZone(z, [node]);
            });
        } else {
            _fillZone(_fakeZone, [node]);
        }
    };

    /**
     * Returns all zones which contain obtained points.
     * @private
     * @param {Point[]} points
     * @return {NodesZone[]}
    */
    function _zonesForPoints(points) {
        points = points || [];
        var suitableZones = [];

        function recursion(p, zones) {
            zones.forEach(function (z) {
                if (z.hitTest(p)) {
                    if (z instanceof GroupOfZones) {
                        recursion(p, z.zones);
                    } else if (suitableZones.indexOf(z) === -1) {
                        suitableZones.push(z);
                    }
                }
            });
        }
        points.forEach(function (p) {
            recursion(p, self.zones);
        });
        suitableZones.push(_fakeZone);

        return suitableZones;
    }

    /**
     * Calculates zones tree.
     * @private
    */
    function _refreshGrid() {
        var minX = undefined,
            minY = undefined,
            maxX = undefined,
            maxY = undefined;

        self.nodes.forEach(function (node) {
            var pos = node.model.position;
            minX = minX === undefined ? pos.x : Math.min(minX, pos.x);
            minY = minY === undefined ? pos.y : Math.min(minY, pos.y);
            maxX = maxX === undefined ? pos.x : Math.max(maxX, pos.x);
            maxY = maxY === undefined ? pos.y : Math.max(maxY, pos.y);
        });

        var zones = [];
        var nodes = [].concat(self.nodes);
        for (var x = minX, i = 0; x <= maxX; x += _zoneSize.width - _elementSize.width, i++) {
            zones[i] = [];
            for (var y = minY, j = 0; y <= maxY; y += _zoneSize.height - _elementSize.height, j++) {
                var newZone = new NodesZone(null, {
                    x: x,
                    y: y,
                    width: _zoneSize.width,
                    height: _zoneSize.height,
                    elementSize: _elementSize
                });
                nodes = _fillZone(newZone, nodes);
                zones[i][j] = newZone;
            }
        }
        self.zones = _groupZones(zones);
        self.zones.push(_fakeZone);
    }

    /**
     * Groups zones by groups of (by default) four.
     * @private
     * @param {NodeZone[]} zones
     * @return {NodeZone[] | GroupOfZones}
    */
    function _groupZones(zones) {
        var MAX_DEEP = 1000;
        var side = Math.sqrt(_zonesInGroup); // length of side of group
        var newZones = void 0;
        for (var n = 0; n < MAX_DEEP && zones.length !== 1; n++) {
            // iterations
            newZones = [];
            for (var i = 0, ni = 0; i < zones.length; i += side, ni++) {
                newZones[ni] = [];
                for (var j = 0, nj = 0; j < zones[i].length; j += side, nj++) {
                    var zonesOfGroup = [];
                    zonesOfGroup.push(zones[i][j]);
                    if (zones[i + 1] && zones[i + 1][j]) zonesOfGroup.push(zones[i + 1][j]);
                    if (zones[i] && zones[i][j + 1]) zonesOfGroup.push(zones[i][j + 1]);
                    if (zones[i + 1] && zones[i + 1][j + 1]) zonesOfGroup.push(zones[i + 1][j + 1]);
                    newZones[ni][nj] = new GroupOfZones(zonesOfGroup);
                }
            }
            zones = newZones;
        }
        if (newZones) zones = newZones;
        return zones[0] || [];
    }

    /**
     * Puts nodes and links into zone.
     * @private
     * @param {NodeZone} zone
     * @param {Node[]} nodes
     * @return {Node[]}
    */
    function _fillZone(zone, nodes) {
        var notFitedNodes = []; // indexes to remove the catched nodes from the list
        nodes.forEach(function (node) {
            if (zone.nodeHitTest(node)) {
                zone.nodes.push(node);

                self.getRelatedNodes(node).forEach(function (n) {
                    if (zone.relatedNodes.indexOf(n) === -1) {
                        zone.relatedNodes.push(n);
                    }
                });

                if (self.maps.sourceMap[node.id]) {
                    self.maps.sourceMap[node.id].forEach(function (link) {
                        zone.links.push(link);
                    });
                }
                if (self.maps.targetMap[node.id]) {
                    self.maps.targetMap[node.id].forEach(function (link) {
                        zone.links.push(link);
                    });
                }
            } else {
                notFitedNodes.push(node);
            }
        });
        return notFitedNodes;
    }

    /**
     * Clear zone - remove all data from the zone.
     * @private
     * @param {NodeZone} zone
    */
    function _clearZone(zone) {
        zone.relatedNodes = [];
        zone.nodes = [];
        zone.links = [];
    }

    /**
     * Creates map for nodes
     * and updates aspect relations between nodes
     * @private
     * @returns nodeMap
    */
    function _createNodeMaps() {
        var nodeMap = {};
        var idMap = {};
        self.nodes.forEach(function (node) {
            nodeMap[node.id] = node;
            nodeMap[node.model.id] = node.id;
        });
        return {
            nodeMap: nodeMap,
            idMap: idMap
        };
    }

    /**
     * Creates maps for links.
     * @private
     * @param {Object} nodeMap
     * @param {Object} idMap
     * @returns {linkMap, idMap}
    */
    function _createLinkMaps(nodeMap, idMap) {
        var sourceMap = {};
        var targetMap = {};
        var linkMap = {};

        self.links.forEach(function (link) {
            linkMap[link.id] = link;
            idMap[link.model.id] = link.id;

            var source = nodeMap[link.model.source];
            var target = nodeMap[link.model.target];

            if (!sourceMap[target.id]) {
                sourceMap[target.id] = [];
            }
            sourceMap[target.id].push(link);

            if (!targetMap[source.id]) {
                targetMap[source.id] = [];
            }
            targetMap[source.id].push(link);
        });
        return {
            linkMap: linkMap,
            sourceMap: sourceMap,
            targetMap: targetMap,
            idMap: idMap
        };
    }

    /**
     * Updates maps.
     * @private
    */
    function _refreshMaps() {
        var _createNodeMaps2 = _createNodeMaps(),
            nodeMap = _createNodeMaps2.nodeMap,
            idMap = _createNodeMaps2.idMap;

        var linkMaps = _createLinkMaps(nodeMap, idMap);

        self.maps = {
            sourceMap: linkMaps.sourceMap,
            targetMap: linkMaps.targetMap,
            nodeMap: nodeMap,
            idMap: linkMaps.idMap,
            linkMap: linkMaps.linkMap
        };
    }

    self.refresh();
}
exports.default = DataContainer;

/**
 * @private
 * Object that is the leaf of the zones tree
 * @class
 * @param {NodeZone[]} zones - Array of zonnes for containing
 * @property {NodeZone[]} zones - Array of zonnes
 */

function GroupOfZones(zones) {
    var self = this;

    self.model = {};
    self.zones = zones;

    _calculateBounds();

    /**
     * @private
     * Calculates bounds of the total area of contained zones. 
    */
    function _calculateBounds() {
        var minX = undefined,
            minY = undefined,
            maxX = undefined,
            maxY = undefined;

        self.zones.forEach(function (zone) {
            minX = minX === undefined ? zone.model.x : Math.min(minX, zone.model.x);
            minY = minY === undefined ? zone.model.y : Math.min(minY, zone.model.y);
            maxX = maxX === undefined ? zone.model.x + zone.model.width : Math.max(maxX, zone.model.x + zone.model.width);
            maxY = maxY === undefined ? zone.model.y + zone.model.height : Math.max(maxY, zone.model.y + zone.model.height);
        });
        self.model.x = minX;
        self.model.y = minY;
        self.model.width = maxX - minX;
        self.model.height = maxY - minY;
    }

    /**
     * Tells us whether a point fall into this group of zones or no.
     * @param {Point} point - Tested point
     * @returns {boolean}
     * @memberof GroupOfZones
     * @method
    */
    self.hitTest = function (point) {
        return point.x >= self.model.x && point.x <= self.model.x + self.model.width && point.y >= self.model.y && point.y <= self.model.y + self.model.height;
    };
}

/**
 * @private
 * Options of a NodeZone
 * @typedef {Object} NodeZoneOptions
 * @property {number} x - Position by x axis
 * @property {number} y - Position by y axis
 * @property {number} width - Width of the rectangle
 * @property {number} height - Height of the rectangle
 * @property {ElementSize} elementSize - Size of elements of the graph
 * @property {boolean} fakeZone - Is it fake zone (abstract or don't has position)
*/

/**
 * @private
 * Object that is the leaf of the tree of zones
 * @class
 * @param {Node[]} nodes - Nodes of the zone (can be undefined)
 * @param {NodeZoneOptions} parameters - Properties set
 * 
 * @property {NodeZoneOptions} model - Properties set
 */
function NodesZone(nodes, parameters) {
    var self = this;

    self.model = parameters;
    self.nodes = nodes || [];
    self.relatedNodes = [];
    self.links = [];

    var _elementSize = parameters.elementSize;

    /**
     * Tells us whether a Node fall into the zone or no.
     * @param {Node} node - Tested node
     * @returns {boolean}
     * @memberof NodesZone
     * @method
    */
    self.nodeHitTest = function (node) {
        if (self.model.fakeZone) return true;
        var nodePosition = node.model.position;

        var p1 = nodePosition;
        var p2 = { x: nodePosition.x + _elementSize.width, y: nodePosition.y };
        var p3 = { x: nodePosition.x, y: nodePosition.y + _elementSize.height };
        var p4 = { x: nodePosition.x + _elementSize.width, y: nodePosition.y + _elementSize.height };

        return self.hitTest(p1) && self.hitTest(p2) && self.hitTest(p3) && self.hitTest(p4);
    };

    /**
     * Tells us whether a point fall into the zone or no.
     * @param {Point} point - Tested point
     * @returns {boolean}
     * @memberof NodesZone
     * @method
    */
    self.hitTest = function (point) {
        return self.model.fakeZone || point.x >= self.model.x && point.x <= self.model.x + self.model.width && point.y >= self.model.y && point.y <= self.model.y + self.model.height;
    };
}

},{}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.processData = processData;
exports.createAspectRelations = createAspectRelations;
var LG_GROUP_TYPE_ID = exports.LG_GROUP_TYPE_ID = 'tq-lg-group';

var NODE_MODEL_FIELDS = exports.NODE_MODEL_FIELDS = ['id', 'label', 'viewFrame', 'typeId', 'resource', 'resourceType', 'position', 'defaultPosition', 'data', 'offset'];

var LINK_MODEL_FIELDS = exports.LINK_MODEL_FIELDS = ['id', 'source', 'target', 'linkType', 'group', 'data'];

/**
 * @private
 *
 * The function filters the data, sets authorities and collapses links.
 * @param {
 *  nodes: NodeModel[],
 *  links: LinkModel[]
 * } data
 */
function processData(data) {
    if (!data || !data.nodes) return;
    data.links = data.links || [];

    var nodeMap = {};

    data.nodes.forEach(function (node) {
        nodeMap[node.id] = node;
        node.position = { x: 0, y: 0 };
        // extracting additional data
        var data = {};
        Object.keys(node).forEach(function (key) {
            var notPermanentField = NODE_MODEL_FIELDS.indexOf(key) === -1;
            if (notPermanentField) {
                data[key] = node[key];
                delete node[key];
            }
        });
        node.data = data;
    });

    var destinationMap = {};
    data.links.forEach(function (rawLink) {
        if (nodeMap[rawLink.source] && nodeMap[rawLink.target]) {
            var linkCacheId = getCacheId(rawLink);

            if (destinationMap[linkCacheId]) {
                destinationMap[linkCacheId] = group(destinationMap[linkCacheId], rawLink);
            } else {
                destinationMap[linkCacheId] = rawLink;
            }
        } else {
            if (!nodeMap[rawLink.source]) {
                console.warn('Source not found! The link from ' + rawLink.source + ' to ' + rawLink.target);
            } else {
                console.warn('Target not found! The link from ' + rawLink.source + ' to ' + rawLink.target);
            }
        }
    });

    var sourceMap = {};
    var targetMap = {};
    var links = Object.keys(destinationMap).map(function (cacheId) {
        var link = destinationMap[cacheId];
        Object.keys(link).forEach(function (key) {
            var notPermanentField = LINK_MODEL_FIELDS.indexOf(key) === -1;
            if (notPermanentField) {
                data[key] = link[key];
                delete link[key];
            }
        });

        if (!sourceMap[link.target]) sourceMap[link.target] = [];
        sourceMap[link.target].push(link);

        if (!targetMap[link.source]) targetMap[link.source] = [];
        targetMap[link.source].push(link);

        return link;
    });

    return {
        nodes: Object.keys(nodeMap).map(function (key) {
            return nodeMap[key];
        }),
        links: links
    };

    function getCacheId(link) {
        return 'source:(' + link.source + ')~#~target:(' + link.target + ')';
    }

    function group(existedLink, newLink) {
        var group = existedLink.group ? existedLink : {
            id: getCacheId(existedLink),
            source: existedLink.source,
            target: existedLink.target,
            linkType: LG_GROUP_TYPE_ID, // existedLink.linkType,
            group: [existedLink]
        };
        group.group.push(newLink);
        // extracting additional data
        return group;
    }
}
exports.default = processData;

/**
 * @private
 *
 * The function filters the data, sets authorities and collapses links.
 * @param {
 *  nodes: NodeModel[],
 *  links: LinkModel[]
 * } data
 */

function createAspectRelations(nodes) {
    var aspectMap = {};
    nodes.forEach(function (node) {
        // combine nodes with the same id
        var clearId = node.model.resource;
        if (clearId) {
            if (!aspectMap[clearId]) {
                aspectMap[clearId] = [node];
            } else {
                aspectMap[clearId].push(node);
            }
        }
    });
    Object.keys(aspectMap).forEach(function (key) {
        if (aspectMap[key].length > 1) {
            aspectMap[key].forEach(function (n) {
                var index = aspectMap[key].indexOf(n);
                n.aspects = aspectMap[key].slice(0, index).concat(aspectMap[key].slice(index + 1, aspectMap[key].length));
            });
        }
    });
}

},{}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DefaultDataProvider = DefaultDataProvider;
function DefaultDataProvider(parameters) {
    var self = this;
    if (!parameters) parameters = {};

    var _serverURL = parameters.serverURL || '/api/tbl/swp';
    var _defaultLineageGramViewClass = parameters.lgViewClass || 'http://edg.topbraid.solutions/model/BuildJSONforLineageModelLineageGram';
    var _vfViewClass = parameters.vfViewClass || 'edg:getViewFramesForResource';
    var _dmViewClass = parameters.dmViewClass || 'edg:DerivationMapDataService';
    var _vcViewClass = parameters.vcViewClass || 'edg:getLineageGramDataProvider';

    var _graph = parameters.graph || 'undefined';
    var _configGraph = parameters.configGraph || 'http://edg.topbraidlive.org/1.0/config/diagrams';
    var _base = parameters.base || 'undefined';

    var _reach = parameters.reach;
    var _range = parameters.range;
    var _breadth = parameters.breadth;
    var _depth = parameters.depth;

    self.fetchData = function (options) {
        return _executQuery(getFetchDataUrl(options.targetNodeId, options.viewFrame, options.lineageGramViewClass, options.diagramType, options.hasOwnProperty('offset') ? options.offset : null));
    };

    self.getViewFrames = function (resource) {
        return _executQuery(getViewFramesUrl(resource));
    };

    self.getViewClassForResource = function (resource) {
        return _executQuery(getViewClassUrl(resource));
    };

    self.relationInfo = function (relation) {
        return _executQuery(getDerivationDataUrl(relation.source.resource, relation.target.resource, relation.linkType));
    };

    function getViewFramesUrl(resource) {
        return _serverURL + '?' + '_viewClass=' + _vfViewClass + '&' + 'graph=' + _graph + '&' + 'resource=' + resource + '&' + 'configGraph=' + _configGraph + '&' + '_base=' + _base;
    }

    function getViewClassUrl(resource) {
        return _serverURL + '?' + '_viewClass=' + _vcViewClass + '&' + 'graph=' + _graph + '&' + 'resource=' + resource + '&' + 'configGraph=' + _configGraph + '&' + '_base=' + _base;
    }

    function getFetchDataUrl(focusNode, viewFrame, lineageGramViewClass, diagramType, offset) {
        var dataUrl = _serverURL + '?' + '_viewClass=' + (lineageGramViewClass || _defaultLineageGramViewClass) + '&' + 'graph=' + _graph + '&' + 'focusNode=' + encodeURIComponent(focusNode) + '&' + '_base=' + _base;

        if (viewFrame) {
            dataUrl += '&viewFrame=' + viewFrame;
        }

        if (offset) {
            dataUrl += '&offset=' + offset;
        }

        if (_reach) {
            dataUrl += '&reach=' + _reach;
        }

        if (_range) {
            dataUrl += '&range=' + _range;
        }

        if (_breadth) {
            dataUrl += '&breadth=' + _breadth;
        }

        if (_depth) {
            dataUrl += '&depth=' + _depth;
        }

        if (diagramType) {
            dataUrl += '&diagramType=' + diagramType;
        }

        return dataUrl;
    }

    function _executQuery(url) {
        return fetch(url, {
            method: 'GET',
            credentials: 'same-origin',
            mode: 'cors',
            cache: 'default',
            headers: {
                'Accept': 'application/json, text/turtle',
                'Content-Type': 'application/sparql-query'
            }
        }).then(function (response) {
            if (response.ok) {
                return response.json(); // Also possible to use: response.text(); //response.type;
            } else {
                var error = new Error(response.statusText);
                error.response = response;
                throw error;
            }
        });
    }

    function getDerivationDataUrl(leftNode, rightNode, linkType) {
        var dataURL = _serverURL + '?' + '_base=' + _base + '&' + '_viewClass=' + _dmViewClass + '&' + 'leftNode=' + leftNode + '&' + 'rightNode=' + rightNode;

        if (linkType) {
            dataURL += '&linkType=' + linkType;
        }

        return dataURL;
    }
}
exports.default = DefaultDataProvider;

},{}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FEED_PIPE_LINK_STYLE = exports.DEFAULT_GROUP_LINK_STYLE = exports.DEFAULT_LINK_STYLE = exports.DEFAULT_DERIVATION_MAP_LINK_STYLE = exports.LG_GROUP_TYPE_ID = exports.FEED_PIPE_TYPE = undefined;
exports.ResourceProvider = ResourceProvider;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _base64Images = require('./base64Images');

var images = _interopRequireWildcard(_base64Images);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var FEED_PIPE_TYPE = exports.FEED_PIPE_TYPE = 'feedpipe';

var LG_GROUP_TYPE_ID = exports.LG_GROUP_TYPE_ID = 'tq-lg-group';

var DEFAULT_DERIVATION_MAP_LINK_STYLE = exports.DEFAULT_DERIVATION_MAP_LINK_STYLE = {
    cssClass: 'derivation-link',
    lineType: 'solid', // 'dashed'
    color: 'black',
    textColor: 'black',
    textBackgroundColor: 'white',
    thickness: 2
};

var DEFAULT_LINK_STYLE = exports.DEFAULT_LINK_STYLE = {
    cssClass: 'lineage-gram-link',
    lineType: 'solid', // 'dashed'
    color: '#3c4260',
    toolButton: {
        image: images.LINK_OPTIONS,
        width: 30,
        height: 30,
        alwaysVisible: false
    },
    thickness: 2,
    hasArrow: true
};

var DEFAULT_GROUP_LINK_STYLE = exports.DEFAULT_GROUP_LINK_STYLE = {
    cssClass: 'lineage-gram-links-group',
    lineType: 'solid', // 'dashed'
    color: '#3c4260',
    thickness: 2,
    hasArrow: true,
    toolButton: {
        alwaysVisible: true
    }
};

var FEED_PIPE_LINK_STYLE = exports.FEED_PIPE_LINK_STYLE = {
    cssClass: 'lineage-gram-feed-pipe-link',
    lineType: 'solid', // 'dashed'
    color: '#3c4260',
    toolButton: {
        image: images.FEED_PIPE,
        width: 30,
        height: 30,
        alwaysVisible: true
    },
    thickness: 3,
    hasArrow: true
};

function ResourceProvider(_parameters) {
    var self = this;

    self.getLinkStyle = _getLinkStyle;
    self.getImage = _getImage;
    self.getColor = _getColor;
    self.getIcon = _getIcon;

    function _getColor(type) {
        if (!type) {
            return 'white';
        }
        if (!type) {
            return _parameters.colors['default'];
        } else {
            return _parameters.colors[type] || _parameters.colors['default'];
        }
    }

    function _getImage(type) {
        if (!type) {
            return images.UNKNOW_IMAGE;
        }
        if (!_parameters.images[type] && type === 'link-options' || type === 'default-link-options') {
            return images.LINK_OPTIONS;
        }
        if (!_parameters.images[type] && type === 'feed-pipe' || type === 'default-feed-pipe') {
            return images.FEED_PIPE;
        }
        return _parameters.resourcePath + (_parameters.images[type] || _parameters.images['unknown'] || images.UNKNOW_IMAGE);
    }

    function _getLinkStyle(type) {
        var linkStyles = _parameters.linkStyles;
        var defaultStyle = _.cloneDeep(linkStyles['default-link-style'] || DEFAULT_LINK_STYLE);

        var linkStyle = void 0;
        if (!type) {
            linkStyle = defaultStyle || defaultStyle;
        } else {
            if (linkStyles[type]) {
                linkStyle = linkStyles[type];
            } else {
                linkStyle = defaultStyle || defaultStyle;
            }
        }
        return _.merge(defaultStyle, linkStyle);
    }

    function _getIcon(type) {
        if (!type) {
            return undefined;
        }

        return _parameters.icons[type];
    }
}

},{"./base64Images":26,"lodash":"lodash"}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.DefaultUI = DefaultUI;

var _visualizationsLibrary = require('visualizations-library');

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

var _viewFrameButtons = require('./viewFrameButtons');

var _map = require('./map');

var _map2 = _interopRequireDefault(_map);

var _infoPanel = require('./infoPanel');

var _infoPanel2 = _interopRequireDefault(_infoPanel);

var _optionsPanel = require('./optionsPanel');

var _optionsPanel2 = _interopRequireDefault(_optionsPanel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Parameters set for a {@link Toolbar}.
 * @typedef {Object} DefaultUIOptions
 * @property {HTMLElement | String} baseElement - Root HTMLElement
 * @property {Object.<string, LegendDescriptor>} legends
 * @property {string} neighborGramViewClass
 */

/**
 * @private
 * @param {DefaultUIOptions} options
 */
function DefaultUI(options) {
    var self = this;
    // Initialization
    // =======================================================
    var _lineageGram = options.lineageGram;
    var markup = '\n        <div class="tq-lg-default-user-ui">\n            <div id="tqLgToolbar"></div>\n            <div id="tqLgMiniMap"></div>\n            <div id="tqLgInfoPanel"></div>\n            <div id="tqLgOptionsPanel"></div>\n            <div id="tqLgSearchPanel"></div>\n        </div>\n    ';

    var _el = void 0;
    if (typeof options.baseElement === 'string') {
        _el = document.getElementById(options.baseElement);
    } else if (_typeof(options.baseElement) === 'object') {
        _el = options.baseElement;
    }
    if (!_el) return;
    _el.innerHTML = markup;

    var tqLgToolbar = _el.querySelector('#tqLgToolbar');
    var tqLgMiniMap = _el.querySelector('#tqLgMiniMap');
    var tqLgInfoPanel = _el.querySelector('#tqLgInfoPanel');
    var tqLgOptionsPanel = _el.querySelector('#tqLgOptionsPanel');
    var tqLgSearchPanel = _el.querySelector('#tqLgSearchPanel');

    var _zooming = _lineageGram.zoom();
    var _expandAll = true;
    // =======================================================

    var _coloredButtons = new _viewFrameButtons.ViewFrameButtons({
        lineageGram: _lineageGram
    });
    var _switcher = new _visualizationsLibrary2.default.Switcher({
        states: [{
            id: 'lineageDiagram',
            label: 'Lineage diagram view',
            icon: 'glyphicon glyphicon-modal-window'
        }, {
            id: 'birdEye',
            label: 'Bird eye view',
            icon: 'glyphicon glyphicon-eye-open'
        }],
        verticalOrientation: true
    });

    _switcher.on('state-changed', function (tabId) {
        _lineageGram.setCurrentView(tabId);
    });

    var _toolbar = new _visualizationsLibrary2.default.Toolbar({
        baseElement: tqLgToolbar,
        tools: [{
            id: 'tqLgSearch',
            icon: 'glyphicon glyphicon-search',
            label: 'Search'
        }, {
            id: 'tqLgZoomIn',
            icon: 'glyphicon glyphicon-zoom-in',
            label: 'Zoom in',
            callback: function callback() {
                _zooming = _lineageGram.zoomIn();
                _toolbar.rootHtml.querySelector('#tqLgZoomIn').disabled = _zooming.cur === _zooming.max;
                _toolbar.rootHtml.querySelector('#tqLgZoomOut').disabled = _zooming.cur === _zooming.min;
            }
        }, {
            id: 'tqLgZoomOut',
            icon: 'glyphicon glyphicon-zoom-out',
            label: 'Zoom out',
            callback: function callback() {
                _zooming = _lineageGram.zoomOut();
                _toolbar.rootHtml.querySelector('#tqLgZoomIn').disabled = _zooming.cur === _zooming.max;
                _toolbar.rootHtml.querySelector('#tqLgZoomOut').disabled = _zooming.cur === _zooming.min;
            }
        }, {
            id: 'tqLgZoomToFit',
            icon: 'glyphicon glyphicon-fullscreen',
            label: 'Zoom to fit',
            callback: function callback() {
                _zooming = _lineageGram.zoomToFit();
            }
        }, {
            id: 'tqLgReset',
            icon: 'glyphicon glyphicon-refresh',
            label: 'Reset layout',
            callback: function callback() {
                _lineageGram.resetLayout();
            }
        }, {
            id: 'tqLgGather',
            icon: 'glyphicon glyphicon-pushpin',
            label: 'Gather relatives',
            callback: function callback() {
                _lineageGram.combine();
            }
        }, {
            id: 'expandAll',
            icon: 'glyphicon glyphicon-resize-full',
            icon2: 'glyphicon glyphicon-resize-small',
            label: 'Expand all nodes',
            callback: function callback() {
                if (_expandAll) {
                    _lineageGram.expandAllNodes();
                } else {
                    _lineageGram.collapseAllNodes();
                }
                _expandAll = !_expandAll;
            }
        }, _coloredButtons, _switcher, {
            id: 'infoPanelBtn',
            icon: 'glyphicon glyphicon-info-sign',
            label: 'Info panel'
        }, {
            id: 'tqLgOptionsButton',
            icon: 'glyphicon glyphicon-menu-hamburger'
        }]
    });
    self.toolbar = _toolbar;

    _lineageGram.on('current-view-changed', function (viewId) {
        var disabled = viewId !== 'lineageDiagram';
        _switcher.setState(viewId);
        _toolbar.rootHtml.querySelector('#expandAll').disabled = disabled;
        _toolbar.rootHtml.querySelector('#tqLgReset').disabled = disabled;
        _toolbar.rootHtml.querySelector('#tqLgZoomIn').disabled = disabled;
        _toolbar.rootHtml.querySelector('#tqLgZoomOut').disabled = disabled;
        _toolbar.rootHtml.querySelector('#tqLgZoomToFit').disabled = disabled;
    });

    new _visualizationsLibrary2.default.SearchPanel({
        baseElement: tqLgSearchPanel,
        triggerButton: _toolbar.rootHtml.querySelector('#tqLgSearch'),
        active: false
    });

    new _infoPanel2.default({
        baseElement: tqLgInfoPanel,
        active: false,
        triggerButton: _toolbar.rootHtml.querySelector('#infoPanelBtn'),
        lineageGram: _lineageGram
    });

    new _optionsPanel2.default({
        lineageGram: _lineageGram,
        baseElement: tqLgOptionsPanel,
        active: false,
        triggerButton: _toolbar.rootHtml.querySelector('#tqLgOptionsButton'),
        legends: options.legends,
        onPressHelp: options.onPressHelp
    });

    new _map2.default({
        baseElement: tqLgMiniMap,
        active: false,
        lineageGram: _lineageGram,
        position: {
            x: 'calc(100% - 265px)',
            y: 'calc(100% - 265px)'
        }
    });
}
exports.default = DefaultUI;

},{"./infoPanel":34,"./map":35,"./optionsPanel":36,"./viewFrameButtons":38,"visualizations-library":5}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.DMDefaultUI = DMDefaultUI;

var _visualizationsLibrary = require('visualizations-library');

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

var _dmInfoPanel = require('./dmInfoPanel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Parameters set for a {@link Toolbar}.
 * @typedef {Object} DefaultUIOptions
 * @property {HTMLElement | String} baseElement - Root HTMLElement
 * @property {Object.<string, LegendDescriptor>} legends
 * @property {string} neighborGramViewClass
 */

/**
 * @private
 * @param {DefaultUIOptions} options
 */
function DMDefaultUI(options) {
    var self = this;
    var _derivationMap = options.derivationMap;
    var _base = _createBase(_getHtmlElement(options.baseElement), _getHtmlElement(options.infoPanel));
    var _expandAll = true;

    // Initialization
    // ==================================================

    var baseTools = [{
        id: 'tqDMSearch',
        icon: 'glyphicon glyphicon-search',
        label: 'Search',
        callback: _openCloseSearchPanel
    }, {
        id: 'tqDMExportSVG',
        icon: 'tool-bar-svg-icon',
        label: 'Export to SVG',
        callback: function callback() {
            _derivationMap.exportToSvg();
        }
    }, {
        id: 'tqDMExportPNG',
        icon: 'tool-bar-png-icon',
        label: 'Export to PNG',
        callback: function callback() {
            _derivationMap.exportToPng();
        }
    }, {
        id: 'tqPrint',
        icon: 'glyphicon glyphicon-print',
        label: 'Print',
        callback: function callback() {
            _derivationMap.print();
        }
    }, {
        id: 'tqDMZoomIn',
        icon: 'glyphicon glyphicon-zoom-in',
        label: 'Zoom in',
        callback: function callback() {
            _derivationMap.zoomIn();
        }
    }, {
        id: 'tqDMZoomOut',
        icon: 'glyphicon glyphicon-zoom-out',
        label: 'Zoom out',
        callback: function callback() {
            _derivationMap.zoomOut();
        }
    }, {
        id: 'tqDMZoomToFit',
        icon: 'glyphicon glyphicon-fullscreen',
        label: 'Zoom to fit',
        callback: function callback() {
            _derivationMap.zoomToFit();
        }
    }, {
        id: 'infoPanelBtn',
        icon: 'glyphicon glyphicon-info-sign',
        label: 'Open Info panel'
    }, {
        id: 'expandAll',
        icon: 'glyphicon glyphicon-resize-full',
        icon2: 'glyphicon glyphicon-resize-small',
        label: 'Expand all',
        callback: function callback() {
            if (_expandAll) {
                _derivationMap.expandAllElements();
            } else {
                _derivationMap.collapseAllElements();
            }
            _expandAll = !_expandAll;
        }
    }];

    if (options.tools) {
        options.tools.forEach(function (tool) {
            if (tool.position < baseTools.length) {
                baseTools.splice(tool.position, 0, tool);
            } else {
                baseTools.push(tool);
            }
        });
    }

    self.toolbar = new _visualizationsLibrary2.default.Toolbar({
        baseElement: _base.toolbar,
        tools: baseTools
    });

    self.infoPanel = new _dmInfoPanel.DMInfoPanel({
        baseElement: _base.infoPanel,
        triggerButton: self.toolbar.rootHtml.querySelector('#infoPanelBtn')
    });

    self.infoPanel.on('size-changed', function () {
        return _derivationMap.resetFocus();
    });

    self.infoPanel.on('element-click', function (elementId) {
        _derivationMap.setSelectedElement(elementId);
    });

    // =======================================================

    var searchPaneVisible = false;
    var debounce = false;
    var searchButton = self.toolbar.rootHtml.querySelector('#tqDMSearch');
    var searchInput = _base.searchPanel.querySelector('input');
    searchInput.onkeyup = function () {
        if (debounce) clearTimeout(debounce);

        debounce = setTimeout(function () {
            var searchKey = searchInput.value;
            _derivationMap.setSearchKey(searchKey);
        }, 300);
    };
    function _openCloseSearchPanel() {
        if (searchPaneVisible) {
            _derivationMap.setSearchKey(undefined);
            _base.searchPanel.classList.add('tq-dm-hidden');
            searchButton.classList.remove('tq-ui-selected');
        } else {
            _derivationMap.setSearchKey(searchInput.value);
            _base.searchPanel.classList.remove('tq-dm-hidden');
            searchButton.classList.add('tq-ui-selected');
        }
        searchPaneVisible = !searchPaneVisible;
    }

    function _getHtmlElement(baseElement) {
        var baseHtml = void 0;
        if (typeof baseElement === 'string') {
            baseHtml = document.getElementById(baseElement);
        } else if ((typeof baseElement === 'undefined' ? 'undefined' : _typeof(baseElement)) === 'object') {
            baseHtml = baseElement;
        }
        if (!baseHtml) throw new Error('Base element is not found!');
        return baseHtml;
    }

    /**
     * Creates html markup.
     * @private
     * @param {HTMLElement} htmlNode - Root node for markup
     * @returns {Object.<string, HTMLElement>} - Map of html elements
     */
    function _createBase(htmlNode, infoPanel) {
        htmlNode.innerHTML = '';
        htmlNode.tabIndex = 1;

        var toolbarBase = document.createElement('DIV');
        toolbarBase.className = 'tq-derivation-map__toolbar';
        toolbarBase.id = 'tq-derivation-map-toolbar';
        htmlNode.appendChild(toolbarBase);

        var searchPanel = document.createElement('DIV');
        searchPanel.className = 'tq-derivation-map_search-pane tq-dm-hidden';
        searchPanel.innerHTML = '\n            <input\n                id="tq-dm-search-pane"\n                type="text"\n                class="tq-derivation-map_search-pane__input">\n            </input>\n        ';
        htmlNode.appendChild(searchPanel);

        return {
            searchPanel: searchPanel,
            rootHtml: htmlNode,
            infoPanel: infoPanel,
            toolbar: toolbarBase
        };
    }
}
exports.default = DMDefaultUI;

},{"./dmInfoPanel":33,"visualizations-library":5}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.DMInfoPanel = DMInfoPanel;

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _mapElements = require('../jointViews/derivationMap/mapElements');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @private
 * The data model for a {@link DMInfoPanel} object.
 * @typedef {Object} DMInfoPanelModel
 * @property {string|HTMLElement} baseElement - Root for this panel
 * @property {LineageGram} derivationMap - DerivationMap object.
 */

/**
 * @private
 * @class
 * @param {DMInfoPanelModel} - Data model.
 * @fires size-changed
 * @fires element-click (id:string)
*/
function DMInfoPanel(parameters) {
    _subscribeable2.default.apply(this); // make this class Subscribable
    var self = this;

    if (!parameters) parameters = {};

    var _selectedElement = parameters.selectedElement;
    var _width = 250;
    var _hidden = true;
    // ===================================================
    self.rootHtml = _getElement(parameters.baseElement);

    var _container = document.createElement('DIV');
    _container.className = 'tq-lg-dm-property-pane-container';
    self.rootHtml.appendChild(_container);

    var _triggerButton = parameters.triggerButton;
    _triggerButton.onclick = function () {
        if (_hidden) {
            _show();
        } else {
            _hide();
        }
    };

    var _slider = document.createElement('DIV');
    _slider.className = 'tq-lg-dm-slider';
    _slider.addEventListener('mousedown', function (event) {
        _onMousedown(event);
    });
    _container.appendChild(_slider);

    var _closeButton = document.createElement('DIV');
    _closeButton.setAttribute('title', 'Close info panel');
    _closeButton.className = 'tq-lg-dm-hide-button';
    _closeButton.onclick = function () {
        _hide();
    };
    _container.appendChild(_closeButton);

    self.body = document.createElement('DIV');
    _container.appendChild(self.body);
    // ===================================================
    self.id = 'derivationMapInfoPanel';
    self.redraw = _redraw;
    self.setSelectedElement = _setSelectedElement;
    self.show = _show;
    self.hidde = _hide;
    // width: 250px;

    _redraw();

    function _redraw() {
        if (_hidden) return;
        var markup = void 0;
        if (_selectedElement) {
            if (_selectedElement instanceof _mapElements.Node) {
                markup = _getNodeInfo(_selectedElement);
            } else if (_selectedElement instanceof _mapElements.Link) {
                markup = _getLinkInfo(_selectedElement);
            } else {
                markup = '\n                    <div class="tq-lg-dm-property-pane tq-lg-dm-empty">\n                        <div>Unknown type of element</div>\n                    </div>\n                ';
            }
        } else {
            markup = '\n                <div class="tq-lg-dm-property-pane tq-lg-dm-empty">\n                    <div>Select a diagram element</div>\n                </div>\n            ';
        }
        self.body.style.width = _width + 'px';
        self.body.innerHTML = markup;

        if (_selectedElement instanceof _mapElements.Node) {
            var children = self.body.querySelectorAll('.tq-lg-dm-child-button');
            for (var i = 0; i < children.length; i++) {
                children[i].onclick = function () {
                    self.trigger('element-click', this.id);
                };
            }
        } else if (_selectedElement instanceof _mapElements.Link) {
            self.body.querySelector('.tq-lg-dm-source-button').onclick = function () {
                self.trigger('element-click', this.id);
            };
            self.body.querySelector('.tq-lg-dm-target-button').onclick = function () {
                self.trigger('element-click', this.id);
            };
        } else {
            //...
        }
    }

    function _getNodeInfo(node) {
        var chilren = node.children.map(function (child) {
            return '<div\n                id="' + child.id + '"\n                title="' + child.label + '(' + child.endpointId + ')"\n                type="text"\n                class="tq-ui-property-button tq-lg-dm-child-button">\n                ' + child.label + '\n            </div>';
        }).join('');
        return '\n            <div class="tq-lg-dm-property-pane">\n                <label class="tq-label">ID</label>\n                <input\n                    value="' + node.endpointId + '"\n                    title="' + node.endpointId + '" type="text"  class="tq-ui-property" disabled>\n                </input>\n                <label class="tq-label">Diagram ID</label>\n                <input\n                    value="' + node.id + '"\n                    title="' + node.id + '"\n                    type="text"\n                    class="tq-ui-property"\n                    disabled>\n                </input>\n                <label class="tq-label">Label</label>\n                <input value="' + node.label + '" title="' + node.label + '" type="text" class="tq-ui-property" disabled></input>\n                ' + (chilren.length > 0 ? '<label class="tq-label">Children</label>' : '') + '\n                ' + chilren + '\n            </div>\n        ';
    }

    function _getLinkInfo(link) {
        return '\n            <div class="tq-lg-dm-property-pane">\n                <label class="tq-label">Label</label>\n                <input value="' + link.label + '" title="' + link.label + '" type="text" class="tq-ui-property" disabled></input>\n                <label class="tq-label">Source</label>\n                <div id="' + link.source.id + '"\n                    title="' + link.source.label + '(' + link.source.endpointId + ')"\n                    type="text"\n                    class="tq-ui-property-button tq-lg-dm-source-button">\n                    ' + link.source.label + '\n                </div>\n                <label class="tq-label">Target</label>\n                <div id="' + link.target.id + '"\n                    title="' + link.target.label + '(' + link.target.endpointId + ')"\n                    type="text"\n                    class="tq-ui-property-button tq-lg-dm-target-button">\n                    ' + link.target.label + '\n                </div>\n            </div>\n        ';
    }

    var SELECTED_CLASS = 'tq-ui-selected';
    function _show() {
        _hidden = false;
        _container.style.display = null;
        _triggerButton.classList.add(SELECTED_CLASS);
        _redraw();
        setTimeout(function () {
            self.trigger('size-changed');
        }, 0);
    }

    function _hide() {
        _hidden = true;
        _container.style.display = 'none';
        _triggerButton.classList.remove(SELECTED_CLASS);
        setTimeout(function () {
            self.trigger('size-changed');
        }, 0);
    }

    function _onMousedown(event) {
        var startX = 0;
        var MIN_WIDTH = 100;

        if (event.pageX) startX = event.pageX;else if (event.clientX) startX = event.clientX;

        window.getSelection().removeAllRanges();

        document.body.addEventListener('mousemove', _onchange);
        document.body.addEventListener('mouseup', _onmouseup);

        function _onchange(event) {
            var endX = 0;

            if (event.pageX) endX = event.pageX;else if (event.clientX) endX = event.clientX;

            var diffX = startX - endX;
            startX = endX;

            _width += diffX;
            _width = Math.max(MIN_WIDTH, _width);
            self.trigger('size-changed');
            _redraw();
        }

        function _onmouseup(event) {
            if (self._mouseMove) {
                _onchange(event, true);
                self._mouseMove = false;
            }
            document.body.onmousemove = document.body.onmouseup = null;
            document.body.removeEventListener('mousemove', _onchange);
            document.body.removeEventListener('mouseup', _onmouseup);
        }
    }

    function _setSelectedElement(element) {
        _selectedElement = element;
        _redraw();
    }
}
exports.default = DMInfoPanel;


function _getElement(el) {
    var element = void 0;
    if (typeof el === 'string') {
        element = document.getElementById(el);
    } else if ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object') {
        element = el;
    }
    return element;
}

},{"../jointViews/derivationMap/mapElements":42,"../subscriptionAPI/subscribeable":65}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InfoPanel = InfoPanel;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _visualizationsLibrary = require('visualizations-library');

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * The data model for a {@link InfoPanel} object.
 * @typedef {Object} InfoPanelModel
 * @property {string|HTMLElement} baseElement - Root for this panel
 * @property {LineageGram} lineageGram - LineageGram object.
 * @property {boolean} active - false - collapsed, true - expanded
 * @property {string|HTMLElement} triggerButton
 * @property {Function} onPressExternal
 */

/**
 * Class which is a simple UI panel.
 * This panel can represent an information about selected element
 * and also, it supports simple navigation between elements.
 * @class
 * @param {InfoPanelModel} options - Data model.
 * @fires state-changed
*/
function InfoPanel(options) {
    _subscribeable2.default.apply(this); // make this class Subscribable

    var infoTemplate = new _visualizationsLibrary2.default.InfoPanel({ launchExternal: options.lineageGram.launchExternal });

    var _lineageGram = options.lineageGram;

    _visualizationsLibrary2.default.FlyingPanel.apply(this, [{
        baseElement: options.baseElement,
        active: options.active,
        header: 'Info panel',
        triggerButton: options.triggerButton,
        launchExternal: options.onPressExternal,
        emptyBody: false,
        size: { width: '300px', height: '450px' },
        body: infoTemplate,
        resizable: true
    }]);

    _lineageGram.on('selected-element-changed', function (elementModel) {
        var graphModel = _lineageGram.getGraphModel();
        var nodeMap = graphModel.maps.nodeMap;

        if (elementModel) {
            var source = nodeMap[elementModel.source];
            var target = nodeMap[elementModel.target];

            var data = void 0;
            if (elementModel.linkType && elementModel.group) {
                data = {};
                elementModel.group.forEach(function (el) {
                    return data = _.merge(data, el.data);
                });
            } else {
                data = _.cloneDeep(elementModel.data) || {};
            }

            if (elementModel.linkType) {
                if (elementModel.linkType && !elementModel.group) {
                    data['Link type'] = elementModel.linkType;
                } else {
                    var typeMap = {};
                    elementModel.group.forEach(function (el) {
                        return typeMap[el.linkType] = el;
                    });
                    var types = Object.keys(typeMap);
                    if (types.length > 1) {
                        data['Link type'] = elementModel.linkType;
                        data['Grouped types'] = types.join(', ');
                    } else {
                        data['Link type'] = types[0];
                    }
                    data['IDs'] = elementModel.group.map(function (el) {
                        return el.id;
                    }).join(', ');
                }
            }

            if (elementModel.offset) data['Offset'] = elementModel.offset;
            if (elementModel.viewFrame) data['View frame'] = elementModel.viewFrame;

            infoTemplate.setSelectedElement({
                id: elementModel.id,
                label: elementModel.label,
                resource: elementModel.resource,
                resourceType: elementModel.resourceType,
                diagramType: elementModel.diagramType,
                types: elementModel.typeId,
                source: source ? {
                    id: source.id,
                    label: source.label
                } : undefined,
                target: target ? {
                    id: target.id,
                    label: target.label
                } : undefined,
                data: data,
                relations: _getRelations(elementModel, graphModel)
            });
        } else {
            infoTemplate.setSelectedElement(undefined);
        }
    });

    infoTemplate.on('selected-element-changed', function (elementId) {
        _lineageGram.setSelectedElement(elementId);
    });

    function _getAspects(elementModel, nodes) {
        var aspects = [];
        if (elementModel.resource) {
            nodes.forEach(function (node) {
                if (node.resource === elementModel.resource) aspects.push(node);
            });
        } else {
            aspects.push(elementModel);
        }
        return aspects;
    }

    function _getRelations(elementModel, graphModel) {
        var sourceMap = graphModel.maps.sourceMap;
        var targetMap = graphModel.maps.targetMap;
        var nodeMap = graphModel.maps.nodeMap;

        var ids = _getAspects(elementModel, graphModel.nodes).map(function (a) {
            return a.id;
        });

        var sources = [];
        var targets = [];
        ids.forEach(function (id) {
            if (sourceMap[id]) {
                sources = sources.concat(sourceMap[id].map(function (l) {
                    var node = nodeMap[l.source];
                    return {
                        id: node.id,
                        label: node.label
                    };
                }));
            }
            if (targetMap[id]) {
                targets = targets.concat(targetMap[id].map(function (l) {
                    var node = nodeMap[l.target];
                    return {
                        id: node.id,
                        label: node.label
                    };
                }));
            }
        });

        if (sources && sources.length > 0 || targets && targets.length > 0) {
            return {
                incomings: sources,
                outgoings: targets
            };
        }
        return undefined;
    }
}
exports.default = InfoPanel;

},{"../subscriptionAPI/subscribeable":65,"lodash":"lodash","visualizations-library":5}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.Map = Map;

var _visualizationsLibrary = require('visualizations-library');

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Map(options) {
    var markup = '\n        <div id="mapButton" class="tq-lg-map">\n            <span title="Mini map" class="tq-lg-collapse-panel_body__label glyphicon glyphicon-picture" aria-hidden="true"></span>\n        </div>\n        <div id="baseElementForMap"></div>\n    ';
    var _lineageGram = options.lineageGram;

    var _el = void 0;

    if (typeof options.baseElement === 'string') {
        _el = document.getElementById(options.baseElement);
    } else if (_typeof(options.baseElement) === 'object') {
        _el = options.baseElement;
    }
    if (!_el) return;

    _el.innerHTML = markup;

    var mapFlyingPanel = new _visualizationsLibrary2.default.FlyingPanel({
        baseElement: _el.querySelector('#baseElementForMap'),
        active: options.active,
        header: 'Map',
        triggerButton: _el.querySelector('#mapButton'),
        emptyBody: false,
        size: { width: '250px', height: '250px' },
        position: options.position,
        body: '',
        resizable: true
    });

    _lineageGram.setRootHtmlForMap(mapFlyingPanel.rootHtml.querySelector('.tq-ui-body_container'));

    mapFlyingPanel.on('size-changed', function () {
        _lineageGram.refresh('graphMap');
    });
}
exports.default = Map;

},{"visualizations-library":5}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OptionsPanel = OptionsPanel;

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _visualizationsLibrary = require('visualizations-library');

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The data model for a {@link OptionsPanel} object.
 * @typedef {Object} OptionsPanelModel
 * @property {string|HTMLElement} baseElement - Root for this panel
 * @property {LineageGram} lineageGram - LineageGram object.
 * @property {boolean} active - false - collapsed, true - expanded
 * @property {string|HTMLElement} triggerButton
 */

/** 
 * Class which is a simple UI panel.
 * This panel can represent an information about selected element
 * and also, it supports simple navigation between elements.
 * @class
 * @param {OptionsPanelModel} options - Data model.
 * @fires state-changed
*/
function OptionsPanel(options) {
    _subscribeable2.default.apply(this); // make this class Subscribable

    var legends = options.legends || [];
    var _lineageGram = options.lineageGram;
    var self = this;

    _visualizationsLibrary2.default.FlyingPanel.apply(this, [{
        baseElement: options.baseElement,
        active: options.active,
        header: 'Options panel',
        triggerButton: options.triggerButton,
        emptyBody: true,
        size: {
            width: '400px',
            height: '500px'
        },
        removeBackground: true,
        body: new _visualizationsLibrary2.default.TabPanel({
            tabs: [{
                id: 'tqUiGeneral',
                label: 'General',
                body: '\n                        <label for="displayGroup" class="tq-label">Display</label>\n                        <div id="displayGroup" class="tq-ui-group">\n                            <div class="tq-ui-group__select-line">\n                                <select id="tqUiOrientation" size="1" name="orientation">\n                                    <option value="left-to-right">left to right</option>\n                                    <option value="right-to-left">right to left</option>\n                                    <option value="top-to-bottom">top to bottom</option>\n                                    <option value="bottom-to-top">bottom to top</option>\n                                </select>\n                                <span> - Graph orientation</span>\n                            </div>\n                            <div class="tq-ui-group__select-line">\n                                <select id="tqUiRouting" size="1" name="routing">\n                                    <option value="metro">Metro</option>\n                                    <option value="lgrouter">RailRoad</option>\n                                    <option value="normal">Normal</option>\n                                    <option value="manhattan">Manhattan</option>\n                                </select>\n                                <span> - Link routing</span>\n                            </div>\n                            <div class="tq-ui-group__select-line">\n                                <select id="tqUiLayout" size="1" name="layout">\n                                    <option value="sankey">Sankey</option>\n                                    <option value="flow-directed">Flow-directed</option>\n                                </select>\n                                <span> - Layout algorithm</span>\n                            </div>\n                            <div class="tq-ui-group__check-box-line">\n                                <span><input id="tqUiExpandCollapse" type="checkbox"></span>\n                                <span>Expand node containers to show full text labels</span>\n                            </div>\n                            <div class="tq-ui-group__check-box-line">\n                                <span><input id="tqUiClipNodes" type="checkbox"></span>\n                                <span>Nodes trimming on borders</span>\n                            </div>\n                        </div>\n                        <label for="exportGroup" class="tq-label">Export as</label>\n                        <div id="exportGroup" class="tq-ui-group tq-ui-export-group">\n                            <button id="tqUiExportSVG" title="Export diagram to SVG" class="tq-button">SVG</button>\n                            <button id="tqUiExportPNG" title="Export diagram to PNG" class="tq-button">PNG</button>\n                            <button id="tqUiPrint" title="Print" class="tq-button">\n                                <span class="glyphicon glyphicon-print"></span>\n                            </button>\n                        </div>\n                        <label for="howToUseGroup" class="tq-label">How to use</label>\n                        <div id="howToUseGroup" class="tq-ui-group tq-ui-opt-group">\n                            <button id="tqUiHelpBtn" title="Help" class="tq-button">\n                                <span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span>\n                            </button>\n                            <a class="tq-button" title="Documentation" href="./documentation/index.html">DOC</a>\n                        </div>\n                    '
            }, {
                id: 'tqUiLegends',
                label: 'Legends',
                body: new _visualizationsLibrary2.default.Legends({ legends: legends })
            }]
        })
    }]);

    // General

    var svgButton = self.rootHtml.querySelector('#tqUiExportSVG');
    var pngButton = self.rootHtml.querySelector('#tqUiExportPNG');
    var printButton = self.rootHtml.querySelector('#tqUiPrint');
    var expandCollapse = self.rootHtml.querySelector('#tqUiExpandCollapse');
    var orientation = self.rootHtml.querySelector('#tqUiOrientation');
    var routing = self.rootHtml.querySelector('#tqUiRouting');
    var layout = self.rootHtml.querySelector('#tqUiLayout');
    var clipping = self.rootHtml.querySelector('#tqUiClipNodes');
    var helpButton = self.rootHtml.querySelector('#tqUiHelpBtn');

    _lineageGram.on('current-view-changed', function (viewId) {
        svgButton.disabled = viewId !== 'lineageDiagram';
        expandCollapse.disabled = viewId !== 'lineageDiagram';
    });

    svgButton.onclick = function () {
        _lineageGram.export({
            type: 'svg',
            view: 'lineageDiagram'
        });
    };
    pngButton.onclick = function () {
        _lineageGram.export({
            type: 'png'
        });
    };
    printButton.onclick = function () {
        _lineageGram.print();
    };

    expandCollapse.onchange = function () {
        if (expandCollapse.checked) {
            _lineageGram.expandAllNodes();
        } else {
            _lineageGram.collapseAllNodes();
        }
    };

    orientation.value = _lineageGram.getOrientation();
    orientation.onchange = function () {
        _lineageGram.setOrientation(orientation.value);
    };

    routing.value = _lineageGram.getRouting();
    routing.onchange = function () {
        _lineageGram.setRouting(routing.value);
    };

    layout.value = _lineageGram.getLayoutAlgorithm();
    layout.onchange = function () {
        _lineageGram.setLayoutAlgorithm(layout.value);
    };

    helpButton.onclick = options.onPressHelp;

    clipping.checked = _lineageGram.getClipping();
    clipping.onchange = function () {
        _lineageGram.setClipping(clipping.checked);
    };

    helpButton.onclick = options.onPressHelp;
}
exports.default = OptionsPanel;

},{"../subscriptionAPI/subscribeable":65,"visualizations-library":5}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Splitter = Splitter;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * 
 * Html-UI element which manage size of two splitted windows.
 * 
 * Constructor parameters:
 * ========================================
 * @param {
 *  viewFrameA: ViewFrame,
 *  viewFrameB: ViewFrame,
 * } model
 * @param {Object} parameters - parameters set
 * 
 * Public properties:
 * ========================================
 * el: HTMLELement
 * 
 * Public methods:
 * ========================================
 * on (event: string, callback: function): void
 * unsubscribe (callback: function): void
 * trigger (event: string, parameters: any): void
 * 
 * Events:
 * ===========================================
 * @fires diff({ diff: number, lastChange: boolean })
 */
function Splitter(model, parameters) {
    // Init
    // ===================================================================
    // ===================================================================
    _subscribeable2.default.apply(this); // make this class Subscribable

    var self = this;
    var _graphOrientation = parameters.graphOrientation === 'left-to-right' || parameters.graphOrientation === 'right-to-left';
    var _visible = true;

    self.model = model;
    if (parameters.graphOrientation === 'right-to-left' || parameters.graphOrientation === 'bottom-to-top') {
        _swapViewFrames();
    }

    self.el = document.createElement('DIV');
    self.el.className = _graphOrientation ? 'tq_lineage_ui__view-frame-splitter' : 'tq_lineage_ui__view-frame-splitter-vertical';
    self.el.addEventListener('mousedown', _onmousedown);

    var start = 0;
    function _onmousedown(event) {
        event = event || window.event;
        start = 0;
        window.getSelection().removeAllRanges();

        if (_graphOrientation) {
            if (event.pageX) start = event.pageX;else if (event.clientX) start = event.clientX;
        } else {
            if (event.pageY) start = event.pageY;else if (event.clientY) start = event.clientY;
        }

        document.body.addEventListener('mousemove', _onchange);
        document.body.addEventListener('mouseup', _onmouseup);

        function _onchange(event, onMouseUp) {
            event = event || window.event;
            var end = 0;

            if (_graphOrientation) {
                if (event.pageX) end = event.pageX;else if (event.clientX) end = event.clientX;
            } else {
                if (event.pageY) end = event.pageY;else if (event.clientY) end = event.clientY;
            }

            var diff = end - start;
            start = end;
            self.trigger('splitter-position-changed', { diff: _limitDiff(diff), lastChange: onMouseUp });
        }

        function _onmouseup(event) {
            _onchange(event, true);
            document.body.onmousemove = document.body.onmouseup = null;
            document.body.removeEventListener('mousemove', _onchange);
            document.body.removeEventListener('mouseup', _onmouseup);
        }
    }

    // ===================================================================
    // ===================================================================

    self.updateNeighbour = function (newNeighbour) {
        if (self.model.viewFrameB !== newNeighbour) {
            self.model.viewFrameB = newNeighbour;
        }
    };

    self.hide = function () {
        if (_visible) {
            self.el.style.display = 'none';
            _visible = false;
        }
    };

    self.show = function () {
        if (!_visible) {
            self.el.style.display = '';
            _visible = true;
        }
    };

    function _swapViewFrames() {
        var temp = model.viewFrameA;
        model.viewFrameA = model.viewFrameB;
        model.viewFrameB = temp;
    }

    function _limitDiff(diff) {
        if (diff === 0) return;
        var vfA = self.model.viewFrameA;
        var vfB = self.model.viewFrameB;

        var sideA = void 0;
        var sideB = void 0;
        var minSideShouldBe = void 0;

        if (_graphOrientation) {
            sideA = vfA.size.width;
            sideB = vfB.size.width;
            minSideShouldBe = parameters.framePadding.x * 2 + 1;
        } else {
            sideA = vfA.size.height;
            sideB = vfB.size.height;
            minSideShouldBe = parameters.framePadding.y * 2 + 1;
        }

        var resultSideA = sideA + diff;
        var resultSideB = sideB - diff;

        var limitationA = 0;
        var limitationB = 0;
        if (resultSideA < minSideShouldBe && resultSideB < minSideShouldBe) {
            return;
        }
        if (resultSideA < minSideShouldBe) {
            limitationA = minSideShouldBe - resultSideA;
        }
        if (resultSideB < minSideShouldBe) {
            limitationB = resultSideB - minSideShouldBe;
        }
        if (limitationA !== 0 || limitationB !== 0) {
            var resultDiff = Math.abs(limitationA) > Math.abs(limitationB) ? diff + limitationA : diff + limitationB;
            var _resultSideA = sideA + resultDiff;
            var _resultSideB = sideB - resultDiff;
            if (_resultSideA < minSideShouldBe || _resultSideB < minSideShouldBe) {
                return;
            }
            return resultDiff;
        } else {
            return diff;
        }
    }
}
Splitter.prototype = Object.create(joint.shapes.basic.Rect.prototype);

exports.default = Splitter;

},{"../subscriptionAPI/subscribeable":65,"rappid":"rappid"}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ViewFrameButtons = ViewFrameButtons;
/**
 * ColoredButtonModel - data model for ColoredButtons in the ColoredButtonsList
 * @typedef {Object} ColoredButtonModel
 * @property {string} id - String id
 * @property {string} label - are used for implementing tooltip and icon
 * @property {string} borderColor - Border color
 * @property {string} backgroundColor - Background color
 * @property {function} callback - Function wich will be colled on mouse click on button
*/

var uniqueId = 0;

/**
 * Class is a collection of colored buttons,
 * which use first letters of the label as an icons for the buttons.
 * (Initially it was developed as a collection of collapsed viewFrames for LineageGram)
 * @class
 * @augments TQUIElement
 * @param {LineageGram} lineageGram
 * 
 * @property {ColoredButtonModel[]} buttons - list of button models
*/
function ViewFrameButtons(parameters) {
    var self = this;
    if (!parameters) throw Error('The arguments parameters shouldn\'t be undefined!');
    if (!parameters.lineageGram) throw Error('lineageGram field is undefined!');

    self.rootHtml = _initRootElement();
    self.id = parameters.lineageGram.id || 'coloredButtons-' + uniqueId++;
    self.rootHtml.id = self.id;

    var _lineageGram = parameters.lineageGram;
    var _state = {};
    var _buttons = {};
    var _overViewFrameButton = void 0;

    _createButtons();

    _lineageGram.on('view-frame-state-changed', _updateButtons);
    _lineageGram.on('history-state-changed', _createButtons);

    function _createButtons() {
        var viewFrames = _lineageGram.getViewFrames();
        var overViewFrame = _lineageGram.getOverViewFrame();

        _state = {};
        _buttons = {};
        self.rootHtml.innerHTML = '';

        if (overViewFrame) {
            _overViewFrameButton = createButton(overViewFrame);
            _overViewFrameButton.style.borderColor = null;
            _overViewFrameButton.style.backgroundColor = null;
            _overViewFrameButton.style.color = null;
            _overViewFrameButton.classList.add('tq-ui-colored-buttons-overview');
            self.rootHtml.appendChild(_overViewFrameButton);
        }

        viewFrames.forEach(function (viewFrame) {
            if (viewFrame.id !== overViewFrame.id) {
                var htmlButton = createButton(viewFrame);
                _buttons[viewFrame.id] = htmlButton;
                self.rootHtml.appendChild(htmlButton);
            }
        });

        _updateButtons();

        function createButton(viewFrame) {
            var htmlButton = document.createElement('BUTTON');

            htmlButton.className = 'tq-ui-toolbar__button tq-ui-colored-button';

            if (viewFrame.isOverView) {
                htmlButton.classList.add('tq-ui-colored-buttons-overview');
                htmlButton.onclick = function () {
                    if (_state[viewFrame.id]) {
                        _lineageGram.setFullScreenMode(false);
                    } else {
                        _lineageGram.setFullScreenMode(true);
                    }
                };
            } else {
                htmlButton.innerHTML = '<span>' + _getShortLabel(viewFrame.label) + '</span>';
                htmlButton.style.backgroundColor = viewFrame.backgroundColor || 'white';
                htmlButton.style.borderColor = viewFrame.borderColor || 'black';
                htmlButton.style.color = viewFrame.borderColor || 'black';
                htmlButton.onclick = function () {
                    if (_state[viewFrame.id]) {
                        _lineageGram.collapseViewFrame(viewFrame.id);
                    } else {
                        _lineageGram.expandViewFrame(viewFrame.id);
                    }
                };
            }

            _state[viewFrame.id] = viewFrame.expanded;
            return htmlButton;
        }
    }

    function _updateButtons() {
        var viewFrames = _lineageGram.getViewFrames();
        var overViewFrame = _lineageGram.getOverViewFrame();

        if (overViewFrame) {
            _state[overViewFrame.id] = overViewFrame.active;
            _overViewFrameButton.innerHTML = '<span>' + (overViewFrame.active ? 'F' : 'O') + '</span>';
            if (overViewFrame.active) {
                _overViewFrameButton.title = 'Switch to Frames mode';
                self.rootHtml.classList.add('tq-ui-colored-buttons-collapsed');
            } else {
                _overViewFrameButton.title = 'Switch to single frame mode';
                self.rootHtml.classList.remove('tq-ui-colored-buttons-collapsed');
            }
        }

        viewFrames.forEach(function (viewFrame) {
            if (viewFrame.id !== overViewFrame.id) {
                _state[viewFrame.id] = viewFrame.expanded;
                updateButton(viewFrame);
            }
        });

        function updateButton(viewFrame) {
            var htmlButton = _buttons[viewFrame.id];
            if (_state[viewFrame.id]) {
                htmlButton.title = 'Collapse ' + viewFrame.label;
                htmlButton.classList.remove('tq-ui-selected');
            } else {
                htmlButton.title = 'Expand ' + viewFrame.label;
                htmlButton.classList.add('tq-ui-selected');
            }
        }
    }

    function _getShortLabel(label) {
        if (!label) return;
        var words = label.match(/[a-z'\-]+/gi);
        return words.filter(function (w) {
            return w.toLowerCase() !== 'and' && w !== '&';
        }).map(function (w) {
            return w[0];
        }).join('');
    }

    function _initRootElement() {
        var el = document.createElement('DIV');
        el.className = 'tq-ui-colored-buttons-list';
        el.innerHTML = '';
        return el;
    }
}
exports.default = ViewFrameButtons;

},{}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ViewFramesUI = ViewFramesUI;

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _splitter = require('./splitter');

var _splitter2 = _interopRequireDefault(_splitter);

var _lineageDiagramUtils = require('../utils/lineageDiagramUtils');

var _utils = require('../utils/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @private
 * 
 * Manages the main view of application (View-2)
 * 
 * Constructor parameters:
 * ========================================
 * @param {
 *  rootEl: HTMLElement
 *  viewFrames: Array of ViewFrame
 * } options
 * @param {Object} parameters - parameters set
 * 
 * Public methods:
 * ========================================
 * refreshState (): void
 * updateViewFrames (viewFrames: ViewFrame[]): void
 * ----------------------------------------
 * on (event: string, callback: function): void
 * unsubscribe (callback: function): void
 * trigger (event: string, parameters: any): void
 * 
 * Events:
 * ===========================================
 * @fires view-port-position-changed (ViewFrame)
 * @fires splitter-position-changed (vf: ViewFrame, diff: { diff: number, lastChange: boolean })
 * @fires view-frame-collapsed (ViewFrame, boolean)
 */
function ViewFramesUI(options, parameters) {
    // Init
    // ===================================================================
    // ===================================================================

    _subscribeable2.default.apply(this); // make this class Subscribable

    var self = this;
    var _root = options.rootEl;

    var _orientation = parameters.graphOrientation === 'right-to-left' || parameters.graphOrientation === 'bottom-to-top';
    var _graphOrientation = parameters.graphOrientation === 'left-to-right' || parameters.graphOrientation === 'right-to-left';

    var _viewManager = options.viewManager;
    var _viewFrames = _viewManager.getViewFrames() || [];
    var _viewFramesMap = (0, _utils.arrayToMap)(_viewFrames);
    var _uiSetForViewFrames = void 0;
    var _buttons4Sets = void 0;
    var _splitters = void 0;
    var _uiBody = void 0;

    _createUI();

    // ===================================================================
    // ===================================================================

    /**
     * Refreshes a state of UI. (Change arrows states)
     */
    self.refresh = _refresh;

    /**
     * Set new view manager
     * @param {Array of ViewFrame} viewFrames
     */
    self.setViewManager = function (viewManager) {
        _viewManager = viewManager;
        _viewFrames = _viewManager.getViewFrames();
        _createUI();
    };

    /**
     * It changes orientation of the graph.
     * @param {string} orientation - Values: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
     * @memberof ViewFramesUI
     * @method
     */
    self.setOrientation = function (orientation) {
        _orientation = orientation === 'right-to-left' || orientation === 'bottom-to-top';
        _graphOrientation = orientation === 'left-to-right' || orientation === 'right-to-left';
        _createUI();
    };

    /**
     * Refreshes a state of UI. (Change arrows states)
     */
    function _refresh() {
        _updateViewFrames();
        _refreshUI();
        _viewFrames.forEach(function (vf) {
            if (vf.customeSized) {
                if (vf.size.width) _uiSetForViewFrames[vf.id].style.width = vf.size.width + 'px';
                if (vf.size.height) _uiSetForViewFrames[vf.id].style.height = vf.size.height + 'px';
                _uiSetForViewFrames[vf.id].style.flexGrow = 0;
            } else {
                _uiSetForViewFrames[vf.id].style.flexGrow = vf.spaceShare;
            }
        });
    }

    function _updateViewFrames() {
        _viewFrames = _viewManager.getViewFrames();
        var vfMap = (0, _utils.arrayToMap)(_viewFrames);
        _splitters.forEach(function (splitter) {
            splitter.model.viewFrameA = vfMap[splitter.model.viewFrameA.id];
            splitter.model.viewFrameB = vfMap[splitter.model.viewFrameB.id];
        });
        _viewFramesMap = (0, _utils.arrayToMap)(_viewFrames);
    }

    /**
     * Creates html navigate buttons for the views.
     */
    function _createUI() {
        if (!_root) return;else _root.innerHTML = '';

        _uiBody = document.createElement('DIV');
        _uiBody.className = 'tq_lineage_ui';
        _root.appendChild(_uiBody);
        _splitters = [];

        _uiBody.innerHTML = '';
        _uiSetForViewFrames = {};
        _buttons4Sets = {};

        var MODIFIER = 0.5;

        if (parameters.graphOrientation === 'right-to-left') {
            _uiBody.style.flexDirection = 'row-reverse';
        } else if (parameters.graphOrientation === 'top-to-bottom') {
            _uiBody.style.flexDirection = 'column';
        } else if (parameters.graphOrientation === 'bottom-to-top') {
            _uiBody.style.flexDirection = 'column-reverse';
        } else {
            // horizontal
            _uiBody.style.flexDirection = 'row';
        }

        _viewFrames.forEach(function (vf, index, arr) {
            var viewFrameUi = document.createElement('DIV');
            viewFrameUi.id = (0, _lineageDiagramUtils.cacheIdForViewFrameUI)(vf);
            if (_orientation) {
                viewFrameUi.className = 'tq_lineage_ui_view-frame_' + parameters.graphOrientation;
            } else {
                viewFrameUi.className = 'tq_lineage_ui_view-frame_' + parameters.graphOrientation;
            }

            if (vf.customeSized) {
                if (vf.size.width) viewFrameUi.style.width = vf.size.width + 'px';
                if (vf.size.height) viewFrameUi.style.height = vf.size.height + 'px';
                viewFrameUi.style.flexGrow = 0;
            } else {
                viewFrameUi.style.flexGrow = vf.spaceShare;
            }
            _uiBody.appendChild(viewFrameUi);

            var up = document.createElement('IMG');
            up.className = 'tq_lineage_ui__button tq_lineage_ui__up-button';
            up.onclick = function () {
                var viewFrame = _viewFramesMap[vf.id];
                var curPos = viewFrame.viewPortPosition;
                self.trigger('view-port-position-changed', {
                    id: vf.id,
                    viewPortPosition: { x: curPos.x, y: curPos.y - viewFrame.size.height * MODIFIER }
                });
            };
            viewFrameUi.appendChild(up);

            var down = document.createElement('IMG');
            down.className = 'tq_lineage_ui__button tq_lineage_ui__down-button';
            down.onclick = function () {
                var viewFrame = _viewFramesMap[vf.id];
                var curPos = viewFrame.viewPortPosition;
                self.trigger('view-port-position-changed', {
                    id: vf.id,
                    viewPortPosition: { x: curPos.x, y: curPos.y + viewFrame.size.height * MODIFIER }
                });
            };
            viewFrameUi.appendChild(down);

            var left = document.createElement('IMG');
            left.className = 'tq_lineage_ui__button tq_lineage_ui__left-button';
            left.onclick = function () {
                var viewFrame = _viewFramesMap[vf.id];
                var curPos = viewFrame.viewPortPosition;
                self.trigger('view-port-position-changed', {
                    id: vf.id,
                    viewPortPosition: { x: curPos.x - viewFrame.size.width * MODIFIER, y: curPos.y }
                });
            };
            viewFrameUi.appendChild(left);

            var right = document.createElement('IMG');
            right.className = 'tq_lineage_ui__button tq_lineage_ui__right-button';
            right.onclick = function () {
                var viewFrame = _viewFramesMap[vf.id];
                var curPos = viewFrame.viewPortPosition;
                self.trigger('view-port-position-changed', {
                    id: vf.id,
                    viewPortPosition: { x: curPos.x + viewFrame.size.width * MODIFIER, y: curPos.y }
                });
            };
            viewFrameUi.appendChild(right);

            var collapse = document.createElement('IMG');
            collapse.className = 'tq_lineage_ui__button tq_lineage_ui__collapse-button';
            collapse.onclick = function () {
                self.trigger('view-frame-collapsed', { id: vf.id, expanded: false });
            };
            viewFrameUi.appendChild(collapse);

            _buttons4Sets[vf.id] = {
                up: up,
                down: down,
                left: left,
                right: right
            };

            if (index !== arr.length - 1) {
                var splitter = new _splitter2.default({
                    viewFrameA: vf,
                    viewFrameB: arr[index + 1]
                }, parameters);
                _splitters.push(splitter);
                _uiBody.appendChild(splitter.el);
                splitter.on('splitter-position-changed', function (diff) {
                    self.trigger('splitter-position-changed', [splitter, diff]);
                });
            }

            _uiSetForViewFrames[vf.id] = viewFrameUi;
        });

        _refreshUI();
    }

    /**
     * Refresh navigation buttons. Button isn't active if the viewPort can't move by this direction.
     */
    function _refreshUI() {
        if (!_root) return;
        _refreshSplittersState();

        _viewFrames.forEach(function (vf) {
            var check = (0, _lineageDiagramUtils.checkPagination)(vf);

            _uiSetForViewFrames[vf.id].style.display = vf.active ? '' : 'none';

            var up = _buttons4Sets[vf.id].up;
            var down = _buttons4Sets[vf.id].down;
            var left = _buttons4Sets[vf.id].left;
            var right = _buttons4Sets[vf.id].right;

            up.style.cursor = check.canMoveUp ? 'pointer' : 'not-allowed';
            down.style.cursor = check.canMoveDown ? 'pointer' : 'not-allowed';
            left.style.cursor = check.canMoveLeft ? 'pointer' : 'not-allowed';
            right.style.cursor = check.canMoveRight ? 'pointer' : 'not-allowed';

            up.style.opacity = check.canMoveUp ? '' : '0.03';
            down.style.opacity = check.canMoveDown ? '' : '0.03';
            left.style.opacity = check.canMoveLeft ? '' : '0.03';
            right.style.opacity = check.canMoveRight ? '' : '0.03';
        });
    }

    function _refreshSplittersState() {
        var activeFrames = _viewFrames.filter(function (vf) {
            return vf.active;
        }).sort(function (a, b) {
            var posA = a.position;
            var posB = b.position;
            if (_graphOrientation) {
                return posA.x - posB.x;
            } else {
                return posA.y - posB.y;
            }
        });
        var activeIds = activeFrames.map(function (vf) {
            return vf.id;
        });

        if (_orientation) {
            _splitters.forEach(function (splitter) {
                updateSplitter(splitter);
            });
        } else {
            for (var i = _splitters.length - 1; i >= 0; i--) {
                updateSplitter(_splitters[i]);
            }
        }

        function updateSplitter(splitter) {
            if (splitter.model.viewFrameA.active) {
                var neighbour = getNeighbour(splitter.model.viewFrameA.id);
                if (!neighbour) {
                    splitter.hide();
                } else {
                    splitter.updateNeighbour(neighbour);
                    splitter.show();
                }
            } else {
                splitter.hide();
            }
        }

        function getNeighbour(viewFrameId) {
            if (!viewFrameId) return null;
            var index = activeIds.indexOf(viewFrameId);
            if (index >= 0 && index < activeIds.length - 1) {
                return activeFrames[index + 1];
            } else {
                return null;
            }
        }
    }
}
exports.default = ViewFramesUI;

},{"../subscriptionAPI/subscribeable":65,"../utils/lineageDiagramUtils":68,"../utils/utils":69,"./splitter":37}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.processData = processData;

var _lodash = require('lodash');

var _mapElements = require('./mapElements');

var _resourceProvider = require('../../data/resourceProvider');

function processData(rawData, parameters) {
    var topNodeModels = processNodes(rawData.nodes, parameters);
    var derivationMapNodes = createDiagramNodes(topNodeModels, parameters);

    var mapLinkModels = processLinks(rawData.edges, derivationMapNodes);
    // Create fake link if there are no links at all (it means we have a problem with a data)
    // ===================================
    if (mapLinkModels.length === 0 && topNodeModels.length === 2) {
        var topIds = topNodeModels.map(function (tm) {
            return tm.id;
        });
        var topViews = derivationMapNodes.filter(function (n) {
            return topIds.indexOf(n.id) !== -1;
        });
        mapLinkModels.push({
            source: topViews[0],
            target: topViews[1],
            label: ''
        });
    }
    // ===================================
    var finalLinkModels = groupLinks(mapLinkModels, parameters);
    var derivationMapLinks = finalLinkModels.map(function (model) {
        return new _mapElements.Link(model, parameters);
    });
    return {
        elements: derivationMapNodes,
        links: derivationMapLinks
    };
}
exports.default = processData;


function processLinks(rawLinks, derivationMapNodes) {
    if (!rawLinks) return [];

    var nodeMap = {};
    derivationMapNodes.forEach(function (node) {
        if (nodeMap[node.endpointId]) {
            nodeMap[node.endpointId].push(node);
        } else {
            nodeMap[node.endpointId] = [node];
        }
    });

    var existingLinks = {};
    rawLinks.forEach(function (link) {
        (nodeMap[link.source] || []).forEach(function (source) {
            (nodeMap[link.target] || []).forEach(function (target) {
                if (!(existingLinks[source.id] && existingLinks[source.id][target.id])) {
                    var finalLink = {
                        source: source,
                        target: target,
                        label: link.label || getLabelFromId(link.id),
                        typeId: link.id
                    };

                    [source.id].concat(source.orderedPossibleIds).forEach(function (sourceId) {
                        [target.id].concat(target.orderedPossibleIds).forEach(function (targetId) {
                            if (!existingLinks[sourceId]) existingLinks[sourceId] = {};
                            existingLinks[sourceId][targetId] = finalLink;
                        });
                    });
                }
            });
        });
    });

    var links = [];
    Object.keys(existingLinks).forEach(function (sourceId) {
        Object.keys(existingLinks[sourceId]).forEach(function (targetId) {
            var link = existingLinks[sourceId][targetId];
            if (links.indexOf(link) === -1) {
                links.push(link);
            }
        });
    });

    return links;
}

function groupLinks(linkModels, parameters) {
    var groupsBySource = {};
    var groupsByTarget = {};

    linkModels.forEach(function (linkModel) {
        var typeId = linkModel.typeId || linkModel.label;
        var sourceCacheId = cacheFunction(typeId, linkModel.source.id);
        if (!groupsBySource[sourceCacheId]) {
            groupsBySource[sourceCacheId] = [];
            groupsBySource[sourceCacheId].source = linkModel.source;
            groupsBySource[sourceCacheId].label = linkModel.label;
            groupsBySource[sourceCacheId].typeId = typeId;
        }
        groupsBySource[sourceCacheId].push(linkModel);

        var targetCacheId = cacheFunction(typeId, linkModel.target.id);
        if (!groupsByTarget[targetCacheId]) {
            groupsByTarget[targetCacheId] = [];
            groupsByTarget[targetCacheId].target = linkModel.target;
            groupsByTarget[targetCacheId].label = linkModel.label;
            groupsByTarget[targetCacheId].typeId = typeId;
        }
        groupsByTarget[targetCacheId].push(linkModel);
    });

    Object.keys(groupsBySource).forEach(function (groupId) {
        var group = groupsBySource[groupId];
        var crossedElements = group.length > 1 ? group : [];
        var crossNode = new _mapElements.GraphCrossNode({ crossedElements: crossedElements });
        var sourceLink = new _mapElements.GraphLink({
            source: group.source,
            target: crossNode,
            label: group.label,
            typeId: group.typeId,
            crossedElements: crossedElements
        }, parameters);
        crossedElements.forEach(function (linkModel) {
            var targetLink = new _mapElements.GraphCrossLink({
                typeId: group.typeId,
                source: crossNode,
                target: linkModel.target,
                label: ''
            });
            linkModel.graphPrimitives = [crossNode, sourceLink, targetLink];
            linkModel.groupedBy = 'source';
        }, parameters);
    });

    Object.keys(groupsByTarget).forEach(function (groupId) {
        var group = groupsByTarget[groupId];
        var crossedElements = group.length > 1 ? group.filter(function (linkModel) {
            return !linkModel.graphPrimitives;
        }) : [];
        var crossNode = new _mapElements.GraphCrossNode({ crossedElements: crossedElements });
        var targetLink = new _mapElements.GraphCrossLink({
            source: crossNode,
            target: group.target,
            label: group.label,
            typeId: group.typeId,
            crossedElements: crossedElements
        }, parameters);
        crossedElements.forEach(function (linkModel) {
            var sourceLink = new _mapElements.GraphLink({
                typeId: group.typeId,
                source: linkModel.source,
                target: crossNode,
                label: ''
            }, parameters);
            linkModel.graphPrimitives = [crossNode, sourceLink, targetLink];
            linkModel.groupedBy = 'target';
        });
    });

    return linkModels;

    function cacheFunction(label, terminalId) {
        return label + '~#tqDMLink#~' + terminalId;
    }
}

function processNodes(rawNodes, parameters) {
    var topNodesMap = {};
    var allNodesMap = {};
    var parentMap = {};
    var res = new _resourceProvider.ResourceProvider(parameters);

    rawNodes.forEach(function (rawNode) {
        if (rawNode.id) {
            var children = parentMap[rawNode.id];
            var typeIcon = res.getIcon(rawNode.type);
            var model = allNodesMap[rawNode.id] || createModel(rawNode, children, typeIcon);
            allNodesMap[rawNode.id] = model;
            delete parentMap[rawNode.id];

            if (rawNode.parent) {
                if (allNodesMap[rawNode.parent]) {
                    allNodesMap[rawNode.parent].children.push(model);
                } else {
                    if (!parentMap[rawNode.parent]) parentMap[rawNode.parent] = [];
                    parentMap[rawNode.parent].push(model);
                }
            } else if (!topNodesMap[rawNode.id]) {
                topNodesMap[rawNode.id] = model;
            }
        }
    });

    // Process orphan nodes.
    // There were links to them but no defenitions.
    Object.keys(parentMap).forEach(function (id) {
        topNodesMap[id] = createModel({
            id: id,
            label: getLabelFromId(id),
            children: parentMap[id]
        });
    });

    var topNodes = Object.keys(topNodesMap).map(function (key) {
        return topNodesMap[key];
    });

    // remove cycles
    var processedNodesMap = {};
    function recursion(rootNode) {
        var childrenIds = {};
        rootNode.children = rootNode.children.filter(function (child) {
            if (!processedNodesMap[child.id] && !childrenIds[child.id]) {
                childrenIds[child.id] = true;
                processedNodesMap[child.id] = true;
                recursion(child);
                processedNodesMap[child.id] = false;
                return true;
            } else {
                return false;
            }
        });
    }

    return topNodes.filter(function (top) {
        if (!processedNodesMap[top.id]) {
            processedNodesMap[top.id] = true;
            recursion(top);
            processedNodesMap[top.id] = false;
            return true;
        } else {
            return false;
        }
    });
}

function createModel(rawNode, children, typeIcon) {
    return {
        id: (0, _lodash.uniqueId)('mapElement'),
        endpointId: rawNode.id,
        label: rawNode.label || getLabelFromId(rawNode.id),
        children: children || [],
        resourceType: rawNode.resourceType || 'undefined',
        resource: rawNode.resource || 'undefined',
        type: rawNode.type || 'undefined',
        collapsed: rawNode.collapsed,
        icon: rawNode.icon || typeIcon
    };
}

function createDiagramNodes(topNodeModels, parameters) {
    var derivationMapNodes = [];

    function copy(element, dublicationMap) {
        var dublication = dublicationMap || {};
        if (!dublication[element.id]) {
            var clonedElement = (0, _lodash.clone)(element);
            clonedElement.id = (0, _lodash.uniqueId)('copyOfMapElement');

            dublication[element.id] = clonedElement;
            clonedElement.children = element.children.map(function (child) {
                return copy(child, dublication);
            });
        }
        return dublication[element.id];
    }

    function createGroup(model1, model2) {
        return {
            id: (0, _lodash.uniqueId)('Group'),
            label: 'Group',
            endpointId: 'none',
            children: [model1, model2],
            synthetic: true,
            collapsed: true
        };
    }

    function addToGroup(group, model) {
        group.children.push(model);
    }

    // if there is more then one topElement for some model
    var topElementForId = {};
    var filteredTopModels = {};
    topNodeModels.forEach(function (topElement) {
        recursion(topElement);

        function recursion(curModel) {
            if (topElementForId[curModel.id]) {
                if (!topElementForId[curModel.id].synthetic && topElement.id !== topElementForId[curModel.id].id) {
                    delete filteredTopModels[topElement.id];
                    delete filteredTopModels[topElementForId[curModel.id].id];

                    topElementForId[curModel.id] = createGroup(topElementForId[curModel.id], topElement);

                    filteredTopModels[topElementForId[curModel.id].id] = topElementForId[curModel.id];
                } else {
                    addToGroup(topElementForId[curModel.id], topElement);
                }
                return copy(curModel);
            } else {
                topElementForId[curModel.id] = topElement;
                filteredTopModels[topElement.id] = topElement;
                curModel.children = curModel.children.map(function (child) {
                    return recursion(child);
                });
                return curModel;
            }
        }
    });

    Object.keys(filteredTopModels).forEach(function (topElementId) {
        var topElement = filteredTopModels[topElementId];

        var graphNode = new _mapElements.GraphNode(topElement, parameters);
        var processedNodes = {};
        recursion(topElement, []);

        function recursion(curModel, possibleIds) {
            if (!processedNodes[curModel.id]) {
                var model = (0, _lodash.cloneDeep)(curModel);
                model.orderedPossibleIds = possibleIds;
                model.graphNode = graphNode;

                processedNodes[curModel.id] = new _mapElements.Node(model, parameters);
                processedNodes[curModel.id].children = curModel.children.map(function (child) {
                    return recursion(child, possibleIds.concat([curModel.id]));
                });
                derivationMapNodes.push(processedNodes[curModel.id]);
            }
            return processedNodes[curModel.id];
        }
    });

    return derivationMapNodes;
}

function getLabelFromId(id) {
    var terms = id.split('/');
    var slashLabel = terms[terms.length - 1];
    if (slashLabel) {
        return slashLabel;
    } else {
        var hashIndex = id.indexOf('#');
        if (hashIndex !== -1) {
            var hashLabel = id.substring(hashIndex, id.length - 1);
            return hashLabel;
        } else {
            return id;
        }
    }
}

},{"../../data/resourceProvider":30,"./mapElements":42,"lodash":"lodash"}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getDefaultParametersSet = getDefaultParametersSet;
exports.DerivationMap = DerivationMap;

var _visualizationsLibrary = require('visualizations-library');

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _dataProcessing = require('./dataProcessing');

var _dataProcessing2 = _interopRequireDefault(_dataProcessing);

var _mapElements = require('./mapElements');

var mapElements = _interopRequireWildcard(_mapElements);

var _mapLayout = require('./mapLayout');

var _dmDefaultUI = require('../../htmlUI/dmDefaultUI');

var _resourceProvider = require('../../data/resourceProvider');

var _dataUtils = require('../../utils/dataUtils');

var _subscribeable = require('../../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Link style definition for DM
 * @typedef {Object} DMLinkStyleDefinition
 * @property {string} cssClass - CSS class which will be attached to the svg component
 * @property {string} lineType - 'solid' or 'dashed'
 * @property {string} color - Color of the line
 * @property {string} textColor - Color of the text on the line
 * @property {string} textBackgroundColor - Color of the background of the text on the line
 * @property {number} thickness
*/

/**
 * Set of parameters for Derivation Map
 * @typedef {Object} DerivationMapParameters
 * @property {Object.<string, LinkStyleDefinition>} linkStyles - Map between the linkTypes and LinkStyles.
 * @property {number} defaultElementWidth
 * @property {number} defaultElementHeight
 * @property {number} defaultLinkLabelLength
 * @property {number} defaultLayoutStep
 * @property {Function} errorCallBack - it is called in response to warnings and errors
*/

/**
 * Returns default set of parameters
 * @returns {DerivationMapParameters}
 */
function getDefaultParametersSet() {
    return {
        defaultElementWidth: 250,
        defaultElementHeight: 250,
        defaultLinkLabelLength: 100,
        defaultLayoutStep: 150,
        linkStyles: {
            'default-link-style': _resourceProvider.DEFAULT_DERIVATION_MAP_LINK_STYLE
            // Example:
            // 'type-id-1234': {
            //     lineType: 'dashed', // 'solid'
            //     cssClass: 'class-123'
            //     color: 'green',
            //     textColor: 'blue',
            //     textBackgroundColor: 'yellow',
            //     thickness: 5,
            // },
        },
        icons: {
            'SQL script': 'glyphicon glyphicon-cog',
            'Database Table': 'glyphicon glyphicon-folder-close'
        },
        tools: [],
        errorCallBack: undefined // It is called in response to warnings and errors
    };
}

/**
 * @private
 * @class
 * Displays derivation view for selected link
 *
 * Constructor parameters:
 * ========================================
 * @param {
 *  dataProvider: DataContainer
 *  rootElement: HTMLElement
 *  relation: { source: string, target: string }
 * } options
 * @param {DerivationMapParameters} parameters - parameters set
 *
 * Public properties:
 * ========================================
 * relation: { source: string, target: string }
 *
 * Public methods:
 * ========================================
 * openWithRelation (relation: { source: string, target: string }) - Initializes DM diagram
 * exportToSvg()
 * exportToPng()
 * resetFocus()
 * zoomIn()
 * zoomOut()
 * zoomToFit()
 * print()
 * ----------------------------------------
 * on (event: string, callback: function): void
 * unsubscribe (callback: function): void
 * trigger (event: string, parameters: any): void
 *
 * Events:
 * ========================================
 * @fires diagram-state-changed (stateId: string)
 */
function DerivationMap(properties, parameters) {
    var _this = this;

    _subscribeable2.default.apply(this);

    var defaultParameterSet = getDefaultParametersSet();
    // Merging parameters default and user
    var _parameters = _.merge(defaultParameterSet, parameters || {});

    var _errorCallback = function _errorCallback(e) {
        if (_parameters.errorCallback && _parameters.errorCallback instanceof Function) {
            var error = typeof e === 'string' ? new Error(e) : e;
            _parameters.errorCallback.call(_this, error);
        }
    };

    /**
     * State changed event - fires when DM state changes.
     * E.g. from a fetching state to a rendering state.
     * The state string identifier is returned as a parameter of the event
     * @event diagram-state-changed
     * @type {Object}
     * @property {string} state - Parameter can take the following values: 'fetching' | 'rendering' | 'completed' | 'error'
    */

    var self = this;
    var _dataProvider = properties.dataProvider;
    var _base = _createBase(properties.rootElement);

    var _layout = new _mapLayout.MapLayout({
        rootElement: _base.derivationMapRootHtml
    }, _parameters);
    var _progressScreen = new _visualizationsLibrary2.default.ProgressScreen({
        baseElement: _base.container
    });

    var _selectedElement = undefined;

    // Initialization
    // ==================================================

    var _defaultUI = new _dmDefaultUI.DMDefaultUI({
        baseElement: _base.toolbar,
        infoPanel: _base.infoPanel,
        tools: _parameters.tools || null,
        derivationMap: self
    });

    if (properties.relation) {
        _openWithRelation(properties.relation);
    }

    // Public functions
    // ==================================================

    self.relation;
    self.openWithRelation = _openWithRelation;

    self.resetFocus = function () {
        _layout.zoom();
        _layout.zoom(-0.2, { max: 2, min: 0.2 });
    };

    self.getSelectedElement = function () {
        return _selectedElement;
    };

    self.setSelectedElement = function (elementId) {
        var selectedELement = _layout.getNodes().find(function (el) {
            return el.id === elementId;
        });
        _setSelectedElement(selectedELement);
    };

    self.setSearchKey = function (key) {
        _layout.setSearchKey(key);
    };

    self.expandAllElements = function () {
        _layout.getNodes().forEach(function (el) {
            el.expand();
        });
    };

    self.collapseAllElements = function () {
        _layout.getNodes().forEach(function (el) {
            el.collapse();
        });
    };

    self.exportToSvg = function () {
        _layout.export({ type: 'svg' });
    };

    self.exportToPng = function () {
        _layout.export({ type: 'png' });
    };

    self.zoomIn = function () {
        _layout.zoom(0.2, { max: 4 });
    };

    self.zoomOut = function () {
        _layout.zoom(-0.2, { min: 0.2 });
    };

    self.zoomToFit = function () {
        _layout.zoom();
    };

    self.print = function () {
        _layout.print();
    };

    // Private functions
    // ==================================================

    function _openWithRelation(relation) {
        _setSelectedElement(undefined);
        if (relation) {
            if (!self.relation || relation.source !== self.relation.source || relation.target !== self.relation.target || relation.linkType !== self.relation.linkType) {
                _layout.clear();
                self.relation = relation;
                _setDiagramState('fetching');
                _dataProvider.relationInfo(relation).then(function (rawData) {
                    _setDiagramState('rendering');

                    (0, _dataUtils.checkDmRawData)(rawData);

                    var mapElements = (0, _dataProcessing2.default)(rawData, _parameters);
                    _layout.addElements(mapElements.elements.concat(mapElements.links));
                    self.resetFocus();
                    _subscribeOnElements();
                    _setDiagramState('completed');
                }).catch(function (e) {
                    var error = typeof e === 'string' ? new Error(e) : e;

                    _setDiagramState('error', error.message);
                    _errorCallback(error);

                    console.error(error.message);
                    console.error(error.stack);
                });
            } else {
                self.resetFocus();
            }
        } else {
            var errorText = 'The relation you want to use is empty!';
            var error = new Error(errorText);
            _setDiagramState('error', errorText);
            _errorCallback(error);
            throw error;
        }
    }

    function _subscribeOnElements() {
        _layout.getNodes().forEach(function (el) {
            el.on('element-click', function () {
                _setSelectedElement(el);
            });
            el.on('collapse-button-click', function () {
                var model = el.getModel();
                if (model.collapsed) {
                    el.expand();
                } else {
                    el.collapse();
                }
            });
        });

        _layout.getLinks().forEach(function (el) {
            el.on('element-click', function () {
                _setSelectedElement(el);
            });
        });
    }

    _layout.on('blank-click', function () {
        return _setSelectedElement(undefined);
    });

    function _setSelectedElement(element) {
        if (_selectedElement) _selectedElement.highlighting(false);
        _selectedElement = element;

        if (_selectedElement) _selectedElement.highlighting(true);
        _defaultUI.infoPanel.setSelectedElement(element);

        self.trigger('selected-element-changed', _getModel(element));
    }

    /**
     * Sets state of indicator
     * @private
     * @param {string} state - fetching | rendering | completed
     * @param {string} message - Custom message
     */
    function _setDiagramState(state, message) {
        self.state = state;
        if (state === 'fetching') {
            _progressScreen.setState('active', message || 'Fetching data');
        } else if (state === 'rendering') {
            _progressScreen.setState('active', message || 'Rendering graph');
        } else if (state === 'completed') {
            _progressScreen.setState('completed');
        } else if (state === 'error') {
            _progressScreen.setState('error', message || 'Error has occurred!');
        }
        self.trigger('diagram-state-changed', message || state);
    }

    function _getModel(element) {
        if (element instanceof mapElements.Node) {
            return {
                id: element.id,
                label: element.label,
                resource: element.resource,
                parent: element.parent,
                resourceType: element.resourceType,
                diagramType: 'node',
                endpointId: element.endpointId
            };
        } else if (element instanceof mapElements.Link) {
            return {
                id: element.id,
                source: element.source.endpointId,
                target: element.target.endpointId,
                diagramType: 'link',
                typeId: element.typeId
            };
        } else {
            return undefined;
        }
    }

    /**
     * Creates html markup.
     * @private
     * @param {HTMLElement} htmlNode - Root node for markup
     * @returns {Object.<string, HTMLElement>} - Map of html elements
     */
    function _createBase(htmlNode) {
        htmlNode.innerHTML = '';
        htmlNode.tabIndex = 1;

        var rowContainer = document.createElement('DIV');
        rowContainer.className = 'tq-row-container';
        htmlNode.appendChild(rowContainer);

        var baseDiv = document.createElement('DIV');
        baseDiv.className = 'tq-derivation-map';
        baseDiv.id = 'tq-derivation-map';
        rowContainer.appendChild(baseDiv);

        var derivationMapRootHtml = document.createElement('DIV');
        derivationMapRootHtml.className = 'tq-derivation-map-diagram';
        derivationMapRootHtml.id = 'tq-derivation-map-diagram';
        baseDiv.appendChild(derivationMapRootHtml);

        var progressIndication = document.createElement('DIV');
        progressIndication.className = 'tq-lg-progress-screen';
        baseDiv.appendChild(progressIndication);

        var toolbarBase = document.createElement('DIV');
        toolbarBase.className = 'tq-derivation-map__toolbar';
        toolbarBase.id = 'tq-derivation-map-toolbar';
        baseDiv.appendChild(toolbarBase);

        var infoPanel = document.createElement('DIV');
        infoPanel.className = 'tq-row-container__properties-pane';
        infoPanel.id = 'tq-properties-pane';
        rowContainer.appendChild(infoPanel);

        return {
            container: htmlNode,
            baseDiv: baseDiv,
            infoPanel: infoPanel,
            toolbar: toolbarBase,
            derivationMapRootHtml: derivationMapRootHtml,
            progress: progressIndication
        };
    }
}

exports.default = DerivationMap;

},{"../../data/resourceProvider":30,"../../htmlUI/dmDefaultUI":32,"../../subscriptionAPI/subscribeable":65,"../../utils/dataUtils":66,"./dataProcessing":40,"./mapElements":42,"./mapLayout":43,"lodash":"lodash","visualizations-library":5}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Z_INDEXES = exports.LINK_LABEL_FONT_SIZE = undefined;
exports.Node = Node;
exports.Link = Link;
exports.GraphNode = GraphNode;
exports.GraphCrossNode = GraphCrossNode;
exports.GraphLink = GraphLink;
exports.GraphCrossLink = GraphCrossLink;
exports.getPortId = getPortId;
exports.getLinkMarkerTarget = getLinkMarkerTarget;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _subscribeable = require('../../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _resourceProvider = require('../../data/resourceProvider');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var DEFAULT_LINK_TYPE = 'derivation-link';
var MARKER_TARGET = {
    fill: 'black',
    stroke: 'black',
    d: 'M 10 0 L 0 5 L 10 10 z'
};
var LINK_LABEL_FONT_SIZE = exports.LINK_LABEL_FONT_SIZE = 16;
var Z_INDEXES = exports.Z_INDEXES = {
    NODE: 30,
    SELECTED_ELEMENT: 20,
    LINK: 15,
    BLURED_NODE: 10,
    BLURED_LINK: 5
};

/**
 * Node
 * @private
 * @class
 * ==========================================
 * @fires element-click
 * @fires collapse-button-click
 * @fires ports-state-changed
 * @fires element-state-changed
 * @fires position-changed
 */
function Node(options, parameters) {
    _subscribeable2.default.apply(this);

    /**
     * It fires when user click on node.
     * @event element-click
     * @type {Object}
     * @property {MouseEvent} event - origin MouseEvtnt
    */

    var self = this;
    var _graphNode = options.graphNode || new GraphNode(options.model, parameters);

    self.id = options.id;
    self.endpointId = options.endpointId;
    self.resourceType = options.resourceType;
    self.parent = options.parent;
    self.label = options.label;
    self.children = options.children;
    self.orderedPossibleIds = options.orderedPossibleIds;
    self.resource = options.resource;

    self.highlighting = function (value) {
        if (value !== undefined) {
            if (value) {
                _graphNode.setHighlightedId(self.id);
            } else if (self.id === _graphNode.highlightedId) {
                _graphNode.setHighlightedId(undefined);
            }
        }
        return _graphNode.highlightedId === self.id;
    };

    self.collapse = function () {
        _graphNode._collapseElement(self.id);
    };

    self.expand = function () {
        _graphNode._expandElement(self.id);
    };

    self.show = function () {
        // not implemented..
    };

    self.hide = function () {
        // not implemented..
    };

    self.isVisible = function () {
        return true;
    };

    self.getCells = function () {
        return [_graphNode];
    };

    self.getPort = function () {
        return {
            id: _getAvailablePortId(),
            primitive: _graphNode
        };
    };

    self.getModel = _getModel;

    self.getPortPosition = function (direction) {
        var svgObject = _graphNode.attr('.' + getPortId(_getAvailablePortId(), direction));
        var primitivePosition = self.getPort().primitive.position();
        if (svgObject) {
            return {
                x: svgObject['ref-x'] + primitivePosition.x,
                y: svgObject['ref-y'] + primitivePosition.y
            };
        } else {
            return primitivePosition;
        }
    };

    self.onPaperCellPointerDown = function () {
        // ...
    };

    _graphNode.on('ports-state-changed', function () {
        self.trigger('ports-state-changed');
    });

    _graphNode.on('elements-state-changed', function () {
        self.trigger('element-state-changed');
    });

    _graphNode.on('body-click', function (_ref) {
        var event = _ref.event,
            elementId = _ref.elementId;

        if (self.id === elementId) {
            self.trigger('element-click', event);
        }
    });

    _graphNode.on('change:position', function () {
        self.trigger('position-changed');
    });

    _graphNode.on('collapse-button-click', function (elementId) {
        if (elementId === self.id) {
            self.trigger('collapse-button-click');
        }
    });

    function _getModel() {
        return _graphNode.elementsMap[self.id];
    }

    function _getAvailablePortId() {
        var model = _getModel();
        if (!model.invisible) {
            return self.id;
        }
        for (var i = 0; i < self.orderedPossibleIds.length; i++) {
            var curId = self.orderedPossibleIds[i];
            if (_graphNode.elementsMap[curId].invisible) {
                var prevId = self.orderedPossibleIds[i - 1];
                return prevId;
            }
        }
        return self.orderedPossibleIds[self.orderedPossibleIds.length - 1];
    }
}

/**
 * Link
 * @private
 * @class
 * ==========================================
 */
function Link(options, parameters) {
    _subscribeable2.default.apply(this);

    var self = this;

    self.source = options.source;
    self.target = options.target;
    self.label = options.label;
    self.typeId = options.typeId;
    self.groupedBy = options.groupedBy; // source | target | undefined

    var _getConnectionParamet = _getConnectionParameters(),
        source = _getConnectionParamet.source,
        target = _getConnectionParamet.target;

    var primitivesAreDefined = options.graphPrimitives && options.graphPrimitives.length > 0;
    var _graphPrimitives = primitivesAreDefined ? options.graphPrimitives : [new GraphLink({
        typeId: options.typeId,
        source: source,
        target: target,
        label: _getLabel()
    }, parameters)];

    _refreshPorts();

    self.getCells = function () {
        return _graphPrimitives;
    };

    var _highlighted = false;
    self.highlighting = function (value) {
        if (value !== undefined) {
            _highlighted = value;
            _graphPrimitives.forEach(function (primitive) {
                if (value) {
                    primitive.highlight();
                } else {
                    primitive.unhighlight();
                }
            });
        }
        return _highlighted;
    };

    self.show = function () {
        _graphPrimitives.forEach(function (primitive) {
            return primitive.show();
        });
    };

    self.hide = function () {
        _graphPrimitives.forEach(function (primitive) {
            return primitive.hide();
        });
    };

    self.isVisible = function () {
        return !self.get('hidden');
    };

    self.onPaperCellPointerDown = function (cell) {
        var cellIsMyPrimitive = _graphPrimitives.indexOf(cell) !== -1;
        if (cellIsMyPrimitive) {
            self.trigger('element-click', event);
        }
    };

    self.alignCrossNode = _alignCrossNode;
    self.getCrossNode = _getCrossNode;

    function _getCrossNode() {
        var isCrossed = _graphPrimitives.length > 1;
        if (isCrossed) {
            return _graphPrimitives[0];
        } else {
            return undefined;
        }
    }

    function _alignCrossNode() {
        var crossNode = _getCrossNode();
        if (!crossNode) return;

        var crossedElements = crossNode.getCrossedElements();
        var firstCrossedElement = crossedElements[0];
        var groupedBySource = firstCrossedElement.groupedBy === 'source';
        var DEFAULT_PADDING = 30;
        var sumY = 0;
        var minX = Infinity;
        var maxX = -Infinity;

        crossedElements.forEach(function (crossedLinks) {
            var allignTo = groupedBySource ? crossedLinks.target.getPortPosition('in') : crossedLinks.source.getPortPosition('out');

            sumY += allignTo.y;
            minX = Math.min(minX, allignTo.x);
            maxX = Math.max(maxX, allignTo.x);
        });
        var xPosition = groupedBySource ? minX - DEFAULT_PADDING : maxX + DEFAULT_PADDING;
        var yPosition = sumY / crossedElements.length;
        crossNode.position(xPosition, yPosition);
    }

    function _getLabel() {
        return joint.util.breakText(self.label, {
            width: parameters.defaultLinkLabelLength
        }, { 'font-size': LINK_LABEL_FONT_SIZE });
    }

    function _refreshPorts() {
        var _getConnectionParamet2 = _getConnectionParameters(),
            targetTopId = _getConnectionParamet2.targetTopId,
            source = _getConnectionParamet2.source,
            target = _getConnectionParamet2.target;

        var sourcePrimitive = _graphPrimitives[1] || _graphPrimitives[0];
        var targetPrimitive = _graphPrimitives[2] || _graphPrimitives[0];

        var targetLinkStyle = targetPrimitive.getLinkStyle();
        if (target.id === targetTopId) {
            targetPrimitive.attr('.marker-target', getLinkMarkerTarget(targetLinkStyle));
        } else {
            targetPrimitive.removeAttr('.marker-target');
        }

        sourcePrimitive.prop({ source: source });
        targetPrimitive.prop({ target: target });

        _alignCrossNode();
    }

    function _getConnectionParameters() {
        var sourcePort = self.source.getPort();
        var targetPort = self.target.getPort();

        var sourcePosition = sourcePort.primitive.position();
        var targetPosition = targetPort.primitive.position();

        var reverse = sourcePosition.x > targetPosition.x;
        var source = {
            id: sourcePort.primitive.id,
            port: getPortId(sourcePort.id, reverse ? 'in' : 'out')
        };
        var target = {
            id: targetPort.primitive.id,
            port: getPortId(targetPort.id, reverse ? 'out' : 'in')
        };

        return {
            sourceTopId: sourcePort.id,
            targetTopId: targetPort.id,
            source: source,
            target: target
        };
    }

    self.source.on('element-state-changed', _refreshPorts);
    self.target.on('element-state-changed', _refreshPorts);
    self.source.on('ports-state-changed', _alignCrossNode);
    self.target.on('ports-state-changed', _alignCrossNode);
    self.source.on('position-changed', _refreshPorts);
    self.target.on('position-changed', _refreshPorts);
}

/**
 * JointNode
 * @private
 * @class
 * ==========================================
 * @fires body-click
 * @fires highlighted-id
 */
function GraphNode(model, parameters) {
    var self = this;

    /**
     * It fires when user click on node.
     * @event body-click
     * @type {Object}
     * @property {
     *  event: MouseEvent, // original mouse event
     *  elementId: string, // id of the clicked element
     * }
    */

    self.elementsMap = _getFlatElementsMap(model);
    self.model = model;
    self.scale = 1;
    self.activePorts = {};

    joint.shapes.basic.Generic.apply(self, [{
        id: model.id,
        markup: '<g class="rotatable">\n            <g class="scalable export-anchor">\n                <rect class="body"/>\n            </g>\n            ' + _portsTemplate() + '\n        </g>',
        type: 'graph-derivation-node.GraphNode',
        position: { x: 0, y: 0 },
        z: Z_INDEXES.NODE,
        size: {
            width: parameters.defaultElementWidth,
            height: parameters.defaultElementHeight
        },
        attrs: {
            rect: {
                stroke: 'transparent'
            },
            circle: {
                r: 0,
                fill: 'red'
            },
            '.dn-in-port': {
                ref: '.body',
                'ref-x': 0,
                'ref-y': 0
            },
            '.dn-out-port': {
                ref: '.body',
                'ref-x': parameters.defaultElementWidth + 20,
                'ref-y': 0
            }
        }
    }]);

    self.set('collapsed', false);
    self.sctollTop = 0;

    self.setHighlightedId = function (targetId) {
        self.highlightedId = targetId;
        var changedIds = _updateState(this.model);
        changedIds.concat(_updateVisibility(this.model));
        self.trigger('elements-state-changed', [changedIds]);
        self.prop({ z: Z_INDEXES.NODE });
    };

    self._collapseElement = function (elementId) {
        if (elementId) {
            self.elementsMap[elementId].collapsed = true;
            var changedIds = _updateVisibility(self.elementsMap[elementId]);
            changedIds.push(elementId);
            if (changedIds.length > 0) self.trigger('elements-state-changed', [changedIds]);
        } else {
            self.set('collapsed', true);
        }
    };

    self._expandElement = function (elementId) {
        if (elementId) {
            self.elementsMap[elementId].collapsed = false;
            var changedIds = _updateVisibility(self.elementsMap[elementId]);
            changedIds.push(elementId);
            if (changedIds.length > 0) self.trigger('elements-state-changed', [changedIds]);
        } else {
            self.set('collapsed', false);
        }
    };

    self.onClickCollapseButton = function (elementId) {
        self.trigger('collapse-button-click', elementId);
    };

    self.updatePorts = function () {
        self.trigger('ports-state-changed');
    };

    self.fireClickEvent = function (event, elementId) {
        self.trigger('body-click', {
            event: event,
            elementId: elementId
        });
    };

    self.getAllChildren = _getAllChildren;

    self.activePorts = {};
    self.refresh = function () {
        self.trigger('redraw-view');
    };

    self.setScale = function (scale) {
        self.scale = scale;
    };

    self.setSearchKey = function (searchKey) {
        self.searchKey = searchKey ? searchKey.toLowerCase() : undefined;

        var changedIds = _updateVisibility(this.model);
        self.trigger('elements-state-changed', [changedIds]);
    };

    function _updateState(rootModel) {
        var highlightedId = self.highlightedId;
        var changedIds = [];

        updateState(rootModel);

        return changedIds;

        function updateState(model) {
            var isSelected = model.id === highlightedId;

            var containSelectedElement = false;
            model.children.forEach(function (child) {
                containSelectedElement = updateState(child) || containSelectedElement;
            });

            var newCollapsedState = model.collapsed && !containSelectedElement;
            if (Boolean(newCollapsedState) !== Boolean(model.collapsed)) changedIds.push(model.id);
            model.collapsed = newCollapsedState;

            return isSelected || containSelectedElement;
        }
    }

    function _updateVisibility(rootModel) {
        var searchKey = self.searchKey;
        var changedIds = [];

        updateVisibility(rootModel, false);

        return changedIds;

        function updateVisibility(model, parentInvisible) {
            var notContainKey = !searchKey || model.label.toLowerCase().indexOf(searchKey) === -1;
            var invisible = parentInvisible && notContainKey;

            var noVisibleChildren = true;
            model.children.forEach(function (child) {
                noVisibleChildren = updateVisibility(child, parentInvisible || model.collapsed) && noVisibleChildren;
            });
            var newVisibiblity = invisible && noVisibleChildren;
            if (Boolean(newVisibiblity) !== Boolean(model.invisible)) changedIds.push(model.id);
            model.invisible = invisible && noVisibleChildren;

            return model.invisible;
        }
    }

    function _getAllChildren() {
        return Object.keys(self.elementsMap).map(function (id) {
            return self.elementsMap[id];
        });
    }

    function _getFlatElementsMap(model) {
        var elementsMap = {};
        recursion(model, false);
        return elementsMap;

        function recursion(element, invisible) {
            if (!elementsMap[element.id]) {
                elementsMap[element.id] = element;
                element.invisible = invisible;
                element.children.map(function (child) {
                    recursion(child, element.collapsed);
                });
            }
        }
    }

    function _portsTemplate() {
        return _getAllChildren().map(function (element) {
            var inPortId = getPortId(element.id, 'in');
            var outPortId = getPortId(element.id, 'out');

            return '\n                <circle class="dn-in-port ' + inPortId + '" port="' + inPortId + '"/>\n                <circle class="dn-out-port ' + outPortId + '" port="' + outPortId + '"/>\n            ';
        }).join('');
    }
}
GraphNode.prototype = Object.create(joint.shapes.devs.Model.prototype);

var DEFAULT_CROSS_NODE_SIZE = {
    width: 1, height: 1
};
/**
 * JointCrossNode
 * @private
 * @class
 * ==========================================
 */
function GraphCrossNode(model) {
    var self = this;

    self.model = model;
    self.hidden = false;

    joint.shapes.basic.Generic.apply(self, [{
        type: 'derivationCrossNode',
        markup: '<g class="rotatable">\n            <g class="scalable export-anchor">\n                <circle class="body"/>\n            </g>\n        </g>',
        size: DEFAULT_CROSS_NODE_SIZE,
        z: Z_INDEXES.LINK,
        attrs: {
            circle: {
                r: '5px',
                stroke: 'black',
                'stroke-width': 3
            }
        }
    }]);

    self.highlight = function () {
        self.hidden = false;
        self.prop({ z: Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    self.unhighlight = function () {
        self.prop({ z: Z_INDEXES.LINK });
        self.set('highlighted', false);
    };

    self.show = function () {
        self.hidden = false;
        self.prop({ z: Z_INDEXES.LINK });
        self.trigger('update-state');
    };

    self.hide = function () {
        self.hidden = true;
        self.prop({ z: Z_INDEXES.BLURED_LINK });
        self.trigger('update-state');
    };

    self.getCrossedElements = function () {
        return self.model.crossedElements;
    };

    self.refresh = function () {
        self.trigger('redraw-view');
    };

    self.setScale = function (scale) {
        self.scale = scale;
    };
}
GraphCrossNode.prototype = Object.create(joint.shapes.basic.Generic.prototype);

/**
 * DMLinkModel - data model for a {@link Link} object
 * @typedef {Object} DMLinkModel
 * @property {string} typeId - Link type identifyer
 * @property {GraphNode} target - Target Node
 * @property {GraphNode} source - Source Node
 * @property {string} label - Text in the middle of the link
 * @property {string} linktype - Type of the Link
 * @property {GraphLink[]} crossedElements - in case of the link is a part of grouped links
*/

/**
 * JointLink
 * @private
 * @class
 * @param {DMLinkModel} model
 * @param {Paramters} parameters
 * ==========================================
 */
function GraphLink(model, parameters) {
    var self = this;

    self.model = model;
    self.hidden = false;

    var _res = new _resourceProvider.ResourceProvider(parameters);
    var _linkStyle = _res.getLinkStyle(model.typeId);
    var types = [DEFAULT_LINK_TYPE];

    if (_linkStyle.cssClass && _linkStyle.cssClass !== DEFAULT_LINK_TYPE) {
        types.push(_linkStyle.cssClass);
    }

    joint.dia.Link.apply(self, [{
        type: types.join(' '),
        z: Z_INDEXES.LINK,
        source: model.source,
        target: model.target,
        attrs: _getLinkAttributes(_linkStyle),
        labels: [{
            position: .5,
            attrs: {
                rect: { fill: _linkStyle.textBackgroundColor },
                text: { fill: _linkStyle.textColor, text: model.label }
            }
        }],
        connector: { name: 'rounded' }
    }]);

    self.highlight = function () {
        self.hidden = false;
        self.prop({ z: Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    self.unhighlight = function () {
        self.prop({ z: Z_INDEXES.LINK });
        self.set('highlighted', false);
    };

    self.getLinkStyle = function () {
        return _linkStyle;
    };

    self.show = function () {
        self.hidden = false;
        self.prop({ z: Z_INDEXES.LINK });
        self.trigger('update-state');
    };

    self.hide = function () {
        self.hidden = true;
        self.prop({ z: Z_INDEXES.BLURED_LINK });
        self.trigger('update-state');
    };

    function _getLinkAttributes(linkStyle, hasArrow) {
        var attributes = {};
        attributes['.connection'] = {
            stroke: linkStyle.color,
            'stroke-width': linkStyle.thickness,
            'stroke-dasharray': linkStyle.lineType === 'solid' ? undefined : '5,5'
        };
        if (hasArrow) {
            attributes['.marker-target'] = getLinkMarkerTarget(linkStyle);
        }
        return attributes;
    }
}
GraphLink.prototype = Object.create(joint.dia.Link.prototype);

/**
 * JointLink
 * @private
 * @class
 * ==========================================
 */
function GraphCrossLink(model, paramters) {
    var self = this;

    self.model = model;

    GraphLink.apply(self, [model, paramters]);

    self.getCrossedElements = function () {
        return self.model.crossedElements;
    };
}
GraphCrossLink.prototype = Object.create(GraphLink.prototype);

function getPortId(portId, direction) {
    var isTarget = direction === 'in';
    return (isTarget ? 'In_' : 'Out_') + 'Port_' + encodeURI(portId);
}

function getLinkMarkerTarget(linkStyle) {
    return {
        fill: linkStyle.color,
        stroke: linkStyle.color,
        d: MARKER_TARGET.d,
        'stroke-width': linkStyle.thickness
    };
}

},{"../../data/resourceProvider":30,"../../subscriptionAPI/subscribeable":65,"rappid":"rappid"}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MapLayout = MapLayout;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _fileSaverjs = require('file-saverjs');

var _fileSaverjs2 = _interopRequireDefault(_fileSaverjs);

var _mapViews = require('./mapViews');

var _mapElements = require('./mapElements');

var _toSvg = require('../toSvg');

var _subscribeable = require('../../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _sankey = require('../../layout/sankey');

var _sankey2 = _interopRequireDefault(_sankey);

var _layout = require('../../layout/layout');

var _layoutUtils = require('../../utils/layoutUtils');

var _dataUtils = require('../../utils/dataUtils');

var _lineageDiagramUtils = require('../../utils/lineageDiagramUtils');

var _utils = require('../../utils/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

joint.shapes['graph-derivation-node'] = {
    GraphNode: _mapElements.GraphNode,
    GraphNodeView: _mapViews.GraphNodeView
};

/**
 * @private
 * @param {*} properties
 * @fires blank-click
 */
function MapLayout(properties, parameters) {
    _subscribeable2.default.apply(this);

    var self = this;
    var _graph = new joint.dia.Graph();
    var _startPoint = undefined;

    var _paper = new joint.dia.Paper({
        model: _graph,
        // elementView: GraphNodeView,
        linkView: _mapViews.GraphLinkView,
        gridSize: 1,
        preventContextMenu: false,
        interactive: function interactive() {
            return { vertexAdd: false };
        },
        width: 5000,
        height: 5000
    });
    var _paperScroller = new joint.ui.PaperScroller({
        paper: _paper,
        autoResizePaper: true
    });

    var _nodes = [];
    var _links = [];

    properties.rootElement.innerHTML = '';
    properties.rootElement.appendChild(_paperScroller.render().el);

    // Initialization
    // =======================================================
    // =======================================================
    // =======================================================

    /**
     * Handling multiple link situations - bends them so they don't cross
     * @private
    */

    // Just refreshes related elements on changes.
    _graph.on('change:source change:target', _refreshRelatedElement);

    _paper.on('blank:pointerdown', function (event, x, y) {
        _startPoint = { x: event.pageX, y: event.pageY };
        _paperScroller.startPanning(event, x, y);
    });
    _paper.on('blank:pointerclick', function (event) {
        if (!_startPoint) return;

        var newPoint = { x: event.pageX, y: event.pageY };
        var OFFSET_THRESHOLD = 5;
        var offsetExceedThreshold = Math.abs(newPoint.x - _startPoint.x) < OFFSET_THRESHOLD || Math.abs(newPoint.x - _startPoint.x) < OFFSET_THRESHOLD;
        if (offsetExceedThreshold) {
            self.trigger('blank-click', event);
        }
        _startPoint = undefined;
    });
    _paper.on('cell:pointerdown', function (cellView) {
        _nodes.forEach(function (el) {
            if (el.onPaperCellPointerDown) el.onPaperCellPointerDown(cellView.model);
        });
        _links.forEach(function (el) {
            if (el.onPaperCellPointerDown) el.onPaperCellPointerDown(cellView.model);
        });
    });

    var onMouseWheel = function onMouseWheel(evt, x, y, delta) {
        if (evt.ctrlKey) {
            self.zoom(0.1 * (delta < 0 ? -1 : 1), { max: 4 });
            evt.preventDefault();
        }
    };
    _paper.on('cell:mousewheel', function (cell, evt, x, y, delta) {
        return onMouseWheel(evt, x, y, delta);
    });
    _paper.on('blank:mousewheel', onMouseWheel);

    // =======================================================
    // =======================================================
    // =======================================================

    self.getNodes = function () {
        return _nodes;
    };

    self.getLinks = function () {
        return _links;
    };

    self.getGraphNodes = function () {
        return _graph.getElements();
    };

    self.getGraphLinks = function () {
        return _graph.getLinks();
    };

    self.clear = function () {
        _nodes = [];
        _links = [];
        _graph.clear();
    };

    self.zoom = function (scaleDiff, opt) {
        if (!scaleDiff) {
            _paperScroller.zoomToFit();
        } else {
            _paperScroller.zoom(scaleDiff, opt);
        }
        var newScale = _paperScroller._sx;

        _graph.getElements().forEach(function (node) {
            node.setScale(newScale);
            node.refresh();
        });
    };

    self.addElements = function (newElements) {
        var newNodes = [];
        var newLinks = [];
        newElements.forEach(function (el) {
            if (el instanceof _mapElements.Node) {
                newNodes.push(el);
            } else if (el instanceof _mapElements.Link) {
                newLinks.push(el);
            }
        });

        _nodes = _nodes.concat(newNodes);
        _links = _links.concat(newLinks);

        var processedIds = {};
        var cells = [];

        newElements.forEach(function (element) {
            var elementCells = element.getCells();
            elementCells.forEach(function (cell) {
                if (!processedIds[cell.id]) {
                    processedIds[cell.id] = true;
                    cells.push(cell);
                }
            });
        });
        cells.sort(function (cell1, cell2) {
            var c1 = cell1 instanceof joint.shapes.basic.Generic ? 1 : 0;
            var c2 = cell2 instanceof joint.shapes.basic.Generic ? 1 : 0;
            return c2 - c1;
        });
        _graph.addCells(cells);

        cells.forEach(function (cell) {
            return _refreshRelatedElement(cell);
        });
        _subscribeOnElements();
        _doLayout();
    };

    /**
     * Exports graph to png or svg file
     * @param {
     *  name?: string - file name
     *  type?: string - (png/svg)
     * } options
    */
    self.export = function (options) {
        var fileName = options.name || 'DM_lineage_diagram_snapshot_' + (0, _dataUtils.date2String)(new Date());

        if (options.type === 'png') {
            (0, _toSvg.toDataURL)(_paper, {
                backgroundColor: 'white',
                svgOptions: {
                    elementsToRemoveSelector: '',
                    convertHtml: true
                }
            }).then(function (base64URL) {
                saveData(base64URL, fileName, 'png');
            }).catch(function (error) {
                if (typeof error === 'string') alert(error);else alert('This type of export is not supported in the Internet Explorer');
                console.error(error);
            });
        } else {
            (0, _toSvg.exportToSVG)(_paper, {
                elementsToRemoveSelector: '',
                convertHtml: true
            }).then(function (svgString) {
                saveData(svgString, fileName, 'svg');
            }).catch(function (error) {
                alert(error);
                console.error(error);
            });
        }

        function saveData(data, fileName, type) {
            var blob = void 0;
            if (type === 'svg') {
                blob = new Blob([data], { type: type });
            } else if (type === 'png') {
                blob = (0, _dataUtils.png2Blob)(data);
            }
            (0, _fileSaverjs2.default)(blob, fileName + '.' + type);
        }
    };

    /**
     * Shows print dialog.
    */
    self.print = function () {
        (0, _toSvg.toDataURL)(_paper, {
            backgroundColor: 'white',
            svgOptions: {
                elementsToRemoveSelector: '',
                convertHtml: true
            }
        }).then(function (base64URL) {
            var printWindow = window.open('', undefined, 'width=1280,height=720');
            if (printWindow) {
                printWindow.document.write('\n                    <html>\n                        <body>\n                            <img src="' + base64URL + '"/>\n                        </body>\n                    </html>\n                ');
                printWindow.document.querySelector('img').onload = function () {
                    printWindow.document.close();
                    printWindow.print();
                };
            } else {
                alert('You should unblock popup windows for the current url to be able to print this diagram!');
            }
        }).catch(function (error) {
            if (typeof error === 'string') alert(error);else alert('This type of export is not supported in the Internet Explorer');
            console.error(error);
        });
    };

    self.setSearchKey = function (searchKey) {
        _graph.getElements().forEach(function (node) {
            node.setSearchKey(searchKey);
        });
    };

    function _doLayout() {
        // todo: refactor this algorithm
        var centerX = _paperScroller.options.baseWidth / 2;
        var centerY = _paperScroller.options.baseHeight / 2;

        var elements = (0, _layoutUtils.convertDMElementsToLayoutModels)(_nodes, _links);
        (0, _layout.removeCycles)(elements.nodes, elements.links);
        tqSankeyLayout(elements.nodes, elements.links);

        var jointElements = (0, _layoutUtils.convertJointElementsToLayoutModels)(_graph.getElements(), _graph.getLinks());
        (0, _layout.removeCycles)(jointElements.nodes, jointElements.links);
        tqSankeyLayout(jointElements.nodes, jointElements.links);
        var depthMap = (0, _utils.arrayToMap)(jointElements.nodes.map(function (je) {
            return { id: je.id, depth: je.y };
        }));

        var maxCol = -Infinity;
        elements.nodes.forEach(function (n) {
            maxCol = Math.max(n.x, maxCol);
        });

        var possibleXes = {};
        var order = {};
        elements.nodes.forEach(function (node) {
            possibleXes[node.x] = true;
        });
        var possibleColumnsList = Object.keys(possibleXes).map(function (px) {
            return Math.round(+px);
        });
        possibleColumnsList.sort(function (x1, x2) {
            if (x1 > x2) {
                return 1;
            } else if (x1 < x2) {
                return -1;
            } else {
                return 0;
            }
        }).forEach(function (x, index) {
            return order[x] = index;
        });

        var stepX = parameters.defaultElementWidth + parameters.defaultLayoutStep;
        var startPosition = centerX - stepX * (possibleColumnsList.length + 1) / 2;

        var columns = {};
        elements.nodes.forEach(function (node) {
            var originalNode = node.originalNode;
            var x = startPosition + stepX * order[Math.round(node.x)];
            if (!columns[x]) columns[x] = [];
            columns[x].push(originalNode);
        });

        var BOTTOM_MARGIN = 50;
        Object.keys(columns).forEach(function (key) {
            var column = columns[key];
            var totalHeight = 0;
            column.forEach(function (el, index) {
                var theLast = index === column.length - 1;
                var step = theLast ? 0 : BOTTOM_MARGIN;
                totalHeight += el.get('size').height + step;
            });
            column.sort(function (e1, e2) {
                var e1Depth = depthMap[e1.id] ? depthMap[e1.id].depth : 0;
                var e2Depth = depthMap[e2.id] ? depthMap[e2.id].depth : 0;

                if (e1Depth > e2Depth) {
                    return 1;
                } else if (e1Depth < e2Depth) {
                    return -1;
                } else {
                    return 0;
                }
            });
            var startY = centerY - totalHeight / 2;
            var x = +key;
            var curY = 0;
            column.forEach(function (el, index) {
                var theLast = index === column.length - 1;
                var step = theLast ? 0 : BOTTOM_MARGIN;
                el.position(x, startY + curY);
                curY += el.get('size').height + step;
            });
        });

        _paperScroller.center(centerX, centerY);

        // We hide dublications using highlighter.
        // That's why we need to be sure that nodes are
        // on the page, so we use requestAnimationFrame
        setTimeout(function () {
            _alignCrossNodes();
            _graph.getLinks().forEach(function (link) {
                _adjustAllVertices(link);
            });
            _hideDublications();
        }, 300);
    }

    // adjusting vertices
    // =============================================

    _graph.on('change:source change:target update-vertices', _adjustVertices);
    _paper.on('cell:pointerup', _adjustVertices);

    function _adjustAllVertices() {
        setTimeout(function () {
            _graph.getLinks().forEach(function (link) {
                (0, _lineageDiagramUtils.adjustVertices)(_graph, link);
            });
        }, 100);
    }

    function _adjustVertices(cell) {
        setTimeout(function () {
            (0, _lineageDiagramUtils.adjustVertices)(_graph, cell);
        }, 100);
    }

    // =============================================

    function _subscribeOnElements() {
        _nodes.forEach(function (node) {
            node.on('element-state-changed', function () {
                _adjustVertices(node.getPort().primitive);
            });
        });
    }

    function _refreshRelatedElement(cell) {
        if (cell instanceof _mapElements.GraphLink) {
            var elementsToUpdate = {};

            var link = cell;
            var prevSourceDescriptor = link.previous('source');
            var prevTargetDescriptor = link.previous('target');
            var prevSource = prevSourceDescriptor ? _graph.getCell(prevSourceDescriptor.id) : undefined;
            var prevTarget = prevTargetDescriptor ? _graph.getCell(prevTargetDescriptor.id) : undefined;

            var sourceDescriptor = link.get('source');
            var targetDescriptor = link.get('target');
            var source = _graph.getCell(sourceDescriptor.id);
            var target = _graph.getCell(targetDescriptor.id);

            if (prevSource && prevSource.activePorts) {
                elementsToUpdate[prevSource.id] = prevSource;
                var portId = prevSourceDescriptor.port;
                prevSource.activePorts[portId] = prevSource.activePorts[portId] || {};
                delete prevSource.activePorts[portId][link.id];
            }
            if (prevTarget && prevTarget.activePorts) {
                elementsToUpdate[prevTarget.id] = prevTarget;
                var _portId = prevTargetDescriptor.port;
                prevTarget.activePorts[_portId] = prevTarget.activePorts[_portId] || {};
                delete prevTarget.activePorts[_portId][link.id];
            }

            if (source.activePorts) {
                elementsToUpdate[source.id] = source;
                source.activePorts[sourceDescriptor.port] = source.activePorts[sourceDescriptor.port] || {};
                source.activePorts[sourceDescriptor.port][link.id] = link;
            }

            if (target.activePorts) {
                elementsToUpdate[target.id] = target;
                target.activePorts[targetDescriptor.port] = target.activePorts[targetDescriptor.port] || {};
                target.activePorts[targetDescriptor.port][link.id] = link;
            }

            Object.keys(elementsToUpdate).forEach(function (elId) {
                return elementsToUpdate[elId].refresh();
            });
            _hideDublications();
            _alignCrossNodes();
        }
    }

    function _alignCrossNodes() {
        var tempMap = {};
        var uniqueCrossLinks = [];
        _links.forEach(function (link) {
            var crossNode = link.getCrossNode();
            if (crossNode && !tempMap[crossNode.id]) {
                tempMap[crossNode.id] = true;
                uniqueCrossLinks.push(link);
            }
        });

        uniqueCrossLinks.forEach(function (l) {
            return l.alignCrossNode();
        });
    }

    function _hideDublications() {
        var uniqueMap = {};
        _links.forEach(function (link) {
            var typeId = /*link.typeId ||*/link.label;
            var sourcePortId = link.source.getPort().id;
            var targetPortId = link.target.getPort().id;
            var cacheKey = cacheFunction(typeId, sourcePortId, targetPortId);
            var isHighlighted = link.highlighting();
            if (isHighlighted || !uniqueMap[cacheKey]) {
                if (uniqueMap[cacheKey]) {
                    uniqueMap[cacheKey].hide();
                }
                uniqueMap[cacheKey] = link;
                link.show();
            } else {
                link.hide();
            }
        });

        function cacheFunction(label, sourcePortId, targetPortId) {
            return label + '~#tqDMLink#~' + sourcePortId + '~#tqDMLink#~' + targetPortId;
        }
    }
}
exports.default = MapLayout;


function tqSankeyLayout(nodes, links) {
    (0, _sankey2.default)().step([10, 10]).groups([{
        nodes: nodes,
        links: links
    }]).nodeWidth(1).nodeHeight(1).nodes(nodes).links(links).layout(2000);
}

},{"../../layout/layout":56,"../../layout/sankey":57,"../../subscriptionAPI/subscribeable":65,"../../utils/dataUtils":66,"../../utils/layoutUtils":67,"../../utils/lineageDiagramUtils":68,"../../utils/utils":69,"../toSvg":53,"./mapElements":42,"./mapViews":44,"file-saverjs":2,"rappid":"rappid"}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CSS_CLASS_NUMBER = exports.MAX_NODE_HEIGHT = undefined;
exports.GraphNodeView = GraphNodeView;
exports.GraphLinkView = GraphLinkView;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _mapElements = require('./mapElements');

var _utils = require('../../utils/utils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function GraphNodeView() {
    joint.dia.ElementView.apply(this, arguments);
}

var MAX_NODE_HEIGHT = exports.MAX_NODE_HEIGHT = 200;
var CSS_CLASS_NUMBER = exports.CSS_CLASS_NUMBER = 3;

GraphNodeView.prototype = Object.create(joint.dia.ElementView.prototype);
GraphNodeView.prototype._processedIds; // prevent cycles
GraphNodeView.prototype._scale = 1; // default scale

GraphNodeView.prototype.initialize = function () {
    var _this = this;

    joint.dia.ElementView.prototype.initialize.apply(this, arguments);
    this._processedIds = {};
    this.parts = {};

    var box = document.createElement('DIV');
    box.className = 'derivation-node';
    box.id = this.model.id;
    box.onmousedown = function (event) {
        (0, _utils.onDragStart)(event, function (diff) {
            var curPos = _this.model.position();
            _this.model.position(curPos.x + diff.x / _this._scale, curPos.y + diff.y / _this._scale);
            event.stopPropagation();
        }, function (event) {
            if (_this.model.graph) _this.model.graph.trigger('update-vertices', event);
        });
        event.stopPropagation();
    };

    this.parts['box'] = box;

    var scroller = this._createScroller();
    box.appendChild(scroller);
    this.parts['scroller'] = scroller;

    var header = this._createHeader(this.model.model);
    box.appendChild(header);
    this.parts['header'] = header;

    var body = this._createBody(this.model.model);
    box.appendChild(body);
    this.parts['body'] = body;

    var collapseButton = this._createCollapseButton();
    header.appendChild(collapseButton);
    this.parts['collapseButton'] = collapseButton;

    this.model.on('change', this._updateBox, this);
    this.model.on('remove', this._removeBox, this);
    this.model.on('redraw-view', this.debouncedRender, this);
    this.model.on('elements-state-changed', this.debouncedRender, this);
    this.model.on('ports-state-changed', this._updatePorts, this);
    this.model.on('change:collapsed', this.debouncedRender, this);

    this._update();
};

GraphNodeView.prototype.debouncer;
GraphNodeView.prototype.debouncedRender = function () {
    var _this2 = this;

    cancelAnimationFrame(this.debouncer);
    this.debouncer = requestAnimationFrame(function () {
        _this2.render();
    });
};

GraphNodeView.prototype.render = function () {
    this._processedIds = {};
    joint.dia.ElementView.prototype.render.apply(this, arguments);
    var box = this.parts['box'];
    if (this.paper) {
        this._update();
        this.paper.$el.prepend(box);
        this._updateScroller();
        return this;
    } else {
        return this;
    }
};

GraphNodeView.prototype._update = function (components) {
    var _this3 = this;

    this._updateBody();

    components = components || this.model.getAllChildren();
    components.forEach(function (model) {
        return _this3._updateModel(model);
    });

    this._updateCollapseButton();
    this._updateBox();
    this._updatePorts();
};

GraphNodeView.prototype._updateBox = function () {
    var box = this.parts['box'];

    var elementBBox = this.model.getBBox();
    var height = box.getBoundingClientRect().height / this._scale;

    box.style.width = elementBBox.width + 'px';
    this.model.resize(elementBBox.width, height);

    var x_error = elementBBox.width / 2;
    var y_error = height / 2;
    box.style.left = (elementBBox.x + x_error) * this.model.scale - x_error + 'px';
    box.style.top = (elementBBox.y + y_error) * this.model.scale - y_error + 'px';

    this._scale = this.model.scale;
    box.style.transform = 'scale(' + this._scale + ')';
};

GraphNodeView.prototype._updatePorts = function () {
    var box = this.parts['box'];
    var body = this.parts['body'];
    var freshPorts = {};
    var size = this.model.get('size');
    this.model.getAllChildren().forEach(function (element) {
        var inPortId = (0, _mapElements.getPortId)(element.id, 'in');
        var outPortId = (0, _mapElements.getPortId)(element.id, 'out');
        var htmlElement = box.querySelector('#' + element.id);

        var header = htmlElement ? htmlElement.querySelector('.dn-group_header') : undefined;
        var portHtmlElement = void 0;
        if (header) {
            portHtmlElement = header;
        } else {
            portHtmlElement = htmlElement;
        }
        if (portHtmlElement) {
            var offsetTop = getOffsetTop(portHtmlElement);
            var clientHeight = portHtmlElement.clientHeight;
            var scrollToTop = body.scrollTop;
            var minY = body.offsetTop;
            var maxY = body.clientHeight + minY;
            var middlePoint = -scrollToTop + offsetTop + clientHeight / 2;
            var refY = Math.max(Math.min(middlePoint, maxY), minY);

            freshPorts['.' + inPortId] = {
                ref: '.body',
                'ref-y': refY,
                'ref-x': 0
            };
            freshPorts['.' + outPortId] = {
                ref: '.body',
                'ref-y': refY,
                'ref-x': size.width
            };
        }
    });

    this.model.attr(freshPorts);

    function getOffsetTop(element) {
        if (element.className !== 'derivation-node') {
            return element.offsetTop + element.clientTop + (element.offsetParent ? getOffsetTop(element.offsetParent) : 0);
        } else {
            return 0;
        }
    }
};

GraphNodeView.prototype._createScroller = function () {
    var _this4 = this;

    var scroller = document.createElement('DIV');
    scroller.className = 'derivation-node_body-scroller';
    scroller.onscroll = function () {
        _this4.parts['body'].scrollTop = _this4.model.sctollTop = scroller.scrollTop;
        _this4.model.updatePorts();
    };
    var bodySize = document.createElement('DIV');
    bodySize.className = 'derivation-node_body-scroller__size';
    scroller.appendChild(bodySize);

    return scroller;
};

GraphNodeView.prototype._updateScroller = function () {
    var scroller = this.parts['scroller'];
    var body = this.parts['body'];
    var collapseButton = this.parts['collapseButton'];

    var bbox = body.firstChild.getBoundingClientRect();
    var bodyHeight = bbox.height / this._scale;
    var bodyWidth = bbox.width / this._scale;
    if (scroller.firstChild) {
        // for IE11
        scroller.firstChild.style.height = bodyHeight + 'px';
        scroller.firstChild.style.width = bodyWidth + 'px';
    }
    var exceedSize = bodyHeight <= MAX_NODE_HEIGHT;
    var isScrollable = exceedSize || !this.model.get('collapsed');
    collapseButton.style.display = exceedSize ? 'none' : null;
    scroller.style.display = isScrollable ? 'none' : null;

    body.scrollTop = this.model.sctollTop;
    scroller.scrollTop = this.model.sctollTop;
};

GraphNodeView.prototype._removeBox = function () {
    this.parts['box'].parentNode.removeChild(this.parts['box']);
    this.parts = {};
};

GraphNodeView.prototype._createBody = function (model) {
    var body = document.createElement('DIV');
    body.className = 'derivation-node_body';
    var renderedModel = this._createModel(model, 0);
    body.appendChild(renderedModel);

    return body;
};

GraphNodeView.prototype._updateBody = function () {
    var body = this.parts['body'];

    if (this.model.get('collapsed')) {
        body.style.maxHeight = MAX_NODE_HEIGHT + 'px';
    } else {
        body.style.maxHeight = null;
    }
};

GraphNodeView.prototype._createCollapseButton = function () {
    var _this5 = this;

    var collapseButton = document.createElement('IMG');
    collapseButton.className = 'derivation-node-collapse-button';
    collapseButton.onclick = function () {
        if (_this5.model.get('collapsed')) {
            _this5.model._expandElement();
        } else {
            _this5.model._collapseElement();
        }
    };

    return collapseButton;
};

GraphNodeView.prototype._updateCollapseButton = function () {
    var collapseButton = this.parts['collapseButton'];
    if (this.model.get('collapsed')) {
        collapseButton.classList.add('collapsed');
    } else {
        collapseButton.classList.remove('collapsed');
    }
};

GraphNodeView.prototype._createHeader = function (model) {
    var header = document.createElement('DIV');
    header.className = 'derivation-node_header';

    var label = document.createElement('LABEL');
    label.className = 'derivation-node_header__label';
    label.innerText = model.title || '';

    header.appendChild(label);

    return header;
};

GraphNodeView.prototype._createModel = function (model, deep) {
    if (!this._processedIds[model.id]) {
        this._processedIds[model.id] = true;

        var modelView = void 0;
        if (model.children.length > 0) {
            modelView = this._createGroup(model, deep);
        } else {
            modelView = this._createElement(model, deep);
        }
        this.parts[model.id] = modelView;
        return modelView;
    }
};

GraphNodeView.prototype._updateModel = function (model) {
    if (model.children.length > 0) {
        this._updateGroup(model);
    } else {
        this._updateElement(model);
    }
};

GraphNodeView.prototype._createGroup = function (rootModel, deep) {
    var _this6 = this;

    var icon = rootModel.icon ? '<span class="dn-header-icon"><i class="' + rootModel.icon + '"></i></span>' : '';
    var groupElement = document.createElement('div');
    var cssClass = 'derivation-node_group_' + deep % (CSS_CLASS_NUMBER + 1);
    groupElement.id = rootModel.id;
    groupElement.className = cssClass + ' dn-group';
    groupElement.innerHTML = '\n        <div class="dn-group_header">\n            <span class="dn-arrow dn__incoming-arrow">\n                <div class="dn-arrow-triangle"></div>\n            </span>\n            <img/>\n            <div class="dn-group_header__label"  title="' + (rootModel.endpointId + '(type: ' + rootModel.type + ')') + '">\n                ' + icon + '\n                <label>' + rootModel.label + '</label>\n            </div>\n            <span class="dn-arrow dn__outgoing-arrow">\n                <div class="dn-arrow-triangle"></div>\n            </span>\n        </div>\n        <ul class="derivation-node_list-of-elements"></ul>\n    ';

    var activeHeaderArea = groupElement.querySelector('.dn-group_header__label');
    activeHeaderArea.onclick = function (event) {
        _this6.model.fireClickEvent(event, groupElement.id);
        event.stopPropagation();
    };

    var children = groupElement.querySelector('.derivation-node_list-of-elements');
    rootModel.children.forEach(function (element) {
        var renderedModel = _this6._createModel(element, deep + 1);
        if (renderedModel) {
            children.appendChild(renderedModel);
        }
    });

    var collapseButton = groupElement.querySelector('.dn-group img');
    collapseButton.onclick = function (event) {
        event.stopPropagation();
        _this6.model.onClickCollapseButton(rootModel.id);
    };

    return groupElement;
};

GraphNodeView.prototype._updateGroup = function (rootModel) {
    var groupElement = this.parts[rootModel.id];

    groupElement.style.display = rootModel.invisible ? 'none' : null;
    if (rootModel.invisible) return;

    var noVisibleChildren = !rootModel.children || rootModel.children.filter(function (child) {
        return !child.invisible;
    }).length === 0;
    if (rootModel.collapsed && noVisibleChildren) {
        groupElement.classList.add('dn-collapsed');
    } else {
        groupElement.classList.remove('dn-collapsed');
    }

    if (rootModel.collapsed && noVisibleChildren) {
        groupElement.classList.add('dn-collapsed');
    } else {
        groupElement.classList.remove('dn-collapsed');
    }

    var isHighlighted = this.model.highlightedId === rootModel.id;
    if (isHighlighted) {
        groupElement.classList.add('tq-dm-highlighted');
    } else {
        groupElement.classList.remove('tq-dm-highlighted');
    }

    var htmlInPorts = groupElement.querySelector('.dn-arrow.dn__incoming-arrow');
    var htmlInTriangel = htmlInPorts.querySelector('.dn-arrow-triangle');
    var inPortId = (0, _mapElements.getPortId)(rootModel.id, 'in');
    var incomingLinksMap = this.model.activePorts[inPortId] || {};
    var activeInLinks = Object.keys(incomingLinksMap).map(function (key) {
        return incomingLinksMap[key];
    });
    var inPortVisible = activeInLinks.length > 0 && rootModel !== this.model.model;
    var needInArrow = activeInLinks && checkArrow(this.model, activeInLinks);
    htmlInPorts.style.display = inPortVisible ? null : 'none';
    htmlInTriangel.style.display = needInArrow ? null : 'none';

    var htmlOutPorts = groupElement.querySelector('.dn-arrow.dn__outgoing-arrow');
    var htmlOutTriangel = htmlOutPorts.querySelector('.dn-arrow-triangle');
    var outPortId = (0, _mapElements.getPortId)(rootModel.id, 'out');
    var outgoingLinksMap = this.model.activePorts[outPortId] || {};
    var activeOutLinks = Object.keys(outgoingLinksMap).map(function (key) {
        return outgoingLinksMap[key];
    });
    var needOutArrow = activeOutLinks && checkArrow(this.model, activeOutLinks);
    var outPortVisible = activeOutLinks.length > 0 && rootModel !== this.model.model;
    htmlOutPorts.style.display = outPortVisible ? null : 'none';
    htmlOutTriangel.style.display = needOutArrow ? null : 'none';

    var img = groupElement.querySelector('.dn-group_header img');
    img.className = rootModel.collapsed ? 'dn-collapsed' : '';

    var label = groupElement.querySelector('.dn-group_header__label label');
    label.innerHTML = getColoredLabel(rootModel.label, this.model.searchKey);
};

GraphNodeView.prototype._createElement = function (rootModel, deep) {
    var _this7 = this;

    var element = document.createElement('div');
    var icon = rootModel.icon ? '<span class="dn-header-icon"><i class="' + rootModel.icon + '"></i></span>' : '';

    element.className = 'dn-element derivation-node_element_' + deep;
    element.id = rootModel.id;
    element.onclick = function (event) {
        _this7.model.fireClickEvent(event, element.id);
        event.stopPropagation();
    };
    element.innerHTML = '\n        <span class="dn-arrow dn__incoming-arrow">\n            <div class="dn-arrow-triangle"></div>\n        </span>\n        <div class="dn-element_center">\n            ' + icon + '\n            <label title="' + (rootModel.endpointId + '(type: ' + rootModel.type + ')') + '">\n                ' + rootModel.label + '\n            </label>\n        </div>\n        <span class="dn-arrow dn__outgoing-arrow">\n            <div class="dn-arrow-triangle"></div>\n        </span>\n    ';

    return element;
};

GraphNodeView.prototype._updateElement = function (rootModel) {
    var element = this.parts[rootModel.id];

    element.style.display = rootModel.invisible ? 'none' : null;
    if (rootModel.invisible) return;

    var htmlInPorts = element.querySelector('.dn-arrow.dn__incoming-arrow');
    var htmlInTriangel = htmlInPorts.querySelector('.dn-arrow-triangle');
    var inPortId = (0, _mapElements.getPortId)(rootModel.id, 'in');
    var incomingLinksMap = this.model.activePorts[inPortId] || {};
    var activeInLinks = Object.keys(incomingLinksMap).map(function (key) {
        return incomingLinksMap[key];
    });
    var inPortVisible = activeInLinks.length > 0 && rootModel !== this.model.model;
    var needInArrow = activeInLinks && checkArrow(this.model, activeInLinks);
    htmlInPorts.style.display = inPortVisible ? null : 'none';
    htmlInTriangel.style.display = needInArrow ? null : 'none';

    var htmlOutPorts = element.querySelector('.dn-arrow.dn__outgoing-arrow');
    var htmlOutTriangel = htmlOutPorts.querySelector('.dn-arrow-triangle');
    var outPortId = (0, _mapElements.getPortId)(rootModel.id, 'out');
    var outgoingLinksMap = this.model.activePorts[outPortId] || {};
    var activeOutLinks = Object.keys(outgoingLinksMap).map(function (key) {
        return outgoingLinksMap[key];
    });
    var needOutArrow = activeOutLinks && checkArrow(this.model, activeOutLinks);
    var outPortVisible = activeOutLinks.length > 0 && rootModel !== this.model.model;
    htmlOutPorts.style.display = outPortVisible ? null : 'none';
    htmlOutTriangel.style.display = needOutArrow ? null : 'none';

    var isHighlighted = this.model.highlightedId === rootModel.id;
    if (isHighlighted) {
        element.classList.add('tq-dm-highlighted');
    } else {
        element.classList.remove('tq-dm-highlighted');
    }

    var label = element.querySelector('.dn-element_center label');
    label.innerHTML = getColoredLabel(rootModel.label, this.model.searchKey);
};

function getColoredLabel(label, key) {
    if (!key) return label;
    var lowerCaseLabel = label.toLowerCase();
    var keyIndex = lowerCaseLabel.indexOf(key);

    if (keyIndex === -1) {
        return label;
    } else if (keyIndex === 0) {
        var firstPart = label.substring(0, key.length);
        var secondPart = label.substring(key.length, label.length);
        return '<i class="tq-dm-highlighted-key">' + firstPart + '</i>' + secondPart;
    } else if (keyIndex + key.length === label.length) {
        var _firstPart = label.substring(0, keyIndex);
        var _secondPart = label.substring(keyIndex, label.length);
        return _firstPart + '<i class="tq-dm-highlighted-key">' + _secondPart + '</i>';
    } else {
        var _firstPart2 = label.substring(0, keyIndex);
        var _secondPart2 = label.substring(keyIndex, keyIndex + key.length);
        var thirdPart = label.substring(keyIndex + key.length, label.length);
        return _firstPart2 + '<i class="tq-dm-highlighted-key">' + _secondPart2 + '</i>' + thirdPart;
    }
}

/**
 * @private
 * The GraphLinkView class. Mainly in charge of link highlighting.
 * Listen to events and apply highlighters.
 * @class
 * @augments joint.dia.LinkView
 * @param {NodeModel} dataModel - Model of graph node
 * @param {Parameters} parameters - The set of parameters
*/
function GraphLinkView() {
    joint.dia.LinkView.apply(this, arguments);
}
GraphLinkView.prototype = Object.create(joint.dia.LinkView.prototype);
GraphLinkView.prototype.initialize = function () {
    joint.dia.LinkView.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, 'change:highlighted change:blured update-state', onEvent);
};

var LG_DM_CELL_HIGHLIGHTER = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-dm-highlighted'
        }
    }
};
var LG_DM_CELL_BLURER = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-dm-blured'
        }
    }
};

var LG_DM_CELL_HIDDEN = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-dm-hidden'
        }
    }
};

function onEvent() {
    if (this.model.get('highlighted')) {
        this.highlight(null, LG_DM_CELL_HIGHLIGHTER);
    } else {
        this.unhighlight(null, LG_DM_CELL_HIGHLIGHTER);
    }
    if (this.model.get('blured')) {
        this.highlight(null, LG_DM_CELL_BLURER);
    } else {
        this.unhighlight(null, LG_DM_CELL_BLURER);
    }
    if (this.model.hidden) {
        this.highlight(null, LG_DM_CELL_HIDDEN);
    } else {
        this.unhighlight(null, LG_DM_CELL_HIDDEN);
    }
}

function checkArrow(self, links) {
    for (var i = 0; i < links.length; i++) {
        var link = links[i];

        if (link.get('target').id === self.id) {
            return true;
        }
    }
    return false;
}

},{"../../utils/utils":69,"./mapElements":42,"rappid":"rappid"}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AspectLink = AspectLink;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _resourceProvider = require('../../data/resourceProvider');

var _elements = require('./elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * AspectLinkModel - data model of an AspectLink object
 * @typedef {Object} AspectLinkModel
 * @property {Node | TerminationNode} target - Target Node
 * @property {Node | TerminationNode} source - Source Node
*/

/**
 * @private
 * The graph Link based on joint.dia.Link.
 * @class
 * @augments joint.dia.Link
 * @param {AspectLinkModel} options
 * @param {Parameters} parameters - The set of parameters
 * @property {SimpleLinkModel} model - Data model 
*/
function AspectLink(options, parameters) {
    var self = this;

    var _res = new _resourceProvider.ResourceProvider(parameters);

    var source = { id: options.source.id, port: 'clipRectPort' };
    var target = { id: options.target.id, port: 'clipRectPort' };

    var linkColor = _res.getColor('aspectLink');

    joint.dia.Link.apply(self, [{
        id: options.id,
        type: 'aspect-link',
        source: source,
        target: target,
        z: _elements.Z_INDEXES.ASPECT_LINK,
        attrs: {
            '.connection': {
                stroke: linkColor,
                'stroke-dasharray': '10, 10',
                'stroke-width': '5px'
            },
            '.marker-source': {
                fill: linkColor,
                stroke: linkColor,
                d: 'M0,3a3,3 0 1,0 6,0a3,3 0 1,0 -6,0'
            },
            '.marker-target': {
                fill: linkColor,
                stroke: linkColor,
                d: 'M0,3a3,3 0 1,0 6,0a3,3 0 1,0 -6,0'
            }
        },
        // variants for the experimenting
        connector: { name: 'rounded' }
    }]);

    /**
     * Blurs the AspectLink.
     * @memberof AspectLink
     * @method
    */
    self.blure = function () {
        self.set('blured', true);
    };

    /**
     * Removes blur from the AspectLink.
     * @memberof AspectLink
     * @method
    */
    self.unblure = function () {
        self.set('blured', false);
    };

    /**
     * Hides the AspectLink.
     * @memberof AspectLink
     * @method
    */
    self.hide = function () {
        self.set('hidden', true);
    };

    /**
     * Shows the AspectLink.
     * @memberof AspectLink
     * @method
    */
    self.show = function () {
        self.set('hidden', false);
    };

    self.model = { source: options.source.id, target: options.target.id };
}
AspectLink.prototype = Object.create(joint.dia.Link.prototype);

},{"../../data/resourceProvider":30,"./elements":46,"rappid":"rappid"}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Z_INDEXES = exports.AspectLink = exports.TerminationLink = exports.TerminationNode = exports.Link = exports.Node = undefined;
exports.NodeView = NodeView;
exports.LinkView = LinkView;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _node = require('./node');

var _link = require('./link');

var _terminationLink = require('./terminationLink');

var _terminationNode = require('./terminationNode');

var _aspectLink = require('./aspectLink');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.Node = _node.Node;
exports.Link = _link.Link;
exports.TerminationNode = _terminationNode.TerminationNode;
exports.TerminationLink = _terminationLink.TerminationLink;
exports.AspectLink = _aspectLink.AspectLink;


var V = joint.V;
var g = joint.g;

var Z_INDEXES = exports.Z_INDEXES = {
    ASPECT_LINK: 25,
    TERMINATION_ELEMENT: 25,
    SELECTED_ELEMENT: 30,
    NODE: 20,
    LINK: 15,
    BLURED_NODE: 10,
    BLURED_LINK: 5,
    VIEW_FRAME: 1
};

var LG_CELL_HIGHLIGHTER = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-lg-highlighted'
        }
    }
};
var LG_CELL_HIDDEN = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-lg-hidden-element'
        }
    }
};
var LG_CELL_BLURER = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-lg-blured'
        }
    }
};
var LG_SHORT_LABEL = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-lg-short-label'
        }
    }
};
var LG_DRAGGED_NODE = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-lg-dragged-node'
        }
    }
};

function getClass() {
    if (this.model.get('highlighted')) {
        this.highlight(null, LG_CELL_HIGHLIGHTER);
    } else {
        this.unhighlight(null, LG_CELL_HIGHLIGHTER);
    }
    if (this.model.get('blured')) {
        this.highlight(null, LG_CELL_BLURER);
    } else {
        this.unhighlight(null, LG_CELL_BLURER);
    }
    if (this.model.get('hidden')) {
        this.highlight(null, LG_CELL_HIDDEN);
    } else {
        this.unhighlight(null, LG_CELL_HIDDEN);
    }
    if (this.model.get('short-label')) {
        this.highlight(null, LG_SHORT_LABEL);
    } else {
        this.unhighlight(null, LG_SHORT_LABEL);
    }
    if (this.model.get('dragged')) {
        this.highlight(null, LG_DRAGGED_NODE);
    } else {
        this.unhighlight(null, LG_DRAGGED_NODE);
    }
}

/**
 * @private
 * The LinkView class. Mainly in charge of node highlighting.
 * Listen to events and apply highlighters.
 * @class
 * @augments joint.dia.LinkView
 * @param {NodeModel} dataModel - Model of graph node
 * @param {ver} parameters - The set of parameters
*/
function NodeView() {
    joint.dia.ElementView.apply(this, arguments);
}
NodeView.prototype = Object.create(joint.dia.ElementView.prototype);
NodeView.prototype.initialize = function () {
    joint.dia.ElementView.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, ['change:dragged', 'change:highlighted', 'change:blured', 'change:hidden', 'refresh-highlighting', 'change:short-label'].join(' '), this.debouncedHighlighting);
};
NodeView.prototype.debouncer;
NodeView.prototype.debouncedHighlighting = function () {
    var _this = this;

    cancelAnimationFrame(this.debouncer);
    this.debouncer = requestAnimationFrame(function () {
        getClass.call(_this);
    });
};

/**
 * @private
 * The LinkView class. Mainly in charge of link highlighting.
 * Listen to events and apply highlighters.
 * @class
 * @augments joint.dia.LinkView
 * @param {NodeModel} dataModel - Model of graph node
 * @param {Parameters} parameters - The set of parameters
*/
function LinkView() {
    joint.dia.LinkView.apply(this, arguments);
}
LinkView.prototype.render = function () {
    joint.dia.LinkView.prototype.render.apply(this, arguments);
};
LinkView.prototype = Object.create(joint.dia.LinkView.prototype);
LinkView.prototype.initialize = function () {
    joint.dia.LinkView.prototype.initialize.apply(this, arguments);

    this.listenTo(this.model, ['change:highlighted', 'change:blured', 'change:hidden', 'refresh-highlighting'].join(' '), this.debouncedHighlighting);
};
LinkView.prototype.getPointAtLength = function (k) {
    return this._V.connection.node.getPointAtLength(this._V.connection.node.getTotalLength() * k);
};
LinkView.prototype.debouncer;
LinkView.prototype.debouncedHighlighting = function () {
    var _this2 = this;

    cancelAnimationFrame(this.debouncer);
    this.debouncer = requestAnimationFrame(function () {
        getClass.call(_this2);
    });
};
LinkView.prototype.updateToolsPosition = function () {
    var _this3 = this;

    if (!this._V.linkTools) return this;

    // Move the tools a bit to the target position but don't cover the `sourceArrowhead` marker.
    // Note that the offset is hardcoded here. The offset should be always
    // more than the `this.$('.marker-arrowhead[end="source"]')[0].bbox().width` but looking
    // this up all the time would be slow.

    var scale = '';
    var connectionLength = this.getConnectionLength();

    // Firefox returns connectionLength=NaN in odd cases (for bezier curves).
    // In that case we won't update tools position at all.
    if (!_.isNaN(connectionLength)) {

        // If the link is too short, make the tools half the size and the offset twice as low.
        if (connectionLength < this.options.shortLinkLength) {
            scale = 'scale(.5)';
        }

        this._toolCache.forEach(function (tool, index, arr) {
            var i = index + 1;
            var l = arr.length + 1;
            var k = i / l;
            var toolPosition = _this3.getPointAtLength(k);
            if (tool.node instanceof SVGGElement) {
                tool.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);

                if (_this3.options.doubleLinkTools && connectionLength >= _this3.options.longLinkLength) {
                    var newPosition = _this3.getPointAtLength(k /*connectionLength - doubleLinkToolsOffset*/);
                    _this3._tool2Cache.attr('transform', 'translate(' + newPosition.x + ', ' + newPosition.y + ') ' + scale);
                    _this3._tool2Cache.attr('visibility', 'visible');
                } else if (_this3.options.doubleLinkTools) {
                    _this3._tool2Cache.attr('visibility', 'hidden');
                }
            }
        });
    }

    return this;
};

LinkView.prototype.renderTools = function () {

    if (!this._V.linkTools) return this;

    // Tools are a group of clickable elements that manipulate the whole link.
    // A good example of this is the remove tool that removes the whole link.
    // Tools appear after hovering the link close to the `source` element/point of the link
    // but are offset a bit so that they don't cover the `marker-arrowhead`.

    var htmlTools = this._V.linkTools.node;
    var toolTemplate = joint.util.template(this.model.get('toolMarkup') || this.model.toolMarkup);
    var vTools = V(toolTemplate());

    var tools;
    if (vTools instanceof Array) {
        tools = vTools;
    } else {
        tools = [vTools];
    }

    tools.forEach(function (tool) {
        htmlTools.appendChild(tool.node);
    });

    // Cache the tool node so that the `updateToolsPosition()` can update the tool position quickly.
    this._toolCache = tools;

    return this;
};

var overridedFunction = LinkView.prototype.getConnectionPoint;
LinkView.prototype.getConnectionPoint = function (end, selectorOrPoint, referenceSelectorOrPoint) {
    var connectionPoint = overridedFunction.apply(this, arguments);

    var limitBox = void 0;
    _.isEmpty(selectorOrPoint) && (selectorOrPoint = { x: 0, y: 0 });
    _.isEmpty(referenceSelectorOrPoint) && (referenceSelectorOrPoint = { x: 0, y: 0 });

    if (!selectorOrPoint.id) {
        var point = g.point(selectorOrPoint);
        limitBox = {
            x: point.x,
            y: point.y,
            width: 0,
            height: 0,
            center: function center() {
                return point;
            }
        };
    } else {
        limitBox = end === 'source' ? this.sourceBBox : this.targetBBox;
    }
    var limitCeter = limitBox.center();

    var rightBorder = Math.round(limitCeter.x + limitBox.width / 2);
    var leftBorder = Math.round(limitCeter.x - limitBox.width / 2);
    var bottomBorder = Math.round(limitCeter.y + limitBox.height / 2);
    var topBorder = Math.round(limitCeter.y - limitBox.height / 2);

    var xInside = leftBorder < connectionPoint.x && connectionPoint.x < rightBorder;
    var yInside = topBorder < connectionPoint.y && connectionPoint.y < bottomBorder;
    var isInTheBody = xInside && yInside;

    if (isInTheBody) {
        var rightDist = rightBorder - connectionPoint.x;
        var leftDist = connectionPoint.x - leftBorder;
        var bottomDist = bottomBorder - connectionPoint.y;
        var topDist = connectionPoint.y - topBorder;

        var minDist = Math.min(rightDist, leftDist, bottomDist, topDist);

        if (rightDist === minDist) {
            connectionPoint.offset(rightDist, 0);
        } else if (leftDist === minDist) {
            connectionPoint.offset(-leftDist, 0);
        } else if (topDist === minDist) {
            connectionPoint.offset(0, -topDist);
        } else if (bottomDist === minDist) {
            connectionPoint.offset(0, bottomDist);
        }
    }

    var reference = void 0;
    var spotBbox = end === 'source' ? this.sourceBBox : this.targetBBox;
    if (!referenceSelectorOrPoint.id) {
        reference = g.point(referenceSelectorOrPoint);
    } else {
        var referenceBbox = end === 'source' ? this.targetBBox : this.sourceBBox;

        reference = g.rect(referenceBbox).intersectionWithLineFromCenterToPoint(g.rect(spotBbox).center());
        reference = reference || g.rect(referenceBbox).center();
    }

    var alignX = Math.abs(reference.x - connectionPoint.x);
    var alignY = Math.abs(reference.y - connectionPoint.y);

    var routerId = this.model.get('router') && this.model.get('router').name;
    var specialRouter = routerId && (routerId === 'lgrouter' || routerId === 'metro');
    if (this.model instanceof _link.Link && specialRouter) {
        if (alignX <= alignY) {
            connectionPoint.offset(reference.x - connectionPoint.x, 0);
        } else {
            connectionPoint.offset(0, reference.y - connectionPoint.y);
        }
    }

    connectionPoint = g.point({
        x: Math.max(Math.min(Math.round(connectionPoint.x), rightBorder), leftBorder),
        y: Math.max(Math.min(Math.round(connectionPoint.y), bottomBorder), topBorder)
    });

    return connectionPoint;
};

},{"./aspectLink":45,"./link":47,"./node":48,"./terminationLink":49,"./terminationNode":50,"lodash":"lodash","rappid":"rappid"}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ALWAYS_VISIBLE_TOOL_BUTTONS = exports.DEFAULT_LINK_TYPE = undefined;
exports.Link = Link;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _resourceProvider = require('../../data/resourceProvider');

var _elements = require('./elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var DEFAULT_LINK_TYPE = exports.DEFAULT_LINK_TYPE = 'lineage-gram-link';
var ALWAYS_VISIBLE_TOOL_BUTTONS = exports.ALWAYS_VISIBLE_TOOL_BUTTONS = 'lg-visible-tool-buttons';

/**
 * LinkModel - data model for a {@link Link} object
 * @typedef {Object} LinkModel
 * @property {string} id - Link identifyer
 * @property {string} target - Target Node id
 * @property {string} source - Source Node id
 * @property {string} linktype - Type of the Link
*/

/**
 * The graph Link class which is  based on joint.dia.Link. Is the one of the main elements of the LineageFram.
 * Represents existing relation of the parts of the dataset.  Has specific type and id.
 * @class
 * @private
 * @augments joint.dia.Link
 * 
 * @param {LinkModel} dataModel - Data model
 * @param {Parameters} parameters - The set of parameters
 * 
 * @property {LinkModel} model - Data model
 * @property {TerminationLink} terminationLink - Termination link which
 * represents this link, when the node is out of the viewFrame
 * @property {boolean} highlighted - Tells wheter highlighted link or not (use method get to get this property, e.g. link.get('highlighted'))
 * @property {boolean} blured - Tells wheter blured link or not (use method get to get this property, e.g. link.get('blured'))
*/
function Link(dataModel, parameters) {
    var self = this;
    var _res = new _resourceProvider.ResourceProvider(parameters);

    self.terminationLinks = [];
    self.highlighted = false;
    self.blured = false;

    var _linkStyle = void 0;
    var _toolMarkup = void 0;
    if (dataModel.group) {
        var existedTypeIds = [];
        var groupTools = dataModel.group.filter(function (model) {
            var decision = existedTypeIds.indexOf(model.linkType) === -1;
            if (decision) {
                existedTypeIds.push(model.linkType);
            }
            return decision;
        }).map(function (model) {
            return {
                linkType: model.linkType,
                linkStyle: _res.getLinkStyle(model.linkType)
            };
        });

        if (groupTools.length === 1) _linkStyle = groupTools[0].linkStyle;else _linkStyle = _res.getLinkStyle(dataModel.linkType);
        _toolMarkup = _getToolMarkup(groupTools);
    } else {
        _linkStyle = _res.getLinkStyle(dataModel.linkType);
        _toolMarkup = _getToolMarkup([{
            linkType: dataModel.linkType,
            linkStyle: _linkStyle
        }]);
    }

    var types = [DEFAULT_LINK_TYPE];
    if (_linkStyle.cssClass && _linkStyle.cssClass !== DEFAULT_LINK_TYPE) {
        types.push(_linkStyle.cssClass);
    }

    if (_linkStyle.toolButton.alwaysVisible) {
        types.push(ALWAYS_VISIBLE_TOOL_BUTTONS);
    }

    joint.dia.Link.apply(self, [{
        type: types.join(' '),
        source: { id: dataModel.source, port: 'clipRectPort' },
        target: { id: dataModel.target, port: 'clipRectPort' },
        z: _elements.Z_INDEXES.LINK,
        attrs: _getLinkAttributes(_linkStyle),
        connector: { name: 'rounded' },
        // connector: { name: 'jumpover', args: { type: 'gap' }},
        router: {
            name: dataModel.routing,
            args: {
                excludeTypes: ['viewFrame', 'terminationLink', 'terminationNode', 'view-frame-splitter', 'view-frame-splitter-vertical', 'aspectLink'],
                maximumLoops: 3000,
                maxAllowedDirectionChange: 3000
            }
        },
        toolMarkup: _toolMarkup
    }]);

    function _getLinkAttributes(linkStyle) {
        var attributes = {};
        attributes['.connection'] = {
            stroke: linkStyle.color,
            'stroke-width': linkStyle.thickness,
            'stroke-dasharray': linkStyle.lineType === 'solid' ? undefined : '5,5'
        };
        if (linkStyle.hasArrow) {
            attributes['.marker-source'] = {
                fill: linkStyle.color,
                stroke: linkStyle.color,
                d: 'M0,3a3,3 0 1,0 6,0a3,3 0 1,0 -6,0',
                'stroke-width': linkStyle.thickness
            };
            attributes['.marker-target'] = {
                fill: linkStyle.color,
                stroke: linkStyle.color,
                d: 'M 10 0 L 0 5 L 10 10 z',
                'stroke-width': linkStyle.thickness
            };
        }
        return attributes;
    }

    function _getToolMarkup(linkTools) {
        return linkTools.map(function (linkTool) {
            var linkTypeId = linkTool.linkType;
            var tool = linkTool.linkStyle.toolButton;
            var width = tool.width || 30;
            var hieght = tool.hieght || 30;
            return '<g class="link-tool">\n                <g class="tool-options" event="link:options" linkType="' + linkTypeId + '">\n                    <image\n                        width="' + width + '"\n                        height="' + hieght + '"\n                        x="-' + width / 2 + '"\n                        y="-' + hieght / 2 + '"\n                        xlink:href="' + tool.image + '"\n                        onerror="this.setAttribute( \'xlink:href\', \'' + _res.getImage('default-link-options') + '\' );"\n                    />\n                    <title>Open derivation map' + (linkTypeId ? ' for ' + linkTypeId : '') + '</title>\n                </g>\n            </g>';
        }).join();
    }

    /**
     * Tells us whether the link is currently
     * on the graph (in the any of view frames) or not
     * @returns {boolena}
     */
    self.isOnTheGraph = function () {
        return self.graph ? true : false;
    };

    /**
     * Highlights the Link.
     * @memberof Link
     * @method
    */
    self.select = function () {
        self.terminationLinks.forEach(function (tl) {
            return tl.select(true);
        });
        if (self.get('blured')) self.unblure();
        if (self.get('hidden')) self.show();
        self.prop({ z: _elements.Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    /**
     * Removes highlighting from the Link.
     * @memberof Link
     * @method
    */
    self.unselect = function () {
        self.terminationLinks.forEach(function (tl) {
            return tl.unselect(true);
        });
        self.prop({ z: _elements.Z_INDEXES.LINK });
        self.set('highlighted', false);
    };

    /**
     * Blurs the Link.
     * @memberof Link
     * @method
    */
    self.blure = function () {
        if (self.get('highlighted')) return;
        self.terminationLinks.forEach(function (tl) {
            return tl.blure(true);
        });
        self.prop({ z: _elements.Z_INDEXES.BLURED_LINK });
        self.set('blured', true);
    };

    /**
     * Removes blur from the Link.
     * @memberof Link
     * @method
    */
    self.unblure = function () {
        self.terminationLinks.forEach(function (tl) {
            return tl.unblure(true);
        });
        self.prop({ z: _elements.Z_INDEXES.LINK });
        self.set('blured', false);
    };

    /**
     * Hides the Link.
     * @memberof Link
     * @method
    */
    self.hide = function () {
        self.terminationLinks.forEach(function (tl) {
            return tl.hide(true);
        });
        self.set('hidden', true);
    };

    /**
     * Shows the Link.
     * @memberof Link
     * @method
    */
    self.show = function () {
        self.terminationLinks.forEach(function (tl) {
            return tl.show(true);
        });
        self.set('hidden', false);
    };

    /**
     * Refreshes highlighters of the view of this element.
     * @memberof Link
     * @method
    */
    self.refreshHighlighting = function () {
        self.trigger('refresh-highlighting', self);
    };

    self.model = dataModel;
}
Link.prototype = Object.create(joint.dia.Link.prototype);

},{"../../data/resourceProvider":30,"./elements":46,"rappid":"rappid"}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EXPANDED_NODE_GROWING = exports.FONT_SIZE = exports.IMG_PADDING = exports.BODY_PADDING = exports.LABEL_LINE_HEIGHT = exports.LABEL_TOP_BOTTOM_PADDING = exports.LABEL_LEFT_RIGHT_PADDING = undefined;
exports.Node = Node;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _lodash = require('lodash');

var _resourceProvider = require('../../data/resourceProvider');

var _elements = require('./elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var LABEL_LEFT_RIGHT_PADDING = exports.LABEL_LEFT_RIGHT_PADDING = 5;
var LABEL_TOP_BOTTOM_PADDING = exports.LABEL_TOP_BOTTOM_PADDING = 10;
var LABEL_LINE_HEIGHT = exports.LABEL_LINE_HEIGHT = 20;
var BODY_PADDING = exports.BODY_PADDING = 25;
var IMG_PADDING = exports.IMG_PADDING = 10;
var FONT_SIZE = exports.FONT_SIZE = 16;
var EXPANDED_NODE_GROWING = exports.EXPANDED_NODE_GROWING = 1.5;

/**
 * NodeModel - data model for a {@link Node} object
 * @typedef {Object} NodeModel
 * @property {string} id - Node identifyer
 * @property {string} label - Title of the Node,
 * @property {string} viewFrame - Id of ViewFrame wich will include this node
 * @property {string} typeId - Type identifyer
*/

/**
 * The graph Node class which is based on joint.shapes.basic.Generic. Is the one of the main elements of the LineageFram.
 * Represents existing part of the dataset with specified image, color, type and id and placed in separated ViewFrame.
 * @class
 * @private
 * @augments joint.shapes.basic.Generic
 * @param {NodeModel} dataModel - Model of graph node
 * @param {Parameters} parameters - The set of parameters
 * 
 * @property {Node[]} aspects - Copies of this node in other frames
 * @property {NodeModel} model - Data model
 * @property {TerminationNode[]} terminationNodes - Termination nodes which exists on in the frame
 * @property {boolean} highlighted - Tells wheter highlighted node or not (use method get to get this property, e.g. node.get('highlighted'))
 * @property {boolean} blured - Tells wheter blured node or not (use method get to get this property, e.g. node.get('blured'))
 * @property {ViewFrame} viewFrameOwnerId - Exists only if element was dragged from one to another frame
 * @property {boolean} dragged - If somebody is dragging this Node now, then true.
*/
function Node(dataModel, parameters) {
    var self = this;
    var _size = parameters.elementSize;
    var _res = new _resourceProvider.ResourceProvider(parameters);

    var _isVerticalOriented = parameters.graphOrientation === 'top-to-bottom' || parameters.graphOrientation === 'bottom-to-top';

    self.model = dataModel;
    self.terminationNodes = [];
    self.aspects = [];
    self.viewFrameOwnerId = null;
    self.dragged = false;
    self.blured = false;
    self.highlighted = false;
    self.size = { width: _size.width, height: _size.height, maxWidth: _size.width, maxHeight: _size.height };

    var image = _res.getImage(dataModel.typeId);

    var ID = (0, _lodash.uniqueId)('Node');
    joint.shapes.basic.Generic.apply(self, [{
        type: 'lineage-gram-node',
        id: ID,
        position: { x: 0, y: 0 },
        markup: '<g class="rotatable" clip-path="url(' + ('#' + ID + '_clipPath') + ')">\n                    <g class="scalable">\n                        <rect class="body"/>\n                    </g>\n                    <rect class="tq-lg-body"></rect>\n                    <image class="scalable" onerror="this.setAttribute( \'xlink:href\', \'' + _res.getImage() + '\' );"/>\n                    <text class="label"/>\n                </g>\n                <rect class="clipRect"></rect>\n                <defs>\n                    <clipPath id="' + (ID + '_clipPath') + '">\n                        <rect class="clipRect"></rect>\n                    </clipPath>\n                </defs>',
        size: self.size,
        attrs: {
            'circle': {
                fill: 'transparent',
                stroke: 'transparent',
                r: 1
            },
            '.clipRect': {
                port: 'clipRectPort',
                width: self.size.width,
                height: self.size.height,
                fill: 'transparent',
                opacity: 0,
                'stroke-width': 0,
                rx: 5,
                ry: 5
            },
            '.body': {
                'stroke-width': 0,
                fill: 'transparent',
                rx: 5,
                ry: 5
            },
            '.label': {
                fill: _res.getColor('text'),
                'font-size': FONT_SIZE,
                'alignment-baseline': 'hanging',
                ref: '.body',
                tooltip: self.model.label,
                y: 0
            },
            '.tq-lg-body': {
                'ref-x': .5,
                'x-alignment': 'middle',
                'y-alignment': 'top',
                ref: '.body',
                rx: 5,
                ry: 5,
                stroke: _res.getColor(dataModel.typeId)
            },
            image: {
                'xlink:href': image,
                'ref-x': .5,
                ref: '.body',
                'x-alignment': 'middle',
                'y-alignment': 'top'
            },
            '.label tspan': {
                dy: LABEL_LINE_HEIGHT
            }
        },
        z: _elements.Z_INDEXES.NODE
    }]);

    // =====================================

    var _blockSubscription = false;
    var oldPosition = self.position;
    self.position = function (x, y) {
        _blockSubscription = true;
        var result = oldPosition.call(self, x, y);
        _blockSubscription = false;
        return result;
    };
    self.on('change:position', function () {
        if (_blockSubscription) return;
        self.setClipping(undefined);
    });

    self.on('change:size', function (cell, size) {
        self.attr({
            '.clipRect': {
                width: size.width,
                height: size.height
            }
        });
    });

    self.on('change:expanded', function () {
        _refreshSize(self.collapsedSize);
    });

    // =====================================

    _refreshSize(self.size);

    self.set('expanded', false);

    self.setSize = function (size) {
        if (self.collapsedSize.width !== size.width || self.collapsedSize.height !== size.height || self.size.maxWidth !== size.maxWidth || self.size.maxHeight !== size.maxHeight) {
            _refreshSize(size);
        }
    };

    self.setOrientation = function (orientation) {
        _isVerticalOriented = orientation === 'top-to-bottom' || orientation === 'bottom-to-top';
    };

    /**
     * Tells us whether the node is currently
     * on the graph (in the any of view frames) or not
     * @returns {boolena}
     */
    self.isOnTheGraph = function () {
        return self.graph ? true : false;
    };

    self.calculateSize = function (size) {
        var calculations = _calculateNode(size);
        return {
            width: calculations.width,
            height: calculations.height,
            maxWidth: calculations.maxWidth,
            maxHeight: calculations.maxHeight
        };
    };

    /**
     * Highlights the Node.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof Node
     * @method
    */
    self.select = function (once) {
        self.terminationNodes.forEach(function (tn) {
            return tn.select(true);
        });
        if (!once) self.aspects.forEach(function (a) {
            return a.select(true);
        });
        if (self.get('blured')) self.unblure();
        if (self.get('hidden')) self.show();
        self.prop({ z: _elements.Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    /**
     * Removes highlighting from the Node.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof Node
     * @method
    */
    self.unselect = function (once) {
        self.terminationNodes.forEach(function (tn) {
            return tn.unselect(true);
        });
        if (!once) self.aspects.forEach(function (a) {
            return a.unselect(true);
        });
        self.prop({ z: _elements.Z_INDEXES.NODE });
        self.set('highlighted', false);
    };

    /**
     * Blurs the Node.
     * @memberof Node
     * @method
    */
    self.blure = function () {
        if (self.get('highlighted')) return;
        self.terminationNodes.forEach(function (tn) {
            return tn.blure(true);
        });
        self.prop({ z: _elements.Z_INDEXES.BLURED_NODE });
        self.set('blured', true);
    };

    /**
     * Removes blur from the Node.
     * @memberof Node
     * @method
    */
    self.unblure = function () {
        self.terminationNodes.forEach(function (tn) {
            return tn.unblure(true);
        });
        self.prop({ z: _elements.Z_INDEXES.NODE });
        self.set('blured', false);
    };

    /**
     * Hides the Node.
     * @memberof Node
     * @method
    */
    self.hide = function () {
        self.terminationNodes.forEach(function (tn) {
            return tn.hide(true);
        });
        self.set('hidden', true);
    };

    /**
     * Shows the Node.
     * @memberof Node
     * @method
    */
    self.show = function () {
        self.terminationNodes.forEach(function (tn) {
            return tn.show(true);
        });
        self.set('hidden', false);
    };

    /**
     * Refreshes highlighters of the view of this element.
     * @memberof Link
     * @method
    */
    self.refreshHighlighting = function () {
        self.trigger('refresh-highlighting', self);
    };

    /**
     * Sets offset and size of clipping rectangle.
     * @param {Point} point - Offset of the clipping rectangle
     * @memberof Node
     * @method
    */
    self.setClipping = function (point) {
        point = point || { x: 0, y: 0 };

        var x = point.x > 0 ? point.x : 0;
        var y = point.y > 0 ? point.y : 0;
        var width = self.size.width - Math.abs(point.x);
        var height = self.size.height - Math.abs(point.y);

        self.attr({
            '.clipRect': {
                x: x,
                y: y,
                width: width > 0 ? width : 0,
                height: height > 0 ? height : 0
            }
        });
    };

    function _refreshSize(size) {
        self.collapsedSize = size;

        var calculations = _calculateNode(size);
        self.size = {
            width: calculations.width,
            height: calculations.height,
            maxWidth: calculations.maxWidth,
            maxHeight: calculations.maxHeight
        };

        var scale = calculations.scale;
        var bodyPadding = BODY_PADDING * scale;
        var topBottomPadding = LABEL_TOP_BOTTOM_PADDING * scale;
        var labelLineHeight = LABEL_LINE_HEIGHT * scale;

        self.attr({
            '.tq-lg-body': {
                width: calculations.rectWidth,
                height: calculations.rectHeight,
                'ref-y': bodyPadding
            },
            image: {
                width: Math.max(0, calculations.rectWidth - IMG_PADDING * 2),
                height: Math.max(0, calculations.rectHeight - IMG_PADDING * 2),
                'ref-y': bodyPadding + IMG_PADDING
            },
            '.label': {
                text: calculations.label,
                'ref-y': bodyPadding + topBottomPadding + calculations.rectHeight + FONT_SIZE * scale - labelLineHeight
            },
            '.label tspan': {
                'font-size': FONT_SIZE * scale,
                dy: labelLineHeight
            }
        });

        self.resize(self.size.width, self.size.height);
        self.set('short-label', calculations.shortLabel);
    }

    var _catchedResult = null;
    function _calculateNode(size) {
        if (_catchedResult && _catchedResult.inSize.width === size.width && _catchedResult.inSize.height === size.height && _catchedResult.inSize.maxWidth === size.maxWidth && _catchedResult.inSize.maxHeight === size.maxHeight && _catchedResult.expanded === self.get('expanded')) {
            return _catchedResult.outSize;
        }

        var width = void 0;
        var height = void 0;
        if (!self.get('expanded')) {
            width = size.width;
            height = size.height;
        } else {
            width = Math.min(size.maxWidth, size.width * EXPANDED_NODE_GROWING);
            height = Math.min(size.maxHeight, size.height * EXPANDED_NODE_GROWING);
        }

        var xScale = size.width / parameters.elementSize.width;
        var yScale = size.height / parameters.elementSize.height;
        var scale = Math.min(xScale, yScale);
        var bodyPadding = BODY_PADDING * scale;
        var labelLineHeight = LABEL_LINE_HEIGHT * scale;

        var calculations = {
            width: width,
            height: height,
            maxWidth: size.maxWidth,
            maxHeight: size.maxHeight,
            rectWidth: width - bodyPadding * 2,
            rectHeight: height - bodyPadding * 2,
            scale: scale,
            shortLabel: false
        };

        if (self.model.label) {
            calculations.height -= bodyPadding;

            var fontSize = FONT_SIZE * scale;
            var leftRightPadding = LABEL_LEFT_RIGHT_PADDING * scale * 2;
            var topBottomPadding = LABEL_TOP_BOTTOM_PADDING * scale * 2;

            var label = _breakTextByLines(self.model.label, width - leftRightPadding, fontSize);

            var labelHeight = 0;
            var substrings = label.split('\n');

            if (substrings.length > 1) {
                var maxRowCount = (_isVerticalOriented ? 2 : 3) + (self.get('expanded') ? 1 : 0);

                if (substrings.length > maxRowCount) calculations.shortLabel = true;

                substrings = substrings.slice(0, maxRowCount);

                if (_isVerticalOriented) {
                    var finalLabel = substrings.join(' ') + (calculations.shortLabel ? '...' : '');
                    var labelWidth = _getTextWidth(finalLabel, fontSize + 'px sans-serif');
                    calculations.width = labelWidth + leftRightPadding * substrings.length;
                    calculations.label = finalLabel;
                    labelHeight = fontSize + topBottomPadding;
                } else {
                    // We use dy property for each line that's why font-size goes only one time into acount.
                    // Because dx is distance between top lines of each text line. And for a full text height we add font size of lust line.
                    labelHeight = fontSize + topBottomPadding + (substrings.length - 1) * labelLineHeight;
                    calculations.label = substrings.join('\n') + (calculations.shortLabel ? '...' : '');
                }
            } else {
                labelHeight = fontSize + topBottomPadding;
                calculations.label = self.model.label;
            }

            calculations.height += labelHeight;
            calculations.labelHeight = labelHeight;
            calculations.expanded = self.get('expanded');
        }
        _catchedResult = {
            inSize: size,
            outSize: calculations,
            expanded: calculations.expanded
        };

        return calculations;
    }

    function _breakTextByLines(label, width, fontSize) {
        var brokenText = joint.util.breakText(label, {
            width: width
        }, { 'font-size': fontSize });

        var lines = brokenText.split('\n');

        if (lines.length > 1) {
            var lastChild = lines[lines.length - 1];
            var MIN_CHARACTER_NUMBER = 4;

            if (lastChild.length < MIN_CHARACTER_NUMBER) {
                var diff = MIN_CHARACTER_NUMBER - lastChild.length;
                var threshold = lines.length - (diff + 1);
                // max error is 3 extra letters, so I hope it's OK.
                var numberOfStealedNodes = Math.round(diff / Math.min(diff, lines.length - 1));

                var prevRest = '';
                var offset = 0;
                var newLines = lines.map(function (line, index, arr) {
                    if (index >= threshold) {
                        var isLastLine = index === arr.length - 1;
                        var fullLine = prevRest + line;
                        offset += numberOfStealedNodes;
                        if (isLastLine) {
                            return fullLine;
                        } else {
                            prevRest = fullLine.substring(fullLine.length - offset, fullLine.length);
                            return fullLine.substring(0, fullLine.length - offset);
                        }
                    } else {
                        return line;
                    }
                });

                return newLines.join('\n');
            } else {
                return brokenText;
            }
        } else {
            return label;
        }
    }

    /**
     * @private
     * Update size of element. Takes collapsed size,
     * and if element are expanded trying to set a twise size.
     * @param {Size} size 
    */

    /**
     * @private
     * @param {string} text 
     * @param {string} font 
    */
    function _getTextWidth(text, font) {
        var canvas = _getTextWidth.canvas || (_getTextWidth.canvas = document.createElement('CANVAS'));
        var context = canvas.getContext('2d');
        context.font = font;
        var metrics = context.measureText(text);
        return metrics.width;
    }
}

Node.prototype = Object.create(joint.shapes.devs.Model.prototype);

},{"../../data/resourceProvider":30,"./elements":46,"lodash":"lodash","rappid":"rappid"}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TerminationLink = TerminationLink;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _resourceProvider = require('../../data/resourceProvider');

var _elements = require('./elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * TerminationLinkOptions - options for TerminationLink object
 * @typedef {Object} TerminationLinkOptions
 * @property {Link} link - Original link
 * @property {Node} target - Target Node
 * @property {Node} source - Source Node
*/

/**
 * @private
 * SimpleLinkModel - data model of a TerminationLink object
 * @typedef {Object} SimpleLinkModel - Data model
 * @property {string} target - Target Node id
 * @property {string} source - Source Node id
*/

/**
 * @private
 * The graph Link based on joint.dia.Link.
 * @class
 * @augments joint.dia.Link
 * 
 * @param {TerminationLinkOptions} options - options for TerminationLink object
 * @param {Parameters} parameters - the set of parameters
 * 
 * @property {Link} originalLink - Original Link - the link to a node which is out of the ViewFrmae
 * @property {boolean} highlighted - Tells wheter highlighted link or not (use method get to get this property, e.g. link.get('highlighted'))
 * @property {boolean} blured - Tells wheter blured link or not (use method get to get this property, e.g. link.get('blured'))
 * @property {SimpleLinkModel} model - Data model 
*/
function TerminationLink(options, parameters) {
    var self = this;
    var _res = new _resourceProvider.ResourceProvider(parameters);

    self.originalLink = options.link;
    self.highlighted = false;
    self.blured = false;
    self.originalLink.terminationLinks.push(self);

    var source = { id: options.source.id, port: 'clipRectPort' };
    var target = { id: options.target.id, port: 'clipRectPort' };

    var linkColor = _res.getColor('terminationLink');

    joint.dia.Link.apply(self, [{
        type: 'termination-link',
        source: source,
        target: target,
        z: _elements.Z_INDEXES.TERMINATION_ELEMENT,
        attrs: {
            '.connection': {
                stroke: linkColor,
                'stroke-width': parameters.linkThickness * (1 + (self.originalLink.model.thickness || 0)),
                'stroke-dasharray': '5,5'
            },
            '.marker-source': {
                fill: linkColor,
                stroke: linkColor,
                'stroke-width': parameters.linkThickness * (1 + (self.originalLink.model.thickness || 0)),
                d: 'M0,3a3,3 0 1,0 6,0a3,3 0 1,0 -6,0'
            },
            '.marker-target': {
                fill: linkColor,
                stroke: linkColor,
                'stroke-width': parameters.linkThickness * (1 + (self.originalLink.model.thickness || 0)),
                d: 'M 10 0 L 0 5 L 10 10 z'
            }
        },
        connector: { name: 'rounded' }
    }]);

    /**
     * Highlights the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.select = function (once) {
        if (!once) self.originalLink.select(true);
        if (self.get('blured')) self.unblure();
        if (self.get('hidden')) self.show();
        self.prop({ z: _elements.Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    /**
     * Removes highlighting from the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.unselect = function (once) {
        if (!once) self.originalLink.unselect(true);
        self.prop({ z: _elements.Z_INDEXES.TERMINATION_ELEMENT });
        self.set('highlighted', false);
    };

    /**
     * Blurs the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.blure = function (once) {
        if (self.get('highlighted')) return;
        if (!once) self.originalLink.blure(true);
        self.prop({ z: _elements.Z_INDEXES.BLURED_LINK });
        self.set('blured', true);
    };

    /**
     * Removes blur from the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.unblure = function (once) {
        if (!once) self.originalLink.unblure(true);
        self.prop({ z: _elements.Z_INDEXES.TERMINATION_ELEMENT });
        self.set('blured', false);
    };

    /**
     * Hides the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.hide = function (once) {
        if (!once) self.originalLink.hide(true);
        self.set('hidden', true);
    };

    /**
     * Shows the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.show = function (once) {
        if (!once) self.originalLink.show(true);
        self.set('hidden', false);
    };

    /**
     * Refreshes highlighters of the view of this element.
     * @memberof Link
     * @method
    */
    self.refreshHighlighting = function () {
        _synchronizeWithOrigin();
        self.trigger('refresh-highlighting', self);
    };

    /**
     * Reset highlighting for the TerminationLink.
     * @memberof TerminationLink
     * @method
    */
    function _synchronizeWithOrigin() {
        if (self.originalLink.get('highlighted')) {
            self.set('highlighted', true, { silent: true });
        } else {
            self.set('highlighted', false, { silent: true });
        }
        if (self.originalLink.get('blured')) {
            self.set('blured', true, { silent: true });
        } else {
            self.set('blured', false, { silent: true });
        }
    }

    self.model = { source: options.source.id, target: options.target.id };
    self.refreshHighlighting();

    var onRemove = self.remove;

    /**
     * Removes link from the paper.
     * @memberof TerminationLink
     * @method
    */
    self.remove = function () {
        var index = self.originalLink.terminationLinks.indexOf(self);
        self.originalLink.terminationLinks.splice(index, 1);
        onRemove.call(self);
    };
}
TerminationLink.prototype = Object.create(joint.dia.Link.prototype);

},{"../../data/resourceProvider":30,"./elements":46,"rappid":"rappid"}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TerminationNode = TerminationNode;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _resourceProvider = require('../../data/resourceProvider');

var _elements = require('./elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * TerminationNodeModel - data model of a TerminationNode object
 * @typedef {Object} TerminationNodeModel
 * @property {Point} position - Node identifyer
 * @property {Node} node - Original node
*/

/**
 * @private
 * The graph TerminationNode based on joint.shapes.basic.Rect.
 * @class
 * @augments joint.shapes.basic.Rect
 * 
 * @param {TerminationNodeModel} options - Data model
 * @param {Parameters} parameters - The set of parameters
 * 
 * @property {Node} originalNode - The original node,
 * which is out of the viewFrame so we use termination instead
 * @property {Node[]} related - List of the nodes related with this node
 * @property {boolean} highlighted - Tells wheter highlighted node or not (use method get to get this property, e.g. node.get('highlighted'))
 * @property {boolean} blured - Tells wheter blured node or not (use method get to get this property, e.g. node.get('blured'))
 * @property {boolean} removed - Is the node removed from the paper
*/
function TerminationNode(options, parameters) {
    var self = this;
    var _res = new _resourceProvider.ResourceProvider(parameters);

    self.originalNode = options.node;
    self.highlighted = false;
    self.blured = false;
    self.related = [];
    self.size = parameters.terminationNodeSize;

    options.node.terminationNodes.push(self);

    joint.shapes.basic.Generic.apply(self, [{
        markup: '<g class="rotatable">\n                    <g class="scalable">\n                        <rect class="body"/>\n                    </g>\n                    <rect class="tq-lg-body"/>\n                    <text/>\n                </g>',
        type: 'termination-node',
        position: options.position,
        size: parameters.terminationNodeSize,
        attrs: {
            '.body': {
                port: 'clipRectPort',
                fill: 'transparent',
                'stroke-width': 0,
                rx: 10,
                ry: 10
            },
            '.tq-lg-body': {
                'ref-x': .5,
                'ref-y': .5,
                'x-alignment': 'middle',
                'y-alignment': 'middle',
                width: parameters.terminationNodeSize.width - 10,
                height: parameters.terminationNodeSize.height - 10,
                ref: '.body',
                rx: 2,
                ry: 2,
                stroke: _res.getColor(options.node.model.typeId),
                fill: 'white',
                port: 'clipRectPort'
            },
            text: {
                text: 'Ð¡',
                fill: _res.getColor(options.node.model.typeId),
                stroke: _res.getColor(options.node.model.typeId),
                'ref-x': .5,
                'ref-y': .55,
                ref: '.body',
                tooltip: self.originalNode.model.label // see the line 221 at lineageGram.js
            }

        },
        z: _elements.Z_INDEXES.TERMINATION_ELEMENT
    }]);

    var _isDragging = true;
    var oldPosition = self.position;
    self.position = function (x, y) {
        _isDragging = false;
        var result = oldPosition.call(self, x, y);
        _isDragging = true;
        return result;
    };
    self.on('change:position', function () {
        if (_isDragging) self.set('dragged', _isDragging);
    });
    self.on('change:dragged', function () {
        var oldSize = self.size;
        var oldPos = self.position();

        if (self.get('dragged')) {
            self.size = {
                width: self.originalNode.size.width,
                height: self.originalNode.size.height
            };
            self.attr({
                text: {
                    text: '+',
                    'ref-y': .51
                },
                '.body': {
                    rx: 0,
                    ry: 0
                }
            });
            self.resize(self.size.width, self.size.height);
            self.position(oldPos.x - (self.size.width - oldSize.width) / 2, oldPos.y - (self.size.height - oldSize.height) / 2);
        } else {
            self.size = {
                width: parameters.terminationNodeSize.width,
                height: parameters.terminationNodeSize.height
            };
            self.attr({
                text: {
                    text: 'C',
                    'ref-y': .55
                },
                '.body': {
                    rx: 10,
                    ry: 10
                }
            });
            self.resize(self.size.width, self.size.height);

            self.position(oldPos.x + (self.size.width - oldSize.width) / 2, oldPos.y + (self.size.height - oldSize.height) / 2);
        }
    });

    /**
     * Highlights the TerminationNode.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationNode
     * @method
    */
    self.select = function (once) {
        if (self.originalNode && !once) self.originalNode.select(true);
        if (self.get('blured')) self.unblure();
        if (self.get('hidden')) self.show();
        self.prop({ z: _elements.Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    /**
     * Removes highlighting from the TerminationNode.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationNode
     * @method
    */
    self.unselect = function (once) {
        if (self.originalNode && !once) self.originalNode.unselect(true);
        self.prop({ z: _elements.Z_INDEXES.TERMINATION_ELEMENT });
        self.set('highlighted', false);
    };

    /**
      * Blurs the TerminationNode.
      * @param {boolean} once - Boolean flag to protect code from recursion (optional)
      * @memberof TerminationNode
      * @method
     */
    self.blure = function (once) {
        if (self.get('highlighted')) return;
        if (self.originalNode && !once) self.originalNode.blure(true);
        self.prop({ z: _elements.Z_INDEXES.BLURED_NODE });
        self.set('blured', true);
    };

    /**
     * Removes blur from the TerminationNode.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationNode
     * @method
    */
    self.unblure = function (once) {
        if (self.originalNode && !once) self.originalNode.unblure(true);
        self.prop({ z: _elements.Z_INDEXES.TERMINATION_ELEMENT });
        self.set('blured', false);
    };

    /**
      * Blurs the TerminationNode.
      * @param {boolean} once - Boolean flag to protect code from recursion (optional)
      * @memberof TerminationNode
      * @method
     */
    self.hide = function (once) {
        if (self.originalNode && !once) self.originalNode.hide(true);
        self.set('hidden', true);
    };

    /**
     * Removes blur from the TerminationNode.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationNode
     * @method
    */
    self.show = function (once) {
        if (self.originalNode && !once) self.originalNode.show(true);
        self.set('hidden', false);
    };

    /**
     * Refreshes highlighters of the view of this element.
     * @memberof Link
     * @method
    */
    self.refreshHighlighting = function () {
        _synchronizeWithOrigin();
        self.trigger('refresh-highlighting', self);
    };

    function _synchronizeWithOrigin() {
        if (self.originalNode.get('highlighted')) {
            self.set('highlighted', true, { silent: true });
        } else {
            self.set('highlighted', false, { silent: true });
        }
        if (self.originalNode.get('blured')) {
            self.set('blured', true, { silent: true });
        } else {
            self.set('blured', false, { silent: true });
        }
    }

    var onRemove = self.remove;

    /**
     * Removes node from the paper.
     * @memberof TerminationNode
     * @method
    */
    self.remove = function () {
        var index = self.originalNode.terminationNodes.indexOf(self);
        self.originalNode.terminationNodes.splice(index, 1);
        onRemove.call(self);
    };

    self.refreshHighlighting();
}
TerminationNode.prototype = Object.create(joint.shapes.basic.Rect.prototype);

},{"../../data/resourceProvider":30,"./elements":46,"rappid":"rappid"}],51:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = LineageDiagram;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _fileSaverjs = require('file-saverjs');

var _fileSaverjs2 = _interopRequireDefault(_fileSaverjs);

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _viewManager2 = require('./viewManager');

var _routingManager2 = require('./linkRoutingManager/routingManager');

var _viewFrame = require('./viewFrame');

var _elements = require('./graphElements/elements');

var _viewFramesUI2 = require('../htmlUI/viewFramesUI');

var _viewFramesUI3 = _interopRequireDefault(_viewFramesUI2);

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _toSvg = require('./toSvg');

var _layout = require('../layout/layout');

var _dataUtils = require('../utils/dataUtils');

var _utils = require('../utils/utils');

var _lineageDiagramUtils = require('../utils/lineageDiagramUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var DIRECTION = {
    UP: 38,
    DOWN: 40,
    LEFT: 37,
    RIGHT: 39
};

/**
 * @private
 * @class
 * Manages the main view of application (View-2)
 * All changes goes through the render function.
 *
 * Constructor parameters:
 * ========================================
 * @param {
 *  dataContainer: DataContainer
 *  graphPlace: HTMLElement
 *  viewFrames: ViewFrameModels
 * } options
 * @param {Parameters} parameters - parameters set
 *
 * Public properties:
 * ========================================
 * selectedElement: Node|Link
 *
 * Public methods:
 * ========================================
 * redraw: (options: {
    viewFrames: ViewFramePublicModel[];
    selectedElement: (Node|Link);
    path: { [id: string]: (Node|Link) };
    quickUpdate: boolean;
    updateBounds: boolean;
    paperOptions: {
        orientation: Orientation;
        width: number;
        height:number;
        scale: Point;
    };
    elementOptions: {
        elementSize: ElementSize;
 * }) => void;
 * delayedRedraw: (options: { ... see redraw}) => void;
 * openViewFrame: (id:string) => void;
 * closeViewFrame: (id:string) => void;
 * openOverViewFrame: () => void;
 * closeOverViewFrame: () => void;
 * updateNodesPositions: (nodes: Node[]) => void;
 * combine: () => void;
 * resetLayout: () => void;
 * refresh: () => void;
 * getSelectedElement: () => (Node|Link);
 * getVisibleCells: () => (Node|Link|ViewFrame|TerminationNode|TerminationLink);
 * getVisibleNodes: () => (Node|ViewFrame|TerminationNode);
 * getVisibleLinks: () => (Link|TerminationLink);
 * setSelectedElement: (element: (Node|Link|undefined), focusOn: boolean) => void;
 * positionViewPort: (vf: ViewFramePublicModel, point: Point, animation: boolean) => void;
 * export: () => void;
 * print: () => void;
 * setData: (dataContainer: DataContainer, viewFrames: ViewFrameDefinition[]) => void;
 * scale: (scale: Point) => void; - Sets and limits value of the scale of the graph
 * zoomIn: () => void;
 * zoomOut: () => void;
 * zoomToFit: () => void;
 * setOrientation: (orientation: Orientation) => void; Values: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
 * getViewFrames: () => ViewFramePublicModel[];
 * translateViewPort (vf: ViewFrame, dx: number, dy: number, animation: boolean)
 * ----------------------------------------
 * on (event: string, callback: function) => void
 * unsubscribe (callback: function) => void
 * trigger (event: string, parameters: any) => void
 *
 * Events:
 * ========================================
 * @fires selected-element-changed (Node|Link)
 * @fires scale-changed (scale)
 * @fires view-frames-state-changed (ViewFrame, boolean)
 * @fires view-frames-size-or-position-changed (ViewFrame, boolean)
 * @fires cell-double-click (cell)
 * @fires cell-single-click (cell)
 * @fires link-options-click (Link)
 * @fires nodes-position-changed
 */
function LineageDiagram(options, parameters) {
    // Init
    // ===================================================================
    // ===================================================================
    _subscribeable2.default.apply(this); // make this class Subscribable

    var _base = _createBase(options.graphPlace);

    // Creating a joint graph and joint paper
    var _graph = new joint.dia.Graph();
    var _paper = new joint.dia.Paper({
        el: _base.diagram,
        model: _graph,
        elementView: _elements.NodeView,
        linkView: _elements.LinkView,
        gridSize: 1,
        interactive: function interactive() {
            return { vertexAdd: false };
        },
        preventContextMenu: false,
        width: '100%',
        height: '100%'
    });

    var _scale = parameters.defaultScale;
    var _dataContainer = void 0;

    var _orientation = parameters.graphOrientation;
    var _fullScreenMode = parameters.fullScreenMode;
    var _path = null; // highlighting path
    var _mask = parameters.mask; // highlighting path
    var _selectedElement = null;
    var _routingManager = void 0;
    var _viewFramesUI = void 0;
    var _viewManager = void 0;

    var self = this;
    var _keyboard = new joint.ui.Keyboard();
    var _scaleBounds = _.clone(parameters.scaleBounds);
    var _overViewScaleBounds = _.clone(parameters.overViewScaleBounds);
    var _scaleStep = parameters.scaleStep;

    _setData(options.dataContainer, options.viewFrames);
    _subscribeOnEvents();
    // ===================================================================
    // ===================================================================

    /**
     * Drawing options (deprecated)
     * @typedef {Object} DrawingOptions
     * @param {boolean} quickUpdate - don't updates links and remove them.
     * @param {Array of ViewFrame} viewFrames - update only limitted number of viewFrames.
    */

    /**
     * @private
     * Updates the graph's state, - Add/remove
     * visible Nodes and TerminationNodes
     * @param {DrawingOptions} options
     */
    self.redraw = _redraw;
    /**
     * Same as redraw but it's quick update
     * with delayed full redraw (debouncer).
     */
    self.delayedRedraw = _delayedRedraw;

    /**
     * Opens ViewFrame with specified id
     * @param {string} viewFrameId
     */
    self.openViewFrame = _openViewFrame;

    /**
     * Closes ViewFrame with specified id
     * @param {string} viewFrameId
     */
    self.closeViewFrame = _closeViewFrame;

    /**
     * Changes mode fullScreen/viewFrame.
     * @param {boolean} value
    */
    self.setFullScreenMode = _setFullScreenMode;

    /**
     * Opens OverViewFrame
     * @param {string} viewFrameId
     */
    self.openOverViewFrame = function () {
        return _openViewFrame(_viewManager.getOverViewFrame().id);
    };

    /**
     * Closes OverViewFrame
     * @param {string} viewFrameId
     */
    self.closeOverViewFrame = function () {
        return _closeViewFrame(_viewManager.getOverViewFrame().id);
    };

    /**
     * Updates layout positions of the nodes using paper positions
     * @param {Node[]} nodes
     */
    self.updateNodesPositions = _updateNodesPositions;

    /**
     * Groups nodes around selected
     * and highlights neighbours
     */
    self.combine = _combine;

    /**
     * Restore nodes positions
     */
    self.resetLayout = _resetLayout;

    /**
     * Refreshes all viewFrames bounds.
     */
    self.refresh = _refresh;

    /**
     * @returns {Node|Link}.
    */
    self.getSelectedElement = function () {
        return _selectedElement;
    };

    /**
     * @returns {(Node|Link|ViewFrame|TerminationNode|TerminationLink)}.
    */
    self.getVisibleCells = function () {
        return _graph.getCells();
    };

    /**
     * @returns {(Node|ViewFrame|TerminationNode)}.
    */
    self.getVisibleNodes = function () {
        return _graph.getElements();
    };

    /**
     * @returns {(Link|TerminationLink)}.
    */
    self.getVisibleLinks = function () {
        return _graph.getLinks();
    };

    /**
     * Sets selected element
     * @param {Node|Link|undefined}.
    */
    self.setSelectedElement = function (element, focusOn) {
        if (element) {
            _select(element, focusOn);
        } else {
            _unselect();
        }
    };

    /**
     * It sets offset for all elements into the viewPort.
     * @param {ViewFrame} viewFrame
     * @param {Point} point
     * @param {boolean} animation - it's optional
     * @param {function} callback - it's called after focus
     * @fires view-frames-size-or-position-changed
    */
    self.positionViewPort = function (viewFramePublicModel, point, animation, callback) {
        var relevantViewFrame = _viewManager.getViewFrameById(viewFramePublicModel.id);
        _positionViewPort(relevantViewFrame, point, animation, function () {
            callback();
            var changedViewFrame = _viewManager.getViewFrameById(viewFramePublicModel.id);
            self.trigger('view-frames-size-or-position-changed', [[changedViewFrame]]);
        });
    };

    /**
     * Exports graph to png or svg file.
     * @param {
     *  name?: string - file name
     *  type?: string - (png/svg)
     * } options
    */
    self.export = function (options) {
        if (!options) options = {};
        var fileName = options.name || 'LG_lineage_diagram_snapshot_' + (0, _dataUtils.date2String)(new Date());

        if (options.type === 'png') {
            (0, _toSvg.toDataURL)(_paper, {
                backgroundColor: 'white',
                svgOptions: {
                    elementsToRemoveSelector: '',
                    convertImagesToDataUris: true
                }
            }).then(function (base64URL) {
                saveData(base64URL, fileName, 'png');
            }).catch(function (error) {
                if (typeof error === 'string') alert(error);else alert('This type of export is not supported in the Internet Explorer');
                console.error(error);
            });
        } else {
            (0, _toSvg.exportToSVG)(_paper, {
                elementsToRemoveSelector: '',
                convertImagesToDataUris: true
            }).then(function (svgString) {
                saveData(svgString, fileName, 'svg');
            }).catch(function (error) {
                alert(error);
                console.error(error);
            });
        }

        function saveData(data, fileName, type) {
            var blob = void 0;
            if (type === 'svg') {
                blob = new Blob([data], { type: type });
            } else if (type === 'png') {
                blob = (0, _dataUtils.png2Blob)(data);
            }
            (0, _fileSaverjs2.default)(blob, fileName + '.' + type);
        }
    };

    /**
     * Shows print dialog.
    */
    self.print = function () {
        (0, _toSvg.exportToSVG)(_paper, {
            preserveDimensions: false,
            elementsToRemoveSelector: '',
            convertImagesToDataUris: true,
            pdfMode: true
        }).then(function (svgString) {
            var printWindow = window.open('', undefined, 'width=1280,height=720');
            if (printWindow) {
                printWindow.document.write(svgString);
                printWindow.document.close();
                printWindow.print();
            } else {
                alert('You should unblock popup windows for the current url to be able to print this diagram!');
            }
        });
    };

    /**
     * Define data container with nodes and links for the Jointjs view (view-2)
     * and path it to the forms
     * @param {DataContainer} dataContainer - data for the graph
     * @param {ViewFramePublicModel[]} viewFrames - view frames
    */
    self.setData = _setData;

    self.setRouting = function (routingId) {
        _routingManager.setRouting(routingId);
    };

    self.getRouting = function () {
        return _routingManager.getRouting();
    };

    self.scale = function (scale) {
        if (scale) {
            _updateScale(scale);
            _limitViewPortsPostions(_viewManager.getViewFrames());
        }
        return _scale;
    };

    /**
     * Increases scale of the graph.
     * And redraw it after that.
     */
    self.zoomIn = function () {
        _updateScale({
            x: _scale.x + _scaleStep,
            y: _scale.y + _scaleStep
        });
        _limitViewPortsPostions(_viewManager.getViewFrames());
    };

    /**
     * Decreases scale of the graph.
     * And redraw it after that.
     */
    self.zoomOut = function () {
        _updateScale({
            x: _scale.x - _scaleStep,
            y: _scale.y - _scaleStep
        });
        _limitViewPortsPostions(_viewManager.getViewFrames());
    };

    /**
     * Increases scale of the graph.
     * And redraw it after that.
     */
    self.zoomToFit = function () {
        var overViewFrame = _viewManager.getOverViewFrame();
        var nodeBounds = overViewFrame.nodeBounds;
        var width = _paper.el.clientWidth - _viewManager2.FRAME_OUT_MARGIN * 2;
        var height = _paper.el.clientHeight - _viewManager2.FRAME_OUT_MARGIN * 2;

        var scale = overViewFrame.scale;
        var necessarySize = (0, _utils.globalToScaledSize)({
            width: nodeBounds.width,
            height: nodeBounds.height
        }, scale);
        var xRatio = width / (necessarySize.width + parameters.framePadding.x * 2);
        var yRatio = height / (necessarySize.height + parameters.framePadding.y * 2);

        _updateScale({
            x: scale.x * xRatio,
            y: scale.y * yRatio
        });
        _redraw();
    };

    /**
     * It changes orientation of the graph.
     * @param {string} orientation - Values: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
     * @memberof LineageDiagram
     * @method
     */
    self.setOrientation = function (orientation) {
        _orientation = orientation;
        _redraw();
        _viewFramesUI.setOrientation(orientation);
    };

    /**
     * Returns all ViewFrames
     * @memberof LineageDiagram
     * @method
     * @returns {ViewFramePublicModel[]}
     */
    self.getViewFrames = function () {
        return _viewManager.getViewFrames();
    };

    /**
     * Returns one ViewFrame by id 
     * @memberof LineageDiagram
     * @method
     * @param {string} viewFrameId
     * @returns {ViewFramePublicModel}
    */
    self.getViewFrameById = function (viewFrameId) {
        return _viewManager.getViewFrameById(viewFrameId);
    };

    /**
     * Returns one ViewFrame by id 
     * @memberof LineageDiagram
     * @method
     * @returns {ViewFramePublicModel}
    */
    self.getOverViewFrame = function () {
        return _viewManager.getOverViewFrame();
    };

    self.setMask = function (mask) {
        _mask = mask;
        _redraw();
    };

    self.getMask = function () {
        return _mask;
    };

    self.isFullScreenMode = function () {
        return _viewManager.isFullScreenMode();
    };

    function _redraw(options) {
        _routingManager.resetRouting();
        _routingManager.setBounds({
            x: _viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth,
            y: _viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth,
            width: _paper.el.clientWidth - (_viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth) * 2,
            height: _paper.el.clientHeight - (_viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth) * 2
        });

        options = options || {};
        var renderOptions = {
            viewFrames: options.viewFrames,
            fullScreenMode: options.fullScreenMode,
            selectedElement: _selectedElement,
            path: _path,
            mask: _mask,
            quickUpdate: options.quickUpdate,
            updateBounds: options.updateBounds,
            paperOptions: {
                orientation: _orientation,
                width: _paper.el.clientWidth,
                height: _paper.el.clientHeight,
                scale: _scale
            },
            elementOptions: {
                elementSize: options.elementSize
            }
        };

        if (!renderOptions.quickUpdate) clearTimeout(_timeoutRef);

        _graph.startBatch('remove');
        if (renderOptions.quickUpdate) _graph.removeCells(_graph.getLinks());

        var renderData = _viewManager.prepareRenderData(renderOptions);

        renderData = _removeDeprecatedAndExistingCells(renderData);
        _graph.stopBatch('remove');

        _graph.startBatch('add');
        _graph.addCells(renderData);
        _graph.stopBatch('add');

        _updateHighlighting(renderData);
        _viewFramesUI.refresh();
        // console.log('Redraw' + (renderOptions.quickUpdate ? ' (quick)' : ''));
    }

    var _timeoutRef = 0;
    var _blockMultipleQueries = false;
    function _delayedRedraw(options, callback) {
        if (_blockMultipleQueries) return;
        clearTimeout(_timeoutRef);
        options = options || {};

        var quickOptions = _.cloneDeep(options) || {};
        quickOptions.quickUpdate = true;

        _blockMultipleQueries = true;
        requestAnimationFrame(function () {
            _blockMultipleQueries = false;
        });
        _redraw(quickOptions);

        _timeoutRef = setTimeout(function () {
            options.quickUpdate = false;
            // console.log(`Redraw (delay:start-${_timeoutRef}) => `);
            _redraw(options);
            if (callback) callback();
        }, 150);
        // console.log(`Redraw (delay:wait-${_timeoutRef})`);
    }

    function _removeDeprecatedAndExistingCells(newCells) {
        var oldCells = _graph.getCells();
        var cellMap = {};

        newCells.forEach(function (cell) {
            cellMap[cell.id] = cell;
        });
        oldCells.forEach(function (cell) {
            if (!cellMap[cell.id]) {
                cell.remove();
            } else {
                delete cellMap[cell.id];
            }
        });

        return Object.keys(cellMap).map(function (key) {
            return cellMap[key];
        });
    }

    function _updateHighlighting(cells) {
        cells.forEach(function (cell) {
            if (cell.refreshHighlighting) {
                cell.refreshHighlighting();
            }
        });
    }

    function _combine() {
        var selectedElementIsNode = _selectedElement instanceof _elements.Node;
        if (selectedElementIsNode) {
            var selectedNode = _selectedElement;
            var nodeMap = _dataContainer.maps.nodeMap;
            var sourceMap = _dataContainer.maps.sourceMap;
            var targetMap = _dataContainer.maps.targetMap;

            var relativeLinks = (sourceMap[selectedNode.id] || []).concat(targetMap[selectedNode.id] || []);
            var relativeNodes = relativeLinks.map(function (l) {
                if (l.model.source !== selectedNode.id) return nodeMap[l.model.source];else if (l.model.target !== selectedNode.id) return nodeMap[l.model.target];else if (l.model.source === l.model.target) return nodeMap[l.model.source];
            });

            var newPositions = (0, _layout.combineOperation)({
                selectedNode: selectedNode,
                relativeLinks: relativeLinks,
                relativeNodes: relativeNodes,
                scale: _scale
            }, parameters);

            var targetViewFrameId = (0, _lineageDiagramUtils.getViewFrameIdForNode)(selectedNode);
            var newPath = {};
            var affectedViewFramesMap = {};
            relativeNodes.forEach(function (node) {
                var curPosition = (0, _utils.getGlobalNodePosition)(node);
                node.model.position = newPositions[node.id];
                _dataContainer.updateZonesForNode(node, curPosition);

                var viewFrame = _viewManager.getViewFrameForNode(node);
                affectedViewFramesMap[viewFrame.id] = viewFrame;
                node.viewFrameOwnerId = targetViewFrameId;
                newPath[node.id] = node;
            });
            newPath[selectedNode.id] = selectedNode;

            relativeLinks.forEach(function (link) {
                newPath[link.id] = link;
            });

            _path = newPath;

            var affectedViewFrames = Object.keys(affectedViewFramesMap).map(function (key) {
                return affectedViewFramesMap[key];
            });
            _redraw({ viewFrames: affectedViewFrames, updateBounds: true });
            _limitViewPortsPostions(affectedViewFrames);
        }
    }

    /**
     * Removes all from the paper besides viewFrames.
     */
    function _clear() {
        _unselect();
        _graph.clear();
        _viewManager = undefined;
    }

    /**
     * Define data container with nodes and links for the Jointjs view (view-2)
     * and path it to the forms
     * @param {DataContainer} dataContainer - data for the graph
     * @param {ViewFramePublicModel[]} viewFrames - view frames
    */
    function _setData(dataContainer, viewFrames) {
        _clear();

        _dataContainer = dataContainer;
        _routingManager = new _routingManager2.RoutingManager({
            links: _dataContainer.links,
            bounds: {
                x: _viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth,
                y: _viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth,
                width: _paper.el.clientWidth - (_viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth) * 2,
                height: _paper.el.clientHeight - (_viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth) * 2
            }
        }, parameters);
        _viewManager = new _viewManager2.ViewManager({
            dataContainer: dataContainer,
            viewFrames: viewFrames,
            fullScreenMode: _fullScreenMode
        }, parameters);

        _viewFramesUI = _createViewFramesUI(_viewManager);

        _viewManager.on('change-view-port-position', function (viewFrame) {
            _redraw({ viewFrames: [viewFrame], quickUpdate: true });
        });

        _correctScale();
        _redraw();
    }

    /**
     * @param {string} viewFrameId 
     * @fires view-frames-size-or-position-changed
     */
    function _openViewFrame(viewFrameId) {
        var viewFrame = _viewManager.getViewFrameById(viewFrameId);
        if (!viewFrame) return;

        viewFrame.expanded = true;
        var viewFrames = [viewFrame];

        _redraw({ viewFrames: viewFrames });

        self.trigger('view-frames-state-changed', [viewFrames]);

        _limitViewPortsPostions(_viewManager.getViewFrames().filter(function (vf) {
            return vf.active;
        }));
    }

    function _closeViewFrame(viewFrameId) {
        var viewFrame = _viewManager.getViewFrameById(viewFrameId);
        if (!viewFrame) return;

        viewFrame.expanded = false;
        var viewFrames = [viewFrame];

        _redraw({ viewFrames: viewFrames });

        self.trigger('view-frames-state-changed', [viewFrames]);

        _limitViewPortsPostions(_viewManager.getViewFrames().filter(function (vf) {
            return vf.active;
        }));
    }

    function _setFullScreenMode(value) {
        _fullScreenMode = value;

        if (!_fullScreenMode) {
            _scale = {
                x: Math.max(Math.min(_scale.x, _scaleBounds.max), _scaleBounds.min),
                y: Math.max(Math.min(_scale.y, _scaleBounds.max), _scaleBounds.min)
            };
        }

        _redraw({ fullScreenMode: value });

        var viewFrames = _viewManager.getViewFrames();
        self.trigger('view-frames-state-changed', [viewFrames]);

        if (value) {
            var overViewFrame = _viewManager.getOverViewFrame();
            _limitViewPortPostion(overViewFrame, function () {
                _redraw();
                self.trigger('view-frames-size-or-position-changed', [[overViewFrame]]);
            });
        } else {
            _limitViewPortsPostions(viewFrames.filter(function (vf) {
                return vf.active;
            }));
        }
    }

    /**
     * Sets and limits value of the scale of the graph.
     * @param {number} scale
     * @returns {number}
     * =================
     * @fires scale-changed
     */
    function _updateScale(scale) {
        var fullScreen = _viewManager.isFullScreenMode();

        scale = scale || _scale;
        if (fullScreen) {
            _scale = {
                x: Math.max(Math.min(scale.x, _overViewScaleBounds.max), _overViewScaleBounds.min),
                y: Math.max(Math.min(scale.y, _overViewScaleBounds.max), _overViewScaleBounds.min)
            };
        } else {
            _scale = {
                x: Math.max(Math.min(scale.x, _scaleBounds.max), _scaleBounds.min),
                y: Math.max(Math.min(scale.y, _scaleBounds.max), _scaleBounds.min)
            };
        }
        return _scale;
    }

    function _correctScale() {
        var viewFramesNumber = _viewManager.getViewFrames().length;
        var width = _paper.el.clientWidth - _viewManager2.FRAME_OUT_MARGIN * 2;
        var height = _paper.el.clientHeight - _viewManager2.FRAME_OUT_MARGIN * 2;

        var cutedWidth = width - _viewManager2.DISTANCE_BETWEEN_FRAMES * (viewFramesNumber - 1);
        var cutedHeight = height - _viewManager2.DISTANCE_BETWEEN_FRAMES * (viewFramesNumber - 1);

        var minHorNum = 4; // it's for max scale because when we have max scale we also have minimum node number
        var minVertNum = 3;

        var maxHorNum = 8; // it's for min scale because when we have min scale we also have maximum node number
        var maxVertNum = 7;

        var nodeSize = {
            width: parameters.elementSize.width,
            height: parameters.elementSize.height
        };
        var step = {
            x: parameters.layoutStep.x,
            y: parameters.layoutStep.y
        };

        var minScale = getScaleForNodeNumber(maxHorNum, maxVertNum);
        var maxScale = getScaleForNodeNumber(minHorNum, minVertNum);

        // parameters.defaultScale = scale;
        _scaleBounds.min = Math.max(minScale.x, minScale.y);
        _scaleBounds.max = Math.min(maxScale.x, maxScale.y);
        // _setScale(scale);

        function getScaleForNodeNumber(horNum, vertNum) {
            var curXValue = horNum * nodeSize.width + (horNum - 1) * step.x;
            var curYValue = vertNum * nodeSize.height + (horNum - 1) * step.y;

            var scale = void 0;
            if (Math.abs(cutedWidth - curXValue) >= Math.abs(cutedHeight - curYValue)) {
                scale = {
                    x: cutedWidth / curXValue,
                    y: cutedWidth / curXValue
                };
            } else {
                scale = {
                    x: cutedHeight / curYValue,
                    y: cutedHeight / curYValue
                };
            }

            return scale;
        }
    }

    function _findNextNode(direction) {
        if (!_selectedElement) return undefined;
        var curPos = void 0;
        if (_selectedElement instanceof _elements.Node) {
            curPos = (0, _utils.getGlobalNodePosition)(_selectedElement);
        } else {
            var source = _dataContainer.maps.nodeMap[_selectedElement.model.source];
            var sourcePos = source.model.position;
            var target = _dataContainer.maps.nodeMap[_selectedElement.model.target];
            var targetPos = target.model.position;
            if (direction === DIRECTION.UP) {
                if (source.model.y < target.model.y) {
                    return source;
                } else {
                    return target;
                }
            } else if (direction === DIRECTION.DOWN) {
                if (source.model.y > target.model.y) {
                    return source;
                } else {
                    return target;
                }
            } else if (direction === DIRECTION.LEFT) {
                if (sourcePos.x < targetPos.x) {
                    return source;
                } else {
                    return target;
                }
            } else if (direction === DIRECTION.RIGHT) {
                if (sourcePos.x > targetPos.x) {
                    return source;
                } else {
                    return target;
                }
            }
        }

        var prevNodes = []; // to break cycling
        return getNextNode(curPos);

        function getNextNode(curPos) {
            function diffToNode(node) {
                var nodePosition = (0, _utils.getGlobalNodePosition)(node);
                return {
                    x: curPos.x - nodePosition.x,
                    y: curPos.y - nodePosition.y
                };
            }

            var X_STEP = parameters.dataZoneSize.width;
            var Y_STEP = parameters.dataZoneSize.height;
            var rect = {
                x: curPos.x - X_STEP / 2,
                y: curPos.y - Y_STEP / 2,
                width: X_STEP,
                height: Y_STEP
            };

            var nodes = _dataContainer.getElementsForRectangle(rect).nodes.filter(function (n) {
                return prevNodes.indexOf(n) === -1;
            });
            if (nodes.length === 0) return _selectedElement;
            prevNodes = nodes;

            var nextElements = void 0;
            if (direction === DIRECTION.UP) {
                nextElements = nodes.filter(function (n) {
                    var dist = diffToNode(n);
                    return dist.y > 0 && Math.abs(dist.y) > Math.abs(dist.x);
                });
                if (nextElements.length === 0) {
                    return getNextNode({
                        x: curPos.x,
                        y: curPos.y - Y_STEP
                    });
                }
            } else if (direction === DIRECTION.DOWN) {
                nextElements = nodes.filter(function (n) {
                    var dist = diffToNode(n);
                    return dist.y < 0 && Math.abs(dist.y) > Math.abs(dist.x);
                });
                if (nextElements.length === 0) {
                    return getNextNode({
                        x: curPos.x,
                        y: curPos.y + Y_STEP
                    });
                }
            } else if (direction === DIRECTION.LEFT) {
                nextElements = nodes.filter(function (n) {
                    var dist = diffToNode(n);
                    return dist.x > 0 && Math.abs(dist.y) < Math.abs(dist.x);
                });
                if (nextElements.length === 0) {
                    return getNextNode({
                        x: curPos.x - X_STEP,
                        y: curPos.y
                    });
                }
            } else if (direction === DIRECTION.RIGHT) {
                nextElements = nodes.filter(function (n) {
                    var dist = diffToNode(n);
                    return dist.x < 0 && Math.abs(dist.y) < Math.abs(dist.x);
                });
                if (nextElements.length === 0) {
                    return getNextNode({
                        x: curPos.x + X_STEP,
                        y: curPos.y
                    });
                }
            }
            nextElements.sort(function (a, b) {
                var aPos = (0, _utils.getGlobalNodePosition)(a);
                var bPos = (0, _utils.getGlobalNodePosition)(b);
                var aDist = (0, _utils.getDist)(aPos, curPos);
                var bDist = (0, _utils.getDist)(bPos, curPos);

                if (aDist > bDist) {
                    return 1;
                } else if (aDist < bDist) {
                    return -1;
                } else {
                    return 0;
                }
            });
            return nextElements[0];
        }
    }

    /**
     * Subscribes on paper and Keyboard events.
     */
    function _subscribeOnEvents() {
        var queryAnimationFrame = void 0;

        _paper.on('link:options', function (cellView, event) {
            var linkType = event.target.parentNode.getAttribute('linkType');
            self.trigger('link-options-click', {
                link: cellView.model,
                linkType: linkType
            });
        });

        _keyboard.on({
            'up down left right': function upDownLeftRight(evt) {
                cancelAnimationFrame(queryAnimationFrame);
                queryAnimationFrame = requestAnimationFrame(function () {
                    _select(_findNextNode(evt.keyCode), true);
                    evt.stopPropagation();
                });
            }
        });

        var _clickCounter = 0;
        _paper.on('cell:pointerup', function (cellView, event) {
            var isViewFrame = cellView.model instanceof _viewFrame.ViewFrame;
            if (isViewFrame) {
                onSingleClick(cellView, event);
                _clickCounter = 0;
            } else {
                if (_clickCounter > 1) {
                    onDoubleClick(cellView, event);
                    _clickCounter = 0;
                } else {
                    setTimeout(function () {
                        if (_clickCounter === 1) onSingleClick(cellView, event);
                        _clickCounter = 0;
                    }, 200);
                }
            }

            function onSingleClick(cellView, event) {
                var isDragging = Math.abs(_mouseDownPosition.x - event.pageX) > 5 || Math.abs(_mouseDownPosition.y - event.pageY);
                var cell = cellView.model;
                if (cell instanceof _viewFrame.ViewFrame) {
                    var viewFrame = _viewManager.getViewFrameById(cell.id);
                    // ViewFrame click
                    // ================================
                    if (!isDragging) _unselect();
                    _limitViewPortPostion(viewFrame, function () {
                        _redraw();
                        self.trigger('view-frames-size-or-position-changed', [[_viewManager.getViewFrameById(cell.id)]]);
                    });
                    // ================================
                } else {
                    // Node/Link click
                    // ================================
                    var draggingNode = isDragging && (cell instanceof _elements.Node || cell instanceof _elements.TerminationNode);
                    var clickTerminationNode = cell instanceof _elements.TerminationNode;
                    var clickOnNodeOrLink = !(cell instanceof _elements.AspectLink); // Exclude AspectLink
                    if (draggingNode) {
                        _updateNodesPositions([cell]);
                    } else if (clickTerminationNode) {
                        _select(cell, true);
                    } else if (clickOnNodeOrLink) {
                        _select(cell);
                    }
                    // ================================
                }
                self.trigger('cell-single-click', cellView.model);
            }

            function onDoubleClick(cellView) {
                var element = cellView.model;
                if (element instanceof _elements.Node) {
                    element.set('expanded', !cellView.model.get('expanded'));
                    _updateNodesPositions([element]);
                }
                self.trigger('cell-double-click', cellView.model);
            }
        });

        var _mouseDownPosition = { x: 0, y: 0 };
        _paper.on('cell:pointerdown', function (cell, event) {
            _mouseDownPosition = { x: event.pageX, y: event.pageY };
            _clickCounter++;
        });

        _paper.on('cell:mousewheel', function (cell, evt, x, y, delta) {
            var SCROLL_STEP = 100;
            var viewFrame = _viewManager.getVieFrameByScreenPoint({ x: x, y: y });

            if (viewFrame) {
                if (evt.shiftKey) {
                    viewFrame.viewPortPosition.x += (delta < 0 ? 1 : -1) * SCROLL_STEP;
                    viewFrame.viewPortPosition = (0, _utils.limitPointPosition)(viewFrame.viewPortPosition, viewFrame.viewPortPositionBounds);
                    _delayedRedraw({ viewFrames: [viewFrame] }, function () {
                        self.trigger('view-frames-size-or-position-changed', [[viewFrame]]);
                    });
                } else if (evt.ctrlKey) {
                    var diff = delta > 0 ? _scaleStep : -_scaleStep;
                    var scale = {
                        x: _scale.x + diff,
                        y: _scale.y + diff
                    };
                    _updateScale(scale);
                    _delayedRedraw(undefined, function () {
                        // _limitViewPortsPostions(_viewManager.getViewFrames());
                        self.trigger('scale-changed', scale);
                    });
                } else {
                    viewFrame.viewPortPosition.y += (delta < 0 ? 1 : -1) * SCROLL_STEP;
                    viewFrame.viewPortPosition = (0, _utils.limitPointPosition)(viewFrame.viewPortPosition, viewFrame.viewPortPositionBounds);
                    _delayedRedraw({ viewFrames: [viewFrame] }, function () {
                        self.trigger('view-frames-size-or-position-changed', [[viewFrame]]);
                    });
                }
                evt.preventDefault();
            }
        });

        window.onresize = function () {
            _correctScale();
            _delayedRedraw(undefined, function () {
                self.trigger('scale-changed');
            });
        };
    }

    function _updateNodesPositions(nodes) {
        var changedViewFrames = [];
        var overViewFrame = _viewManager.getOverViewFrame();

        nodes.forEach(function (n) {
            var node = (0, _dataUtils.getBaseElement)(n);
            var isTerminationNode = n instanceof _elements.TerminationNode;
            var viewFrameByPosition = _viewManager.getVieFrameForNodeByPosition(n);

            var prevOwnerFrame = _viewManager.getViewFrameOwner(node) || overViewFrame;
            var viewFrame = void 0;

            viewFrame = viewFrameByPosition || prevOwnerFrame;
            var draggedElementPosition = n.position(); // could be termination node

            if (isTerminationNode) {
                draggedElementPosition.x -= (node.size.width - n.size.width) / 2;
                draggedElementPosition.y -= (node.size.height - n.size.height) / 2;
            }

            var newGlobalPosition = (0, _utils.localToGlobalPoint)(draggedElementPosition, _fullScreenMode ? overViewFrame.scale : viewFrame.scale, _fullScreenMode ? overViewFrame : viewFrame);
            var oldGlobalPosition = (0, _utils.getGlobalNodePosition)(node);

            node.model.position = newGlobalPosition;
            node.viewFrameOwnerId = viewFrame.id;

            _dataContainer.updateZonesForNode(node, oldGlobalPosition);

            var addedFrameIds = changedViewFrames.map(function (vf) {
                return vf.id;
            });
            var prevOwnerNotAddedInList = addedFrameIds.indexOf(prevOwnerFrame.id) === -1;
            var viewFrameNotAddedInList = addedFrameIds.indexOf(viewFrame.id) === -1;
            if (prevOwnerNotAddedInList && prevOwnerFrame.active) {
                prevOwnerFrame.updateBounds = true;
                changedViewFrames.push(prevOwnerFrame);
            }
            if (viewFrameNotAddedInList && viewFrame.active) {
                viewFrame.updateBounds = true;
                changedViewFrames.push(viewFrame);
            }
        });

        if (_fullScreenMode) {
            overViewFrame.updateBounds = true;
            changedViewFrames.push(overViewFrame);
        }

        _redraw({ viewFrames: changedViewFrames });
        _limitViewPortsPostions(changedViewFrames, function () {
            self.trigger('nodes-position-changed', [nodes]);
        });
    }

    /**
     * Creates ui for ViewFrames.
     */
    function _createViewFramesUI(viewManager) {
        if (_base.ui) {
            var viewFramesUI = new _viewFramesUI3.default({
                rootEl: _base.ui,
                viewManager: viewManager
            }, parameters);

            viewFramesUI.on('splitter-position-changed', function (s, diffObj) {
                var isHorizontalOrientated = _orientation === 'left-to-right' || _orientation === 'right-to-left';
                var diff = diffObj.diff;
                var vfA = s.model.viewFrameA;
                var vfB = s.model.viewFrameB;
                var thereIsDifference = diff !== undefined && diff !== null;
                if (thereIsDifference) {
                    if (isHorizontalOrientated) {
                        vfA.size.width += diff;
                        vfB.size.width -= diff;
                        vfB.position.x += diff;
                    } else {
                        vfA.size.height += diff;
                        vfB.size.height -= diff;
                        vfB.position.y += diff;
                    }
                    vfA.customeSized;
                    vfB.customeSized;
                }
                if (diffObj.lastChange) {
                    _redraw({ viewFrames: [vfA, vfB], quickUpdate: false });
                    _limitViewPortsPostions([vfA, vfB]);
                } else if (thereIsDifference) {
                    _redraw({ viewFrames: [vfA, vfB], quickUpdate: true });
                }
            });

            viewFramesUI.on('view-port-position-changed', function (viewFrame) {
                var relevantViewFrame = _viewManager.getViewFrameById(viewFrame.id);
                _positionViewPort(relevantViewFrame, viewFrame.viewPortPosition, parameters.animation, function () {
                    var changedViewFrame = _viewManager.getViewFrameById(viewFrame.id);
                    self.trigger('view-frames-size-or-position-changed', [[changedViewFrame]]);
                });
            });

            viewFramesUI.on('view-frame-collapsed', function (viewFrame) {
                viewFrame.expanded = false;
                _closeViewFrame(viewFrame.id);
            });

            return viewFramesUI;
        }
    }

    /**
    * Creates html base for diagram.
    */
    function _createBase(baseDiv) {
        baseDiv.innerHTML = '';

        var diagram = document.createElement('DIV');
        diagram.className = 'tq-lg-lineage-diagram';
        diagram.id = 'tq_lineage-graph';
        baseDiv.appendChild(diagram);

        var ui = document.createElement('DIV');
        ui.className = 'tq-lg-lineage-ui';
        baseDiv.appendChild(ui);

        return { ui: ui, diagram: diagram };
    }

    /**
     * Clears selected object.
     * @param {boolean} silent - blocks throwing of event
     * @fires selected-element-changed
     */
    function _unselect(silent) {
        if (_selectedElement) {
            _path = null;
            _selectedElement.unselect();
            _selectedElement = null;

            if (!silent) {
                _redraw();
                self.trigger('selected-element-changed', null);
            }
        }
    }

    /**
     * Sets selected object and changes viewPort position if it's needed.
     * @param {Node|Link} element
     * @param {boolean} focusOn
     * ========================
     * @fires selected-element-changed
     */
    function _select(element, focusOn) {
        var selectedElement = (0, _dataUtils.getBaseElement)(element);

        if (selectedElement !== _selectedElement) {
            if (_selectedElement) _selectedElement.unselect();
            _selectedElement = selectedElement;
            _selectedElement.select();
        }

        if (focusOn) {
            _focusOnElement(_selectedElement, function () {
                _path = (0, _lineageDiagramUtils.getPath)(_selectedElement, _dataContainer);
                _redraw();
                self.trigger('selected-element-changed', element);
            });
        } else {
            setTimeout(function () {
                _path = (0, _lineageDiagramUtils.getPath)(_selectedElement, _dataContainer);
                _redraw();
                self.trigger('selected-element-changed', element);
            }, 0);
        }
    }

    /**
     * It moves position of the viewPort so that
     * the selected element appears in the senter of the viewPort
     * @param {Node|Link} element
     * @param {function} callback - _focusOnElement can be asynchronous depends on animation mode
     */
    function _focusOnElement(element, callback) {
        var focusNode = null;
        if (element instanceof _elements.Link) {
            focusNode = _dataContainer.maps.nodeMap[element.model.source];
        } else if (element instanceof _elements.Node) {
            focusNode = element;
        }
        if (focusNode) {
            var viewFrame = _viewManager.getViewFrameForNode(focusNode);
            if (!viewFrame.active) {
                _redraw({ viewFrames: [{ id: viewFrame.id, expanded: true }], quickUpdate: true });
                viewFrame = _viewManager.getViewFrameById(viewFrame.id);
                self.trigger('view-frames-state-changed', [[viewFrame]]);
            }
            var viewPortSize = viewFrame.size;
            var nodeSize = (0, _utils.getGlobalNodeSize)(focusNode, _scale);
            var nodePosition = (0, _utils.getGlobalNodePosition)(focusNode);

            var targetPosition = {
                x: nodePosition.x + (nodeSize.width - viewPortSize.width) / 2,
                y: nodePosition.y + (nodeSize.height - viewPortSize.height) / 2
            };

            _positionViewPort(viewFrame, targetPosition, parameters.animation, function () {
                callback();
                var changedViewFrame = _viewManager.getViewFrameById(viewFrame.id);
                self.trigger('view-frames-size-or-position-changed', [[changedViewFrame]]);
            });
        }
    }

    /**
     * All viewPort position changes should be performed through this methods.
     * _positionViewPort (exclude scale)
     * It's needed to stop animation in case of animation haven't been done.
     */

    /**
     * It sets offset for all elements into the viewPort.
     * @param {ViewFrame} viewFrame
     * @param {Point} point
     * @param {boolean} animation - it's optional
     * @param {function} callback - it's called after focus
     */
    function _positionViewPort(viewFrame, point, animation, callback) {
        var relevatnViewFrame = _viewManager.getViewFrameById(viewFrame.id);
        var targetPos = (0, _utils.limitPointPosition)(point, relevatnViewFrame.viewPortPositionBounds);
        var viewPortPosition = relevatnViewFrame.viewPortPosition;
        var targetIsReached = viewPortPosition.x === targetPos.x && viewPortPosition.y === targetPos.y;

        if (!animation || targetIsReached || !viewFrame.active) {
            cancelAnimationFrame(_animationId);
            viewFrame.viewPortPosition = targetPos;
            _redraw({ viewFrames: [viewFrame], quickUpdate: true });
            if (callback) callback();
        } else {
            _animatedViewPortChanging(relevatnViewFrame, targetPos, callback);
        }
    }

    function _limitViewPortsPostions(viewFrames, callback) {
        recursiveCall(0);

        function recursiveCall(index) {
            var viewFrame = viewFrames[index];
            if (!viewFrame) {
                if (callback) callback();
                return;
            }

            var targetViewFrame = _viewManager.getViewFrameById(viewFrame.id);
            if (!targetViewFrame) {
                if (callback) callback();
                return;
            }

            _limitViewPortPostion(targetViewFrame, function () {
                if (index < viewFrames.length) {
                    recursiveCall(index + 1);
                } else {
                    var changedViewFramesModels = viewFrames.map(function (vf) {
                        return _viewManager.getViewFrameById(vf.id);
                    });
                    self.trigger('view-frames-size-or-position-changed', [changedViewFramesModels]);
                    if (callback) callback();
                }
            });
        }
    }

    function _limitViewPortPostion(viewFrame, callback) {
        var limittedPosition = (0, _utils.limitPointPosition)(viewFrame.viewPortPosition, viewFrame.viewPortPositionBounds);
        var positionIsIncorrect = limittedPosition.x !== viewFrame.viewPortPosition.x || limittedPosition.y !== viewFrame.viewPortPosition.y;
        if (positionIsIncorrect) {
            _positionViewPort(viewFrame, limittedPosition, parameters.animation, callback);
        } else if (callback) {
            callback();
        }
    }

    /**
     * Chages viewPort position smoothly from current position to target.
     * @param {ViewFrame} vf
     * @param {Point} targetPos
     * @param {function} callback
     */
    var _animationId = undefined;
    function _animatedViewPortChanging(viewFrame, targetPos, callback) {
        var startPos = viewFrame.viewPortPosition;

        var diffX = (0, _utils.getDiff)(startPos.x, targetPos.x);
        var diffY = (0, _utils.getDiff)(startPos.y, targetPos.y);
        var max = Math.max(diffX, diffY);
        var scale = viewFrame.scale || _scale;
        var defaultStepX = parameters.animationStep / scale.x;
        var defaultStepY = parameters.animationStep / scale.y;

        var stepX = void 0,
            stepY = void 0;
        if (max === diffX) {
            stepX = defaultStepX;
            stepY = diffY / (diffX / defaultStepY);
        } else {
            stepX = diffX / (diffY / defaultStepX);
            stepY = defaultStepY;
        }

        var startDistance = (0, _utils.getDist)(viewFrame.viewPortPosition, targetPos);

        cancelAnimationFrame(_animationId);

        var time = void 0;
        reqursiveAnimation();

        function reqursiveAnimation(oldPos) {
            _animationId = requestAnimationFrame(function () {
                var now = new Date().getTime();
                var timeRate = 1000 / (now - time) || parameters.minFrameRate;

                var tModifier = 1;
                if (parameters.minFrameRate > timeRate) {
                    tModifier = parameters.minFrameRate / timeRate;
                }
                if (timeRate > parameters.maxFrameRate) {
                    tModifier = parameters.maxFrameRate / timeRate;
                }
                time = now;

                var curPos = viewFrame.viewPortPosition;
                var targetIsReached = curPos.x === targetPos.x && curPos.y === targetPos.y;
                var weAreNotMoving = oldPos && curPos.x === oldPos.x && curPos.y === oldPos.y;

                if (targetIsReached || weAreNotMoving) {
                    _delayedRedraw({ viewFrames: [viewFrame] });
                    // _redraw({ viewFrames: [viewFrame], quickUpdate: false });
                    cancelAnimationFrame(_animationId);
                    if (callback) callback();
                    return;
                } else {
                    var _diffX = (0, _utils.getDiff)(curPos.x, targetPos.x);
                    var _diffY = (0, _utils.getDiff)(curPos.y, targetPos.y);

                    var newPos = { x: curPos.x, y: curPos.y };

                    var curDistance = (0, _utils.getDist)(curPos, targetPos);
                    var k = 1 - Math.cos(Math.PI * (startDistance - curDistance) / startDistance) * 0.3;

                    var finalStepX = stepX;
                    var finalStepY = stepY;

                    if (newPos.x !== targetPos.x) {
                        var d = Math.min(_diffX, finalStepX * k * tModifier);
                        newPos.x += curPos.x < targetPos.x ? d : -d;
                    }
                    if (newPos.y !== targetPos.y) {
                        var _d = Math.min(Math.abs(_diffY), finalStepY * k * tModifier);
                        newPos.y += curPos.y < targetPos.y ? _d : -_d;
                    }
                    viewFrame.viewPortPosition = newPos;

                    _redraw({ viewFrames: [viewFrame], quickUpdate: true });

                    reqursiveAnimation(curPos);
                }
            });
        }
    }

    /**
     * Refreshes all viewFrames bounds.
     */
    function _refresh(viewFrames) {
        viewFrames = viewFrames || _viewManager.getViewFrames();
        _redraw({ viewFrames: viewFrames, updateBounds: true });
        _limitViewPortsPostions(viewFrames);
    }

    function _resetLayout() {
        var viewFrameAffectedIds = {};
        var overViewFrameId = _viewManager.getOverViewFrame().id;

        _dataContainer.nodes.forEach(function (node) {
            if (node.model.defaultPosition) {
                var curPos = (0, _utils.getGlobalNodePosition)(node);
                node.model.position = node.model.defaultPosition;
                _dataContainer.updateZonesForNode(node, curPos);
                if (node.viewFrameOwnerId) viewFrameAffectedIds[node.viewFrameOwnerId] = true;

                var isFullScreenMode = _viewManager.isFullScreenMode();
                viewFrameAffectedIds[isFullScreenMode ? overViewFrameId : node.model.viewFrame] = true;
                delete node.viewFrameOwnerId;
            }
        });
        var viewFrames = Object.keys(viewFrameAffectedIds).map(function (key) {
            return { id: key, updateBounds: true };
        });
        _redraw({ viewFrames: viewFrames });
        _limitViewPortsPostions(viewFrames);
    }
}

},{"../htmlUI/viewFramesUI":39,"../layout/layout":56,"../subscriptionAPI/subscribeable":65,"../utils/dataUtils":66,"../utils/lineageDiagramUtils":68,"../utils/utils":69,"./graphElements/elements":46,"./linkRoutingManager/routingManager":52,"./toSvg":53,"./viewFrame":54,"./viewManager":55,"file-saverjs":2,"lodash":"lodash","rappid":"rappid"}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ENABLE_ROUTINGS = undefined;
exports.RoutingManager = RoutingManager;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var g = joint.g;
var LINK_OFFSET = 7;

var ENABLE_ROUTINGS = exports.ENABLE_ROUTINGS = ['metro', 'normal', 'manhattan', 'orthogonal', 'lgrouter'];

/**
 * RoutingManager
 * @private
 * @param {linkRouting, links, bounds} options 
 * @param {*} parameters 
 */
function RoutingManager(options, parameters) {
    var self = this;

    var _links = void 0;
    var _routing = options.linkRouting || parameters.linkRouting;

    var _vertexMap = {};
    var _idToVertex = {};
    var _bounds = options.bounds;

    self.setData = _setData;
    self.setRouting = _setRouting;
    self.resetRouting = _resetRouting;
    self.setBounds = _setBounds;

    self.getRouting = function () {
        return _routing;
    };

    function _init() {
        _setData(options.links);
        joint.routers.lgrouter = lgrouter;
        joint.routers.metro = newMetro;
    }

    function _setBounds(bounds) {
        _bounds = bounds;
    }

    function _setData(links) {
        _links = links;
        _updateLinkRouting();
    }

    function _setRouting(routing) {
        var isUnknownRoutingId = ENABLE_ROUTINGS.indexOf(routing) === -1;
        if (isUnknownRoutingId) {
            routing = 'metro';
        }
        if (routing !== _routing) {
            _routing = routing;
            _updateLinkRouting();
        }
    }

    function _updateLinkRouting() {
        _vertexMap = {};
        _idToVertex = {};
        _links.forEach(function (link) {
            var router = {
                name: _routing,
                args: link.get('router').args
            };
            link.set('router', router, link.isOnTheGraph() ? {} : { silent: true });
        });
    }

    function _resetRouting() {
        _vertexMap = {};
        _idToVertex = {};
    }

    // Routers
    // =========================================

    var lgrouter = function () {
        return function (manualVertices, opts, linkView) {
            var defaultCofig = {
                step: 10
            };
            var vertices = joint.routers.manhattan(manualVertices, _.extend({}, defaultCofig, opts), linkView);

            this._findConnectionPoints(vertices);

            var allVertices = findIntermediateVertices([this.sourcePoint].concat(vertices).concat([this.targetPoint]),
            // vertices.length > 0 ? vertices : [this.sourceBBox.center(), this.targetBBox.center()],
            defaultCofig.step);

            var translatedVertices = [];
            clearVertices(linkView);

            var maxOffset = { x: 0, y: 0 };
            for (var i = 0; i < allVertices.length; i++) {
                var prevVertex = allVertices[i - 1];
                var vertex = allVertices[i];
                var nextVertex = allVertices[i + 1];
                vertex.type = getPositionType(prevVertex, vertex, nextVertex);
                maxOffset = getOffset(vertex, maxOffset);
            }

            allVertices.forEach(function (vertex) {
                var newVertex = storeVeertex(vertex, maxOffset, linkView);
                if (vertices.indexOf(vertex) !== -1) {
                    translatedVertices.push(newVertex);
                }
            });

            return translatedVertices.map(function (vertex) {
                return {
                    x: Math.min(Math.max(vertex.x, _bounds.x), _bounds.x + _bounds.width),
                    y: Math.min(Math.max(vertex.y, _bounds.y), _bounds.y + _bounds.height)
                };
            });
        };
    }();

    var newMetro = function () {
        var config = {
            // cost of a diagonal step (calculated if not defined).
            diagonalCost: null,
            // an array of directions to find next points on the route
            directions: function directions() {
                var step = this.step;
                var diagonalCost = this.diagonalCost || Math.ceil(Math.sqrt(step * step << 1));

                return [{ offsetX: step, offsetY: 0, cost: step }, { offsetX: step, offsetY: step, cost: diagonalCost }, { offsetX: 0, offsetY: step, cost: step }, { offsetX: -step, offsetY: step, cost: diagonalCost }, { offsetX: -step, offsetY: 0, cost: step }, { offsetX: -step, offsetY: -step, cost: diagonalCost }, { offsetX: 0, offsetY: -step, cost: step }, { offsetX: step, offsetY: -step, cost: diagonalCost }];
            },
            maxAllowedDirectionChange: 45,
            // a simple route used in situations, when main routing method fails
            // (exceed loops, inaccessible).
            fallbackRoute: function fallbackRoute(from, to) {
                // Find a route which breaks by 45 degrees ignoring all obstacles.
                var theta = from.theta(to);

                var a = { x: to.x, y: from.y };
                var b = { x: from.x, y: to.y };

                if (theta % 180 > 90) {
                    var t = a;
                    a = b;
                    b = t;
                }

                var p1 = theta % 90 < 45 ? a : b;
                var l1 = g.line(from, p1);
                var alpha = 90 * Math.ceil(theta / 90);
                var p2 = g.point.fromPolar(l1.squaredLength(), g.toRad(alpha + 135), p1);
                var l2 = g.line(to, p2);
                var point = l1.intersection(l2);

                return point ? [point.round(), to] : [to];
            }
        };

        // public function
        return function (vertices, opts, linkView) {
            return lgrouter.call(this, vertices, _.extend({}, config, opts), linkView);
        };
    }();

    // =========================================

    function getPositionType(prevVertex, vertex, nextVertex) {
        if (prevVertex || nextVertex) {
            var x = Math.round(vertex.x);
            var y = Math.round(vertex.y);
            var equalX = (!prevVertex || Math.round(prevVertex.x) === x) && (!nextVertex || Math.round(nextVertex.x) === x);
            var equalY = (!prevVertex || Math.round(prevVertex.y) === y) && (!nextVertex || Math.round(nextVertex.y) === y);
            if (equalX) {
                return 'vertical';
            } else if (equalY) {
                return 'horizontal';
            } else {
                return 'point';
            }
        } else {
            return 'point';
        }
    }

    function applyOffset(vertex, offset) {
        var isHorizontal = vertex.type === 'horizontal';
        var isVerical = vertex.type === 'vertical';
        return {
            x: vertex.x + (isHorizontal ? 0 : offset.x),
            y: vertex.y + (isVerical ? 0 : offset.y),
            type: vertex.type
        };
    }

    function getId(vertex) {
        return Math.round(vertex.x) + '@' + Math.round(vertex.y) + ':' + vertex.type;
    }

    // function getOffset (vertex, defaultOffset) {
    //     const curVertex = applyOffset(vertex, defaultOffset);
    //     const vId = getId(curVertex);

    //     if (_vertexMap[vId]) {
    //         const isHorizontal = vertex.type === 'horizontal'; 
    //         const isVerical = vertex.type === 'vertical';
    //         return getOffset (vertex, {
    //             x: defaultOffset.x + (isHorizontal ? 0 : -LINK_OFFSET),
    //             y: defaultOffset.y + (isVerical ? 0 : LINK_OFFSET),
    //         });
    //     } else {
    //         return defaultOffset;
    //     }
    // }

    function getOffset(vertex, defaultOffset) {
        var isHorizontal = vertex.type === 'horizontal';
        var isVerical = vertex.type === 'vertical';

        var curOffset = defaultOffset;
        var curVertex = applyOffset(vertex, defaultOffset);
        var curId = getId(curVertex);

        var xType = defaultOffset.x === 0 ? 'trigger' : defaultOffset.x > 0 ? 'rise' : 'fall';
        var yType = defaultOffset.y === 0 ? 'trigger' : defaultOffset.y > 0 ? 'rise' : 'fall';
        var xTrigger = 1;
        var yTrigger = 1;
        var xStep = 0;
        var yStep = 0;
        while (_vertexMap[curId]) {
            curOffset = { x: defaultOffset.x, y: defaultOffset.y };
            if (xType === 'trigger') {
                xTrigger = -xTrigger;
                if (xTrigger < 0) {
                    xStep++;
                }
            } else if (xType === 'rise') {
                xStep++;
            } else {
                xStep--;
            }
            if (yType === 'trigger') {
                yTrigger = -yTrigger;
                if (yTrigger < 0) {
                    yStep++;
                }
            } else if (yType === 'rise') {
                yStep++;
            } else {
                yStep--;
            }
            curOffset = {
                x: defaultOffset.x + (isHorizontal ? 0 : xStep * LINK_OFFSET * xTrigger),
                y: defaultOffset.y + (isVerical ? 0 : yStep * LINK_OFFSET * yTrigger)
            };

            curVertex = applyOffset(vertex, curOffset);
            curId = getId(curVertex);
        }

        return curOffset;
    }

    function clearVertices(linkView) {
        if (_idToVertex[linkView.model.id]) {
            _idToVertex[linkView.model.id].forEach(function (vertexId) {
                delete _vertexMap[vertexId];
            });
            delete _idToVertex[linkView.model.id];
        }
    }

    function storeVeertex(vertex, offset, linkView) {
        var newVertex = applyOffset(vertex, offset);

        var vertexId = getId(newVertex);
        _vertexMap[vertexId] = newVertex;

        if (!_idToVertex[linkView.model.id]) {
            _idToVertex[linkView.model.id] = [];
        }
        _idToVertex[linkView.model.id].push(vertexId);
        return newVertex;
    }

    function findIntermediateVertices(vertices, step) {
        var allVertices = [];
        var prev = undefined;
        vertices.forEach(function (vertex) {
            if (prev !== undefined) {
                var isVertical = prev.x === vertex.x;
                var isHorizontal = prev.y === vertex.y;

                if (isVertical) {
                    if (prev.y < vertex.y) {
                        for (var y = prev.y + step; y < vertex.y; y += step) {
                            allVertices.push({ x: vertex.x, y: y });
                        }
                    } else {
                        for (var _y = prev.y - step; _y > vertex.y; _y -= step) {
                            allVertices.push({ x: vertex.x, y: _y });
                        }
                    }
                } else if (isHorizontal) {
                    if (prev.x < vertex.x) {
                        for (var x = prev.x + step; x < vertex.x; x += step) {
                            allVertices.push({ x: x, y: vertex.y });
                        }
                    } else {
                        for (var _x = prev.x - step; _x > vertex.x; _x -= step) {
                            allVertices.push({ x: _x, y: vertex.y });
                        }
                    }
                }
            }
            allVertices.push(vertex);
            prev = vertex;
        });

        return allVertices;
    }

    _init();
}

},{"lodash":"lodash","rappid":"rappid"}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EXCLUDED_ELEMENTS = exports.PNG_CONTENT_PADDING = exports.FOREIGN_OBJECT_PADDING = undefined;
exports.exportToSVG = exportToSVG;
exports.toDataURL = toDataURL;
exports.fitRectKeepingAspectRatio = fitRectKeepingAspectRatio;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _elements = require('./graphElements/elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var FOREIGN_OBJECT_PADDING = exports.FOREIGN_OBJECT_PADDING = 2; // in px
var PNG_CONTENT_PADDING = exports.PNG_CONTENT_PADDING = 1; // in px
var EXCLUDED_ELEMENTS = exports.EXCLUDED_ELEMENTS = ['.dn-arrow', 'img', '.derivation-node_body-scroller'];

function exportToSVG(paper, props) {
    props = props || {};

    var vpTransform = paper.viewport.getAttribute('transform');
    paper.viewport.removeAttribute('transform');

    // const paperBoundingBox = paper.viewport.getBBox();
    var paperBoundingBox = paper.getContentBBox();
    var svgCopy = props.convertHtml ? createSVGCopy(paper) : simpleClone(paper);

    paper.viewport.setAttribute('transform', vpTransform || '');

    if (props.pdfMode) {
        svgCopy.removeAttribute('style');
        svgCopy.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        svgCopy.removeAttribute('height');
        if (props.preserveDimensions) {
            svgCopy.setAttribute('width', paperBoundingBox.width.toString());
        } else {
            svgCopy.setAttribute('width', '100%');
        }

        var PADDING = 40;
        svgCopy.setAttribute('viewBox', [paperBoundingBox.x - PADDING, paperBoundingBox.y - PADDING, paperBoundingBox.x + paperBoundingBox.width + PADDING, paperBoundingBox.y + paperBoundingBox.height + PADDING].join(' '));
    } else {
        svgCopy.removeAttribute('style');
        if (props.preserveDimensions) {
            svgCopy.setAttribute('width', paperBoundingBox.width.toString());
            svgCopy.setAttribute('height', paperBoundingBox.height.toString());
        } else {
            svgCopy.setAttribute('width', '100%');
            svgCopy.setAttribute('height', '100%');
        }

        svgCopy.setAttribute('viewBox', '' + paperBoundingBox.x + ' ' + paperBoundingBox.y + ' ' + paperBoundingBox.width + ' ' + paperBoundingBox.height);
    }

    var isIE = !window.ActiveXObject && 'ActiveXObject' in window;

    if (isIE) {
        alignText(svgCopy.querySelectorAll('text'));

        //Shim SVGElement classList
        if (!Object.getOwnPropertyDescriptor(SVGElement.prototype, 'classList')) {
            if (HTMLElement && Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'classList')) {
                var descriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'classList');
                Object.defineProperty(SVGElement.prototype, 'classList', descriptor);
            }
        }
    }

    // workaround to include only ontodia-related stylesheets
    var cssStrings = extractCSSFromPaper(svgCopy);

    var defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.id = 'extracted-styles'; // For IE-EDGE
    cssStrings.forEach(function (cssString, index) {
        var mocDiv = document.createElement('DIV');
        mocDiv.id = 'extracted-file-' + index;
        mocDiv.innerHTML = '<style>' + cssStrings + '</style>';
        defs.appendChild(mocDiv.firstChild);
    });
    svgCopy.insertBefore(defs, svgCopy.firstChild);

    if (props.elementsToRemoveSelector) {
        processNodes(svgCopy.querySelectorAll(props.elementsToRemoveSelector), function (node) {
            return node.remove();
        });
    }
    return convertImages(svgCopy.querySelectorAll('image')).then(function () {
        return new XMLSerializer().serializeToString(svgCopy);
    });
}

function alignText(textBlocks) {
    processNodes(textBlocks, function (text) {
        var anchor = text.getAttribute('text-anchor');
        var transform = text.getAttribute('transform');
        if (anchor === 'middle' && transform.indexOf('translate')) {
            text.removeAttribute('text-anchor');
            var y = transform.match(/,([\d,.]+)\)/)[1];
            text.setAttribute('transform', 'translate(' + _elements.LABEL_LEFT_RIGHT_PADDING + ', ' + y + ')');
        }
    });
}

function convertImages(images) {
    var promises = [];
    processNodes(images, function (image) {
        promises.push(new Promise(function (resolve) {
            if (!image) resolve();

            // Firefox uses `href`, all the others 'xlink:href'
            var url = image.getAttribute('xlink:href') || image.getAttribute('href');

            joint.util.imageToDataUri(url, function (err, dataUri) {
                image.setAttribute('xlink:href', dataUri);
                resolve();
            });
        }));
    });
    return Promise.all(promises);
}

var EXCLUDED_SELECTORS = ['body'];
function extractCSSFromPaper(paper) {
    var cssTexts = [];
    var allElements = paper.querySelectorAll('*');

    var allowedCssClasses = [];
    for (var i = 0; i < allElements.length; i++) {
        var element = allElements[i];

        var classesList = element.classList;
        for (var j = 0; j < classesList.length; j++) {
            allowedCssClasses.push(classesList[j]);
        }
    }

    for (var _i = 0; _i < document.styleSheets.length; _i++) {
        var cssClasses = void 0;
        try {
            var cssFile = document.styleSheets[_i];
            cssClasses = cssFile.cssRules || cssFile.rules;
            if (!cssClasses) {
                continue;
            }
        } catch (e) {
            continue;
        }

        var cssClassText = [];

        for (var _j = 0; _j < cssClasses.length; _j++) {
            var rule = cssClasses[_j];
            var doesContainAllowedClass = containsAllowedClass(rule.selectorText, allowedCssClasses);
            var allowedSelector = EXCLUDED_SELECTORS.indexOf(rule.selectorText) === -1 && doesContainAllowedClass;
            if (rule instanceof CSSStyleRule && allowedSelector) {
                cssClassText.push(rule.cssText);
            }
        }

        cssTexts.push(cssClassText.join('\n'));
    }

    function containsAllowedClass(cssSelector, allowedCssClasses) {
        if (!cssSelector) return true;
        for (var _i2 = 0; _i2 < allowedCssClasses.length; _i2++) {
            if (cssSelector.indexOf(allowedCssClasses[_i2]) !== -1) {
                return true;
            }
        }
        return false;
    }

    return cssTexts;
}

function simpleClone(paper) {
    var svgClone = paper.svg.cloneNode(true);
    return svgClone;
}

function createSVGCopy(paper) {
    var svgClone = paper.svg.cloneNode(true);
    var cells = paper.model.get('cells');
    processNodes(svgClone.querySelectorAll('g.element'), function (cellView) {
        var id = cellView.getAttribute('model-id');
        var htmlView = paper.el.querySelector('.derivation-node[id=\'' + id + '\']');
        if (!htmlView) {
            return;
        }

        var content = void 0;
        var isItIE11 = Boolean(navigator.userAgent.match(/Trident.*rv\:11\./));
        if (isItIE11) {
            content = processHTML(htmlView, EXCLUDED_ELEMENTS);
        } else {
            content = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
            var cell = cells.get(id);
            var cellSize = cell.get('size');

            content.setAttribute('width', cellSize.width + FOREIGN_OBJECT_PADDING);
            content.setAttribute('height', cellSize.height + FOREIGN_OBJECT_PADDING);

            var htmlContent = htmlView.cloneNode(true);
            htmlContent.style.transform = null;

            var body = htmlView.querySelector('.derivation-node_body');
            var newBodies = htmlContent.querySelector('.derivation-node_body');
            if (body.scrollTop !== 0) {
                newBodies.firstChild.style.marginTop = -body.scrollTop + 'px';
            }
            content.appendChild(htmlContent);
        }

        cellView.setAttribute('class', cellView.getAttribute('class'));

        var anchor = cellView.querySelector('.export-anchor');
        anchor.removeAttribute('transform');

        var root = cellView.querySelector('.body');
        anchor.removeChild(root);
        anchor.appendChild(content);
    });

    return svgClone;
}

function processHTML(htmlView, excludedElements) {
    var g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

    function recursion(htmlRoot) {
        if (htmlRoot instanceof HTMLElement) {
            if (checkElement(htmlRoot)) {
                var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                var offsetTop = getOffsetTop(htmlRoot);
                var offsetLeft = getOffsetLeft(htmlRoot);
                var style = window.getComputedStyle(htmlRoot);

                // svgRect.setAttribute('className', htmlRoot.className);
                rect.setAttribute('fill', style.backgroundColor);
                rect.setAttribute('stroke', style.borderColor);
                rect.setAttribute('stroke-width', style.borderWidth);
                rect.setAttribute('x', offsetLeft);
                rect.setAttribute('y', offsetTop);
                rect.setAttribute('width', style.width);
                rect.setAttribute('height', style.height);

                g.appendChild(rect);
                processNodes(htmlRoot.childNodes, function (child) {
                    recursion(child, true);
                });
            }
        } else if (htmlRoot instanceof Text) {
            var textContent = htmlRoot.textContent.trim();
            if (textContent.length === 0) return;

            var text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            var parent = htmlRoot.parentNode;

            var _offsetTop = getOffsetTop(parent);
            var _offsetLeft = getOffsetLeft(parent);
            var _style = window.getComputedStyle(parent);

            text.setAttribute('fill', _style.color);
            text.setAttribute('alignment-baseline', 'hanging');
            text.setAttribute('x', _offsetLeft);
            text.setAttribute('y', _offsetTop);

            var maxCharNumber = getMaxCharNumber(textContent, +_style.width.substring(0, _style.width.length - 2), _style.font);
            if (maxCharNumber === textContent.length) {
                text.textContent = textContent;
            } else {
                var ELIPSIS_LENGTH = 2;
                text.textContent = textContent.substring(0, maxCharNumber - ELIPSIS_LENGTH) + '...';
            }

            g.appendChild(text);
        }
    }

    function checkElement(element) {
        for (var i = 0; i < excludedElements.length; i++) {
            // IE11 fix
            var matches = element.matches ? element.matches : element.msMatchesSelector;
            if (matches.apply(element, [excludedElements[i]])) {
                return false;
            }
        }
        return true;
    }

    function getOffsetTop(element) {
        if (element.className !== 'derivation-node') {
            return element.offsetTop + element.clientTop + (element.offsetParent ? getOffsetTop(element.offsetParent) : 0);
        } else {
            return 0;
        }
    }

    function getOffsetLeft(element) {
        if (element.className !== 'derivation-node') {
            return element.offsetLeft + element.clientLeft + (element.offsetParent ? getOffsetLeft(element.offsetParent) : 0);
        } else {
            return 0;
        }
    }

    function getMaxCharNumber(text, maxWidth, font) {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        ctx.font = font;

        var textWidth = ctx.measureText(text).width;
        if (textWidth <= maxWidth) {
            return text.length;
        } else {
            var FIT_CORRECTION = 0.85;
            return Math.floor(text.length * (maxWidth / textWidth) * FIT_CORRECTION);
        }
    }

    recursion(htmlView);

    return g;
}

function processNodes(nodes, callback) {
    for (var i = 0; i < nodes.length; i++) {
        callback(nodes[i]);
    }
}

function toDataURL(paper, options) {
    return new Promise(function (resolve) {
        var svgOptions = _.clone(options.svgOptions);

        var oldToSvg = paper.toSVG;
        paper.toSVG = function (callback) {
            exportToSVG(paper, svgOptions).then(function (svgString) {
                callback(svgString);
            });
        };
        paper.toPNG(function (image) {
            resolve(image);
        });
        paper.toSVG = oldToSvg;
    });
}

function fitRectKeepingAspectRatio(sourceWidth, sourceHeight, targetWidth, targetHeight) {
    if (!targetWidth && !targetHeight) {
        return { width: sourceWidth, height: sourceHeight };
    }
    var ratio = sourceWidth / sourceHeight;
    targetWidth = targetWidth || targetHeight * ratio;
    targetHeight = targetHeight || targetWidth / ratio;

    if (targetHeight * ratio <= targetWidth) {
        return { width: targetHeight * ratio, height: targetHeight };
    } else {
        return { width: targetWidth, height: targetWidth / ratio };
    }
}

exports.default = exportToSVG;

},{"./graphElements/elements":46,"lodash":"lodash","rappid":"rappid"}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ViewFrame = ViewFrame;
exports.OverViewFrame = OverViewFrame;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _utils = require('../utils/utils');

var _elements = require('./graphElements/elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var HOR_LABEL_PADDING = 8;
var VERT_LABEL_PADDING = 6;
var FONT_SIZE = 11;
var DEFAULT_FRAME_SIZE = { width: 50, height: 50 };

/**
 * Bounds
 * @typedef {Object} Bounds
 * @property {number} maxX
 * @property {number} minX
 * @property {number} maxY
 * @property {number} minY
 * @property {number} width
 * @property {number} height
*/

/**
 * @private
 * @class
 * ViewFrame of the main view (View-2).
 * Provides visible elements to the LineageDiagram.
 * Based on joint.shapes.basic.Rect.
 *
 * Constructor parameters:
 * ========================================
 * @param {
 *  dataContainer: DataContainer
 *  id: string
 *  backgroundColor: string
 *  borderColor: string
 *  spaceShare: number
 * } options
 * @param {Parameters} parameters - parameters set
 *
 * Public properties:
 * ========================================
 * id: string
 * model: @param options
 * constPosition: Point
 * size: Size (width, height)
 * movingByItself: boolena - it's flag to block a moving
 *
 * Public methods:
 * ========================================
 * refreshNodeState: (node: Node) => void;
 * getNodes: () => Node[];
 * updateBounds: () => void;
 * clear: () => void;
 * getNodeBounds: () => Bounds;
 * getViewPortBounds: () => Bounds;
 * setData: (dataContainer: DataContainer) => void
 * getVisibleCells: () => { nodes: Node[], link: Link[] };
 * calculateVisibleCells: () => void;
 * setPosition: (pos: Point) => void;
 * setSize: (size: Size) => void;
 * positionViewPort: (x: number, y: number) => Point;
 * resetSize: () => void;
 * hitScaledPointTest (point: Point) => boolean;
 * hitTest (node: Node, partialHit: boolean) => boolean;
 * ownerTest (node: Node) => boolean;
 * setScale: (scale: Point) => void;
 * getScale: () => Point;
 * setElementSize: (size: ElementSize) => void;
 * getElementSize: () => ElementSize;
 * limitNodePosition: (node: Node) => void;
 *
 * Events
 * ========================================
 * @fires change:correctPostion (limittedPoint: Point)
 * @fires change-view-port-position (newPosition: Point)
 *
 */
function ViewFrame(options, parameters) {
    // Init
    // ===================================================================
    // ===================================================================

    var self = this;
    self.id = options.id;
    self.model = options;
    self.constPosition = { x: 0, y: 0 };

    self.size = DEFAULT_FRAME_SIZE;
    self.movingByItself = false;

    if (options.singleMode) {
        options.dataContainer.nodes.forEach(function (n) {
            return n.viewFrameOwnerId = self.id;
        });
    }

    self.selectedElement;

    var _cachedResult = void 0;
    var _nodeBounds = void 0;
    var _viewPortPositionBounds = void 0;
    var _dataContainer = options.dataContainer;
    var _scale = void 0;
    var _viewPortPosition = { x: 0, y: 0 }; // global coordinates
    var _defaultElementSize = parameters.elementSize;
    var _referenceSize = _defaultElementSize;
    var _viewPortBounds = void 0;

    var _framePadding = parameters.framePadding;
    var label = joint.util.breakText(options.label, {
        width: self.size.width - HOR_LABEL_PADDING * 2
    });

    joint.shapes.basic.Rect.apply(self, [{
        id: options.id,
        type: 'viewFrame',
        position: { x: 0, y: 0 },
        size: self.size,
        attrs: {
            rect: {
                fill: options.backgroundColor,

                stroke: options.borderColor,
                class: 'body view-frame',
                width: self.size.width,
                height: self.size.height,
                'stroke-width': parameters.frameBorderWidth
            },
            text: {
                'x-alignment': 'left',
                'text-anchor': 'left',
                'font-weight': 'bold',
                ref: 'rect',
                'ref-x': HOR_LABEL_PADDING,
                'ref-y': VERT_LABEL_PADDING + FONT_SIZE,
                text: label.indexOf('\n') === -1 ? label : label.substring(0, label.indexOf('\n')) + '...',
                fill: options.borderColor
            }
        },
        z: _elements.Z_INDEXES.VIEW_FRAME
    }]);

    if (self.model.width) self.model.width = Math.abs(Math.max(self.model.width, parameters.framePadding.x * 2 + 1));
    if (self.model.height) self.model.height = Math.abs(Math.max(self.model.height, parameters.framePadding.y * 2 + 1));

    self.on('change:position', function (cell, position) {
        if (!self.movingByItself) {
            self.movingByItself = true;
            self.position(self.constPosition.x, self.constPosition.y);
            self.movingByItself = false;

            var scaledOffset = {
                x: self.constPosition.x - position.x,
                y: self.constPosition.y - position.y
            };
            var globalOffset = (0, _utils.scaledToGlobalPoint)(scaledOffset, _scale);

            var newViewPortPosition = {
                x: _viewPortPosition.x + globalOffset.x,
                y: _viewPortPosition.y + globalOffset.y
            };
            self.trigger('change-view-port-position', newViewPortPosition);
        }
    });

    _init(options, parameters);

    self.set('correctPostion', null);

    // ===================================================================
    // ===================================================================

    // CallBack to override
    // self._onChangeBounds = undefined;

    /**
     * Update position and size of the node.
     * @param {Node} node
    */
    self.refreshNodeState = _refreshNodeState;

    /**
     * Returns list of nodes which viewFrame owns.
     * @returns {Array of Node}
    */
    self.getNodes = _getNodes;

    /**
     * Recaclulate viewPort bounds
    */
    self.updateBounds = _updateBounds;

    /**
     * Clear caches.
    */
    self.clear = _clear;

    /**
     * ViewFrame public model
     * @typedef {Object} Bounds
     * @property {number} minX
     * @property {number} maxX
     * @property {number} minY
     * @property {number} maxY
     * @property {number} width
     * @property {number} height
    */

    /**
     * Returns bounds of viewFrame in paper coordinates without padding.
     * @returns {Bounds}
    */
    self.getNodeBounds = function () {
        return _nodeBounds;
    };

    /**
     * Returns bounds of viewFrame in paper coordinates.
    */
    self.getViewPortBounds = function () {
        return _viewPortBounds;
    };

    /**
     * Returns bounds of viewFrame in paper coordinates.
    */
    self.getViewPortPositionBounds = function () {
        return _viewPortPositionBounds;
    };

    /**
     * Returns all visible in this viewport cells (Links|Nodes e.t.c.)
     * @returns {
     *  nodes: Node[],
     *  links: Link[],
     * }
     */
    self.getVisibleCells = function () {
        if (!_cachedResult) self.calculateVisibleCells();
        return _cachedResult;
    };

    /**
     * Calculate list of all visible in this viewport cells
     * @param {ViewFrameRenderOptions} options
     */
    self.calculateVisibleCells = function (options) {
        options = options || {};
        _referenceSize = _calculateReferenceNodeSize(options.elementSize || _defaultElementSize);
        _viewPortBounds = _getViewPortBounds();

        var globalSize = (0, _utils.scaledToGlobalSize)(self.size, _scale);
        var globalRectangle = {
            x: _viewPortPosition.x,
            y: _viewPortPosition.y,
            width: globalSize.width,
            height: globalSize.height
        };
        var activeElements = _dataContainer.getElementsForRectangle(globalRectangle);

        var visibleNodeMap = {};
        var visibleNodes = activeElements.nodes.filter(function (node) {
            var isNodeVisible = _ownerTest(node) && _hitTestByGlobalPosition(node);
            if (isNodeVisible) visibleNodeMap[node.id] = node;
            return isNodeVisible;
        });

        visibleNodes.forEach(function (node) {
            _refreshNodeState(node);
        });

        _cachedResult = {
            nodes: visibleNodes,
            links: activeElements.links
        };
    };

    /**
     * Sets position of the viewFrame on the paper
     * @returns {
     *  nodes: Node[],
     *  links: Link[],
     * }
     */
    self.setPosition = function (pos) {
        self.movingByItself = true;
        self.constPosition = pos;
        self.position(self.constPosition.x, self.constPosition.y);
        self.movingByItself = false;
    };

    /**
     * Changes size of the view-port-jointjs element.
     * @param {Size} size
     * @param {boolean} remember
     */
    self.setSize = _setSize;

    /**
     * It sets offset for all elements into the viewPort.
     * @param {number} x
     * @param {number} y
     * @param {boolean} force - disables the limit
     * @returns {Point}
     */
    self.positionViewPort = _positionViewPort;

    /**
     * Resets size.
     */
    self.resetSize = function () {
        self.model.width = undefined;
        self.model.height = undefined;
    };

    /**
     * Tells us whether the
     * point is in the viewPort of ViewFrame or not
     * @param {number} scale
     * @returns {boolean}
    */
    self.hitScaledPointTest = _hitScaledPointTest;

    /**
     * Tells us whether the
     * node is in the viewPort of ViewFrame or not
     * @param {Node} node
     * @returns {boolean}
    */
    self.hitTestByScaledPosition = _hitTestByScaledPosition;

    self.hitTestByGlobalPosition = _hitAreaTestByGlobalPosition;

    /**
     * Tells us whether the
     * ViewFrame is owner of the passed node or not
     * function for overriding
     * @param {Node} node
     * @returns {boolean}
    */
    // self._ownerTest - to override

    /**
     * Sets the scale of the viewFrame.
     * @param {Point} scale
    */
    self.setScale = _setScale;
    // self._scaleWillApplied; - to override

    /**
     * Returns the scale of the viewFrame.
     * @returns {number}
    */
    self.getScale = _getScale;

    /**
     * Sets the default element size.
     * @param {ElementSize} elementSize
    */
    self.setElementSize = function (elementSize) {
        _defaultElementSize = elementSize;
        _updateBounds();
        _limitViewPortPosition();
    };

    /**
     * Returns the default element size.
    */
    self.getElementSize = function () {
        return _defaultElementSize;
    };

    self.limitNodePosition = function (node) {

        var nodeScaledSize = node.calculateSize(_referenceSize); // scaled
        var scaledViewPortBounds = (0, _utils.globalToScaledBounds)(_viewPortPositionBounds);
        var nodeMinScaledPosition = (0, _utils.getScaledNodePosition)(node, _scale);

        var limitByMin = (0, _utils.limitPointPosition)(nodeMinScaledPosition, scaledViewPortBounds);
        var nodeMaxScaledPosition = {
            x: limitByMin.x + nodeScaledSize.width,
            y: limitByMin.y + nodeScaledSize.height
        };
        var limitByMax = (0, _utils.limitPointPosition)(nodeMaxScaledPosition, scaledViewPortBounds);
        var position = (0, _utils.scaledToGlobalPoint)(limitByMax, _scale);

        node.model.position = position;
    };

    function _init(options) {
        if (options.scale) {
            _scale = options.scale;
        } else if (self._scaleWillApplied) {
            _scale = self._scaleWillApplied(parameters.defaultScale);
        } else {
            _scale = parameters.defaultScale;
        }
        if (options.nodeBounds) {
            _nodeBounds = options.nodeBounds;
        } else {
            _nodeBounds = _calculateBounds();
        }
        if (options.viewPortPosition) {
            _viewPortPosition = options.viewPortPosition;
        }
        if (options.viewPortPositionBounds) {
            _viewPortPositionBounds = options.viewPortPositionBounds;
        } else {
            _viewPortPositionBounds = _calculateViewPortPositionBounds();
        }
        _viewPortBounds = _getViewPortBounds();
    }

    /**
     * Sets the scale of the viewFrame.
     * @param {Point} scale
    */
    function _setScale(scale) {
        if (self._scaleWillApplied) {
            _scale = self._scaleWillApplied(scale);
        } else {
            _scale = scale;
        }
        _updateBounds();
        _limitViewPortPosition();
    }

    /**
     * Returns the scale of the viewFrame.
     * @returns {number}
    */
    function _getScale() {
        return _scale;
    }

    function _clear() {
        _cachedResult = undefined;
    }

    /**
     * It sets offset for all elements into the viewPort.
     * @param {number} x
     * @param {number} y
     * @param {boolean} force - disables the limit
     * @returns {Point}
     */
    function _positionViewPort(x, y) {
        if (x !== undefined) _viewPortPosition.x = x;
        if (y !== undefined) _viewPortPosition.y = y;

        return { x: _viewPortPosition.x, y: _viewPortPosition.y };
    }

    /**
     * Returns list of nodes which viewFrame owns.
     * @returns {Array of Node}
    */
    function _getNodes() {
        return _dataContainer.nodes.filter(function (n) {
            return _ownerTest(n);
        });
    }

    /**
     * Changes size of the view-port-jointjs element.
     * @param {Size} size
     * @param {boolean} remember
     */
    function _setSize(size) {
        self.movingByItself = true;

        // it's best solution to fix the svg exporting
        // and for better compatibility IE11
        self.attr({
            'rect': {
                width: size.width,
                height: size.height
            }
        });
        // =================================
        self.resize(size.width, size.height);
        self.size = size;
        self.model.width = size.width;
        self.model.height = size.height;

        self.movingByItself = false;

        var label = joint.util.breakText(options.label, {
            width: self.size.width - HOR_LABEL_PADDING * 2
        });
        var completeLabel = label.indexOf('\n') === -1 ? label : label.substring(0, label.indexOf('\n')) + '...';
        self.attr('text/text', completeLabel);
    }

    /**
     * Update position and size of the node.
    */
    function _refreshNodeState(node) {
        var nodePosition = (0, _utils.getLocalNodePosition)(node, _scale, self);
        node.position(nodePosition.x, nodePosition.y);
        node.setSize(_referenceSize);
        if (parameters.clipNodes) {
            _clipNode(node);
        }
    }

    function _updateBounds() {
        _nodeBounds = _calculateBounds();
        _viewPortPositionBounds = _calculateViewPortPositionBounds();
    }

    /**
     * Recalculate bounds of view port.
    */
    function _calculateBounds() {
        var bounds = {
            minX: Infinity,
            maxX: -Infinity,
            minY: Infinity,
            maxY: -Infinity,
            width: undefined,
            height: undefined
        };

        var nodes = _getNodes();
        if (nodes.length !== 0) {

            nodes.forEach(function (node) {
                var pos = (0, _utils.getGlobalNodePosition)(node);
                var size = (0, _utils.scaledToGlobalSize)(node.calculateSize(_referenceSize), _scale);

                bounds.minX = Math.min(bounds.minX, pos.x);
                if (bounds.minX === pos.x) bounds.minXNode = node;

                bounds.maxX = Math.max(bounds.maxX, pos.x + size.width);
                if (bounds.maxX === pos.x + size.width) bounds.maxXNode = node;

                bounds.minY = Math.min(bounds.minY, pos.y);
                if (bounds.minY === pos.y) bounds.minYNode = node;

                bounds.maxY = Math.max(bounds.maxY, pos.y + size.height);
                if (bounds.maxY === pos.y + size.height) bounds.maxYNode = node;
            });

            bounds.width = bounds.maxX - bounds.minX;
            bounds.height = bounds.maxY - bounds.minY;
        } else {
            bounds.minX = 0;
            bounds.minY = 0;
            bounds.maxX = 0;
            bounds.maxY = 0;
            bounds.width = 0;
            bounds.height = 0;
        }

        return bounds;
    }

    /**
     * Returns bounds of view port.
     * @returns {
     *  maxX: number
     *  minX: number
     *  maxY: number
     *  minY: number
     * }
    */
    function _calculateViewPortPositionBounds() {
        if (!_nodeBounds) return null;
        // _bounds - global coord
        var viewFrameGlobalSize = (0, _utils.scaledToGlobalSize)(self.size, _scale);
        var boundsWithPadding = (0, _utils.extendBounds)(_nodeBounds, _framePadding);

        var viewPortBounds = {
            minX: boundsWithPadding.minX,
            maxX: boundsWithPadding.maxX - viewFrameGlobalSize.width,
            minY: boundsWithPadding.minY,
            maxY: boundsWithPadding.maxY - viewFrameGlobalSize.height,
            width: boundsWithPadding.maxX - viewFrameGlobalSize.width - boundsWithPadding.minX,
            height: boundsWithPadding.maxY - viewFrameGlobalSize.height - boundsWithPadding.minY
        };

        if (viewPortBounds.width < 0) {
            var diffX = (viewFrameGlobalSize.width - boundsWithPadding.width) / 2;
            viewPortBounds.minX = boundsWithPadding.minX - diffX;
            viewPortBounds.maxX = viewPortBounds.minX;
            viewPortBounds.width = 0;
        }

        if (viewPortBounds.height < 0) {
            var diffY = (viewFrameGlobalSize.height - boundsWithPadding.height) / 2;
            viewPortBounds.minY = boundsWithPadding.minY - diffY;
            viewPortBounds.maxY = viewPortBounds.minY;
            viewPortBounds.height = 0;
        }

        return viewPortBounds;
    }

    /**
    * Returns bounds of view port.
    * @returns {
    *  maxX: number
    *  minX: number
    *  maxY: number
    *  minY: number
    * }
    */
    function _getViewPortBounds() {
        var globalViewPortSize = (0, _utils.scaledToGlobalSize)(self.size, _scale);
        return {
            minX: _viewPortPosition.x,
            maxX: _viewPortPosition.x + globalViewPortSize.width,
            minY: _viewPortPosition.y,
            maxY: _viewPortPosition.y + globalViewPortSize.height,
            width: _viewPortPosition.x + globalViewPortSize.width - _viewPortPosition.x,
            height: _viewPortPosition.y + globalViewPortSize.height - _viewPortPosition.y
        };
    }

    /**
     * Limits position of the view port.
     * @returns {Point}
    */
    function _limitViewPortPosition() {
        _viewPortPosition = (0, _utils.limitPointPosition)(_viewPortPosition, _viewPortPositionBounds);
    }

    /**
     * Tells us whether a Node fall into the viewport or no.
     * @param {Node} node
     * @param {boolean} partialHit
     * @returns {boolean}
    */
    function _hitTestByGlobalPosition(node, partialHit) {
        var nodePosition = (0, _utils.getGlobalNodePosition)(node);

        var nodeScaledSize = node.calculateSize(_referenceSize);
        var nodeSize = (0, _utils.scaledToGlobalSize)(nodeScaledSize, _scale);

        var p1 = nodePosition;
        var p2 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y };
        var p3 = { x: nodePosition.x, y: nodePosition.y + nodeSize.height };
        var p4 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y + nodeSize.height };

        var hitP1 = _hitGlobalPointTest(p1);
        var hitP2 = _hitGlobalPointTest(p2);
        var hitP3 = _hitGlobalPointTest(p3);
        var hitP4 = _hitGlobalPointTest(p4);

        var fullHit = hitP1 && hitP2 && hitP3 && hitP4;
        var borderHit = hitP1 || hitP2 || hitP3 || hitP4;

        if (parameters.clipNodes) {
            return borderHit;
        } else {
            return partialHit && borderHit || !partialHit && fullHit;
        }
    }

    function _hitAreaTestByGlobalPosition(node, viewFrame) {
        var scaledPosition = node.position();
        var nodePosition = (0, _utils.localToGlobalPoint)(scaledPosition, _scale, viewFrame || self);

        var nodeScaledSize = node.calculateSize(_referenceSize);
        var nodeSize = (0, _utils.scaledToGlobalSize)(nodeScaledSize, _scale);

        var p1 = nodePosition;
        var p2 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y };
        var p3 = { x: nodePosition.x, y: nodePosition.y + nodeSize.height };
        var p4 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y + nodeSize.height };

        var hitP1 = _hitAreaGlobalPointTest(p1);
        var hitP2 = _hitAreaGlobalPointTest(p2);
        var hitP3 = _hitAreaGlobalPointTest(p3);
        var hitP4 = _hitAreaGlobalPointTest(p4);

        var borderHit = hitP1 || hitP2 || hitP3 || hitP4;

        return borderHit;
    }

    function _hitTestByScaledPosition(node) {
        var scaledPosition = node.position();

        var p1 = scaledPosition;
        var p2 = { x: scaledPosition.x + node.size.width, y: scaledPosition.y };
        var p3 = { x: scaledPosition.x, y: scaledPosition.y + node.size.height };
        var p4 = { x: scaledPosition.x + node.size.width, y: scaledPosition.y + node.size.height };

        var hitP1 = _hitScaledPointTest(p1);
        var hitP2 = _hitScaledPointTest(p2);
        var hitP3 = _hitScaledPointTest(p3);
        var hitP4 = _hitScaledPointTest(p4);

        return hitP1 || hitP2 || hitP3 || hitP4;
    }

    function _hitGlobalPointTest(p) {
        return _viewPortBounds.minX <= p.x && p.x <= _viewPortBounds.maxX && _viewPortBounds.minY <= p.y && p.y <= _viewPortBounds.maxY;
    }

    function _hitAreaGlobalPointTest(p) {
        return _nodeBounds.minX <= p.x && p.x <= _nodeBounds.maxX && _nodeBounds.minY <= p.y && p.y <= _nodeBounds.maxY;
    }

    function _hitScaledPointTest(p) {
        return self.constPosition.x <= p.x && self.constPosition.x + self.size.width >= p.x && self.constPosition.y <= p.y && self.constPosition.y + self.size.height >= p.y;
    }

    function _ownerTest(node) {
        if (self._ownerTest) {
            return self._ownerTest(node);
        }
        var customeOwner = node.viewFrameOwnerId;
        var ownerIsMe = node.viewFrameOwnerId === self.id;
        var meIsNativeOwner = self.id === node.model.viewFrame;
        return customeOwner && ownerIsMe || meIsNativeOwner && !customeOwner;
    }

    /**
     * Calculate the clip point, which
     * tells us how far the node go out of the border of viewFrame.
     * And after calculation the function pass this point into the node.
     * @param {Node} node
    */
    function _clipNode(node) {
        var nodePosition = (0, _utils.getGlobalNodePosition)(node);
        var nodeScaledSize = node.calculateSize(_referenceSize);
        var nodeSize = (0, _utils.scaledToGlobalSize)(nodeScaledSize, _scale);

        var p1 = nodePosition;
        var p2 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y };
        var p3 = { x: nodePosition.x, y: nodePosition.y + nodeSize.height };
        var p4 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y + nodeSize.height };

        var globalOffset = { x: 0, y: 0 };

        var o = getPointOffset(p1);
        globalOffset.x = Math.abs(o.x) > Math.abs(globalOffset.x) ? o.x : globalOffset.x;
        globalOffset.y = Math.abs(o.y) > Math.abs(globalOffset.y) ? o.y : globalOffset.y;

        o = getPointOffset(p2);
        globalOffset.x = Math.abs(o.x) > Math.abs(globalOffset.x) ? o.x : globalOffset.x;
        globalOffset.y = Math.abs(o.y) > Math.abs(globalOffset.y) ? o.y : globalOffset.y;

        o = getPointOffset(p3);
        globalOffset.x = Math.abs(o.x) > Math.abs(globalOffset.x) ? o.x : globalOffset.x;
        globalOffset.y = Math.abs(o.y) > Math.abs(globalOffset.y) ? o.y : globalOffset.y;

        o = getPointOffset(p4);
        globalOffset.x = Math.abs(o.x) > Math.abs(globalOffset.x) ? o.x : globalOffset.x;
        globalOffset.y = Math.abs(o.y) > Math.abs(globalOffset.y) ? o.y : globalOffset.y;

        var scaledOffset = (0, _utils.globalToScaledPoint)(globalOffset, _scale);
        node.setClipping(scaledOffset);

        function getPointOffset(p) {
            var offset = { x: 0, y: 0 };
            if (_viewPortBounds.minX > p.x) {
                offset.x = _viewPortBounds.minX - p.x;
            } else if (_viewPortBounds.maxX < p.x) {
                offset.x = _viewPortBounds.maxX - p.x;
            }
            if (_viewPortBounds.minY > p.y) {
                offset.y = _viewPortBounds.minY - p.y;
            } else if (_viewPortBounds.maxY < p.y) {
                offset.y = _viewPortBounds.maxY - p.y;
            }
            return offset;
        }
    }

    /**
     * Returns current size for node with considering scale.
     * @param {Node} node
     * @returns {Size}
    */
    function _calculateReferenceNodeSize(elementSize) {
        var minScale = Math.min(_scale.x, _scale.y);
        var scaledElementSize = (0, _utils.globalToScaledSize)(elementSize, {
            x: minScale, y: minScale
        });
        // const scaledElementSize = globalToScaledSize(elementSize, _scale);

        var maxBoundedWidth = self.size.width - parameters.framePadding.x;
        var maxWidth = maxBoundedWidth >= elementSize.minWidth / 3 ? maxBoundedWidth : self.size.width;

        var maxBoundedHeight = self.size.height - parameters.framePadding.y;
        var maxHeight = maxBoundedHeight >= elementSize.minHeight ? maxBoundedHeight : self.size.height;

        var referenceSize = {
            width: Math.min(Math.max(elementSize.minWidth, Math.min(scaledElementSize.width, elementSize.maxWidth)), maxWidth),
            height: Math.min(Math.max(elementSize.minHeight, Math.min(scaledElementSize.height, elementSize.maxHeight)), maxHeight),
            maxWidth: maxWidth,
            maxHeight: maxHeight
        };

        return referenceSize;
    }
}
ViewFrame.prototype = Object.create(joint.shapes.basic.Rect.prototype);
exports.default = ViewFrame;

/**
 * @private
 * @class
 * It's special viewFrame to show all Nodes selected nodes.
 * All nodes are passed with options for parent class.
 * @augments ViewFrame.
 * And this class has the same methods, fields and parameters as ViewFrame.
 */

function OverViewFrame(options, parameters) {
    var self = this;
    var _ratioModifyer = 1;

    self._ownerTest = function () {
        return true;
    };

    self._scaleWillApplied = function (scale) {
        if (_ratioModifyer < 1) {
            return {
                x: scale.x,
                y: scale.x * _ratioModifyer
            };
        } else {
            return {
                x: scale.y / _ratioModifyer,
                y: scale.y
            };
        }
    };

    ViewFrame.apply(self, [options, parameters]);
    _init();

    function _init() {
        var paperSize = (0, _utils.getElementSize)(parameters.graphPlace);
        var nodeBounds = self.getNodeBounds();

        var widthIsScalable = nodeBounds.width && nodeBounds.minXNode !== nodeBounds.maxXNode;
        var heightIsScalable = nodeBounds.height && nodeBounds.minYNode !== nodeBounds.maxYNode;
        if (widthIsScalable && heightIsScalable) {
            var xRatio = paperSize.width / nodeBounds.width;
            var yRatio = paperSize.height / nodeBounds.height;

            if (xRatio !== yRatio) {
                _ratioModifyer = yRatio / xRatio;
            }
        }
    }
}
OverViewFrame.prototype = Object.create(ViewFrame.prototype);

},{"../utils/utils":69,"./graphElements/elements":46,"rappid":"rappid"}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FRAME_OUT_MARGIN = exports.DISTANCE_BETWEEN_FRAMES = undefined;
exports.ViewManager = ViewManager;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _viewFrame = require('./viewFrame');

var _elements = require('./graphElements/elements');

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _lineageDiagramUtils = require('../utils/lineageDiagramUtils');

var _utils = require('../utils/utils');

var _dataUtils = require('../utils/dataUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var DISTANCE_BETWEEN_FRAMES = exports.DISTANCE_BETWEEN_FRAMES = 20;
var FRAME_OUT_MARGIN = exports.FRAME_OUT_MARGIN = 20;

/**
 * ViewManager options.
 * @typedef {Object} ViewMangerOptions
 * @property {DataContainer} dataContainer
 * @property {ViewFramePublicModel[]} viewFrames
*/

/**
 * Manage ViewFrames and collect data
 * from them to return to the lineageDiagram render
 * @private
 * @param {ViewMangerOptions} options 
 * @param {Parameters} parameters 
 * @fires change-view-port-position
 * Public methods:
 * ========================================
 * prepareRenderData: (renderOptions) => (Node|Link|ViewFrame)[]
 * getViewFrameForNode: () => ViewFramePublicModel;
 * getVieFrameForNodeByPosition: (node) => ViewFramePublicModel;
 * getViewFrameById: () => ViewFramePublicModel;
 * getOverViewFrame: () => ViewFramePublicModel;
 * fullScreenMode: () => boolean;
 * getViewFrames: () => ViewFramePublicModel[];
 */
function ViewManager(options, parameters) {
    _subscribeable2.default.apply(this); // make this class Subscribable
    var self = this;

    var _terminationNodeSize = parameters.terminationNodeSize;

    var _terminationCellCache = {};
    var _aspectLinksCahe = {};
    var _renderOptions = {};
    var _viewFramesMap = {};
    var _state = {};
    var _dataContainer = void 0;
    var _overViewFrame = void 0;
    var _viewFrames = void 0;
    var _allFrames = void 0;

    var _fullScreenMode = void 0; // changeable

    _init(options, parameters);

    // ===================================================================
    // ===================================================================

    /**
     * Paper render options.
     * @typedef {Object} PaperRenderOptions
     * @property orientation: _orientation,
     * @property width: _paper.el.clientWidth,
     * @property height: _paper.el.clientHeight,
     * @property scale: _scale,
    */

    /**
     * Element render options.
     * @typedef {Object} ElementRenderOptions
     * @property {ElementSize} elementSize
    */

    /**
     * Render options.
     * @typedef {Object} RenderOptions
     * @property {ViewFramePublicModel[]} viewFrames
     * @property {boolean} fullScreenMode
     * @property {Object.<string, (Node|Link)>} path
     * @property {Object.<string, (Node|Link)>} mask
     * @property {boolean} updateBounds
     * @property {boolean} quickUpdate
     * @property {PaperRenderOptions} paperOptions
     * @property {ElementRenderOptions} elementOptions
    */

    /**
     * 1. Takes render data from the ViewFrames,
     * 2. Updates ViewFrames state
     * 3. Changes size and scale of viewFrames
     * 4. Updates highlighting
     * @param {RenderOptions} renderOptions
     * @returns {(Node|Link|ViewFrame)[]}
     */
    self.prepareRenderData = function (renderOptions) {
        _updateViewFrames(renderOptions);

        var visibleViewFrames = _getVisibleViewFrames();
        var viewFrameResults = visibleViewFrames.map(function (vf) {
            return vf.getVisibleCells();
        });
        var renderResults = _calculateRenderData(viewFrameResults, renderOptions);
        _setHighlighting(renderResults, renderOptions);

        return visibleViewFrames.concat(renderResults);
    };

    /**
     * Returns ViewFrame for the node which currently renders this node.
     * @param {Node} node
     * @returns {ViewFramePublicModel}
    */
    self.getViewFrameForNode = function (node) {
        return _getViewFramePublicModel(_getViewFrameForNode(node));
    };

    /**
     * Returns ViewFrame which currently owns this node.
     * @param {Node} node
     * @returns {ViewFramePublicModel}
    */
    self.getViewFrameOwner = function (node) {
        var viewFrameId = (0, _lineageDiagramUtils.getViewFrameIdForNode)(node);
        return _getViewFramePublicModel(_viewFramesMap[viewFrameId]);
    };

    /**
     * Returns ViewFrame for the node by his position.
     * @param {Node} node
     * @returns {ViewFramePublicModel | undefined}
    */
    self.getVieFrameForNodeByPosition = function (node) {
        if (_fullScreenMode) return undefined;

        var visibleFrames = _getVisibleViewFrames();
        for (var i = 0; i < visibleFrames.length; i++) {
            var vf = visibleFrames[i];

            if (vf.hitTestByScaledPosition(node)) return _getViewFramePublicModel(vf);
        }
        return undefined;
    };

    /**
     * Returns ViewFrame for the node by his position.
     * @param {Point} point
     * @returns {ViewFramePublicModel}
    */
    self.getVieFrameByScreenPoint = function (point) {
        var visibleFrames = _getVisibleViewFrames();
        for (var i = 0; i < visibleFrames.length; i++) {
            var vf = visibleFrames[i];
            if (vf.hitScaledPointTest(point)) {
                return _getViewFramePublicModel(vf);
            }
        }
        return undefined;
    };

    /**
     * Restores default size of ViewFrames
     */
    self.resetFrameLayout = function () {
        _viewFrames.forEach(function (vf) {
            vf.resetSize();
        });
    };

    /**
     * Returns ViewFrame by id
     * @param {string} id
     * @returns {ViewFramePublicModel | undefined}
     */
    self.getViewFrameById = function (viewFrameId) {
        return _getViewFramePublicModel(_viewFramesMap[viewFrameId]);
    };

    /**
     * Returns OverViewFrame
     * @returns {ViewFramePublicModel}
     */
    self.getOverViewFrame = function () {
        return _getViewFramePublicModel(_overViewFrame);
    };

    /**
     * Tells us whether overView is active or not
     * @returns {boolean}
     */
    self.isFullScreenMode = function () {
        return _fullScreenMode;
    };

    /**
     * Returns all ViewFrames
     * @returns {ViewFramePublicModel[]}
    */
    self.getViewFrames = function () {
        return _allFrames.map(function (vf) {
            return _getViewFramePublicModel(vf);
        });
    };

    /**
     * ViewFrame public model
     * @typedef {Object} ViewFramePublicModel
     * @property {string} id - Identifyer
     * @property {string} label - Label in the top-right corner
     * @property {string} backgroundColor - Bacground color
     * @property {string} borderColor - Border color
     * @property {boolean} active - Is on the screen
     * @property {boolean} expanded - Is expanded
     * @property {Point} position - Real position on the paper
     * @property {Point} viewPortPosition - Position of the viewPort
     * @property {Bounds} bounds - Real visual bounds of active zone of viewFrame (Zone around nodes)
     * @property {Size} size - Real size of viewFrame
     * @property {boolean} customeSized - Tells us whether size was changed by user or not
     * @property {Bounds} viewPortPositionBounds - Min max values of the position of the viewPort
     * @property {number} spaceShare - relative size of view frame (horizontal/vertical depends on orientation)
     * @property {boolean} updateBounds - Flag to pass into the render pipline
    */

    /**
     * @private
     * @param {ViewFrame} viewFrame
     * @returns {ViewFramePublicModel}
     */
    function _getViewFramePublicModel(viewFrame) {
        if (!viewFrame) return;
        var customeSized = viewFrame.model.width || viewFrame.model.height;

        var isActive = viewFrame === _overViewFrame ? _fullScreenMode : _fullScreenMode ? false : _state[viewFrame.model.id];

        var isExpanded = viewFrame === _overViewFrame ? _fullScreenMode : _state[viewFrame.model.id];

        return {
            id: viewFrame.model.id,
            label: viewFrame.model.label,
            backgroundColor: viewFrame.model.backgroundColor,
            borderColor: viewFrame.model.borderColor,
            active: isActive,
            expanded: isExpanded,
            position: viewFrame.position(), // local
            viewPortPosition: viewFrame.positionViewPort(), // global
            viewPortPositionBounds: viewFrame.getViewPortPositionBounds(), // global
            viewPortBounds: viewFrame.getViewPortBounds(), // global
            nodeBounds: viewFrame.getNodeBounds(), // global
            size: { width: viewFrame.size.width, height: viewFrame.size.height }, // local
            customeSized: customeSized,
            spaceShare: viewFrame.model.spaceShare,
            updateBounds: false,
            isOverView: viewFrame === _overViewFrame,
            scale: viewFrame.getScale()
        };
    }

    /**
     * Updates data model
     * @param {DataContainer} dataContainer - data for the graph
    */
    function _init(options, parameters) {
        _dataContainer = options.dataContainer;
        var map = {};
        var state = {};

        // Create OverView frame
        _overViewFrame = new _viewFrame.OverViewFrame({
            id: 'overViewFrame',
            label: 'Overview',
            dataContainer: _dataContainer,
            resurrectElements: true,
            borderColor: '#23b0f4',
            backgroundColor: '#f4f4ff',
            spaceShare: 1
        }, parameters);
        map[_overViewFrame.id] = _overViewFrame;

        // Create list of ViewFrames
        _viewFrames = options.viewFrames.map(function (model) {
            state[model.id] = model.expanded;
            var viewFrameOptions = _.cloneDeep(model);
            viewFrameOptions.dataContainer = options.dataContainer;
            var viewFrame = new _viewFrame.ViewFrame(viewFrameOptions, parameters);
            map[viewFrame.id] = viewFrame;
            return viewFrame;
        });
        _allFrames = _viewFrames.concat(_overViewFrame);

        _state = state;
        _viewFramesMap = map;
        _fullScreenMode = options.fullScreenMode;

        _subscribeOnViewFrameEvents(_allFrames);
    }

    /**
     * Updates states of viewFrames using renderOptions
     * @param {RenderOptions} renderOptions
    */
    function _updateViewFrames(renderOptions) {
        var newPaperOptions = renderOptions.paperOptions;
        var previousPaperOptions = _renderOptions.paperOptions || {};
        var viewFrameOptions = (0, _utils.arrayToMap)(renderOptions.viewFrames || []);

        var isScaleChanged = !previousPaperOptions.scale || previousPaperOptions.scale.x !== newPaperOptions.scale.x || previousPaperOptions.scale.y !== newPaperOptions.scale.y;
        var isPaperSizeChanged = previousPaperOptions.width !== newPaperOptions.width || previousPaperOptions.height !== newPaperOptions.height;
        var isOrientationChanged = previousPaperOptions.orientation !== newPaperOptions.orientation;

        var oldElementSize = (_renderOptions.elementOptions || {}).elementSize;
        var elementSize = renderOptions.elementOptions.elementSize;
        var isElementSizeChanged = elementSize && (!oldElementSize || elementSize.width !== oldElementSize.width || elementSize.height !== oldElementSize.height || elementSize.minWidth !== oldElementSize.minWidth || elementSize.minHeight !== oldElementSize.minHeight || elementSize.maxWidth !== oldElementSize.maxWidth || elementSize.maxHeight !== oldElementSize.maxHeight);

        var fullScreenModeChanged = renderOptions.fullScreenMode !== undefined && renderOptions.fullScreenMode !== _fullScreenMode;
        var viewFramesStateChanged = _updateViewFrameVisibility(viewFrameOptions) && !_fullScreenMode || fullScreenModeChanged;

        if (fullScreenModeChanged) {
            _fullScreenMode = renderOptions.fullScreenMode;
        }

        var paperOptionsChanged = renderOptions.updateBounds || isPaperSizeChanged || isOrientationChanged || isScaleChanged || viewFramesStateChanged;
        var resizeViewFrames = isPaperSizeChanged || isOrientationChanged || viewFramesStateChanged;

        if (isElementSizeChanged) {
            _setElementsSize(elementSize);
        }
        if (resizeViewFrames) {
            _resizeViewFrames(newPaperOptions);
        }
        if (isScaleChanged) {
            _scaleViewFrames(newPaperOptions.scale);
        }
        if (paperOptionsChanged || isElementSizeChanged || isScaleChanged) {
            _refreshViewFramesBounds();
        }

        _allFrames.forEach(function (viewFrame) {
            var recalculateVisibleElements = false;
            var newViewFrameData = viewFrameOptions[viewFrame.id];

            if (newViewFrameData) {
                var oldViewFrameData = _getViewFramePublicModel(viewFrame);

                var updateBounds = newViewFrameData.updateBounds;
                var portPositionChanged = newViewFrameData.viewPortPosition && (newViewFrameData.viewPortPosition.x !== oldViewFrameData.viewPortPosition.x || newViewFrameData.viewPortPosition.y !== oldViewFrameData.viewPortPosition.y);
                var sizeChanged = newViewFrameData.size && (newViewFrameData.size.width !== oldViewFrameData.size.width || newViewFrameData.size.height !== oldViewFrameData.size.height);
                var positionChanged = newViewFrameData.position && (newViewFrameData.position.x !== oldViewFrameData.position.x || newViewFrameData.position.y !== oldViewFrameData.position.y);

                if (sizeChanged && !resizeViewFrames) {
                    viewFrame.setSize(newViewFrameData.size, newViewFrameData.customeSized);
                    recalculateVisibleElements = true;
                }

                if (positionChanged && !resizeViewFrames) {
                    viewFrame.setPosition(newViewFrameData.position);
                }

                if (updateBounds || sizeChanged && !resizeViewFrames) {
                    viewFrame.updateBounds();
                    recalculateVisibleElements = true;
                }

                if (portPositionChanged && !resizeViewFrames) {
                    viewFrame.positionViewPort(newViewFrameData.viewPortPosition.x, newViewFrameData.viewPortPosition.y);
                    recalculateVisibleElements = true;
                }
            }
            var isExpanded = _state[viewFrame.id] || viewFrame === _overViewFrame && _fullScreenMode;
            var recalculateContent = isExpanded && (recalculateVisibleElements || paperOptionsChanged || isElementSizeChanged);
            if (recalculateContent) {
                viewFrame.calculateVisibleCells();
            }
        });

        _renderOptions = renderOptions;
    }

    /**
     * Updates state of viewFrames (visible/invisible)
     * @param {ViewFramePublicModel[]} viewFrameOptions
     */
    function _updateViewFrameVisibility(viewFrameOptions) {
        var atLeastOneVisibilityChanged = false;
        _viewFrames.forEach(function (viewFrame) {
            var newViewFrameData = viewFrameOptions[viewFrame.id];
            if (newViewFrameData && newViewFrameData.expanded !== undefined) {
                var visibilitiChanged = newViewFrameData.expanded !== _state[viewFrame.id];
                _state[viewFrame.id] = newViewFrameData.expanded;
                atLeastOneVisibilityChanged = atLeastOneVisibilityChanged || visibilitiChanged;
            }
        });
        return atLeastOneVisibilityChanged;
    }

    /**
     * Changes default element size for all ViewFrames
     * @param {ElementSize} elementSize 
     */
    function _setElementsSize(elementSize) {
        _allFrames.forEach(function (vf) {
            vf.setElementSize(elementSize);
        });
    }

    /**
     * Recalculates bounds for all ViewFrames
     * and allign ViewFrames
    */
    function _refreshViewFramesBounds() {
        _allFrames.forEach(function (vf) {
            vf.updateBounds();
            vf.positionViewPort();
        });
    }

    /**
     * Sets and limits value of the scale for the graph.
     * @param {number} scale
     */
    function _scaleViewFrames(scale) {
        if (scale) {
            _allFrames.forEach(function (vf) {
                var oldScale = vf.getScale();
                var pos = vf.positionViewPort();

                vf.setScale(scale);
                var newScale = vf.getScale(); // overViewFrame changes scale before apply

                var scaledSize = vf.get('size');
                var oldSize = (0, _utils.scaledToGlobalSize)(scaledSize, oldScale);
                var newSize = (0, _utils.scaledToGlobalSize)(scaledSize, newScale);

                var curCenter = {
                    x: pos.x + oldSize.width / 2,
                    y: pos.y + oldSize.height / 2
                };

                vf.positionViewPort(curCenter.x - newSize.width / 2, curCenter.y - newSize.height / 2);
            });
        }
    }

    /**
     * Refresh ViewFrames:
     * Adjust viewFrames size to a paper
     * @param {boolean} updateScale
     */
    function _resizeViewFrames(options) {
        var visibleFrames = _getVisibleViewFrames();
        var vfNumber = visibleFrames.length;
        var isHorizontalOrientated = options.orientation === 'left-to-right' || options.orientation === 'right-to-left';

        if (options.width === 0 || options.height === 0 || vfNumber <= 0) return;
        var totalShare = 0;
        visibleFrames.forEach(function (vf) {
            totalShare += vf.model.spaceShare;
        });

        var width = options.width - FRAME_OUT_MARGIN * 2;
        var height = options.height - FRAME_OUT_MARGIN * 2;

        var cutedWidth = width - DISTANCE_BETWEEN_FRAMES * (vfNumber - 1);
        var cutedHeight = height - DISTANCE_BETWEEN_FRAMES * (vfNumber - 1);

        var segmentWidth = cutedWidth / totalShare;
        var segmentHeight = cutedHeight / totalShare;

        var scale = 1;
        var length = 0;
        var freeLength = 0;
        visibleFrames.forEach(function (viewFrame) {
            if (isHorizontalOrientated) {
                if (viewFrame.model.width) {
                    length += viewFrame.model.width;
                } else {
                    freeLength += segmentWidth * (viewFrame.model.spaceShare || 1);
                }
            } else {
                if (viewFrame.model.height) {
                    length += viewFrame.model.height;
                } else {
                    freeLength += segmentHeight * (viewFrame.model.spaceShare || 1);
                }
            }
        });

        if (isHorizontalOrientated) {
            scale = (cutedWidth - freeLength) / length;
        } else {
            scale = (cutedHeight - freeLength) / length;
        }

        var curPoint = { x: FRAME_OUT_MARGIN, y: FRAME_OUT_MARGIN };

        if (options.orientation === 'top-to-bottom') {

            visibleFrames.forEach(function (vf) {
                if (vf.model.width) vf.model.width = undefined;
                if (vf.model.height) vf.model.height *= scale;

                var MINIMAL_VF_SIZE = { width: 1, height: 1 };
                var size = {
                    width: Math.max(width, MINIMAL_VF_SIZE.width),
                    height: Math.max(vf.model.height ? vf.model.height : segmentHeight * (vf.model.spaceShare || 1), MINIMAL_VF_SIZE.height)
                };

                vf.setPosition(curPoint);
                vf.setSize(size);

                curPoint = { x: FRAME_OUT_MARGIN, y: curPoint.y + size.height + DISTANCE_BETWEEN_FRAMES };
            });
        } else if (options.orientation === 'bottom-to-top') {

            for (var i = visibleFrames.length - 1; i >= 0; i--) {
                var vf = visibleFrames[i];

                if (vf.model.width) vf.model.width = undefined;
                if (vf.model.height) vf.model.height *= scale;

                var size = {
                    width: width,
                    height: vf.model.height ? vf.model.height : segmentHeight * (vf.model.spaceShare || 1)
                };

                vf.setPosition(curPoint);
                vf.setSize(size);

                curPoint = { x: FRAME_OUT_MARGIN, y: curPoint.y + size.height + DISTANCE_BETWEEN_FRAMES };
            }
        } else if (options.orientation === 'right-to-left') {

            for (var _i = visibleFrames.length - 1; _i >= 0; _i--) {
                var _vf = visibleFrames[_i];

                if (_vf.model.width) _vf.model.width *= scale;
                if (_vf.model.height) _vf.model.height = undefined;

                var _size = {
                    width: _vf.model.width ? _vf.model.width : segmentWidth * (_vf.model.spaceShare || 1),
                    height: height
                };

                _vf.setPosition(curPoint);
                _vf.setSize(_size);

                curPoint = { x: curPoint.x + _size.width + DISTANCE_BETWEEN_FRAMES, y: FRAME_OUT_MARGIN };
            }
        } else {
            // horizontal

            visibleFrames.forEach(function (vf) {
                if (vf.model.width) vf.model.width *= scale;
                if (vf.model.height) vf.model.height = undefined;

                var size = {
                    width: vf.model.width ? vf.model.width : segmentWidth * (vf.model.spaceShare || 1),
                    height: height
                };

                vf.setPosition(curPoint);
                vf.setSize(size);

                curPoint = { x: curPoint.x + size.width + DISTANCE_BETWEEN_FRAMES, y: FRAME_OUT_MARGIN };
            });
        }

        visibleFrames.forEach(function (viewFrame) {
            viewFrame.updateBounds();
            // We want not to be in the empty space after resizing but somwhere near the nodes.
            var viewPortPositionBounds = viewFrame.getViewPortPositionBounds();
            var visibleCells = viewFrame.getVisibleCells();
            if (!visibleCells || visibleCells.nodes.length === 0) {
                var nodes = viewFrame.getNodes();
                if (nodes.length > 0) {
                    var nodeToFocus = nodes[Math.round(Math.random() * (nodes.length - 1))];
                    var nodeScaledPos = (0, _utils.getScaledNodePosition)(nodeToFocus, options.scale);
                    var newPosition = {
                        x: nodeScaledPos.x - (viewFrame.size.width - nodeToFocus.size.width) / 2,
                        y: nodeScaledPos.y - (viewFrame.size.height - nodeToFocus.size.height) / 2
                    };
                    var _limitedPoint = (0, _utils.limitPointPosition)(newPosition, viewPortPositionBounds);
                    viewFrame.positionViewPort(_limitedPoint.x, _limitedPoint.y);
                }
            }
            var limitedPoint = (0, _utils.limitPointPosition)(viewFrame.positionViewPort(), viewPortPositionBounds);
            viewFrame.positionViewPort(limitedPoint.x, limitedPoint.y);
        });
    }

    /**
     * Get data (Cells) from ViewFrames,
     * processes it (add termination and aspect elements)
     * and returns to the render pipline
     * @returns {(Link|Node|TerminationNode|TerminationLink|AspectLink)[]}
     */
    function _calculateRenderData(viewFrameResults, renderOptions) {
        var nodes = [];
        var links = [];
        var badLinks = [];
        var visibleNodeMap = {};

        viewFrameResults.forEach(function (result) {
            return result.nodes.forEach(function (node) {
                visibleNodeMap[node.id] = node;
                nodes.push(node);
            });
        });

        viewFrameResults.forEach(function (result) {
            return result.links.forEach(function (link) {
                if (visibleNodeMap[link.model.source] && visibleNodeMap[link.model.target]) {
                    if (!renderOptions.quickUpdate) links.push(link);
                } else if (visibleNodeMap[link.model.source] || visibleNodeMap[link.model.target]) {
                    badLinks.push(link);
                }
            });
        });

        var terminationCellMap = {};
        var terminationNodes = [];
        var terminationLinks = [];
        if (renderOptions.selectedElement) {
            var selectedNodes = _getSelectedNodes(renderOptions.selectedElement);
            selectedNodes.forEach(function (selectedNode) {
                var terminationOrigins = _getTerminationOrigins(selectedNode, visibleNodeMap, badLinks);
                var viewFrame = _getViewFrameForNode(selectedNode);

                if (viewFrame && (_state[viewFrame.id] || _fullScreenMode)) {
                    terminationOrigins.nodes.forEach(function (node) {
                        var nodeCacheId = node.id + '_at_' + viewFrame.id;
                        var terminationNode = _terminationCellCache[nodeCacheId];
                        if (terminationNode) {
                            terminationNode.set('dragged', false);
                        } else {
                            terminationNode = new _elements.TerminationNode({
                                node: node
                            }, parameters);
                        }
                        terminationCellMap[nodeCacheId] = terminationNode;
                        var position = _getTerminationNodePosition(terminationNode, viewFrame, renderOptions);
                        terminationNode.position(position.x, position.y);
                        terminationNodes.push(terminationNode);
                    });
                    if (!renderOptions.quickUpdate) {
                        terminationOrigins.links.forEach(function (link) {
                            var linkCacheId = link.id + '_at_' + viewFrame.id;
                            var sourceCacheId = link.model.source + '_at_' + viewFrame.id;
                            var targetCacheId = link.model.target + '_at_' + viewFrame.id;
                            var terminationLink = _terminationCellCache[linkCacheId] || new _elements.TerminationLink({
                                link: link,
                                source: terminationCellMap[sourceCacheId] || visibleNodeMap[link.model.source],
                                target: terminationCellMap[targetCacheId] || visibleNodeMap[link.model.target]
                            }, parameters);
                            terminationCellMap[linkCacheId] = terminationLink;
                            terminationLinks.push(terminationLink);
                        });
                    }
                }
            });

            var link = renderOptions.selectedElement;
            var addTerminationLinks = link instanceof _elements.Link && (!(visibleNodeMap[link.model.source] || visibleNodeMap[link.model.target]) || renderOptions.quickUpdate);
            if (addTerminationLinks) {
                var nodeMap = _dataContainer.maps.nodeMap;

                var sourceViewFrame = _getViewFrameForNode(nodeMap[link.model.source]);
                var targetViewFrame = _getViewFrameForNode(nodeMap[link.model.target]);

                if (sourceViewFrame && targetViewFrame) {
                    var sourceViewFrameId = sourceViewFrame.id;
                    var targetViewFrameId = targetViewFrame.id;

                    var sourceCacheId = link.model.source + '_at_' + sourceViewFrameId;
                    var targetCacheId = link.model.target + '_at_' + targetViewFrameId;

                    var source = terminationCellMap[sourceCacheId] || visibleNodeMap[link.model.source];
                    var target = terminationCellMap[targetCacheId] || visibleNodeMap[link.model.target];

                    var linkCacheId = source.id + '~#~' + target.id;
                    var terminationLink = _terminationCellCache[linkCacheId] || new _elements.TerminationLink({
                        link: link,
                        source: source,
                        target: target
                    }, parameters);
                    terminationCellMap[linkCacheId] = terminationLink;
                    terminationLinks.push(terminationLink);
                }
            }
        }
        _terminationCellCache = terminationCellMap;

        var visibleNodes = nodes.concat(terminationNodes);
        var aspectLinks = renderOptions.quickUpdate ? [] : _calculateAspectLinks(visibleNodes);
        var visibleLinks = links.concat(terminationLinks).concat(aspectLinks);

        return visibleNodes.concat(visibleLinks);
    }

    /**
     * If the Link is selected then we represent
     * it as two selected nodes
     * @param {Node|Link} selectedElement
     * @returns {Node[]}
     */
    function _getSelectedNodes(selectedElement) {
        var nodeMap = _dataContainer.maps.nodeMap;
        var isNode = selectedElement instanceof _elements.Node;
        return isNode ? [selectedElement] : [nodeMap[selectedElement.model.source], nodeMap[selectedElement.model.target]];
    }

    /**
     * If the Link is selected then we represent
     * it as two selected nodes
     * @param {Node} selectedNode
     * @param {Object.<string, Node>} visibleNodeMap - Visible nodes
     * @param {Link[]} badLinks - Links which have either source either target is not visible
     * @returns {Node[], Link[]}
     */
    function _getTerminationOrigins(selectedNode, visibleNodeMap, badLinks) {
        var terminationOriginNodes = [];
        var terminationOriginLinks = [];
        var processedCellIds = {};
        var nodeMap = _dataContainer.maps.nodeMap;

        var isSelectedNodeVisible = visibleNodeMap[selectedNode.id];
        if (isSelectedNodeVisible) {
            badLinks.forEach(function (link) {
                if (!processedCellIds[link.id]) {
                    processedCellIds[link.id] = true;
                    var isLinkConnectedToSelectedNode = link.model.source === selectedNode.id || link.model.target === selectedNode.id;
                    var terminationsHaveViewFrames = link.model.source === selectedNode.id ? _getViewFrameForNode(nodeMap[link.model.target]) : _getViewFrameForNode(nodeMap[link.model.source]);
                    if (isLinkConnectedToSelectedNode && terminationsHaveViewFrames) {
                        terminationOriginLinks.push(link);

                        var sourceIsntVisible = !visibleNodeMap[link.model.source];
                        if (sourceIsntVisible && !processedCellIds[link.model.source]) {
                            processedCellIds[link.model.source] = true;
                            terminationOriginNodes.push(nodeMap[link.model.source]);
                        }

                        var targetIsntVisible = !visibleNodeMap[link.model.target];
                        if (targetIsntVisible && !processedCellIds[link.model.target]) {
                            processedCellIds[link.model.target] = true;
                            terminationOriginNodes.push(nodeMap[link.model.target]);
                        }
                    }
                }
            });
        } else {
            terminationOriginNodes.push(selectedNode);
            badLinks.forEach(function (link) {
                if (!processedCellIds[link.id]) {
                    processedCellIds[link.id] = true;
                    var isLinkConnectedToSelectedNode = link.model.source === selectedNode.id || link.model.target === selectedNode.id;
                    if (isLinkConnectedToSelectedNode) {
                        terminationOriginLinks.push(link);
                    }
                }
            });
        }

        return {
            nodes: terminationOriginNodes,
            links: terminationOriginLinks
        };
    }

    /**
     * Returns position for the termination node.
     * @param {TerminationNode} terminationNode
     * @param {ViewFrame} viewFrame
     * @param {RenderOption} renderOptions
     * @returns {Point}
    */
    function _getTerminationNodePosition(terminationNode, viewFrame, renderOptions) {
        var originalNode = terminationNode.originalNode;
        var viewFrameSize = viewFrame.size; // local size
        var viewFramePosition = viewFrame.position(); // local position
        var nodeSize = originalNode.size; // local size

        var topLeft = viewFramePosition;
        var topRight = { x: viewFramePosition.x + viewFrameSize.width, y: viewFramePosition.y };
        var bottomLeft = { x: viewFramePosition.x, y: viewFramePosition.y + viewFrameSize.height };
        var bottomRight = { x: viewFramePosition.x + viewFrameSize.width, y: viewFramePosition.y + viewFrameSize.height };

        var calculationPoints = getCalculationPoints();
        var sourcePoint = calculationPoints.sourcePoint;
        var terminationPoint = calculationPoints.terminationPoint;

        // choose a side for termination node

        var crossPoint = (0, _lineageDiagramUtils.getCrosPoint)(sourcePoint, terminationPoint, topLeft, bottomLeft); // left

        if (!crossPoint) {
            crossPoint = (0, _lineageDiagramUtils.getCrosPoint)(sourcePoint, terminationPoint, topLeft, topRight); // top
        }
        if (!crossPoint) {
            crossPoint = (0, _lineageDiagramUtils.getCrosPoint)(sourcePoint, terminationPoint, topRight, bottomRight); // right
        }
        if (!crossPoint) {
            crossPoint = (0, _lineageDiagramUtils.getCrosPoint)(sourcePoint, terminationPoint, bottomLeft, bottomRight); // bottom
        }

        if (crossPoint) {
            return {
                x: crossPoint.x - _terminationNodeSize.width / 2,
                y: crossPoint.y - _terminationNodeSize.height / 2
            };
        } else {
            return {
                x: Math.min(Math.max(terminationPoint.x + nodeSize.width / 2, viewFramePosition.x), viewFramePosition.x + viewFrameSize.width),
                y: Math.min(Math.max(terminationPoint.y + nodeSize.height / 2, viewFramePosition.y), viewFramePosition.y + viewFrameSize.height)
            };
        }

        function getCalculationPoints() {
            var sourcePoint = {
                x: viewFramePosition.x + viewFrameSize.width / 2,
                y: viewFramePosition.y + viewFrameSize.height / 2
            };

            var ownerViewFrame = _getViewFrameForNode(originalNode);
            var nodePosition = (0, _utils.getLocalNodePosition)(originalNode, renderOptions.paperOptions.scale, ownerViewFrame);
            var terminationPoint = {
                x: nodePosition.x + nodeSize.width / 2,
                y: nodePosition.y + nodeSize.height / 2
            };

            var pointIsInTheFrame = viewFrame.hitScaledPointTest(terminationPoint);
            if (pointIsInTheFrame) {
                var distToLeft = terminationPoint.x - viewFramePosition.x;
                var distToTop = terminationPoint.y - viewFramePosition.y;
                var distToRight = viewFramePosition.x + viewFrameSize.width - terminationPoint.x;
                var distToBottom = viewFramePosition.y + viewFrameSize.height - terminationPoint.y;

                var min = Infinity;
                [distToLeft, distToTop, distToRight, distToBottom].forEach(function (dist) {
                    min = Math.min(min, dist);
                });

                if (min === distToLeft) {
                    terminationPoint.x -= min;
                } else if (min === distToRight) {
                    terminationPoint.x += min;
                } else if (min === distToTop) {
                    terminationPoint.y -= min;
                } else {
                    terminationPoint.y += min;
                }
            }

            // Sometime it's confusing for users when
            // nodes are in the leftViewFrame but termination nodes goes to the right
            if (ownerViewFrame.id !== viewFrame.id) {
                var ids = _allFrames.map(function (vf) {
                    return vf.id;
                });
                var viewFrameIndex = ids.indexOf(viewFrame.id);
                var ownerViewFrameIndex = ids.indexOf(ownerViewFrame.id);
                var orientation = renderOptions.paperOptions.orientation;
                var isHorizontalOrientated = orientation === 'left-to-right' || orientation === 'right-to-left';
                if (viewFrameIndex < ownerViewFrameIndex) {
                    if (isHorizontalOrientated) {
                        terminationPoint.x = bottomRight.x;
                    } else {
                        terminationPoint.y = bottomRight.y;
                    }
                } else {
                    if (isHorizontalOrientated) {
                        terminationPoint.x = topLeft.x;
                    } else {
                        terminationPoint.y = topLeft.y;
                    }
                }
            }

            return {
                sourcePoint: sourcePoint,
                terminationPoint: terminationPoint
            };
        }
    }

    /**
     * Creates (or get from cache) aspect links
     * @param {Node[]} nodes - visible nodes
     * @returns {AspectLink[]}
    */
    function _calculateAspectLinks(nodes) {
        var aspectLinksCache = {};
        var nodeMap = (0, _utils.arrayToMap)(nodes);
        nodes.forEach(function (node) {
            var aspects = (0, _dataUtils.getBaseElement)(node).aspects;
            aspects.forEach(function (aspect) {
                var visibleTerminations = aspect.terminationNodes.filter(function (tn) {
                    return nodeMap[tn.id];
                });
                var atLeastOneTermination = visibleTerminations.length > 0;
                var aspectWillOnThePaper = nodeMap[aspect.id] || atLeastOneTermination;
                var viewFrameOwner = _getViewFrameForNode(aspect);
                var viewFrameOwnerIsVisible = _state[viewFrameOwner.id] || _fullScreenMode;
                if (aspectWillOnThePaper && viewFrameOwnerIsVisible) {
                    var aspectInstances = nodeMap[aspect.id] ? [aspect] : visibleTerminations;

                    aspectInstances.forEach(function (aspectInstance) {
                        var cachedLink = getFromCahe(node, aspectInstance);
                        var aspectLink = cachedLink || createAspectLink(node, aspectInstance);

                        aspectLinksCache[aspectLink.id] = aspectLink;
                    });
                }
            });
        });
        _aspectLinksCahe = aspectLinksCache;
        var aspectLinks = Object.keys(aspectLinksCache).map(function (id) {
            return _aspectLinksCahe[id];
        });
        return aspectLinks;

        function createAspectLink(node, aspect) {
            var id = node.id + '~#~' + aspect.id;

            return new _elements.AspectLink({
                id: id,
                source: node,
                target: aspect
            }, parameters);
        }

        function getFromCahe(node, aspect) {
            var id = node.id + '~#~' + aspect.id;
            var reverseId = aspect.id + '~#~' + node.id;

            var linkFromLocal = aspectLinksCache[id] || aspectLinksCache[reverseId];
            var linkFromGlobal = _aspectLinksCahe[id] || _aspectLinksCahe[reverseId];
            return linkFromLocal || linkFromGlobal;
        }
    }

    /**
     * Changes highlighting of the elements
     * @param {(Node|Link|TerminationNode|TerminationLink)[]} cells
     * @param {RenderOption} renderOptions
    */
    function _setHighlighting(cells, renderOptions) {
        var path = renderOptions.path;
        var mask = renderOptions.mask;

        cells.forEach(function (cell) {
            var baseCell = (0, _dataUtils.getBaseElement)(cell);
            if (mask && baseCell !== renderOptions.selectedElement) {
                if (mask[baseCell.id]) {
                    baseCell.hide();
                } else {
                    baseCell.show();
                }
            }
            if (baseCell === renderOptions.selectedElement) {
                baseCell.select();
            } else if (path && !path[baseCell.id]) {
                baseCell.blure();
            } else {
                baseCell.unblure();
            }
        });
    }

    /**
     * Returns list of visible viewFrames
     * @returns {ViewFrame[]}
    */
    function _getVisibleViewFrames() {
        return _fullScreenMode ? [_overViewFrame] : _viewFrames.filter(function (vf) {
            return _state[vf.id];
        });
    }

    /**
     * Returns viewFrame for the node.
     * @param {Node} node
     * @returns {ViewFrame | undefined}
     */
    function _getViewFrameForNode(node) {
        if (_fullScreenMode) {
            return _overViewFrame;
        } else {
            var viewFrameId = (0, _lineageDiagramUtils.getViewFrameIdForNode)(node);
            return _viewFramesMap[viewFrameId];
        }
    }

    /**
     * Subscribes on viewFrame events
    */
    function _subscribeOnViewFrameEvents() {
        _allFrames.forEach(function (viewFrame) {
            viewFrame.on('change-view-port-position', function (newViewPortPosition) {
                if (viewFrame.movingByItself) return;

                var viewFramePublicModel = _getViewFramePublicModel(viewFrame);
                viewFramePublicModel.viewPortPosition = newViewPortPosition;

                self.trigger('change-view-port-position', viewFramePublicModel);
            });
        });
    }
}

exports.default = ViewManager;

},{"../subscriptionAPI/subscribeable":65,"../utils/dataUtils":66,"../utils/lineageDiagramUtils":68,"../utils/utils":69,"./graphElements/elements":46,"./viewFrame":54,"lodash":"lodash"}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.combineOperation = combineOperation;
exports.doLayout = doLayout;
exports.removeCycles = removeCycles;

var _webcola = require('webcola');

var cola = _interopRequireWildcard(_webcola);

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _sankey = require('./sankey');

var _sankey2 = _interopRequireDefault(_sankey);

var _utils = require('../utils/utils');

var _layoutUtils = require('../utils/layoutUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * @param {{
 *  selectedNode: Node,
 *  relativeLinks: Link[],
 *  relativeNodes: Node[],
 * }} options 
 * @param {Parameters} parameters - parameters set
 */
function combineOperation(options, parameters) {
    var scale = options.scale;

    var startPosition = (0, _utils.getGlobalNodePosition)(options.selectedNode);
    var combinedNodes = [options.selectedNode].concat(options.relativeNodes);

    var elements = (0, _layoutUtils.convertLGElementsToLayoutModels)(combinedNodes, options.relativeLinks, {
        scale: scale
    });
    var nodes = elements.nodes;
    var links = elements.links;
    var selectedLayoutNode = nodes[0];

    var layoutOptions = {
        nodes: nodes,
        links: links,
        step: parameters.layoutStep,
        element: parameters.elementSize,
        iterations: parameters.layoutIterations
    };
    tqForceLayout(layoutOptions);

    var result = {};
    nodes.forEach(function (layoutNode) {
        if (layoutNode !== selectedLayoutNode) {
            layoutNode.x = startPosition.x + (layoutNode.x - selectedLayoutNode.x);
            layoutNode.y = startPosition.y + (layoutNode.y - selectedLayoutNode.y);
        }
        result[layoutNode.originalNode.id] = {
            x: layoutNode.x,
            y: layoutNode.y
        };
    });

    return result;
}

/**
 * @private 
 * 
 * Calculates positions for nodes.
 * @param {Array} nodeModels - list of the native nodes
 * @param {Array} nativeLinks - list of the native links
 * @param {Parameters} parameters - parameters set
 */
function doLayout(nodeModels, linkModels, viewFrames, parameters) {
    if (!parameters) return;

    var elements = (0, _layoutUtils.convertNativeToLayoutModels)(nodeModels, linkModels, parameters);
    var nodes = elements.nodes;
    var links = elements.links;
    var isHorizontal = parameters.graphOrientation === 'right-to-left' || parameters.graphOrientation === 'left-to-right';

    removeCycles(nodes, links);

    var groups = breakByGroups(nodes, links, viewFrames, parameters);

    var layoutOptions = {
        groups: groups,
        nodes: nodes,
        links: links,
        isHorizontal: isHorizontal,
        step: parameters.layoutStep,
        element: parameters.elementSize,
        iterations: parameters.layoutIterations
    };

    if (parameters.layoutAlgorithm === 'flow-directed') {
        tqFlowLayout(layoutOptions);
    } else {
        tqSankeyLayout(layoutOptions);
    }
    applyLayout();

    function applyLayout() {
        // Calculating min points
        var minX = Infinity,
            minY = Infinity;
        nodes.forEach(function (node) {
            minX = Math.min(minX, node.x);
            minY = Math.min(minY, node.y);
        });

        var maxX = nodes.length > 0 ? -Infinity : 0;
        var canvasPadding = Math.max(parameters.elementSize.width, parameters.elementSize.height) * 2 * parameters.scaleBounds.max;
        nodes.forEach(function (node) {
            node.originalNode.position.x = node.x - minX + canvasPadding;
            node.originalNode.position.y = node.y - minY + canvasPadding;
            maxX = Math.max(maxX, node.originalNode.position.x);
        });

        if (parameters.graphOrientation === 'right-to-left' || parameters.graphOrientation === 'bottom-to-top') {
            nodeModels.forEach(function (node) {
                node.position.x = maxX - node.position.x;
            });
        }

        if (!isHorizontal) {
            nodeModels.forEach(function (node) {
                var x = node.position.x;
                node.position.x = node.position.y;
                node.position.y = x;
            });
        }

        nodeModels.forEach(function (node) {
            node.defaultPosition = _.clone(node.position);
        });
    }
}

function removeCycles(nodes, links) {
    nodes.forEach(function (n) {
        var repeatMap = {};
        var linksToRemove = [];

        recursion(n);

        linksToRemove.forEach(function (link) {
            links.splice(links.indexOf(link), 1);
            link.target.sourceLinks.splice(link.target.sourceLinks.indexOf(link), 1);
            link.source.targetLinks.splice(link.source.targetLinks.indexOf(link), 1);
        });

        function recursion(node) {
            repeatMap[node.id] = true;
            node.targetLinks.forEach(function (link) {
                if (!repeatMap[link.target.id]) {
                    recursion(link.target);
                } else {
                    linksToRemove.push(link);
                }
            });
            repeatMap[node.id] = false;
        }
    });
}

function breakByGroups(nodes, links, viewFrames, parameters) {
    var nodeMap = (0, _utils.arrayToMap)(nodes);
    var groups = {};
    var paperSize = (0, _utils.getElementSize)(parameters.graphPlace);
    var isHorizontal = parameters.graphOrientation === 'left-to-right' || parameters.graphOrientation === 'right-to-left';
    var totalShare = viewFrames.reduce(function (accumulator, viewFrame) {
        return accumulator + viewFrame.spaceShare;
    }, 0);
    viewFrames.forEach(function (viewFrame) {
        if (!groups[viewFrame.id]) groups[viewFrame.id] = {
            id: viewFrame.id,
            prefferedSize: {
                width: isHorizontal ? paperSize.width / totalShare * viewFrame.spaceShare : paperSize.height / totalShare * viewFrame.spaceShare,
                height: isHorizontal ? paperSize.height : paperSize.width
            },
            nodes: [],
            links: []
        };

        var lastNodes = [];
        nodes.forEach(function (node) {
            if (node.viewFrame === viewFrame.id) {
                groups[viewFrame.id].nodes.push(node);
            } else {
                lastNodes.push(node);
            }
        });
        nodes = lastNodes;

        var lastLinks = [];
        links.forEach(function (l) {
            if (nodeMap[l.source.id].viewFrame === viewFrame.id && nodeMap[l.target.id].viewFrame === viewFrame.id) {
                groups[viewFrame.id].links.push(l);
            } else if (nodeMap[l.source.id].viewFrame !== viewFrame.id && nodeMap[l.target.id].viewFrame !== viewFrame.id) {
                lastLinks.push(l);
            }
        });
        links = lastLinks;
    });
    groups['unknown'] = { id: 'unknown', nodes: nodes, links: links };
    return Object.keys(groups).map(function (key) {
        return groups[key];
    });
}

function tqSankeyLayout(options) {
    var step = options.isHorizontal ? [options.step.x || 100, options.step.y || 15] : [options.step.y || 15, options.step.x || 100];
    options.step = options.step || {};
    (0, _sankey2.default)().step(step).nodeWidth(options.element.width).nodeHeight(options.element.height).nodes(options.nodes).links(options.links).groups(options.groups).layout(options.iterations);
}

function tqFlowLayout(options) {
    tqSankeyLayout(options);

    var layout = new cola.Layout().nodes(options.nodes).links(options.links).convergenceThreshold(1e-9).jaccardLinkLengths(options.step.x * 2 || 400).flowLayout('x', options.step.x * 2 || 400).avoidOverlaps(true).handleDisconnected(true);
    layout.start(100, 0, 50, undefined, false);
}

function tqForceLayout(options) {
    var layout = new cola.Layout().nodes(options.nodes).links(options.links).convergenceThreshold(1e-9).jaccardLinkLengths(options.step.x * 1.5 || 350).avoidOverlaps(true).handleDisconnected(true);
    layout.start(100, 0, 50, undefined, false);
}

},{"../utils/layoutUtils":67,"../utils/utils":69,"./sankey":57,"lodash":"lodash","webcola":6}],57:[function(require,module,exports){
'use strict';

var _layoutUtils = require('../utils/layoutUtils');

var utils = _interopRequireWildcard(_layoutUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var Sankey = function Sankey() {
    var sankey = {},
        nodeWidth = 24,
        nodeHeight = 8,
        size = [1, 1],
        step = [100, 30],
        nodes = [],
        groups = [],
        links = [];

    sankey.nodeWidth = function (_) {
        if (!arguments.length) return nodeWidth;
        nodeWidth = +_;
        return sankey;
    };

    sankey.nodeHeight = function (_) {
        if (!arguments.length) return nodeHeight;
        nodeHeight = +_;
        return sankey;
    };

    sankey.nodes = function (_) {
        if (!arguments.length) return nodes;
        nodes = _;
        return sankey;
    };

    sankey.groups = function (_) {
        if (!arguments.length) return groups;
        groups = _;
        return sankey;
    };

    sankey.links = function (_) {
        if (!arguments.length) return links;
        links = _;
        return sankey;
    };

    sankey.step = function (_) {
        if (!arguments.length) return step;
        step = _;
        return sankey;
    };

    sankey.layout = function (iterations) {
        computeNodeLinks();
        computeNodeValues();
        computeNodeBreadths();
        computeNodeDepths(iterations);
        computeLinkDepths();
        return sankey;
    };

    sankey.relayout = function () {
        computeLinkDepths();
        return sankey;
    };

    sankey.link = function () {
        var curvature = .5;

        function link(d) {
            var x0 = d.source.x + d.source.dx,
                x1 = d.target.x,
                xi = utils.interpolateNumber(x0, x1),
                x2 = xi(curvature),
                x3 = xi(1 - curvature),
                y0 = d.source.y + d.sy + d.dy / 2,
                y1 = d.target.y + d.ty + d.dy / 2;
            return 'M' + x0 + ',' + y0 + 'C' + x2 + ',' + y0 + ' ' + x3 + ',' + y1 + ' ' + x1 + ',' + y1;
        }

        link.curvature = function (_) {
            if (!arguments.length) return curvature;
            curvature = +_;
            return link;
        };

        return link;
    };

    // Populate the sourceLinks and targetLinks for each node.
    // Also, if the source and target are not objects, assume they are indices.
    function computeNodeLinks() {
        nodes.forEach(function (node) {
            node.sourceLinks = [];
            node.targetLinks = [];
        });
        links.forEach(function (link) {
            var source = link.source,
                target = link.target;
            if (typeof source === 'number') source = link.source = nodes[link.source];
            if (typeof target === 'number') target = link.target = nodes[link.target];
            source.sourceLinks.push(link);
            target.targetLinks.push(link);
        });
    }

    // Compute the value (size) of each node by summing the associated links.
    function computeNodeValues() {
        nodes.forEach(function (node) {
            node.value = Math.max(utils.sum(node.sourceLinks, value), utils.sum(node.targetLinks, value)) || 1;
        });
    }

    // Iteratively assign the breadth (x-position) for each node.
    // Nodes are assigned the maximum breadth of incoming neighbors plus one;
    // nodes with no incoming links are assigned breadth zero, while
    // nodes with no outgoing links are assigned the maximum breadth.
    function computeNodeBreadths() {
        groups.forEach(function (group) {
            var remainingNodes = group.nodes;
            var nextNodes = void 0;

            remainingNodes.sort(function (n1, n2) {
                var result = getLinks(n2.targetLinks).length - getLinks(n1.targetLinks).length;
                if (result === 0) {
                    return getLinks(n2.sourceLinks).length - getLinks(n1.sourceLinks).length;
                } else {
                    return result;
                }
            });

            var x = 0;
            var startX = x;
            while (remainingNodes.length > 0) {
                nextNodes = [];
                remainingNodes.forEach(function (node) {
                    node.x = x;
                    node.dx = nodeWidth;

                    getLinks(node.sourceLinks).forEach(function (link) {
                        if (nextNodes.indexOf(link.target) < 0) {
                            nextNodes.push(link.target);
                        }
                    });
                });
                remainingNodes = nextNodes;
                ++x;
            }
            group.breadth = x - startX;

            function getLinks(links) {
                return links.filter(function (l) {
                    return group.links.indexOf(l) !== -1;
                });
            }
        });

        // let maxK = 1;
        // groups.forEach(group => {
        //     if (group.prefferedSize) {
        //         maxK = Math.max(maxK, calculateGroupWidth(group) / group.prefferedSize.width);
        //     }
        // });

        var curXPosition = 0;
        groups.forEach(function (group) {
            var groupSize = calculateGroupWidth(group);

            if (group.prefferedSize && group.breadth > 1) {
                groupSize = Math.max(groupSize, group.prefferedSize.width /* * maxK */);
            }
            var kx = group.breadth > 1 ? groupSize / (group.breadth - 1) : 0;
            group.nodes.forEach(function (node) {
                node.x = curXPosition + node.x * kx;
            });
            curXPosition += groupSize + step[0] + nodeWidth;
        });

        function calculateGroupWidth(group) {
            return (group.breadth - 1) * (step[0] + nodeWidth);
        }
    }

    // function scaleNodeBreadths (nodes, kx) {
    //     nodes.forEach(function (node) {
    //         node.x *= kx;
    //     });
    // }

    function computeHeight(nodesByBreadth) {
        var maxColumnHeight = 0;
        nodesByBreadth.forEach(function (nodes) {
            maxColumnHeight = Math.max(maxColumnHeight, nodes.length);
        });
        size[1] = maxColumnHeight * nodeHeight + (maxColumnHeight - 1) * step[1];
    }

    function computeNodeDepths(iterations) {
        var nodesByBreadth = utils.nest().key(function (d) {
            return d.x;
        }).sortKeys(function (a, b) {
            return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
        }).entries(nodes).map(function (d) {
            return d.values;
        });

        computeHeight(nodesByBreadth);

        initializeNodeDepth();
        resolveCollisions();
        for (var alpha = 1; iterations > 0; --iterations) {
            relaxRightToLeft(alpha *= .99);
            resolveCollisions();
            relaxLeftToRight(alpha);
            resolveCollisions();
        }
        floorToModule();

        function initializeNodeDepth() {
            var ky = utils.min(nodesByBreadth, function (nodes) {
                return (size[1] - (nodes.length - 1) * nodeHeight) / utils.sum(nodes, value);
            });

            nodesByBreadth.forEach(function (nodes) {
                nodes.forEach(function (node, i) {
                    node.y = i;
                    node.dy = node.value * ky;
                });
            });

            links.forEach(function (link) {
                link.dy = link.value * ky;
            });
        }

        function relaxLeftToRight(alpha) {
            nodesByBreadth.forEach(function (nodes) {
                nodes.forEach(function (node) {
                    if (node.targetLinks.length) {
                        var y = utils.sum(node.targetLinks, weightedSource) / utils.sum(node.targetLinks, value);
                        node.y += (y - center(node)) * alpha;
                    }
                });
            });

            function weightedSource(link) {
                return center(link.source) * link.value;
            }
        }

        function relaxRightToLeft(alpha) {
            nodesByBreadth.slice().reverse().forEach(function (nodes) {
                nodes.forEach(function (node) {
                    if (node.sourceLinks.length) {
                        var y = utils.sum(node.sourceLinks, weightedTarget) / utils.sum(node.sourceLinks, value);
                        node.y += (y - center(node)) * alpha;
                    }
                });
            });

            function weightedTarget(link) {
                return center(link.target) * link.value;
            }
        }

        function floorToModule() {
            nodesByBreadth.forEach(function (nodes) {
                var placeMap = {};
                nodes.forEach(function (node) {
                    var fullStep = step[1] + nodeHeight;
                    var y = node.y - node.y % fullStep;
                    while (placeMap[y]) {
                        y += fullStep;
                    }
                    node.y = y;
                    placeMap[y] = true;
                });
            });
        }

        function resolveCollisions() {
            nodesByBreadth.forEach(function (nodes) {
                var node,
                    dy,
                    y0 = 0,
                    n = nodes.length,
                    i;

                // Push any overlapping nodes down.
                nodes.sort(ascendingDepth);
                for (i = 0; i < n; ++i) {
                    node = nodes[i];
                    dy = y0 - node.y;
                    if (dy > 0) node.y += dy;
                    y0 = node.y + node.dy + nodeHeight;
                }

                // If the bottommost node goes outside the bounds, push it back up.
                dy = y0 - nodeHeight - size[1];
                if (dy > 0) {
                    y0 = node.y -= dy;

                    // Push any overlapping nodes back up.
                    for (i = n - 2; i >= 0; --i) {
                        node = nodes[i];
                        dy = node.y + node.dy + nodeHeight - y0;
                        if (dy > 0) node.y -= dy;
                        y0 = node.y;
                    }
                }
            });
        }

        function ascendingDepth(a, b) {
            return a.y - b.y;
        }
    }

    function computeLinkDepths() {
        nodes.forEach(function (node) {
            node.sourceLinks.sort(ascendingTargetDepth);
            node.targetLinks.sort(ascendingSourceDepth);
        });
        nodes.forEach(function (node) {
            var sy = 0,
                ty = 0;
            node.sourceLinks.forEach(function (link) {
                link.sy = sy;
                sy += link.dy;
            });
            node.targetLinks.forEach(function (link) {
                link.ty = ty;
                ty += link.dy;
            });
        });

        function ascendingSourceDepth(a, b) {
            return a.source.y - b.source.y;
        }

        function ascendingTargetDepth(a, b) {
            return a.target.y - b.target.y;
        }
    }

    function center(node) {
        return node.y + node.dy / 2;
    }

    function value(link) {
        return link.value;
    }

    return sankey;
};
module.exports = Sankey;

},{"../utils/layoutUtils":67}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.getDefaultParametersSet = getDefaultParametersSet;
exports.LineageGram = LineageGram;

var _visualizationsLibrary = require('visualizations-library');

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _layout = require('./layout/layout');

var layout = _interopRequireWildcard(_layout);

var _elements = require('./jointViews/graphElements/elements');

var graphElements = _interopRequireWildcard(_elements);

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _lineageDiagram2 = require('./jointViews/lineageDiagram');

var _lineageDiagram3 = _interopRequireDefault(_lineageDiagram2);

var _derivationMap2 = require('./jointViews/derivationMap/derivationMap');

var _derivationMap3 = _interopRequireDefault(_derivationMap2);

var _graphMap2 = require('./sigmaViews/graphMap');

var _graphMap3 = _interopRequireDefault(_graphMap2);

var _birdEye2 = require('./sigmaViews/birdEye');

var _birdEye3 = _interopRequireDefault(_birdEye2);

var _dataContainer2 = require('./data/dataContainer');

var _dataContainer3 = _interopRequireDefault(_dataContainer2);

var _stateStorage2 = require('./stateStorage');

var _stateStorage3 = _interopRequireDefault(_stateStorage2);

var _subscribeable = require('./subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _resourceProvider = require('./data/resourceProvider');

var _dataUtils = require('./utils/dataUtils');

var _dataProcessing = require('./data/dataProcessing');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Class which provides data for the LineageGram.
 * @interface DataProvider
 */

/**
 * The function which returns nodes and link models for the graph.
 * @function
 * @name DataProvider#fetchData
 * @param {string} targetNodeId
 * @param {string} viewFrame
 * @param {string} lineageGramViewClass
 * @param {string} diagramType
   @param {number} offset
 * @returns {Promise<ServerData>} Promise which provides graph data.
 */

/**
* The function which returns nodes and link models for the graph.
* @function
* @name DataProvider#getViewFrames
* @param {string} resource
* @returns {Promise<ViewFrameDefinition[]>} Promise which provides graph data.
*/

/**
* The function which returns nodes and link models for the graph.
* @function
* @name DataProvider#getViewClassForResource
* @param {string} resource
* @returns {Promise<{dataProvider: string}>} Promise which provides graph data.
*/

/**
* The function which returns nodes and link models for the graph.
* @function
* @name DataProvider#relationInfo
* @param {Link} relation
* @returns {Promise<DerivationMapData>} Promise which provides graph data.
*/

/**
* Represents a node model which is extended by diagramType field
* @typedef {Object} PublicNodeModel
* @property {string} id
* @property {string} label
* @property {string} resource
* @property {string} resourceType
* @property {string} diagramType
* @property {string} typeId
* @property {string} viewFrame
* @property {any} data
*/

/**
* Represents a link model which is extended by diagramType field
* @typedef {Object} PublicLinkModel
* @property {string} id
* @property {string} source
* @property {string} target
* @property {string} diagramType
* @property {string} linkType
* @property {any} data
*/

/**
 * Represents a dataProvider response which includes
 * links and nodes for the LineageGram
 * @typedef {Object} ServerData
 * @property {string} diagramType
 * @property {string} focusNode - IRI of focusNode
 * @property {LinkModel[]} links - Link models
 * @property {NodeModel[]} nodes - Node models
*/

/**
 * Represents a state
 * @typedef {Object} HistoryState
 * @property {Link[]} links - Links
 * @property {Node[]} nodes - Nodes
 * @property {ViewFrameDefinition[]} viewFrames
 * @property {Node} focusNode - Focus node for the state
*/

/**
 * Size
 * @typedef {Object} Size
 * @property {number} width - Width
 * @property {number} height - Height
*/

/**
 * Point
 * @typedef {Object} Point
 * @property {number} x - X
 * @property {number} y - Y
*/

/**
 * View frame definition,
 * @typedef {Object} ViewFrameDefinition
 * @property {string} id - View frame identifyer
 * @property {string} label - Title of the view frame,
 * @property {string} borderColor - Color of the border
 * @property {string} backgroundColor - Color of the background
 * @property {number} spaceShare - How much the view frame will take
 * @property {boolean} collapsed - Define default state
 * from whole space of the graph (You can take it as persents or flex grow)
*/

/**
 * Link tool button definition
 * @typedef {Object} LinkToolButton
 * @property {string} image - path to image
 * @property {number} width
 * @property {number} height
*/

/**
 * Link style definition
 * @typedef {Object} LinkStyleDefinition
 * @property {string} cssClass - CSS class which will be attached to the svg component
 * @property {string} lineType - 'solid' or 'dashed'
 * @property {string} color - Color of the line
 * @property {number} thickness
 * @property {boolean} hasArrow - Tells us whether line has a termination arrow or not
 * @property {LinkToolButton} toolButton
*/

/**
 * Size of the nodes of the graph (maximum, minimum, default)
 * @typedef {Object} ElementSize
 * @property {number} width - Default width of the nodes
 * @property {number} height - Default height of the nodes
 * @property {number} minWidth - Minimum width of the nodes
 * @property {number} maxWidth - Maximum width of the nodes
 * @property {number} minHeight - Minimum height of the nodes
 * @property {number} maxHeight - Maximum height of the nodes
*/

/**
 * Scale bounds.
 * @typedef {Object} ScaleBounds
 * @property {number} min
 * @property {number} max
*/

/**
 * In fact the object is a map between colors and keys (ids) of elements,
 * but there are number of default color keys.
 * @typedef {Object.<string, string>} Colors
 * @property {string} terminationText - Color of the text on termination nodes
 * @property {string} text - Color of the text on the graph's nodes,
 * @property {string} unknown - Color for nodes whose id is unknown
 * @property {string} default - Default color for nodes
 * @property {string} selected - Color of elements which are selected
 * @property {string} blured - Color for blured elements
 * @property {string} link - Color for links
 * @property {string} terminationLink - Color for termination links
 * @property {string} aspectLink - Color for aspect links
*/

/**
 * Tool button.
 * @typedef {Object} LinkToolButton
 * @property {string} image - src or xhref for tool button
 * @property {number} width - button width
 * @property {string} height - button height
*/

/**
 * Default parameters set for LineageGram. You can pass any of these parameters into the constructor during the LineageGram initialization.
 * @typedef {Object} Parameters
 * @property {string|HTMLElement} graphPlace - Identifier of the root html element for binding graph or just root HTMLElement
 * @property {string|HTMLElement} mapRootHtml - Identifier of the root html element for binding map or just root html element
 * @property {DataProvider} dataProvider - Function that resieves and returns data for the graph
 * @property {string} focusNode - Focus node id
 *
 * @property {function} launchExternal - It can be called in order to get more information about some element in derivation map and in main class.
 *
 * @property {ElementSize} elementSize - Size of the nodes of the graph
 * @property {ElementSize} overViewElementSize - Size of the nodes of the graph in OverViewFrame
 *
 * @property {number} layoutStep - Distance between elements of the graph
 * @property {number} layoutIterations - How much iterations will be done during the layout algorithm
 * @property {number} offsetBetweenGroups - Additional offset between groups of nodes (viewFrame groups)
 *
 * @property {Colors} colors - Color map
 *
 * @property {boolean} animation - If it's true, the animation is allowed. By default - true
 * @property {number} maxFrameRate - Maximum speed of animation. By defaul - 50 frames per second
 * @property {number} minFrameRate - Minimum speed of animation. By defaul - 10 frames per second
 * @property {number} animationStep - How far viewFrame position is changing per animation frame
 *
 * @property {ViewFrameDefinition[]} - View frames definition
 * @property {boolean} fullScreenMode - Defines whether we want to open LG in full-screen-mode or in the regular mode
 *
 * @property {Object.<string, string>} images - Map between node types and image urls.
 * @property {Object.<string, string>} icons - Map between node types and icons (css).
 * @property {string} resourcePath - Prefix for resources like images (optional)
 * @property {boolean} usePOSTExecutor - to make able use post requests for sparqlProvider
 * @property {Point} framePadding - ViewPorts enabled area expanded by this value
 *
 * @property {boolean} clipNodes - Tells us do or not clipping nodes by viewFrames
 * @property {number} frameBorderWidth - Width of the frame border
 *
 * @property {boolean} showCollapsedFrames - Tells whether hide or show collapsed viewFrmaes in the bottom of the graph.
 *
 * @property {Point} defaultScale
 * @property {ScaleBounds} scaleBounds - Contains minimal(min) and maximum(max) values of the scale.
 * @property {ScaleBounds} overViewScaleBounds - Contains minimal(min) and maximum(max) values of the scale for OverViewFrame.
 * @property {number} scaleStep - How much scale changes per step.
 *
 * @property {Size} terminationNodeSize - Size of the termination nodes
 * @property {Size} dataZoneSize - Size of zones in data container. Zones are grouping and sorting in special areas to implement binary searching
 * @property {number} zonesInGroup - Grouping data zones in bigger groups by groups of (for example) four
 * @property {string} linkRouting - Links routing (based on jointjs routings: metro/normal/manhattan/orthogonal)
 *
 * @property {Object.<string, LinkStyleDefinition>} linkStyles - Map between the linkTypes and LinkStyles.
 * @property {string} graphOrientation - Orientation of the graph. Can be: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
 * @property {DerivationMapParameters} derivationMap - parameters set for DerivationMap
 * @property {Object.<string, boolean>} mask - map of elements. Elements in the mask will be hidden
 * @property {Function} errorCallBack - it is called in response to warnings and errors
*/

/**
 * Returns default set of parameters
 * @returns {Parameters}
 */
function getDefaultParametersSet() {
    return {
        // initialization
        graphPlace: undefined, // Identifier of the root html element for binding graph
        mapRootHtml: undefined, // Identifier of the root html element for binding map or just root HTMLElement
        dataProvider: undefined,
        focusNode: undefined,

        // Elements
        elementSize: { width: 120, height: 120, minWidth: 45, maxWidth: 550, minHeight: 45, maxHeight: 550 }, // default element size
        overViewElementSize: { width: 120, height: 120, minWidth: 5, maxWidth: 550, minHeight: 5, maxHeight: 550 }, // default element size for the OverViewFrame

        // Layout
        layoutStep: { x: 200, y: 100 }, // Distance between elements of the graph
        layoutIterations: 32, // How much iterations will have been done during the layout algorithm
        offsetBetweenGroups: 150, // Additional offset between groups of nodes (viewFrame groups)

        // Color scheme
        colors: { // color map
            'edg:DatabaseColumn': '#23b0f4',
            'edg:SoftwareProgram': 'green',
            'http://edg.topbraid.solutions/model/SoftwareProgram': 'green',
            'http://edg.topbraid.solutions/model/Report': '#23b0f4',
            'http://edg.topbraid.solutions/model/ReportColumn': '#ff7410',

            'terminationText': 'white',
            'text': 'black',
            'unknown': 'black',
            'default': 'black',
            'selected': 'red',
            'blured': 'rgba(100, 100, 100, 0.3)',
            'terminationLink': '#9094a8',
            'aspectLink': 'rgba(0, 255, 0, 0.5)'
        },

        // Animation
        animation: true, // swithc off/on the animation
        maxFrameRate: 50,
        minFrameRate: 10,
        animationStep: 60,

        // View frames definition
        fullScreenMode: true, // Defines whether we want to open LG in full-screen-mode or in the regular mode
        viewFrames: [
            // {
            //     id: 'fullPanel', // identifier of the frame must be unique
            //     label: 'All',   // label in the right-top corner
            //     borderColor: '#23b0f4',
            //     backgroundColor: '#f4f4ff',
            //     // It tells how much space will takes this frame on the paper.
            //     // |[1][ 2 ][  3   ]| or
            //     // |[  50  ][  50  ]| or
            //     // |[10][10][10][10]|
            //     spaceShare: 1,
            // }
        ],

        // Images for types
        images: { // map of images for types of elements
            'edg:DatabaseColumn': 'src/resources/images/table.png',
            'edg:Table': 'src/resources/images/table.png',
            'edg:SoftwareProgram': 'src/resources/images/app.png',
            'http://edg.topbraid.solutions/model/SoftwareProgram': 'src/resources/images/app.png',
            'edg:LineageModel': 'src/resources/images/form.png',
            'edg:Schedule': 'src/resources/images/column.png',
            // 'link-options': 'src/resources/images/derivation-map.png',
            // 'feed-pipe': 'src/resources/images/feed-pipe.png',
            'unknown': 'src/resources/images/unknown.png' // It will work only for unknown types
        }, // if you want change it for lost images,
        // you should change it in the bottom of './jointViews/graphElements.js'

        resourcePath: '', // prefix for resources like images (optional)
        launchExternal: null, //optional
        usePOSTExecutor: false, // to make able use post requests for sparqlProvider

        // Be careful! If you want to change it, you should remember about css (.tq_lineage_ui e.t.c.)
        framePadding: { x: 55, y: 55 }, // viewPorts enabled area expanded by this value

        clipNodes: false, // tells us do or not clipping nodes by viewFrames.
        frameBorderWidth: 3, // styling

        showCollapsedFrames: false,

        defaultScale: { x: 1.0, y: 1.0 }, // It's necessary for calculations
        scaleBounds: { min: 0.7, max: 1.5 },
        overViewScaleBounds: { min: 0.01, max: 15 }, // scale bounds for overView frame
        scaleStep: 0.1, // step of scale changing

        terminationNodeSize: { width: 30, height: 30 }, // size of the termination nodes
        dataZoneSize: { width: 800, height: 600 }, // size of zones in data container. Zones are grouping and sorting in special areas to implement binary searching
        zonesInGroup: 4, // grouping data zones in bigger groups by groups of (for example) four
        linkRouting: 'metro', // links routing (based on jointjs routings: metro/normal/manhattan/orthogonal)

        linkStyles: {
            'default-link-style': _resourceProvider.DEFAULT_LINK_STYLE,
            'feedpipe': _resourceProvider.FEED_PIPE_LINK_STYLE,
            'tq-lg-group': _resourceProvider.DEFAULT_GROUP_LINK_STYLE
            // Example:
            // 'feedpipe': {
            //     cssClass: 'lineage-gram-feed-pipe-link',
            //     lineType: 'solid', // 'dashed'
            //     color: '#3c4260',
            //     toolButton: {
            //         image: 'src/resources/images/feed-pipe.png',
            //         width: 30,
            //         height: 30,
            //         alwaysVisible: true, 
            //     },
            //     thickness: 3,
            //     hasArrow: true,
            // },
        },
        diagramType: undefined,
        graphOrientation: 'left-to-right', // Can be: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
        layoutAlgorithm: 'sankey', // Can be: 'sankey', 'flow-directed'
        derivationMap: (0, _derivationMap2.getDefaultParametersSet)(),
        mask: undefined, // Map of elements. Elements in the mask will be hidden

        errorCallBack: undefined // It is called in response to warnings and errors
    };
}

/**
 * The main class of the library, that manage all views and data.
 * Creates two view on the initialization stage. The first view is a Lineage diagram view.
 * The second view is a Bird Eye view. Also the map can be placed on the page if the mapRootHtmlId
 * was specified in the passed parameters.
 * @class
 * @augments Subscribable
 * @param {Parameters} parameters - Parameters set
 *
 * @fires selected-element-changed
 * @fires history-state-changed
 * @fires focus-node-changed
 * @fires current-view-changed
 * @fires scale-value-changed
 * @fires diagram-state-changed
 * @fires view-frame-state-changed
 * @fires derivation-map-state-changed
 * @fires derivation-map-state-init
 */
function LineageGram(parameters) {
    var _this = this;

    // Events
    // ===================================================================
    // ===================================================================

    /**
     * Element selected event - fires when object changes element selection
     * Selected element is returned as a parameter of the event.
     * @event selected-element-changed
     * @type {Object}
     * @property {PublicNodeModel|PublicLinkModel|undefined} element - SelectedElement
    */

    /**
     * It fires when new element is selected as focusNode.
     * @event focus-node-changed
     * @type {Object}
     * @property {PublicNodeModel} element - FocusNode model
    */

    /**
     * View switched event - fires when current view is changed
     * View id is returned as a parameter of the event
     * @event current-view-changed
     * @type {Object}
     * @property {string} viewId - SelectedView can take the following values: 'lineageDiagram', 'birdEye' or 'none'
    */

    /**
     * Scale changed event - fires when scale value of the Lineage Diagram view is changed.
     * [New scale value]{@link Scale} is returned as a parameter of the event
     * @event scale-value-changed
     * @type {Object}
     * @property {Scale} scale - New scale object.
    */

    /**
     * State changed event - fires when LineageGram state is changed.
     * E.g. from a fetching state to a rendering state.
     * The state string identifier is returned as a parameter of the event
     * @event diagram-state-changed
     * @type {Object}
     * @property {string} state - Parameter can take the following values: 'fetching' | 'rendering' | 'completed' | 'error'
    */

    /**
     * It fires when user is navigating along the history.
     * @event history-state-changed
     * @type {Object}
     * @property {HistoryState[]} states - List of states
     * @property {number} currentIndex - order number of the current state in the list
    */

    /**
     * View frame state changed - fires when the View frame is being collapsed or expanded.
     * @event view-frame-state-changed
     * @type {Object}
     * @property {string} id - id of the changed ViewFrame
     * @property {boolean} value - true - expanded, false - collapsed
    */

    // Init
    // ===================================================================
    // ===================================================================
    _subscribeable2.default.apply(this); // make this class Subscribable

    var self = this; // Save pointer to a context

    var _state = 'initial';
    var _selectedElement = null;
    var _focusElement = void 0;
    var _currentView = 'lineageDiagram'; // Set the lineageDiagram view as a current view


    var defaultParameterSet = getDefaultParametersSet(); // Geting default parameters set
    // If the parameter set includes viewFrames definition, clear the viewFrames definition in the default set for a correct merging
    // (We don't want to get extra viewFrames from the default set.)
    if (parameters && parameters.viewFrames && parameters.viewFrames.length > 0) defaultParameterSet.viewFrames = undefined;
    // Merging default parameters set and custome parameters set
    var _parameters = _.merge(defaultParameterSet, parameters);

    var _errorCallback = function _errorCallback(e) {
        if (_parameters.errorCallback && _parameters.errorCallback instanceof Function) {
            var error = typeof e === 'string' ? new Error(e) : e;
            _parameters.errorCallback.call(_this, error);
        }
    };

    // If the graphPlace is undefined we stop the working process.
    if (!parameters.graphPlace) throw new Error('The graph place isn\'t specified');
    var graphPlaceHtml = void 0;
    if (typeof parameters.graphPlace === 'string') {
        graphPlaceHtml = document.getElementById(parameters.graphPlace);
    } else if (_typeof(parameters.graphPlace) === 'object') {
        graphPlaceHtml = parameters.graphPlace;
    } else {
        throw new Error('The graph place isn\'t specified or specided incorrectly');
    }
    // Creating html markup.
    var _base = _createBase(graphPlaceHtml);
    var _dataProvider = _parameters.dataProvider;
    var _stateStorage = new _stateStorage3.default(_parameters);
    var _progressScreen = new _visualizationsLibrary2.default.ProgressScreen({
        baseElement: _base.container
    });

    // Creating the data container.
    var _dataContainer = void 0;

    var _lineageDiagram = void 0; // Lineage diagram view
    var _birdEye = void 0; // BirdEye biew
    var _derivationMap = void 0;
    var _graphMap = void 0; // define variable
    var _derivationMapPanel = void 0;

    var _diagramType = _parameters.diagramType;

    self.launchExternal = _parameters.launchExternal;

    _createComponents();

    _fetchDiagram({
        focusNodeId: _parameters.focusNode,
        viewFrames: _parameters.viewFrames,
        lineageGramViewClass: _parameters.lineageGramViewClass,
        diagramType: _diagramType
    });

    // ===================================================================
    // ===================================================================

    /**
     * Recovers nodes positions to the initial.
     * @memberof LineageGram
     * @method
     */
    self.resetLayout = function () {
        if (_state !== 'completed') return;
        _lineageDiagram.resetLayout();
    };

    /**
     * @typedef {Object} Scale
     * @property {number} min - The minimum value
     * @property {number} max - The maximum value
     * @property {number} cur - The current value
    */

    /**
     * Changes scale of the main view by the step (defaul: ++0.1).
     * @returns {Scale}
     * @memberof LineageGram
     * @method
     */
    self.zoomIn = function () {
        if (_state === 'completed') {
            _lineageDiagram.zoomIn();
            if (_graphMap) _graphMap.redraw({ viewFrames: _lineageDiagram.getViewFrames() });
        }
        return {
            min: _parameters.scaleBounds.min,
            max: _parameters.scaleBounds.max,
            cur: _state === 'completed' ? _lineageDiagram.scale() : _parameters.defaultScale
        };
    };

    /**
     * Changes scale of the main view to be able to fit whole diagram in the screen.
     * @returns {Scale}
     * @memberof LineageGram
     * @method
     */
    self.zoomToFit = function () {
        if (_state === 'completed') {
            _zoomToFit();
        }
        return {
            min: _parameters.scaleBounds.min,
            max: _parameters.scaleBounds.max,
            cur: _state === 'completed' ? _lineageDiagram.scale() : _parameters.defaultScale
        };
    };

    /**
     * Returns current view id
     * @return {string} currentViewId -'lineageDiagram' | 'birdEye' | 'none'
     * @memberof LineageGram
     * @method
     */
    self.getCurrentView = function () {
        return _currentView;
    };

    /**
     * Returns current state
     * @returns {string} state - 'fetching' | 'active' | 'completed' | 'error'
     * @memberof LineageGram
     * @method
     */
    self.getState = function () {
        return _state;
    };

    /**
     * Changes scale of the main view by the step (defaul: --0.1).
     * @returns {Scale}
     * @memberof LineageGram
     * @method
     */
    self.zoomOut = function () {
        if (_state === 'completed') {
            _lineageDiagram.zoomOut();
            if (_graphMap) _graphMap.redraw({ viewFrames: _lineageDiagram.getViewFrames() });
        }
        return {
            min: _parameters.scaleBounds.min,
            max: _parameters.scaleBounds.max,
            cur: _state === 'completed' ? _lineageDiagram.scale() : _parameters.defaultScale
        };
    };

    /**
     * Changes scale of the main Lineage Diagram view.
     * @param {Point} scale
     * @returns {Scale}
     * @memberof LineageGram
     * @method
     */
    self.zoom = function zoom(scale) {
        if (_state === 'completed') {
            if (scale) {
                _lineageDiagram.scale(scale);
            }
            _lineageDiagram.redraw();
        }
        return {
            min: _parameters.scaleBounds.min,
            max: _parameters.scaleBounds.max,
            cur: _state === 'completed' ? _lineageDiagram.scale() : _parameters.defaultScale
        };
    };

    /**
     * Object which passed into the export function in LineageGram
     * @typedef {Object} ExportParams
     * @property {string} name - The file name
     * @property {string} type - (png/svg)
     * @property {string} view - BirdEye / lineageGram
    */

    /**
     * Exports the graph in a png or svg file.
     * @param {ExportParams} options
     * @memberof LineageGram
     * @method
    */
    self.export = function (options) {
        if (_state !== 'completed') return;

        if (!options) options = {};
        options.view = options.view || _currentView;
        if (options.view === 'lineageDiagram') {
            _lineageDiagram.export({
                name: options.name,
                type: options.type
            });
        } else if (options.view === 'birdEye') {
            _birdEye.export();
        }
    };

    /**
     * Shows print dialog.
     * @memberof LineageGram
     * @method
    */
    self.print = function () {
        if (_currentView === 'lineageDiagram') {
            _lineageDiagram.print();
        } else if (_currentView === 'birdEye') {
            _birdEye.print();
        }
    };

    /**
     * Expands all nodes
     * @memberof LineageGram
     * @method
    */
    self.expandAllNodes = function () {
        var nodes = _dataContainer.nodes;
        nodes.forEach(function (node) {
            node.set('expanded', true);
        });
        if (_currentView === 'lineageDiagram') {
            _lineageDiagram.refresh();
        }
    };

    /**
     * Collapses all nodes
     * @memberof LineageGram
     * @method
    */
    self.collapseAllNodes = function () {
        var nodes = _dataContainer.nodes;
        nodes.forEach(function (node) {
            node.set('expanded', false);
        });
        if (_currentView === 'lineageDiagram') {
            _lineageDiagram.refresh();
        }
    };

    /**
     * This function creates map, using html element with specified ID as a root element.
     * @param {string|HTMLElement} mapRootHtml - ID of root element or HTMLElement
     * @memberof LineageGram
     * @method
     */
    self.setRootHtmlForMap = function (mapRootHtml) {
        var mapHTMLElement = _getMapHTML(mapRootHtml);
        _parameters.mapRootHtml = mapRootHtml;
        _base.mapHTMLElement = mapHTMLElement;

        if (_state !== 'completed') return;

        _updateMap(_dataContainer, _lineageDiagram.getViewFrames());
    };

    /**
     * It changes layout algorithm for the graph.
     * @param {string} orientation - Values: 'sankey', 'flow-directed'
     * @memberof LineageGram
     * @method
     */
    self.setLayoutAlgorithm = function (algorithmId) {
        if (algorithmId === 'sankey' || algorithmId === 'flow-directed') {
            _parameters.layoutAlgorithm = algorithmId;

            var nodes = _dataContainer.nodes.map(function (n) {
                var model = n.model;
                delete model.defaultPosition;
                model.viewFrameOwnerId = null;
                return model;
            });
            var links = _dataContainer.links.map(function (l) {
                return {
                    id: l.model.id,
                    source: l.model.sourceType,
                    target: l.model.targetType
                };
            });

            var viewFrames = _lineageDiagram.getViewFrames();

            layout.doLayout(nodes, links, viewFrames, _parameters);
            _dataContainer.refresh();
            _lineageDiagram.refresh();
            _birdEye.refresh();
            if (_graphMap) _graphMap.redraw({
                viewFrames: _lineageDiagram.getViewFrames()
            });
        }
    };

    /**
     * Returns layout algorithm which is currently used for diagram.
     * @memberof LineageGram
     * @method
     * @returns {string} routing: metro/normal/manhattan
     */
    self.getLayoutAlgorithm = function () {
        return _parameters.layoutAlgorithm;
    };

    /**
     * It changes orientation of the graph
     * @param {string} orientation - Values: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
     * @memberof LineageGram
     * @method
     */
    self.setOrientation = function (orientation) {
        if (_state !== 'completed') return;

        if (orientation && (orientation === 'left-to-right' || orientation === 'right-to-left' || orientation === 'top-to-bottom' || orientation === 'bottom-to-top')) {
            _parameters.graphOrientation = orientation;

            var nodes = _dataContainer.nodes.map(function (n) {
                var model = n.model;
                model.default_x = undefined;
                model.default_y = undefined;
                model.viewFrameOwnerId = null;
                n.setOrientation(orientation);
                return model;
            });
            var links = _dataContainer.links.map(function (link) {
                return {
                    id: link.model.id,
                    source: link.model.sourceType,
                    target: link.model.targetType
                };
            });

            var viewFrames = _lineageDiagram.getViewFrames();

            layout.doLayout(nodes, links, viewFrames, _parameters);
            _dataContainer.refresh();
            _lineageDiagram.setOrientation(orientation);
            _birdEye.refresh();
            if (_graphMap) _graphMap.refresh({
                viewFrames: _lineageDiagram.getViewFrames()
            });
        }
    };

    /**
     * It returns orientation of the graph
     * @memberof LineageGram
     * @method
     * @returns {string} oreintation - Values: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
     */
    self.getOrientation = function () {
        return _parameters.graphOrientation;
    };

    /**
     * Refreshes LineageGram - refreshes all views and adjust size of the canvas.
     * @memberof LineageGram
     * @param {string} target - 'lineageDiagram' | 'birdEye' | 'graphMap'
     * @method
     */
    self.refresh = function (target) {
        if (_state !== 'completed') return;

        if (_currentView === 'lineageDiagram') {
            if (!target || target === 'lineageDiagram') _lineageDiagram.redraw();
        } else {
            if (!target || target === 'birdEye') _birdEye.refresh();
        }
        if (_graphMap && (!target || target === 'graphMap')) _graphMap.refresh({
            viewFrames: _lineageDiagram.getViewFrames()
        });
    };

    /**
     * ViewFrmaes public data
     * @typedef {Object} ViewFramePublicModel
     * @property {string} id - Identifier
     * @property {string} label - Text label
     * @property {string} borderColor - CSS border color
     * @property {string} backgroundColor - CSS bacground color
    */

    /**
     * Get ViewFrames states.
     * @returns {ViewFramePublicModel[]} states - key -> id, value -> true - expanded, false - collapsed
     * @memberof LineageGram
     * @method
     */
    self.getViewFrames = function () {
        if (_state !== 'completed') return [];

        return _lineageDiagram.getViewFrames();
    };

    /**
     * Returns one ViewFrame by id
     * @memberof LineageGram
     * @method
     * @param {string} viewFrameId
     * @returns {ViewFramePublicModel}
    */
    self.getViewFrameById = function (viewFrameId) {
        if (_state !== 'completed') return undefined;

        return _lineageDiagram.getViewFrameById(viewFrameId);
    };

    /**
     * Returns one ViewFrame by id
     * @memberof LineageGram
     * @method
     * @returns {ViewFramePublicModel}
    */
    self.getOverViewFrame = function () {
        if (_state !== 'completed') return undefined;

        return _lineageDiagram.getOverViewFrame();
    };

    /**
     * Collapse the ViewFrame with specified Id.
     * @param {string} viewFrameId - id of the target ViewFrame
     * @memberof LineageGram
     * @method
     */
    self.collapseViewFrame = function (viewFrameId) {
        if (_state !== 'completed') return;
        _lineageDiagram.closeViewFrame(viewFrameId);
    };

    /**
     * Expand ViewFrame with specified Id.
     * @param {string} viewFrameId - id of the target ViewFrame
     * @memberof LineageGram
     * @method
     */
    self.expandViewFrame = function (viewFrameId) {
        if (_state !== 'completed') return;
        _lineageDiagram.openViewFrame(viewFrameId);
    };

    /**
     * Collapses/Expands OverViewFrame.
     * @param {boolean} value
     * @memberof LineageGram
     * @method
    */
    self.setFullScreenMode = function (value) {
        if (_state !== 'completed') return;
        _lineageDiagram.setFullScreenMode(value);
    };

    /**
     * Collapses/Expands OverViewFrame.
     * @param {boolean} value
     * @memberof LineageGram
     * @method
    */
    self.isFullScreenMode = function () {
        if (_state !== 'completed') return _parameters.fullScreenMode;
        return _lineageDiagram.isFullScreenMode();
    };

    /**
     * Groups relative to selected node
     * nodes around  the selected node and highlight them.
     * @memberof LineageGram
     * @method
    */
    self.combine = function () {
        _lineageDiagram.combine();
    };

    /**
     * Finds elements by id(s) and sets it as selected.
     * @param {string|null} id1 - Selected element id or source element id of the link
     * @param {string} id2 - Target element id
     * @returns {Node|Link} - Selected element
     * @memberof LineageGram
     * @method
     */
    self.setSelectedElement = function (id1, id2) {
        if (id1 === undefined) return;

        if (id1 !== null) {
            var selectedElement = _getElementById(id1, id2);
            _setSelectedElement(selectedElement);
        } else {
            _setSelectedElement(null);
        }
    };

    /**
     * Rebuilds diagramm with new focus node
     * @param {string} focusNode - Focus node id
     * @memberof LineageGram
     * @method
     */
    self.setFocusNode = function (focusNodeId) {
        var focusNode = _getElementById(focusNodeId);

        if (!(focusNode instanceof graphElements.Node)) {
            console.error('Incorrect value of element');
            return;
        }

        _stateStorage.updateState(_getHistoryState());
        _setDiagramState('fetching');

        _fetchDiagram({
            focusNodeId: focusNode.model.resource,
            viewFrame: focusNode.model.viewFrame,
            offset: focusNode.model.hasOwnProperty('offset') ? focusNode.model.offset : null,
            diagramType: _diagramType
        });
    };

    /**
     * Returns to previous selected node (Restores previous diagram)
     * @memberof LineageGram
     * @method
     */
    self.undoState = function () {
        _stateStorage.updateState(_getHistoryState());
        var previousState = _stateStorage.undoState();
        if (previousState) _loadState(previousState);
    };

    /**
     * Returns to next selected node
     * (Node which had been selected before the state was restored)
     * @memberof LineageGram
     * @method
     */
    self.redoState = function () {
        _stateStorage.updateState(_getHistoryState());
        var nextState = _stateStorage.redoState();
        if (nextState) _loadState(nextState);
    };

    /**
     * Returns public model of selected element
     * @returns {PublicLinkModel|PublicNodeModel} selectedElement
     * @memberof LineageGram
     * @method
     */
    self.getSelectedElement = function () {
        return _getModel(_selectedElement);
    };

    /**
     * Returns public model of focus element.
     * Element which was used to build diagram around
     * @returns {PublicLinkModel|PublicNodeModel} focusElement
     * @memberof LineageGram
     * @method
     */
    self.getFocusElement = function () {
        return _getModel(_focusElement);
    };

    /**
    * Returns the current derivation map.
    * @returns {DerivationMap} derviationMap
    * @memberof lineageGram
    * @method
    */
    self.getDerivationMap = function () {
        if (_state === 'completed') {
            return _derivationMap;
        } else {
            return undefined;
        }
    };

    self.getNodes = function () {
        if (_state !== 'completed') return [];
        return _dataContainer.nodes.map(function (n) {
            return _getModel(n);
        });
    };

    self.getLinks = function () {
        if (_state !== 'completed') return [];
        return _dataContainer.links.map(function (l) {
            return _getModel(l);
        });
    };

    /**
     * Graphs public maps
     * @typedef {Object} PublicGraphMaps
     * @property {Object.<string, PublicNodeModel>} nodeMap
     * @property {Object.<string, PublicLinkModel>} linkMap
     * @property {Object.<string, PublicLinkModel>} sourceMap
     * @property {Object.<string, PublicLinkModel>} targetMap
    */

    /**
     * Graph model
     * @typedef {Object} PublicGraphModel
     * @property {PublicNodeModel[]} nodes
     * @property {PublicLinkModel[]} links
     * @property {PublicGraphMaps} maps
    */

    /**
     * Returns a data model of LineagGram.
     * @returns {PublicGraphModel}
     * @memberof LineageGram
     * @method
     */
    self.getGraphModel = function () {
        if (_state !== 'completed') return {};

        var graphModel = {
            nodes: _dataContainer.nodes.map(function (n) {
                return _getModel(n);
            }),
            links: _dataContainer.links.map(function (l) {
                return _getModel(l);
            }),
            maps: {
                nodeMap: {},
                linkMap: {},
                sourceMap: {},
                targetMap: {}
            }
        };

        graphModel.nodes.forEach(function (nodeModel) {
            graphModel.maps.nodeMap[nodeModel.id] = nodeModel;
        });
        graphModel.links.forEach(function (linkModel) {
            graphModel.maps.linkMap[linkModel.id] = linkModel;

            if (!graphModel.maps.sourceMap[linkModel.target]) {
                graphModel.maps.sourceMap[linkModel.target] = [];
            }
            if (!graphModel.maps.targetMap[linkModel.source]) {
                graphModel.maps.targetMap[linkModel.source] = [];
            }

            graphModel.maps.sourceMap[linkModel.target].push(linkModel);
            graphModel.maps.targetMap[linkModel.source].push(linkModel);
        });

        return graphModel;
    };

    /**
     * Sets current view. Method takes string identifier of the view as a parameter
     * @param {string} - viewId can be 'lineageDiagram' or 'birdEye' or 'none'
     * @memberof LineageGram
     * @method
     */
    self.setCurrentView = function (viewId) {
        if (viewId === 'lineageDiagram') {
            _showJointGraph();
        } else if (viewId === 'birdEye') {
            _showSigmaGraph();
        } else if (viewId === 'none') {
            _hideViews();
        }
    };
    self.setCurrentView(_currentView);

    /**
     * Sets links routing which is based
     * on jointjs routings: metro | normal | manhattan | orthogonal
     * @param {string} routingId - metro | normal | manhattan | orthogonal
     * @memberof LineageGram
     * @method
     */
    self.setRouting = function (routingId) {
        if (_state === 'completed') {
            _lineageDiagram.setRouting(routingId);
        }
    };

    /**
     * Returns routing which is currently applied for all links.
     * @memberof LineageGram
     * @method
     * @returns {string} routing: metro | normal | manhattan | orthogonal
     */
    self.getRouting = function () {
        if (_state === 'completed') {
            return _lineageDiagram.getRouting();
        } else {
            return parameters.linkRouting;
        }
    };

    /**
     * Sets value of the parameter which tells us wheter we should
     * trim nodes by the borders or not.
     * @memberof LineageGram
     * @param {boolean} clipping
     * @method
     */
    self.setClipping = function (clipping) {
        _parameters.clipNodes = clipping;
        if (_state === 'completed') {
            _lineageDiagram.redraw();
        }
    };

    /**
     * Returns value of the parameter which tells us wheter we
     * trim nodes by the borders or not.
     * @memberof LineageGram
     * @method
     * @returns {boolean} clipping
     */
    self.getClipping = function () {
        return _parameters.clipNodes;
    };

    self.setMask = function (publicMask) {
        var idMap = _dataContainer.maps.idMap;
        var mask = {};
        Object.keys(publicMask).forEach(function (id) {
            var diagramId = idMap[id];
            mask[diagramId] = publicMask[id];
        });
        _lineageDiagram.setMask(mask);
    };

    self.getMask = function () {
        var mask = _lineageDiagram.getMask();
        var nodeMap = _dataContainer.maps.nodeMap;
        var linkMap = _dataContainer.maps.linkMap;
        var publicMask = {};
        if (mask) {
            Object.keys(mask).forEach(function (key) {
                if (mask[key]) {
                    var element = _getModel(nodeMap[key] || linkMap[key]);
                    if (element) {
                        publicMask[element.id] = element;
                    }
                }
            });
        }
        return publicMask;
    };

    /**
     * Fetches diagram using passed options
     * @param {{
     *      focusNodeId: string,
     *      viewFrames: ViewFrameDefinition[],
     *      viewFrame: string
     *      lineageGramViewClass: string,
     *      diagramType: string,
     * }}
     * @memberof LineageGram
     * @method
     * @private
     */
    function _fetchDiagram(options) {
        var targetNodeId = options.focusNodeId;
        var viewFrame = options.viewFrame;
        var diagramType = options.diagramType;
        var offset = options.hasOwnProperty('offset') ? options.offset : null;

        // Switch the loading indicator in state 'fetching'
        // Request data through data provider
        _setDiagramState('fetching');
        if (!_dataProvider) {
            var errorMessage = 'Data provider is not specified!';
            var error = new Error(errorMessage);
            _setDiagramState('error', errorMessage);
            _errorCallback(error);
            throw error;
        }
        if (!_dataProvider.fetchData) {
            var _errorMessage = 'Data provider has incorrect interface! (There is no \'fetchData\' method)';
            var _error = new Error(_errorMessage);
            _setDiagramState('error', _errorMessage);
            _errorCallback(_error);
            throw _error;
        }

        var viewFramesPromise = options.viewFrames && options.viewFrames.length > 0 ? Promise.resolve({ frames: options.viewFrames }) : _dataProvider.getViewFrames(targetNodeId);
        var viewClassPromise = options.lineageGramViewClass ? Promise.resolve(options.lineageGramViewClass) : _dataProvider.getViewClassForResource(targetNodeId);

        return Promise.all([viewFramesPromise, viewClassPromise]).then(function (values) {
            var viewFrames = values[0].frames;
            var viewClass = values[1].dataProvider;

            return _dataProvider.fetchData({
                targetNodeId: targetNodeId,
                viewFrame: viewFrame,
                lineageGramViewClass: viewClass,
                diagramType: diagramType,
                offset: offset
            }).then(function (rawData) {
                _setDiagramState('rendering');

                (0, _dataUtils.checkLgRawData)(rawData);

                var dataContainer = _createDataContainer(rawData, viewFrames);
                var viewFrameDefinitions = filterViewFrameList(viewFrames, dataContainer);
                var publicViewFrameModels = viewFrameDefinitions.map(function (d) {
                    return (0, _dataUtils.defenitionToPublicModel)(d, _lineageDiagram.isFullScreenMode());
                });

                _updateComponents(dataContainer, publicViewFrameModels);

                _diagramType = rawData.diagramType;
                _dataContainer = dataContainer;
                _stateStorage.pushState(_getHistoryState());

                var focusNodeId = rawData.focusNode || (rawData.nodes[0] ? rawData.nodes[0].id : focusNodeId);
                var focusElement = _getElementById(focusNodeId);
                _focusElement = focusElement;

                _setSelectedElement(focusElement);
                _setDiagramState('completed');

                self.trigger('focus-node-changed', _getModel(focusElement));
                self.trigger('history-state-changed', _stateStorage.getHistory());
            });
        }).catch(function (e) {
            var error = typeof e === 'string' ? new Error(e) : e;

            _setDiagramState('error', error.message);
            _errorCallback(error);

            console.error(error.message);
            console.error(error.stack);
        });

        /**
         * Removes empty viewFrames
         * @private
         * @param {ViewFrameDefinition[]} viewFrames
         * @param {DataContainer} dataContainer
         * @returns {ViewFrame[]}
         */
        function filterViewFrameList(viewFrames, dataContainer) {
            var activeViewFrames = {};
            dataContainer.nodes.forEach(function (n) {
                activeViewFrames[n.model.viewFrame] = true;
            });
            var result = viewFrames.filter(function (vf) {
                return activeViewFrames[vf.id];
            });
            if (result.length > 0) {
                return result;
            } else {
                return [];
            }
        }
    }

    /**
     * @private
     * Finds elements by id(s).
     * @param {string} id1 - Selected element id or source element id of the link
     * @param {string} id2 - Target element id
     * @returns {Node|Link} - Selected element
    */
    function _getElementById(id1, id2) {
        if (!id2) {
            var elements = _dataContainer.nodes.concat(_dataContainer.links);
            for (var i = 0; i < elements.length; i++) {
                if (elements[i].model.resource === id1 || elements[i].model.id === id1) {
                    return elements[i];
                }
            }
        } else {
            var nodeMap = _dataContainer.maps.nodeMap;
            var links = _dataContainer.links;
            for (var _i = 0; _i < links.length; _i++) {
                var source = nodeMap[links[_i].model.source];
                var target = nodeMap[links[_i].model.target];
                if (source.resource === id1 && target.resource === id2 || source.resource === id2 && target.resource === id1 || source.id === id1 && target.id === id2 || source.id === id2 && target.id === id1) {
                    return links[_i];
                }
            }
        }
        return undefined;
    }

    /**
     * @private
     * Checks passed element and set it as a selected. Refreshes this value for the views.
     * @param {Node|Link} - Selected element
    */
    function _setSelectedElement(selectedElement) {
        // It shoudln't be undefined, but it can be null
        if (selectedElement === undefined) {
            throw Error('Incorrect value of selected element');
        }

        if (_graphMap) _graphMap.setSelectedElement(selectedElement);
        if (_currentView === 'lineageDiagram') _lineageDiagram.setSelectedElement(selectedElement, true);
        if (_currentView === 'birdEye') _birdEye.setSelectedElement(selectedElement);
    }

    /**
     * @private
     * Returns current state.
     * @returns {HistoryState} current state
    */
    function _getHistoryState() {
        var overViewFrame = _lineageDiagram.getOverViewFrame();
        return {
            nodes: _dataContainer.nodes,
            links: _dataContainer.links,
            focusElement: _focusElement,
            viewFrames: _lineageDiagram.getViewFrames().filter(function (vf) {
                return vf.id !== overViewFrame.id;
            }),
            selectedElement: _selectedElement
        };
    }

    /**
     * @private
     * Restores diagram using the passed state.
     * @param {HistoryState} state - target state
    */
    function _loadState(state) {
        try {
            _setDiagramState('rendering');
            setTimeout(function () {
                var dataContainer = new _dataContainer3.default({
                    nodes: state.nodes,
                    links: state.links
                }, _parameters);

                _updateComponents(dataContainer, state.viewFrames);

                _dataContainer = dataContainer;

                var elementToSelect = state.selectedElement === undefined ? state.focusElement : state.selectedElement;
                _focusElement = state.focusElement;

                _selectedElement = elementToSelect;
                _setSelectedElement(elementToSelect);
                _setDiagramState('completed');

                self.trigger('focus-node-changed', _getModel(state.focusElement));
                self.trigger('history-state-changed', _stateStorage.getHistory());
            }, 0);
        } catch (error) {
            _setDiagramState('error');
            if (typeof error === 'string') {
                console.error(error);
            } else {
                console.error(error.message);
                console.error(error.stack);
            }
        }
    }

    /**
     * @private
     * Changes scale of the main view to be able to fit whole diagram in the screen.
    */
    function _zoomToFit() {
        _lineageDiagram.zoomToFit();
        if (_graphMap) _graphMap.redraw({
            viewFrames: _lineageDiagram.getViewFrames(),
            scale: _lineageDiagram.scale()
        });
    }

    /**
     * @private
     * Creates dataContainer (diagram model) using passed raw data.
     * @param {ServerData} rawData - data
     * @param {ViewFrameDefinition[]} viewFrames - View frame defenitions
    */
    function _createDataContainer(rawData, viewFrames) {
        // if we don't get any data, we create an empty datat
        if (!rawData) rawData = { nodes: [], links: [] };
        if (!rawData.nodes) rawData.nodes = [];
        if (!rawData.links) rawData.links = [];

        // The function filters the data, sets authorities and collapses links.
        var data = (0, _dataProcessing.processData)(rawData);
        // Find and set place for each element of the data set
        layout.doLayout(data.nodes, data.links, viewFrames, _parameters);

        // This two lines create nodes and links from data models
        var jointNodes = (0, _dataUtils.createJointNodes)(data.nodes, _parameters);
        var jointLinks = (0, _dataUtils.createJointLinks)(data.links, jointNodes, _parameters);

        (0, _dataProcessing.createAspectRelations)(jointNodes);

        // Update data container by new nodes and links
        return new _dataContainer3.default({
            nodes: jointNodes,
            links: jointLinks
        }, _parameters);
    }

    /**
     * Initializes (or refreshes if not the first time)
     * the LineageGram - Creates (Refreshes) the main views.
     * @private
     */
    function _createComponents() {
        var emptyDataContainer = new _dataContainer3.default({
            nodes: [],
            links: []
        }, _parameters);
        var emptyList = [];
        // Creates the first view - LineageDiagram
        _createLineageDiagram(emptyDataContainer, emptyList);
        // Creates a sigma graph map on the private root.
        // _createMap(emptyDataContainer, emptyList);
        // Creates the second view - BirdEye (Historically - SigmaPathView)
        _createBirdEye(emptyDataContainer);
        _createDerivationMap(_dataProvider);

        _addHoverHandler();
    }

    /**
     * Updates (or refreshes if not the first time)
     * the LineageGram - Creates (Refreshes) the main views.
     * @private
     */
    function _updateComponents(dataContainer, viewFrames) {
        // Updates the first view - LineageDiagram
        _updateLineageDiagram(dataContainer, viewFrames);
        // Updates a sigma graph map on the private root.
        _updateMap(dataContainer, _lineageDiagram.getViewFrames());
        // Updates the second view - BirdEye (Historically - SigmaPathView)
        _updateBirdEye(dataContainer);

        _zoomToFit();
    }

    // Inner functions
    // ==============================================
    function _createLineageDiagram(dataContainer, viewFrames) {
        _lineageDiagram = new _lineageDiagram3.default({
            graphPlace: _base.lineageDiagram,
            dataContainer: dataContainer,
            viewFrames: viewFrames,
            fullScreenMode: _parameters.fullScreenMode
        }, _parameters);

        _lineageDiagram.on('selected-element-changed', function (eventObject) {
            if (_state !== 'completed') return;

            if (_currentView === 'lineageDiagram' && _state === 'completed') {
                if (_graphMap) _graphMap.setSelectedElement(eventObject);
                _selectedElement = (0, _dataUtils.getBaseElement)(eventObject);
                self.trigger('selected-element-changed', _getModel(_selectedElement));
            }
        });

        _lineageDiagram.on('scale-changed', function (newScale) {
            if (_state !== 'completed') return;

            if (_graphMap) _graphMap.redraw({
                viewFrames: _lineageDiagram.getViewFrames(),
                scale: newScale
            });
            self.trigger('scale-value-changed', {
                min: _parameters.scaleBounds.min,
                max: _parameters.scaleBounds.max,
                cur: _lineageDiagram.scale()
            });
        });

        _lineageDiagram.on('view-frames-state-changed', function (viewFrames) {
            if (_state !== 'completed') return;

            if (_graphMap) {
                _graphMap.redraw({ viewFrames: viewFrames });
            }
            self.trigger('view-frame-state-changed', viewFrames);
        });

        _lineageDiagram.on('view-frames-size-or-position-changed', function (viewFrames) {
            if (_state !== 'completed') return;

            if (_graphMap) {
                _graphMap.redraw({ viewFrames: viewFrames });
            }
        });

        _lineageDiagram.on('nodes-position-changed', function () {
            if (_state !== 'completed') return;

            if (_graphMap) {
                _graphMap.redraw();
            }
            _birdEye.redraw();
        });

        _lineageDiagram.on('cell-double-click', function (eventObject) {
            if (_state !== 'completed') return;

            if (_currentView === 'lineageDiagram') {
                if (eventObject instanceof graphElements.Link || eventObject instanceof graphElements.TerminationLink) {
                    _lineageDiagram.setSelectedElement(eventObject);
                    var link = eventObject.originalLink || eventObject;
                    _showDerivationMap(link);
                }
            }
        });

        _lineageDiagram.on('link-options-click', function (event) {
            if (_state !== 'completed') return;

            var link = event.link;
            var linkType = event.linkType;
            if (_currentView === 'lineageDiagram') {
                _showDerivationMap(link, linkType);
            }
        });
    }

    function _updateLineageDiagram(dataContainer, viewFrames) {
        _lineageDiagram.setData(dataContainer, viewFrames);
        _lineageDiagram.scale(_parameters.defaultScale);
    }

    function _addHoverHandler() {
        // Init the tooltip tool for termintation nodes.
        new joint.ui.Tooltip({
            rootTarget: document.body,
            target: '.termination-node',
            direction: 'auto',
            padding: 15,
            content: function content(cell) {
                return cell.getElementsByTagName('text')[0].attributes.tooltip.value;
            }
        });

        new joint.ui.Tooltip({
            rootTarget: document.body,
            target: '.tq-lg-short-label',
            direction: 'auto',
            padding: 15,
            content: function content(cell) {
                return cell.getElementsByTagName('text')[0].attributes.tooltip.value;
            }
        });
    }

    function _createDerivationMap(dataProvider) {
        _derivationMapPanel = new _visualizationsLibrary2.default.FlyingPanel({
            baseElement: _base.derivationMap,
            active: false,
            header: 'Derivation Map',
            emptyBody: false,
            size: { width: 'calc(100% - 200px)', height: 'calc(100% - 200px)' },
            position: { x: '100px', y: '100px' },
            body: '',
            resizable: true
        });

        _derivationMapPanel.on('size-changed', function () {
            return _derivationMap.resetFocus();
        });

        _derivationMap = new _derivationMap3.default({
            rootElement: _derivationMapPanel.rootHtml.querySelector('.tq-ui-body_container'),
            dataProvider: dataProvider
        }, _parameters.derivationMap);

        self.trigger('derivation-map-state-changed');
        self.trigger('derivation-map-state-init', _derivationMap);
    }

    function _createBirdEye(dataContainer) {
        _birdEye = new _birdEye3.default({
            el: _base.sigmaGraph,
            scale: _lineageDiagram.scale(),
            dataContainer: dataContainer
        }, _parameters);

        _birdEye.on('selected-element-changed', function (eventObject) {
            if (_state !== 'completed') return;

            if (_currentView === 'birdEye') {
                if (_graphMap) _graphMap.setSelectedElement(eventObject);
                _selectedElement = (0, _dataUtils.getBaseElement)(eventObject);
                self.trigger('selected-element-changed', _getModel(_selectedElement));
            }
        });

        _birdEye.on('cell-double-click', function (eventObject) {
            if (_state !== 'completed') return;

            if (_currentView === 'birdEye') {
                if (eventObject instanceof graphElements.Link || eventObject instanceof graphElements.TerminationLink) {
                    _birdEye.setSelectedElement(eventObject);
                    var links = eventObject.originalLink || eventObject;
                    _showDerivationMap(links);
                }
            }
        });
    }

    function _updateBirdEye(dataContainer) {
        _birdEye.setData(dataContainer);
    }

    /**
     * Creates the map If not created.
     * @private
     * @param {DataContainer} dataContainer
     * @param {ViewFramePublicModel[]} viewFrames
     * @returns {ViewFrame[]}
     */
    function _createMap(dataContainer, viewFrames) {
        if (_base.mapHTMLElement) {
            _graphMap = new _graphMap3.default({
                el: _base.mapHTMLElement,
                scale: _lineageDiagram.scale(),
                viewFrames: viewFrames,
                dataContainer: dataContainer
            }, _parameters);

            _graphMap.on('selected-element-changed', function (node) {
                if (_state !== 'completed') return;

                if (_currentView === 'lineageDiagram') {
                    var nodeIsInvisible = _lineageDiagram.getVisibleNodes().indexOf(node) === -1;
                    _lineageDiagram.setSelectedElement(node, nodeIsInvisible);
                }
                if (_currentView === 'birdEye') _birdEye.setSelectedElement(node);

                _selectedElement = (0, _dataUtils.getBaseElement)(node);
                self.trigger('selected-element-changed', _getModel(_selectedElement));
            });

            _graphMap.on('view-frames-position-changed', function (viewFrames) {
                if (_state !== 'completed') return;

                if (viewFrames.length === 0) return;
                var index = 0;

                recursion(viewFrames[index++]);

                function recursion(viewFrame) {
                    _lineageDiagram.positionViewPort(viewFrame, viewFrame.viewPortPosition, _parameters.animation, function () {
                        if (viewFrame[index]) {
                            recursion(viewFrames[index++]);
                        }
                    });
                }
            });
        }

        return _graphMap;
    }

    /**
     * Updates the map.
     * @private
     * @param {DataContainer} dataContainer
     * @param {ViewFramePublicModel[]} viewFrames
     * @returns {ViewFrame[]}
     */
    function _updateMap(dataContainer, viewFrames) {
        if (_graphMap) {
            _graphMap.setData(dataContainer, viewFrames);
        } else {
            _createMap(dataContainer, viewFrames);
        }
    }

    /**
     *
     * @param {Link|Node|TerminationLink|TerminationNode} element
     * @returns {PublicNodeModel|PublicLinkModel}
     */
    function _getModel(element) {
        if (!element) return;

        var elementModel = _.cloneDeep(element.model);
        elementModel.blured = Boolean(element.get('blured'));
        elementModel.highlighted = Boolean(element.get('highlighted'));

        if (element instanceof graphElements.Node) {
            elementModel.diagramType = 'node';
        } else if (element instanceof graphElements.Link) {
            elementModel.source = elementModel.sourceType;
            elementModel.target = elementModel.targetType;
            delete elementModel.sourceType;
            delete elementModel.targetType;
            elementModel.diagramType = 'link';
        }
        return elementModel;
    }

    /**
     * Opens derivation map window.
     * @param {Link} link
     * @param {string} linkType
     * @private
     */
    function _showDerivationMap(link, linkType) {
        if (link instanceof graphElements.Link) {
            var nodeMap = _dataContainer.maps.nodeMap;
            _derivationMap.openWithRelation({
                source: nodeMap[link.model.source].model,
                target: nodeMap[link.model.target].model,
                linkType: linkType
            });
            _derivationMapPanel.show();
        }
    }

    /**
     * Sets state of indicator
     * @private
     * @param {string} state - fetching | rendering | completed | error
     * @param {string} message - Custom message
     */
    function _setDiagramState(state, message) {
        _state = state;

        if (state === 'fetching') {
            _progressScreen.setState('active', message || 'Fetching data');
        } else if (state === 'rendering') {
            _progressScreen.setState('active', message || 'Rendering graph');
        } else if (state === 'completed') {
            _progressScreen.setState('completed');
        } else if (state === 'error') {
            _progressScreen.setState('error', message || 'Error has occurred!');
        }
        self.trigger('diagram-state-changed', state);
    }

    /**
     * Creates html markup.
     * @private
     * @param {HTMLElement} htmlNode - Root node for markup
     * @returns {Object.<string, HTMLElement>} - Map of html elements
     */
    function _createBase(htmlNode) {
        htmlNode.innerHTML = '';
        htmlNode.tabIndex = 1;

        var baseDiv = document.createElement('DIV');
        baseDiv.className = 'tq_lineage';
        baseDiv.id = 'tq_lineage';
        htmlNode.appendChild(baseDiv);

        var lineageDiagram = document.createElement('DIV');
        lineageDiagram.className = 'tq_lineage__graph';
        lineageDiagram.id = 'tq_lineage-graph';
        baseDiv.appendChild(lineageDiagram);

        var sigmaGraph = document.createElement('DIV');
        sigmaGraph.className = 'tq_lineage__sigma_graph';
        sigmaGraph.id = 'tq_lineage-sigma-graph';
        baseDiv.appendChild(sigmaGraph);

        var derivationMap = document.createElement('DIV');
        baseDiv.appendChild(derivationMap);

        return {
            container: htmlNode,
            baseDiv: baseDiv,
            lineageDiagram: lineageDiagram,
            sigmaGraph: sigmaGraph,
            derivationMap: derivationMap,
            mapHTMLElement: _getMapHTML(_parameters.mapRootHtml)
        };
    }

    /**
     * @private
     * Creates html markup for map.
     * @param {string|HTMLElement} mapRootHtml - ID of root element or HTMLElement
     * @returns {HTMLElement}
     */
    function _getMapHTML(mapRootHtml) {
        var mapRootHtmlHtml = void 0;
        if (typeof mapRootHtml === 'string') {
            mapRootHtmlHtml = document.getElementById(mapRootHtml);
        } else if ((typeof mapRootHtml === 'undefined' ? 'undefined' : _typeof(mapRootHtml)) === 'object') {
            mapRootHtmlHtml = mapRootHtml;
        } else {
            return {};
        }

        var mapHTMLElement = void 0;
        if (mapRootHtmlHtml) {
            // check element
            // Clear a content of the map root html element
            mapRootHtmlHtml.innerHTML = '';
            // Create a private root for map into the public root.
            // (User can change style of public root)
            mapHTMLElement = document.createElement('DIV');
            mapHTMLElement.className = 'tq-lg__map';
            mapRootHtmlHtml.appendChild(mapHTMLElement); // adding the private root into the public
        }
        return mapHTMLElement;
    }

    /**
     * @private
     * Makes the view-1 visible and the view-2 invisible.
     * @fires current-view-changed
     */
    function _showSigmaGraph() {
        _base.sigmaGraph.style.opacity = 1;
        _base.sigmaGraph.style.pointerEvents = 'auto';

        _base.lineageDiagram.style.opacity = 0;
        _base.lineageDiagram.style.pointerEvents = 'none';

        if (_state === 'completed') {
            if (_currentView !== 'none') {
                _birdEye.setSelectedElement(_lineageDiagram.getSelectedElement());
                _birdEye.refresh();
            } else {
                _lineageDiagram.resize();
                _birdEye.sigmaGraph.refresh();
            }
        }

        _currentView = 'birdEye';
        self.trigger('current-view-changed', _currentView);
    }

    /**
     * @private
     * Makes the view-2 visible and the view-1 invisible.
     * @fires current-view-changed
     */
    function _showJointGraph() {
        _base.sigmaGraph.style.opacity = 0;
        _base.sigmaGraph.style.pointerEvents = 'none';

        _base.lineageDiagram.style.opacity = 1;
        _base.lineageDiagram.style.pointerEvents = 'auto';

        if (_state === 'completed') {
            if (_currentView !== 'none') {
                if (_birdEye.selectedElement) {
                    var visibleNodes = _lineageDiagram.getVisibleNodes();
                    var isSelectedNode = _birdEye.selectedElement instanceof graphElements.Node;
                    var nodeIsInvisible = visibleNodes.indexOf(_birdEye.selectedElement) === -1;
                    var isSelectedLink = _birdEye.selectedElement instanceof graphElements.Link;
                    var allOfTheEndsIsInvisible = visibleNodes.indexOf(_dataContainer.maps.nodeMap[_birdEye.selectedElement.model.source]) === -1;
                    var focusOn = isSelectedNode && nodeIsInvisible || isSelectedLink && allOfTheEndsIsInvisible;

                    _lineageDiagram.setSelectedElement(_birdEye.selectedElement, focusOn);
                } else {
                    _lineageDiagram.redraw();
                }
            } else {
                _lineageDiagram.resize();
                _lineageDiagram.redraw();
            }
        }

        _currentView = 'lineageDiagram';
        self.trigger('current-view-changed', _currentView);
    }

    /**
     * @private
     * Makes the view-2 and the view-1 invisible.
     * @fires current-view-changed
     */
    function _hideViews() {
        // _base.container.className = 'tq_lineage_disable';
        _base.sigmaGraph.style.opacity = 0;
        _base.sigmaGraph.style.pointerEvents = 'none';
        _base.lineageDiagram.style.opacity = 0;
        _base.lineageDiagram.style.pointerEvents = 'none';

        _currentView = 'none';
        self.trigger('current-view-changed', _currentView);
    }
}
exports.default = LineageGram;

},{"./data/dataContainer":27,"./data/dataProcessing":28,"./data/resourceProvider":30,"./jointViews/derivationMap/derivationMap":41,"./jointViews/graphElements/elements":46,"./jointViews/lineageDiagram":51,"./layout/layout":56,"./sigmaViews/birdEye":60,"./sigmaViews/graphMap":61,"./stateStorage":64,"./subscriptionAPI/subscribeable":65,"./utils/dataUtils":66,"lodash":"lodash","rappid":"rappid","visualizations-library":5}],59:[function(require,module,exports){
'use strict';

var _lineageGram = require('./lineageGram');

var LineageGram = _interopRequireWildcard(_lineageGram);

var _defaultDataProvider = require('./data/defaultDataProvider');

var _defaultDataProvider2 = _interopRequireDefault(_defaultDataProvider);

var _infoPanel = require('./htmlUI/infoPanel');

var _infoPanel2 = _interopRequireDefault(_infoPanel);

var _optionsPanel = require('./htmlUI/optionsPanel');

var _optionsPanel2 = _interopRequireDefault(_optionsPanel);

var _map = require('./htmlUI/map');

var _map2 = _interopRequireDefault(_map);

var _defaultUI = require('./htmlUI/defaultUI');

var _defaultUI2 = _interopRequireDefault(_defaultUI);

var _derivationMap = require('./jointViews/derivationMap/derivationMap');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

require('es6-promise').Promise;
require('whatwg-fetch');

module.exports = {
    LineageGram: LineageGram.LineageGram,
    getDefaultParametersSet: LineageGram.getDefaultParametersSet,
    DefaultDataProvider: _defaultDataProvider2.default,
    DerivationMap: _derivationMap.DerivationMap,
    uiUtils: {
        DefaultUI: _defaultUI2.default,
        Map: _map2.default,
        InfoPanel: _infoPanel2.default,
        OptionsPanel: _optionsPanel2.default
    }
};

},{"./data/defaultDataProvider":29,"./htmlUI/defaultUI":31,"./htmlUI/infoPanel":34,"./htmlUI/map":35,"./htmlUI/optionsPanel":36,"./jointViews/derivationMap/derivationMap":41,"./lineageGram":58,"es6-promise":1,"whatwg-fetch":25}],60:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BirdEye = BirdEye;

var _sigmaBase = require('./sigmaBase');

var _sigmaBase2 = _interopRequireDefault(_sigmaBase);

var _elements = require('../jointViews/graphElements/elements');

var graphElements = _interopRequireWildcard(_elements);

var _lineageDiagramUtils = require('../utils/lineageDiagramUtils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** 
 * @private
 * @class
 * Mini map in the right-bottom corner,
 * which shows the full graph with viewFrame's positions without links
 * @augments SigmaBase
*/
function BirdEye(options, parameters) {
    var self = this;
    var _colors = parameters.colors;
    var _path = null;

    _sigmaBase2.default.apply(self, [options, parameters]);

    var oldSetSelectedElement = self.setSelectedElement;
    self.setSelectedElement = function (element) {
        var selectedElement = void 0;
        if (element instanceof graphElements.Node || element instanceof graphElements.TerminationNode) {
            selectedElement = element.originalNode || element;
        } else if (element instanceof graphElements.Link) {
            var link = element.originalLink || element;
            selectedElement = link;
        } else {
            selectedElement = null;
        }

        if (self.selectedElement !== selectedElement) {
            if (selectedElement) {
                _path = (0, _lineageDiagramUtils.getPath)(selectedElement, self._dataContainer);
            } else {
                _path = null;
            }
        }
        oldSetSelectedElement.call(self, selectedElement);
    };

    self._refreshNodes = function () {
        var nodeMap = self._dataContainer.maps.nodeMap;

        self.sigmaGraph.graph.nodes().forEach(function (sigmaNode) {
            if (nodeMap[sigmaNode.id]) {
                var node = nodeMap[sigmaNode.id];
                var model = node.model;
                sigmaNode.x = model.position.x;
                sigmaNode.y = model.position.y;

                sigmaNode.color = self.selectedElement && (node.id === self.selectedElement.id || self.selectedElement.aspects && self.selectedElement.aspects.filter(function (a) {
                    return a.id === node.id;
                }).length > 0) ? _colors['selected'] : !_path || _path[node.id] ? _colors[model.typeId] : _colors['blured'];
            }
        });
    };

    self._refreshViewFrames = function () {};

    self._refreshLinks = function () {
        self.sigmaGraph.graph.edges().forEach(function (l) {
            l.size = self.selectedElement && l.id === self.selectedElement.id ? 5 : 1, l.color = !_path || _path[l.id] ? self.selectedElement && l.id === self.selectedElement.id ? _colors['selected'] : self._aspectLinks[l.id] ? _colors['aspectLink'] : _colors['link'] : _colors['blured'];
        });
    };

    self._initialize();
}

BirdEye.prototype = Object.create(_sigmaBase2.default.prototype);

exports.default = BirdEye;

},{"../jointViews/graphElements/elements":46,"../utils/lineageDiagramUtils":68,"./sigmaBase":62}],61:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GraphMap = GraphMap;

var _sigmaBase = require('./sigmaBase');

var _sigmaBase2 = _interopRequireDefault(_sigmaBase);

var _elements = require('../jointViews/graphElements/elements');

var graphElements = _interopRequireWildcard(_elements);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** 
 * @private
 * @class
 * Mini map in the right-bottom corner,
 * which shows the full graph with viewFrame's positions without links
 * @augments SigmaBase
 * @fires view-frames-position-changed (params: ViewFramePublicModel[])
*/
function GraphMap(options, parameters) {
    var self = this;
    var _viewFramesMap = {};
    options.viewFrames.forEach(function (vf) {
        return _viewFramesMap[vf.id] = vf;
    });

    _sigmaBase2.default.apply(self, [options, parameters]);

    self._getData = function () {
        return { nodes: self._dataContainer.nodes, links: [] };
    };

    /**
     * Redefinition
     */
    var oldSetSelectedElement = self.setSelectedElement;
    self.setSelectedElement = function (element) {
        var selectedElement = void 0;
        if (element instanceof graphElements.Node || element instanceof graphElements.TerminationNode) {
            selectedElement = element.originalNode || element;
        } else if (element instanceof graphElements.Link) {
            var link = element.originalLink || element;
            selectedElement = link;
        } else {
            selectedElement = null;
        }

        var graph = self.sigmaGraph.graph;
        if (self.selectedElement instanceof graphElements.Link) {
            graph.dropEdge(self.selectedElement.id);
        }
        if (selectedElement instanceof graphElements.Link) {
            graph.addEdge(self._createLink(selectedElement));
        }
        oldSetSelectedElement.call(self, selectedElement);
    };

    var overrideRedraw = self.redraw;
    self.redraw = function (renderOptions) {
        overrideRedraw(renderOptions);
        renderOptions = renderOptions || {};
        if (renderOptions.viewFrames) renderOptions.viewFrames.forEach(function (vf) {
            return _viewFramesMap[vf.id] = vf;
        });
    };

    var overridedSetData = self.setData;
    self.setData = function (dataContainer, viewFrames) {
        overridedSetData(dataContainer, viewFrames);
        _viewFramesMap = {};
        viewFrames.forEach(function (vf) {
            return _viewFramesMap[vf.id] = vf;
        });
    };

    /**
     * Updates viewFrames state. 
     * @param {ViewFramePublicModel} viewFrames
     */
    var _oldImplementation = self._refreshViewFrames;
    self._refreshViewFrames = function (viewFrames) {
        _oldImplementation(viewFrames);
        viewFrames.forEach(function (vf) {
            return _viewFramesMap[vf.id] = vf;
        });
    };

    /**
     * Redefinition.
     */
    self._subscribeOnEvents = function () {
        self.sigmaGraph.bind('clickStage', function (e) {
            var globalClickPoint = _connvertPoint(e);
            var viewFrames = Object.keys(_viewFramesMap).map(function (key) {
                return _viewFramesMap[key];
            });
            for (var i = 0; i < viewFrames.length; i++) {
                var viewFrame = viewFrames[i];
                if (!viewFrame.active) continue;

                var bounds = {
                    minX: viewFrame.viewPortPositionBounds.minX,
                    minY: viewFrame.viewPortPositionBounds.minY,
                    maxX: viewFrame.viewPortPositionBounds.maxX + viewFrame.viewPortBounds.width,
                    maxY: viewFrame.viewPortPositionBounds.maxY + viewFrame.viewPortBounds.height
                };

                var pointHitsTheBounds = bounds.minX <= globalClickPoint.x && globalClickPoint.x <= bounds.maxX && bounds.minY <= globalClickPoint.y && globalClickPoint.y <= bounds.maxY;
                if (pointHitsTheBounds) {
                    var viewFrameOptions = {
                        id: viewFrame.id,
                        viewPortPosition: {
                            x: globalClickPoint.x - viewFrame.size.width / 2,
                            y: globalClickPoint.y - viewFrame.size.height / 2
                        }
                    };
                    self.trigger('view-frames-position-changed', [[viewFrameOptions]]);
                }
            }
        });

        self.sigmaGraph.bind('clickNode', function (evt) {
            var node = evt.data.node ? self._dataContainer.maps.nodeMap[evt.data.node.id] : null;
            self.setSelectedElement(node);
            self.trigger('selected-element-changed', node);
        });

        self.sigmaGraph.bind('clickEdge', function (evt) {
            var link = evt.data.edge ? self._dataContainer.maps.linkMap[evt.data.edge.id] : null;
            self.setSelectedElement(link);
            self.trigger('selected-element-changed', link);
        });
    };

    /** 
     * Calculates sigma paper point to joint paper point.
     * @param {
     *  data: {
     *      cptor: {
     *          clientX,
     *          clientY
     *      }
     *  }
     * } event
    */
    function _connvertPoint(event) {
        var renderer = self.sigmaGraph.renderers[0];
        var _prefix = renderer.options.prefix;
        return executeNodeMouseMove();

        function executeNodeMouseMove() {
            var offset = _calculateOffset(renderer.container),
                x = event.data.captor.clientX - offset.left,
                y = event.data.captor.clientY - offset.top,
                cos = Math.cos(self.sigmaGraph.camera.angle),
                sin = Math.sin(self.sigmaGraph.camera.angle),
                nodes = self.sigmaGraph.graph.nodes(),
                ref = [];

            // Getting and derotating the reference coordinates.
            for (var i = 0; i < 2; i++) {
                var n = nodes[i];
                var aux = {
                    x: n.x * cos + n.y * sin,
                    y: n.y * cos - n.x * sin,
                    renX: n[_prefix + 'x'],
                    renY: n[_prefix + 'y']
                };
                ref.push(aux);
            }

            // Applying linear interpolation.
            // if the nodes are on top of each other, we use the camera ratio to interpolate
            if (ref[0].x === ref[1].x && ref[0].y === ref[1].y) {
                var xRatio = ref[0].renX === 0 ? 1 : ref[0].renX;
                var yRatio = ref[0].renY === 0 ? 1 : ref[0].renY;
                x = ref[0].x / xRatio * (x - ref[0].renX) + ref[0].x;
                y = ref[0].y / yRatio * (y - ref[0].renY) + ref[0].y;
            } else {
                xRatio = (ref[1].renX - ref[0].renX) / (ref[1].x - ref[0].x);
                yRatio = (ref[1].renY - ref[0].renY) / (ref[1].y - ref[0].y);

                // if the coordinates are the same, we use the other ratio to interpolate
                if (ref[1].x === ref[0].x) {
                    xRatio = yRatio;
                }

                if (ref[1].y === ref[0].y) {
                    yRatio = xRatio;
                }

                x = (x - ref[0].renX) / xRatio + ref[0].x;
                y = (y - ref[0].renY) / yRatio + ref[0].y;
            }

            return { x: x * cos - y * sin, y: y * cos + x * sin };
        }
    }

    // Calculates the global offset of the given element more accurately than
    // element.offsetTop and element.offsetLeft.
    function _calculateOffset(element) {
        var style = window.getComputedStyle(element);
        var getCssProperty = function getCssProperty(prop) {
            return parseInt(style.getPropertyValue(prop).replace('px', '')) || 0;
        };
        return {
            left: element.getBoundingClientRect().left + getCssProperty('padding-left'),
            top: element.getBoundingClientRect().top + getCssProperty('padding-top')
        };
    }

    self._initialize();
}
GraphMap.prototype = Object.create(_sigmaBase2.default.prototype);

exports.default = GraphMap;

},{"../jointViews/graphElements/elements":46,"./sigmaBase":62}],62:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SigmaBase = SigmaBase;

var _sigma = require('sigma');

var _sigma2 = _interopRequireDefault(_sigma);

var _sigmaRenderers = require('./sigmaPlagins/sigma.renderers.snapshot/sigma.renderers.snapshot');

var SigmaSnapshotPlugin = _interopRequireWildcard(_sigmaRenderers);

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _elements = require('../jointViews/graphElements/elements');

var graphElements = _interopRequireWildcard(_elements);

var _fileSaverjs = require('file-saverjs');

var _fileSaverjs2 = _interopRequireDefault(_fileSaverjs);

var _dataUtils = require('../utils/dataUtils');

var _utils = require('../utils/utils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

SigmaSnapshotPlugin.usePlugin(_sigma2.default);

/** 
 * @private
 * @class
 * It's the base class for sigma views.
 * 
 * Constructor parameters:
 * ========================================
 * @param {
 *  dataContainer: DataContainer
 *  viewFrames: ViewFramePublicModel[]
 *  el: HTMLElement
 *  selectedElement: Node|Link
 *  scale:number
 * } options
 * @param {Parameters} parameters - parameters set
 * 
 * Public properties:
 * ========================================
 * selectedElement: Node|Link
 * 
 * Public methods:
 * ========================================
 * setSelectedElement: (element: Node|Link) => void
 * setData: (dataContainer: DataContainer, viewFrames: ViewFrame[]) => void
 * setScale: (scale: number) => void
 * refresh: () => void
 * export: (name?: string) => void
 * print: () => void
 * redraw: () => void
 * ----------------------------------------
 * on (event: string, callback: function): void
 * unsubscribe (callback: function): void
 * trigger (event: string, parameters: any): void
 * 
 * Events:
 * ========================================
 * @fires selected-element-changed (params: Node|Link)
 * @fires cell-double-click (params: Node|Link)
*/
function SigmaBase(options, parameters) {

    _subscribeable2.default.apply(this); // make this class Subscribable

    var self = this;
    var _colors = parameters.colors;

    var _maxNodeSize = 0;
    var _rootElement = void 0;
    var _sigmaFrames = {};

    self._aspectLinks = {};
    self.selectedElement;
    self._dataContainer; // to override


    /**
     * Runs initialization. It's executed after creation by descendant
     */
    self._initialize = function () {
        _initialize(options.dataContainer, options.viewFrames, options.el, options.selectedElement, options.scale);
    };

    /**
     * It's kind of constructor, which called after creation the object.
     * @param {DataContainer} dataContainer
     * @param {Array of ViewFrame} viewFrames
     * @param {HTMLElement} rootElement
     * @param {Node|Link} selectedElement
     * @param {number} scale
    */
    function _initialize(dataContainer, viewFrames, rootElement, selectedElement) {
        _rootElement = rootElement;
        self.selectedElement = selectedElement;
        viewFrames = viewFrames || [];
        self._dataContainer = dataContainer;

        var data = self._getData();
        var g = {
            nodes: [],
            edges: []
        };

        data.nodes.forEach(function (node) {
            var newNode = self._createNode(node);
            g.nodes.push(newNode);
        });

        data.links.forEach(function (link) {
            var newLink = self._createLink(link);
            g.edges.push(newLink);
        });

        var aspectLinks = _createAspectLinks(data.nodes);
        aspectLinks.forEach(function (al) {
            g.edges.push(al);
        });

        _maxNodeSize = _getNodeSize();

        self.sigmaGraph = new _sigma2.default({
            graph: g,
            container: _rootElement,
            settings: {
                minNodeSize: 0,
                maxNodeSize: _maxNodeSize,
                nodesPowRatio: 1,
                enableEdgeHovering: true,
                edgeHoverColor: 'edge',
                defaultEdgeHoverColor: '#000',
                edgeHoverSizeRatio: 4,
                edgeHoverExtremities: true,
                autoResize: false,
                clone: false,
                doubleClickZoomingRatio: 1
            }
        });
        self._subscribeOnEvents();
        _maxNodeSize = _getNodeSize();
        self.sigmaGraph.settings('maxNodeSize', _maxNodeSize);

        viewFrames.forEach(function (viewFrame) {
            if (viewFrame.active) {
                _addViewFrame(viewFrame);
            } else {
                _sigmaFrames[viewFrame.id] = _createSigmaFrame(viewFrame);
            }
        });

        self.sigmaGraph.refresh();
    }

    /**
     * Exports graph to png file
     * @param {string} diagramName
    */
    self.export = function (diagramName) {
        var fileName = diagramName || 'LG_bird_eye_snapshot_' + (0, _dataUtils.date2String)(new Date());
        var data = self.sigmaGraph.renderers[0].snapshot({
            format: 'png',
            download: false,
            background: 'transparent',
            labels: true,
            filename: fileName
        });

        (0, _fileSaverjs2.default)((0, _dataUtils.png2Blob)(data), fileName + '.png');
    };

    /**
     * Exports graph to pdf file
     * @param {string} diagramName
    */
    self.print = function (diagramName) {
        var fileName = diagramName || 'LG_bird_eye_snapshot_' + (0, _dataUtils.date2String)(new Date());
        var data = self.sigmaGraph.renderers[0].snapshot({
            format: 'png',
            download: false,
            background: 'transparent',
            labels: true,
            filename: fileName
        });
        var printWindow = window.open('', undefined, 'width=1280,height=720');
        if (printWindow) {
            printWindow.document.write('\n                <html>\n                    <body>\n                        <img src="' + data + '"/>\n                    </body>\n                </html>\n            ');
            printWindow.document.querySelector('img').onload = function () {
                printWindow.document.close();
                printWindow.print();
            };
        } else {
            alert('You should unblock popup windows for the current url to be able to print this diagram!');
        }
    };

    /**
     * Sets selected element.
     * @param {Node|Link} element
    */
    self.setSelectedElement = function (element) {
        var selectedElement = void 0;
        if (element instanceof graphElements.Node || element instanceof graphElements.TerminationNode) {
            selectedElement = element.originalNode || element;
        } else if (element instanceof graphElements.Link) {
            var link = element.originalLink || element;
            selectedElement = link;
        } else {
            selectedElement = null;
        }

        var refresh = self.selectedElement !== selectedElement;
        self.selectedElement = selectedElement;
        if (refresh) self.redraw();
    };

    /**
     * Sets new data container
     * @param {DataContainer} dataContainer
     * @param {ViewFramePublicModel[]} viewFrames
    */
    self.setData = function (dataContainer, viewFrames) {
        self.selectedElement = null;
        self._dataContainer = dataContainer;
        viewFrames = viewFrames || [];

        var data = self._getData();

        self.sigmaGraph.graph.clear();
        _maxNodeSize = _getNodeSize();
        self.sigmaGraph.settings('maxNodeSize', _maxNodeSize);

        data.nodes.forEach(function (node) {
            var newNode = self._createNode(node);
            self.sigmaGraph.graph.addNode(newNode);
        });

        viewFrames.forEach(function (viewFrame) {
            var frame = _createSigmaFrame(viewFrame);
            _sigmaFrames[viewFrame.id] = frame;
            if (viewFrame.active) {
                _addViewFrame(viewFrame);
            } else {
                _sigmaFrames[viewFrame.id] = _createSigmaFrame(viewFrame);
            }
        });

        var aspectLinks = _createAspectLinks(data.nodes);
        aspectLinks.forEach(function (al) {
            self.sigmaGraph.graph.addEdge(al);
        });

        data.links.forEach(function (link) {
            var newLink = self._createLink(link);
            self.sigmaGraph.graph.addEdge(newLink);
        });

        self.sigmaGraph.refresh();
        self.redraw();
    };

    var debouncer = void 0;
    /**
     * Redraws all graph. Mainly - updates colors of elements
     * @param {viewFrames, scale, nodes, fullScreenMode} options
     */
    self.redraw = function (options) {
        options = options || {};

        _maxNodeSize = _getNodeSize();
        self.sigmaGraph.settings('maxNodeSize', _maxNodeSize);

        cancelAnimationFrame(debouncer);
        debouncer = requestAnimationFrame(function () {
            self._refreshNodes();
            self._refreshLinks();

            if (options.viewFrames) {
                self._refreshViewFrames(options.viewFrames);
            }

            self.sigmaGraph.refresh();
        });
    };

    // can be overrided
    self.refresh = function () {
        self.redraw();
    };

    /**
     * Updates links states. 
     */
    self._refreshLinks = function () {
        var edges = self.sigmaGraph.graph.edges();
        edges.forEach(function (l) {
            if (l.id.indexOf('__top') === -1 && l.id.indexOf('__bottom') === -1 && l.id.indexOf('__left') === -1 && l.id.indexOf('__right') === -1) {
                l.size = self.selectedElement && l.id === self.selectedElement.id ? 5 : 1, l.color = self.selectedElement && l.id === self.selectedElement.id ? _colors['selected'] : self._aspectLinks[l.id] ? _colors['aspectLink'] : _colors['link'];
            }
        });
    };

    /**
     * Updates nodes states. 
     */
    self._refreshNodes = function () {
        var nodeMap = self._dataContainer.maps.nodeMap;
        var nodes = self.sigmaGraph.graph.nodes();
        nodes.forEach(function (sigmaNode) {
            if (nodeMap[sigmaNode.id]) {
                var node = nodeMap[sigmaNode.id];
                var position = (0, _utils.getGlobalNodePosition)(node);
                sigmaNode.x = position.x;
                sigmaNode.y = position.y;
                sigmaNode.color = self.selectedElement && (self.selectedElement.id === sigmaNode.id || self.selectedElement.aspects && self.selectedElement.aspects.filter(function (a) {
                    return a.id === sigmaNode.id;
                }).length > 0) ? _colors['selected'] : _colors[node.model.typeId];
            }
        });
    };

    /**
     * Updates viewFrames state. 
     * @param {ViewFramePublicModel[]} viewFrames
     */
    self._refreshViewFrames = function (viewFrames) {
        viewFrames.forEach(function (viewFrame) {
            if (viewFrame.active) {
                var frame = _sigmaFrames[viewFrame.id];
                var points = _getFramesPoints(viewFrame);

                frame.p1.x = points.p1.x;
                frame.p1.y = points.p1.y;

                frame.p2.x = points.p2.x;
                frame.p2.y = points.p2.y;

                frame.p3.x = points.p3.x;
                frame.p3.y = points.p3.y;

                frame.p4.x = points.p4.x;
                frame.p4.y = points.p4.y;

                _addViewFrame(viewFrame);
            } else {
                _removeViewFrame(viewFrame);
            }
        });
    };

    /**
     * Adds viewFrame on the sigma graph.
     * @param {ViewFramePublicModel} viewFrame
     */
    function _addViewFrame(viewFrame) {
        var frame = _sigmaFrames[viewFrame.id] = _sigmaFrames[viewFrame.id] || _createSigmaFrame(viewFrame);
        if (!viewFrame || frame.active) return;

        self.sigmaGraph.graph.addNode(frame.p1);
        self.sigmaGraph.graph.addNode(frame.p2);
        self.sigmaGraph.graph.addNode(frame.p3);
        self.sigmaGraph.graph.addNode(frame.p4);

        self.sigmaGraph.graph.addEdge(frame.top);
        self.sigmaGraph.graph.addEdge(frame.bottom);
        self.sigmaGraph.graph.addEdge(frame.left);
        self.sigmaGraph.graph.addEdge(frame.right);

        frame.active = true;
    }

    /**
     * Removes viewFrame from the sigma graph.
     * @param {ViewFramePublicModel} viewFrame
     */
    function _removeViewFrame(viewFrame) {
        if (!viewFrame || !_sigmaFrames[viewFrame.id].active) return;

        self.sigmaGraph.graph.dropEdge(viewFrame.id + '__top');
        self.sigmaGraph.graph.dropEdge(viewFrame.id + '__bottom');
        self.sigmaGraph.graph.dropEdge(viewFrame.id + '__left');
        self.sigmaGraph.graph.dropEdge(viewFrame.id + '__right');

        self.sigmaGraph.graph.dropNode(viewFrame.id + '__TL');
        self.sigmaGraph.graph.dropNode(viewFrame.id + '__BL');
        self.sigmaGraph.graph.dropNode(viewFrame.id + '__TR');
        self.sigmaGraph.graph.dropNode(viewFrame.id + '__BR');

        _sigmaFrames[viewFrame.id].active = false;
    }

    /**
     * Returns links and nodes.
     * @returns {{Node[], Link[]}}
     */
    self._getData = function () {
        return { nodes: self._dataContainer.nodes, links: self._dataContainer.links };
    };

    /**
     * Creates sigma node from jointjs node.
     * @param {Node} node 
     */
    self._createNode = function (node) {
        var position = (0, _utils.getGlobalNodePosition)(node);
        var model = node.model;
        return {
            id: node.id,
            label: model.label,
            x: position.x,
            y: position.y,
            size: 1,
            color: node === self.selectedElement || self.selectedElement && self.selectedElement.aspects && self.selectedElement.aspects.filter(function (a) {
                return a.id === node.id;
            }).length > 0 ? _colors['selected'] : _colors[model.typeId]
        };
    };

    /**
     * Creates sigma edge from jointjs link.
     * @param {Link} link 
     */
    self._createLink = function (link) {
        return {
            id: link.id,
            source: link.model.source,
            target: link.model.target,
            size: link === self.selectedElement ? 5 : 1,
            color: link === self.selectedElement ? _colors['selected'] : 'black'
        };
    };

    /**
     * Subscribes on events.
     * @fires: selected-element-changed (params: Node|Link)
     * @fires: cell-double-click (params: Node|Link)
     */
    self._subscribeOnEvents = function () {
        self.sigmaGraph.bind('clickNode clickStage', function (e) {
            return _onClick(e, function (event) {
                var node = event.data.node ? self._dataContainer.maps.nodeMap[event.data.node.id] : null;
                if (node || !event.data.captor.isDragging && !node) {
                    self.setSelectedElement(node);
                    self.trigger('selected-element-changed', node);
                }
            }, function (event) {
                var element = event.data.edge ? self._dataContainer.maps.linkMap[event.data.edge.id] : null;
                self.trigger('cell-double-click', element);
            });
        });

        self.sigmaGraph.bind('clickEdge', function (e) {
            return _onClick(e, function (event) {
                var link = event.data.edge ? self._dataContainer.maps.linkMap[event.data.edge.id] : null;
                self.setSelectedElement(link);
                self.trigger('selected-element-changed', link);
            }, function (event) {
                var element = event.data.edge ? self._dataContainer.maps.linkMap[event.data.edge.id] : null;
                self.trigger('cell-double-click', element);
            });
        });
    };

    /**
     * Returns default size for nodes. 
     */
    function _getNodeSize() {
        var result = void 0;
        if (self._dataContainer.nodes.length <= 0) return 0;
        if (self.sigmaGraph) {
            var renderer = self.sigmaGraph.renderers[0] || { width: _rootElement.clientWidth, height: _rootElement.clientHeight };
            if (parameters.elementSize.width > parameters.elementSize.height) {
                result = renderer.width / (parameters.elementSize.width + parameters.layoutStep.x);
            } else {
                result = renderer.height / (parameters.elementSize.height + parameters.layoutStep.y);
            }
        } else {
            result = 5;
        }
        if (self._getNodeSize) return self._getNodeSize(result);else return result;
    }

    /**
     * Creates aspect links.
     * @param {Node[]} nodes
     */
    function _createAspectLinks(nodes) {
        self._aspectLinks = {};
        var linksToReturn = [];
        nodes.forEach(function (node) {
            var aspects = node.aspects;

            aspects.forEach(function (aspect) {
                addLink(node, aspect);
            });
        });

        function addLink(node, aspect) {
            var id1 = node.id + '~#tqLgAspectLink#~' + aspect.id;
            var id2 = aspect.id + '~#tqLgAspectLink#~' + node.id;

            if (!self._aspectLinks[id1] && !self._aspectLinks[id2]) {
                var al = {
                    id: id1,
                    source: node.id,
                    target: aspect.id,
                    color: _colors['aspectLink']
                };
                self._aspectLinks[id1] = al;
                linksToReturn.push(al);
            }
        }

        return linksToReturn;
    }

    /**
     * Creates sigma notation of the joint viewFrame and places on the sigma graph.
     * @param {ViewFramePublicModel} viewFrame
     */
    function _createSigmaFrame(viewFrame) {
        var points = _getFramesPoints(viewFrame);
        var color = viewFrame.borderColor;

        // nodes

        var p1 = {
            id: viewFrame.id + '__TL',
            label: viewFrame.id,
            x: points.p1.x,
            y: points.p1.y,
            size: 0.3,
            color: color
        };

        var p2 = {
            id: viewFrame.id + '__BL',
            label: viewFrame.id,
            x: points.p3.x,
            y: points.p3.y,
            size: 0.3,
            color: color
        };

        var p3 = {
            id: viewFrame.id + '__TR',
            label: viewFrame.id,
            x: points.p2.x,
            y: points.p2.y,
            size: 0.3,
            color: color
        };

        var p4 = {
            id: viewFrame.id + '__BR',
            label: viewFrame.id,
            x: points.p4.x,
            y: points.p4.y,
            size: 0.3,
            color: color
        };

        // Edges

        var top = {
            id: viewFrame.id + '__top',
            source: viewFrame.id + '__TL',
            target: viewFrame.id + '__TR',
            size: 10,
            color: color
        };

        var bottom = {
            id: viewFrame.id + '__bottom',
            source: viewFrame.id + '__BL',
            target: viewFrame.id + '__BR',
            size: 10,
            color: color
        };

        var left = {
            id: viewFrame.id + '__left',
            source: viewFrame.id + '__TL',
            target: viewFrame.id + '__BL',
            size: 10,
            color: color
        };

        var right = {
            id: viewFrame.id + '__right',
            source: viewFrame.id + '__TR',
            target: viewFrame.id + '__BR',
            size: 10,
            color: color
        };

        return {
            p1: p1,
            p2: p2,
            p3: p3,
            p4: p4,

            top: top,
            bottom: bottom,
            left: left,
            right: right,

            active: false
        };
    }

    function _getFramesPoints(viewFrame) {
        var p1 = {
            x: viewFrame.viewPortBounds.minX,
            y: viewFrame.viewPortBounds.minY
        };
        var p2 = { x: p1.x + viewFrame.viewPortBounds.width, y: p1.y };
        var p3 = { x: p1.x, y: p1.y + viewFrame.viewPortBounds.height };
        var p4 = { x: p1.x + viewFrame.viewPortBounds.width, y: p1.y + viewFrame.viewPortBounds.height };

        return {
            p1: p1,
            p2: p2,
            p3: p3,
            p4: p4
        };
    }

    // Fixing the sigma bug with horizontal/vertical lines hovering.
    // ========================================================================
    _sigma2.default.utils.isPointOnSegment = function (x, y, x1, y1, x2, y2, epsilon) {
        // http://stackoverflow.com/a/328122
        var crossProduct = Math.abs((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)),
            d = _sigma2.default.utils.getDistance(x1, y1, x2, y2),
            nCrossProduct = crossProduct / d; // normalized cross product

        return nCrossProduct < epsilon && Math.min(x1, x2) - epsilon <= x && x <= Math.max(x1, x2) + epsilon && Math.min(y1, y2) - epsilon <= y && y <= Math.max(y1, y2) + epsilon;
    };

    var _clicks = 0;
    function _onClick(event, clickCallback, doubleClickCallback) {
        _clicks++;

        if (_clicks >= 2) {
            _clicks = 0;
            doubleClickCallback(event);
        } else if (_clicks === 1) {
            setTimeout(function () {
                if (_clicks === 1) {
                    clickCallback(event);
                }
                _clicks = 0;
            }, 250);
        }
    }
}
exports.default = SigmaBase;

},{"../jointViews/graphElements/elements":46,"../subscriptionAPI/subscribeable":65,"../utils/dataUtils":66,"../utils/utils":69,"./sigmaPlagins/sigma.renderers.snapshot/sigma.renderers.snapshot":63,"file-saverjs":2,"sigma":4}],63:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.usePlugin = usePlugin;
function usePlugin(sigma) {

    /**
     * Sigma Renderer Snapshot Utility
     * ================================
     *
     * The aim of this plugin is to enable users to retrieve a static image
     * of the graph being rendered.
     *
     * Author: Guillaume Plique (Yomguithereal)
     * Version: 0.0.1
     */

    // Terminating if sigma were not to be found
    if (typeof sigma === 'undefined') throw 'sigma.renderers.snapshot: sigma not in scope.';

    // Constants
    var CONTEXTS = ['scene', 'edges', 'nodes', 'labels'],
        TYPES = {
        png: 'image/png',
        jpg: 'image/jpeg',
        gif: 'image/gif',
        tiff: 'image/tiff'
    };

    // Utilities
    function download(dataUrl, extension, filename) {

        // Anchor
        var anchor = document.createElement('a');
        anchor.setAttribute('href', dataUrl);
        anchor.setAttribute('download', filename || 'graph.' + extension);

        // Click event
        var event = document.createEvent('MouseEvent');
        event.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);

        anchor.dispatchEvent(event);
        anchor = undefined;
    }

    // Main function
    function snapshot(params) {
        params = params || {};

        // Enforcing
        if (params.format && !(params.format in TYPES)) throw Error('sigma.renderers.snaphot: unsupported format "' + params.format + '".');

        var self = this,
            webgl = this instanceof sigma.renderers.webgl,
            doneContexts = [];

        // Creating a false canvas where we'll merge the other
        var merged = document.createElement('canvas'),
            mergedContext = merged.getContext('2d'),
            sized = false;

        // Iterating through context
        CONTEXTS.forEach(function (name) {
            if (!self.contexts[name]) return;

            if (params.labels === false && name === 'labels') return;

            var canvas = self.domElements[name] || self.domElements['scene'],
                context = self.contexts[name];

            if (~doneContexts.indexOf(context)) return;

            if (!sized) {
                merged.width = webgl && context instanceof WebGLRenderingContext ? canvas.width / 2 : canvas.width;
                merged.height = webgl && context instanceof WebGLRenderingContext ? canvas.height / 2 : canvas.height;
                sized = true;

                // Do we want a background color?
                if (params.background) {
                    mergedContext.rect(0, 0, merged.width, merged.height);
                    mergedContext.fillStyle = params.background;
                    mergedContext.fill();
                }
            }

            if (context instanceof WebGLRenderingContext) mergedContext.drawImage(canvas, 0, 0, canvas.width / 2, canvas.height / 2);else mergedContext.drawImage(canvas, 0, 0);

            doneContexts.push(context);
        });

        var dataUrl = merged.toDataURL(TYPES[params.format || 'png']);

        if (params.download) download(dataUrl, params.format || 'png', params.filename);

        // Cleaning
        mergedContext = undefined;
        merged = undefined;
        doneContexts = undefined;

        return dataUrl;
    }

    // Extending canvas and webl renderers
    sigma.renderers.canvas.prototype.snapshot = snapshot;
    sigma.renderers.webgl.prototype.snapshot = snapshot;
}
exports.default = usePlugin;

},{}],64:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StateStorage = StateStorage;

var _lodash = require('lodash');

var DEFAULT_DECK_LENGTH = 4;

/**
 * Store states of LG. States is a Diagrams rendered around focusNode.
 * @class
 * @private
 * Constructor parameters
 *  @param {Parameters} parameters

 * Public methods:
 * pushState: () => void
 * getHistory: () => {
 *  states: { nodes: Node[], links: Link[], focusNode: Node }[],
 *  currentIndex: number,
 * }
 * undoState: () => void
 * redoState: () => void
 */
function StateStorage(parameters) {
    var self = this;
    if (!parameters) parameters = {};

    var _stateDeck = [];
    var _maxDeckLength = parameters.deckLength || DEFAULT_DECK_LENGTH;
    var _currentIndex = -1;

    self.pushState = function (state) {
        if (_stateDeck.length - 1 > _currentIndex) {
            _stateDeck.splice(_currentIndex + 1, _stateDeck.length);
        }
        _stateDeck.push(state);
        _check();
        _currentIndex = _stateDeck.length - 1;
    };

    self.updateState = function (state) {
        _stateDeck[_currentIndex] = state;
    };

    self.getHistory = function () {
        return {
            states: (0, _lodash.cloneDeep)(_stateDeck),
            currentIndex: _currentIndex
        };
    };

    self.undoState = function () {
        if (_currentIndex > 0) {
            _currentIndex--;
            return _returnState();
        } else {
            return null;
        }
    };

    self.redoState = function () {
        if (_currentIndex + 1 < _stateDeck.length) {
            _currentIndex++;
            return _returnState();
        } else {
            return null;
        }
    };

    function _returnState() {
        return _stateDeck[_currentIndex];
    }

    function _check() {
        if (_stateDeck.length > _maxDeckLength) _stateDeck.shift();
    }
}

exports.default = StateStorage;

},{"lodash":"lodash"}],65:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Subscribable = Subscribable;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/** 
 * It's base class which provides subscription API for successors.
 * @class
*/
function Subscribable() {
    var self = this;
    self._subscribtions = {};

    /**
     * Method allows to subscribe on a some specific event.
     * @param {string} event - event id
     * @param {function} callback - event handler
     * @memberof Subscribable
     * @method
    */
    self.on = function (event, callback) {
        if (!self._subscribtions[event]) self._subscribtions[event] = [];
        if (callback && callback instanceof Function) {
            self._subscribtions[event].push(callback);
        } else {
            throw new Error('Illegal type of callback!');
        }
    };

    /**
     * Method allows to unsubscribe from a some specific event.
     * @param {function} callback - event handler
     * @memberof Subscribable
     * @method
    */
    self.unsubscribe = function (callback) {
        _.values(self._subscribtions).forEach(function (subscribers) {
            var index = subscribers.indexOf(callback);
            if (index !== -1) subscribers.splice(index, 1);
        });
    };

    /**
     * Method which fires the event.
     * @param {string} event - event id
     * @param {Object[]} parameters
     * @memberof Subscribable
     * @method
    */
    self.trigger = function (event, parameters) {
        var _this = this;

        if (!(parameters instanceof Array)) parameters = [parameters];
        if (self._subscribtions && self._subscribtions[event]) {
            self._subscribtions[event].forEach(function (c) {
                c.apply(_this, parameters);
            });
        }
    };
}
exports.default = Subscribable;

},{"lodash":"lodash"}],66:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getBaseElement = getBaseElement;
exports.checkLgRawData = checkLgRawData;
exports.checkDmRawData = checkDmRawData;
exports.defenitionToPublicModel = defenitionToPublicModel;
exports.createJointNodes = createJointNodes;
exports.createJointLinks = createJointLinks;
exports.date2String = date2String;
exports.png2Blob = png2Blob;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _elements = require('../jointViews/graphElements/elements');

var graphElements = _interopRequireWildcard(_elements);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function getBaseElement(element) {
    if (!element) return null;
    return element.originalLink || element.originalNode || element;
}

function checkLgRawData(data) {
    if (!data.links && !data.nodes) {
        throw new Error('There is no data to show!');
    }
    if (data.nodes) {
        if (!(data.nodes instanceof Array)) {
            throw new Error('\'nodes\' should be an Array, but it is object!');
        } else if (data.nodes.length === 0) {
            throw new Error('There is no data to show!');
        }
    } else {
        throw new Error('There is no nodes information in the data, so we have nothing to show!');
    }
    if (data.links && !(data.links instanceof Array)) {
        throw new Error('\'links\' should be an Array, but it is object!');
    }
    return true;
}

function checkDmRawData(data) {
    if (!data.edges && !data.nodes) {
        throw new Error('There is no data to show!');
    }
    if (data.nodes) {
        if (!(data.nodes instanceof Array)) {
            throw new Error('\'nodes\' should be an Array, but it is object!');
        } else if (data.nodes.length === 0) {
            throw new Error('There is no data to show!');
        }
    } else {
        throw new Error('There is no nodes information in the data, so we have nothing to show!');
    }
    if (data.links && !(data.edges instanceof Array)) {
        throw new Error('\'links\' should be an Array, but it is object!');
    }
    return true;
}

/**
 * View frame definition,
 * @typedef {Object} ViewFrameDefinition
 * @property {string} id - View frame identifyer
 * @property {string} label - Title of the view frame,
 * @property {string} borderColor - Color of the border
 * @property {string} backgroundColor - Color of the background
 * @property {number} spaceShare - How much the view frame will take
 * @property {boolean} collapsed - Define default state
 * from whole space of the graph (You can take it as persents or flex grow)
*/

function defenitionToPublicModel(defenition, fullScreenMode) {
    var isActive = fullScreenMode ? false : !defenition.collapsed;

    return {
        id: defenition.id,
        label: defenition.label,
        backgroundColor: defenition.backgroundColor,
        borderColor: defenition.borderColor,
        active: isActive,
        expanded: !defenition.collapsed,
        position: undefined,
        viewPortPosition: undefined,
        viewPortPositionBounds: undefined,
        viewPortBounds: undefined,
        nodeBounds: undefined,
        size: undefined,
        customeSized: false,
        spaceShare: defenition.spaceShare,
        updateBounds: false,
        isOverView: false
    };
}

/**
 * @private
 * Cretes joint nodes from nodeModels
 * @param {
 *      Array of {
            id: string,
            label: string,
            viewFrame: string,
            typeId: string,
            resourceType: string,
            resource: string,
 *      }
 * } NodeModels - list of models
 * @returns {Array of Node} list of joint nodes
 */
function createJointNodes(nodeModels, parameters) {
    var jointNodes = [];
    nodeModels.forEach(function (node) {
        jointNodes.push(new graphElements.Node(node, parameters));
    });
    return jointNodes;
}

/**
 * @private
 * Cretes joint links from models (nativeLinks)
 * @param {
 *      Array of {
 *          id: string,
 *          target: string,
 *          source: string,
 *      }
 * } nativeLinks - list of models
 * @returns {Link[]} list of joint links
 */
function createJointLinks(linkModels, jointNodes, parameters) {
    var jointLinks = [];
    var idMap = {};
    jointNodes.forEach(function (node) {
        idMap[node.model.id] = node.id;
    });
    linkModels.forEach(function (link) {
        var linkModel = _.cloneDeep(link);
        linkModel.sourceType = link.source;
        linkModel.targetType = link.target;
        linkModel.source = idMap[link.source];
        linkModel.target = idMap[link.target];
        linkModel.routing = parameters.linkRouting;
        var newLink = new graphElements.Link(linkModel, parameters);
        jointLinks.push(newLink);
    });
    return jointLinks;
}

function date2String(date) {
    return padStr(date.getFullYear()) + '_' + padStr(1 + date.getMonth()) + '_' + padStr(date.getDate()) + '_' + padStr(date.getHours()) + '_' + padStr(date.getMinutes()) + '_' + padStr(date.getSeconds());

    function padStr(i) {
        return i < 10 ? '0' + i : '' + i;
    }
}

function png2Blob(dataURI) {
    // convert base64 to raw binary data held in a string
    // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
    var byteString = atob(dataURI.split(',')[1]);

    // write the bytes of the string to an ArrayBuffer
    var ab = new ArrayBuffer(byteString.length);
    var ia = new Uint8Array(ab);
    for (var i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }

    // write the ArrayBuffer to a blob, and you're done
    var bb = new Blob([ab], { type: 'image/png' });
    return bb;
}

},{"../jointViews/graphElements/elements":46,"lodash":"lodash"}],67:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.convertNativeToLayoutModels = convertNativeToLayoutModels;
exports.convertLGElementsToLayoutModels = convertLGElementsToLayoutModels;
exports.convertDMElementsToLayoutModels = convertDMElementsToLayoutModels;
exports.convertJointElementsToLayoutModels = convertJointElementsToLayoutModels;
exports.sum = sum;
exports.map$1 = map$1;
exports.nest = nest;
exports.reinterpolate = reinterpolate;
exports.min = min;

var _utils = require('./utils');

function convertNativeToLayoutModels(nodeModels, linkModels, parameters) {
    var size = parameters.elementSize;
    var nodes = nodeModelsToLayoutNodes(nodeModels, parameters.elementSize);
    var links = linkModelsToLayoutLinks(linkModels, nodes);

    return {
        nodes: nodes,
        links: links
    };

    function nodeModelsToLayoutNodes(nodeModels) {
        return nodeModels.map(function (nodeModel) {
            return nodeModelToLayoutNode(nodeModel);
        });
    }

    function linkModelsToLayoutLinks(linkModels, nodes) {
        var nodeMap = (0, _utils.arrayToMap)(nodes);
        var links = linkModels.map(function (link) {
            return linkModelToLayoutLink(link, nodeMap);
        }).filter(function (link) {
            return link.source && link.target && link.source !== link.target;
        });
        links.forEach(function (link) {
            link.source.targetLinks.push(link);
            link.target.sourceLinks.push(link);
        });
        return links;
    }

    function nodeModelToLayoutNode(nodeModel) {
        return {
            id: nodeModel.id,
            x: nodeModel.position.x || Math.random(),
            y: nodeModel.position.y || Math.random(),
            originalNode: nodeModel,
            width: size.width,
            height: size.height,
            targetLinks: [],
            sourceLinks: [],
            viewFrame: nodeModel.viewFrame
        };
    }

    function linkModelToLayoutLink(linkModel, nodeMap) {
        var source = nodeMap[linkModel.source];
        var target = nodeMap[linkModel.target];
        return {
            originalLink: linkModel,
            source: source,
            target: target,
            value: 1
        };
    }
}

function convertLGElementsToLayoutModels(lgNodes, lgLinks, options) {
    var scale = options.scale;
    var nodes = lgNodes.map(function (node) {
        return nodeToLayoutNode(node);
    });
    var links = linksToLayoutLinks(lgLinks, nodes);

    return {
        nodes: nodes,
        links: links
    };

    function linksToLayoutLinks(link, nodes) {
        var nodeMap = (0, _utils.arrayToMap)(nodes);
        var links = link.map(function (link) {
            return linkToLayoutLink(link, nodeMap);
        }).filter(function (link) {
            return link.source && link.target && link.source !== link.target;
        });
        links.forEach(function (link) {
            link.source.targetLinks.push(link);
            link.target.sourceLinks.push(link);
        });
        return links;
    }

    function nodeToLayoutNode(node) {
        var position = (0, _utils.getGlobalNodePosition)(node);
        var size = (0, _utils.scaledToGlobalSize)(node.size, scale);
        return {
            id: node.id,
            x: position.x,
            y: position.y,
            originalNode: node,
            width: size.width,
            heigth: size.heigth,
            targetLinks: [],
            sourceLinks: []
        };
    }

    function linkToLayoutLink(link, nodeMap) {
        var source = nodeMap[link.model.source];
        var target = nodeMap[link.model.target];
        return {
            originalLink: link,
            source: source,
            target: target,
            value: 1
        };
    }
}

function convertDMElementsToLayoutModels(dmNodes, dmLinks) {
    var nodeMap = (0, _utils.arrayToMap)(dmNodes.map(function (node) {
        return nodeToLayoutNode(node);
    }));
    var links = linksToLayoutLinks(dmLinks, nodeMap);

    return {
        nodes: (0, _utils.mapToArray)(nodeMap),
        links: links
    };

    function linksToLayoutLinks(link, nodeMap) {
        var links = link.map(function (link) {
            return linkToLayoutLink(link, nodeMap);
        }).filter(function (link) {
            return link.source && link.target && link.source !== link.target;
        });
        links.forEach(function (link) {
            link.source.targetLinks.push(link);
            link.target.sourceLinks.push(link);
        });
        return links;
    }

    function nodeToLayoutNode(node) {
        var portPrimitive = node.getPort().primitive;
        return {
            id: portPrimitive.id,
            x: 0,
            y: 0,
            originalNode: portPrimitive,
            targetLinks: [],
            sourceLinks: []
        };
    }

    function linkToLayoutLink(link, nodeMap) {
        var sourcePrimitive = link.source.getPort().primitive;
        var targetPrimitive = link.target.getPort().primitive;

        var source = nodeMap[sourcePrimitive.id];
        var target = nodeMap[targetPrimitive.id];

        return {
            cacheId: cachLinkFunction(sourcePrimitive, targetPrimitive),
            originalLink: link,
            source: source,
            target: target,
            value: 1
        };
    }

    function cachLinkFunction(source, target) {
        return source.id + '~#tqDMLink#~' + target.id;
    }
}

function convertJointElementsToLayoutModels(jNodes, jLinks) {
    var nodeMap = (0, _utils.arrayToMap)(jNodes.map(function (node) {
        return nodeToLayoutNode(node);
    }));
    var links = linksToLayoutLinks(jLinks, nodeMap);

    return {
        nodes: (0, _utils.mapToArray)(nodeMap),
        links: links
    };

    function linksToLayoutLinks(link, nodeMap) {
        var links = link.map(function (link) {
            return linkToLayoutLink(link, nodeMap);
        }).filter(function (link) {
            return link.source && link.target && link.source !== link.target;
        });
        links.forEach(function (link) {
            link.source.targetLinks.push(link);
            link.target.sourceLinks.push(link);
        });
        return links;
    }

    function nodeToLayoutNode(node) {
        return {
            id: node.id,
            x: 0,
            y: 0,
            targetLinks: [],
            sourceLinks: []
        };
    }

    function linkToLayoutLink(link, nodeMap) {
        var source = nodeMap[link.get('source').id];
        var target = nodeMap[link.get('target').id];

        return {
            source: source,
            target: target,
            value: 1
        };
    }
}

function sum(array, f) {
    var s = 0,
        n = array.length,
        a = void 0,
        i = -1;

    if (f == null) {
        while (++i < n) {
            a = +array[i];
            if (a) s += a;
        }
    } else {
        while (++i < n) {
            a = +f(array[i], i, array);
            if (a) s += a;
        }
    }

    return s;
}

var prefix = '$';
function Map() {}
Map.prototype = map$1.prototype = {
    constructor: Map,
    has: function has(key) {
        return prefix + key in this;
    },
    get: function get(key) {
        return this[prefix + key];
    },
    set: function set(key, value) {
        this[prefix + key] = value;
        return this;
    },
    remove: function remove(key) {
        var property = prefix + key;
        return property in this && delete this[property];
    },
    clear: function clear() {
        for (var property in this) {
            if (property[0] === prefix) delete this[property];
        }
    },
    keys: function keys() {
        var keys = [];
        for (var property in this) {
            if (property[0] === prefix) keys.push(property.slice(1));
        }return keys;
    },
    values: function values() {
        var values = [];
        for (var property in this) {
            if (property[0] === prefix) values.push(this[property]);
        }return values;
    },
    entries: function entries() {
        var entries = [];
        for (var property in this) {
            if (property[0] === prefix) entries.push({ key: property.slice(1), value: this[property] });
        }return entries;
    },
    size: function size() {
        var size = 0;
        for (var property in this) {
            if (property[0] === prefix) ++size;
        }return size;
    },
    empty: function empty() {
        for (var property in this) {
            if (property[0] === prefix) return false;
        }return true;
    },
    each: function each(f) {
        for (var property in this) {
            if (property[0] === prefix) f(this[property], property.slice(1), this);
        }
    }
};

function map$1(object, f) {
    var map = new Map();

    // Copy constructor.
    if (object instanceof Map) object.each(function (value, key) {
        map.set(key, value);
    });

    // Index array by numeric index or specified key function.
    else if (Array.isArray(object)) {
            var i = -1,
                n = object.length,
                o = void 0;

            if (f == null) while (++i < n) {
                map.set(i, object[i]);
            } else while (++i < n) {
                map.set(f(o = object[i], i, object), o);
            }
        }

        // Convert object to map.
        else if (object) for (var key in object) {
                map.set(key, object[key]);
            }return map;
}

function nest() {
    var keys = [],
        _sortKeys = [],
        _sortValues = void 0,
        _rollup = void 0,
        nest = void 0;

    function apply(array, depth, createResult, setResult) {
        if (depth >= keys.length) return _rollup != null ? _rollup(array) : _sortValues != null ? array.sort(_sortValues) : array;

        var i = -1,
            n = array.length,
            key = keys[depth++],
            keyValue = void 0,
            value = void 0,
            valuesByKey = map$1(),
            values = void 0,
            result = createResult();

        while (++i < n) {
            values = valuesByKey.get(keyValue = key(value = array[i]) + '');
            if (values) {
                values.push(value);
            } else {
                valuesByKey.set(keyValue, [value]);
            }
        }

        valuesByKey.each(function (values, key) {
            setResult(result, key, apply(values, depth, createResult, setResult));
        });

        return result;
    }

    function _entries(map, depth) {
        if (++depth > keys.length) return map;
        var array = void 0,
            sortKey = _sortKeys[depth - 1];
        if (_rollup != null && depth >= keys.length) array = map.entries();else array = [], map.each(function (v, k) {
            array.push({ key: k, values: _entries(v, depth) });
        });
        return sortKey != null ? array.sort(function (a, b) {
            return sortKey(a.key, b.key);
        }) : array;
    }

    return nest = {
        object: function object(array) {
            return apply(array, 0, createObject, setObject);
        },
        map: function map(array) {
            return apply(array, 0, createMap, setMap);
        },
        entries: function entries(array) {
            return _entries(apply(array, 0, createMap, setMap), 0);
        },
        key: function key(d) {
            keys.push(d);return nest;
        },
        sortKeys: function sortKeys(order) {
            _sortKeys[keys.length - 1] = order;return nest;
        },
        sortValues: function sortValues(order) {
            _sortValues = order;return nest;
        },
        rollup: function rollup(f) {
            _rollup = f;return nest;
        }
    };

    function createObject() {
        return {};
    }

    function setObject(object, key, value) {
        object[key] = value;
    }

    function createMap() {
        return map$1();
    }

    function setMap(map, key, value) {
        map.set(key, value);
    }
}

function reinterpolate(a, b) {
    return a = +a, b -= a, function (t) {
        return a + b * t;
    };
}

function min(array, f) {
    var i = -1,
        n = array.length,
        a = void 0,
        b = void 0;

    if (f == null) {
        while (++i < n) {
            if ((b = array[i]) != null && b >= b) {
                a = b;break;
            }
        }while (++i < n) {
            if ((b = array[i]) != null && a > b) a = b;
        }
    } else {
        while (++i < n) {
            if ((b = f(array[i], i, array)) != null && b >= b) {
                a = b;break;
            }
        }while (++i < n) {
            if ((b = f(array[i], i, array)) != null && a > b) a = b;
        }
    }

    return a;
}

},{"./utils":69}],68:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GAP = undefined;
exports.cacheIdForViewFrameUI = cacheIdForViewFrameUI;
exports.getViewFrameIdForNode = getViewFrameIdForNode;
exports.checkPagination = checkPagination;
exports.getCrosPoint = getCrosPoint;
exports.adjustVertices = adjustVertices;
exports.getPath = getPath;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function cacheIdForViewFrameUI(viewFrame) {
    return 'tq-lg-view-frame-ui-' + viewFrame.id;
}

function getViewFrameIdForNode(node) {
    return node.viewFrameOwnerId || node.model.viewFrame;
}

function checkPagination(viewFrame) {
    var viewPortPositionBounds = viewFrame.viewPortPositionBounds;
    var viewPortPosition = viewFrame.viewPortPosition;

    return {
        canMoveUp: viewPortPositionBounds && viewPortPosition.y > viewPortPositionBounds.minY,
        canMoveDown: viewPortPositionBounds && viewPortPosition.y < viewPortPositionBounds.maxY,
        canMoveLeft: viewPortPositionBounds && viewPortPosition.x > viewPortPositionBounds.minX,
        canMoveRight: viewPortPositionBounds && viewPortPosition.x < viewPortPositionBounds.maxX
    };
}

/**
 * @private
 * Returns point of crossing of two lines
 * @param {Point} p1 - the first point of line-1
 * @param {Point} p2 - the second point of line-1
 * @param {Point} p3 - the first point of line-2
 * @param {Point} p4 - the second point of line-2
 * @returns {Point}
 */
function getCrosPoint(p1, p2, p3, p4) {
    var x1 = p1.x;
    var y1 = p1.y;

    var x2 = p2.x;
    var y2 = p2.y;

    var x3 = p3.x;
    var y3 = p3.y;

    var x4 = p4.x;
    var y4 = p4.y;

    var k1 = void 0,
        k2 = void 0,
        b1 = void 0,
        b2 = void 0;
    var rx = void 0,
        ry = void 0,
        xx = void 0,
        yy = void 0;
    var res = {};

    if (x1 == x2 && x3 == x4) return null;
    if (x1 === x2) {
        k2 = (y3 - y4) / (x3 - x4);
        b2 = y3 - k2 * x3;

        rx = x1;
        ry = k2 * rx + b2;
    } else if (x3 === x4) {
        k1 = (y1 - y2) / (x1 - x2);
        b1 = y1 - k1 * x1;

        rx = x3;
        ry = k1 * rx + b1;
    } else {
        k1 = (y1 - y2) / (x1 - x2);
        b1 = y1 - k1 * x1;

        k2 = (y3 - y4) / (x3 - x4);
        b2 = y3 - k2 * x3;

        if (k1 == k2) {
            return null;
        }

        rx = (b2 - b1) / (k1 - k2);
        ry = k1 * rx + b1;
    }

    if (y2 < y1) {
        yy = y1;
        y1 = y2;
        y2 = yy;
    }
    if (y4 < y3) {
        yy = y3;
        y3 = y4;
        y4 = yy;
    }
    if (x2 < x1) {
        xx = x1;
        x1 = x2;
        x2 = xx;
    }
    if (x4 < x3) {
        xx = x3;
        x3 = x4;
        x4 = xx;
    }
    res.x = rx;
    res.y = ry;
    var error = 1;
    if (x1 - error <= res.x && res.x <= x2 + error && x3 - error <= res.x && res.x <= x4 + error && y1 - error <= res.y && res.y <= y2 + error && y3 - error <= res.y && res.y <= y4 + error) {
        return res;
    } else {
        return null;
    }
}

// This is the maximum distance between links
var GAP = exports.GAP = 10; // px
// Only for Derivation map
function adjustVertices(graph, cell) {
    if (!cell) {
        graph.getLinks().forEach(function (link) {
            adjustVertices(graph, link);
        });
        return;
    }
    // If the cell is a view, find its model.
    cell = cell.model && cell.model.get ? cell.model : cell;

    if (cell instanceof joint.dia.Element) {
        graph.getConnectedLinks(cell).forEach(function (link) {
            adjustVertices(graph, link);
        });
        return;
    }

    if (cell.hidden) return;
    cell.set('vertices', []);

    // The cell is a link. Let's find its source and target models.
    var srcId = cell.get('source').id || cell.previous('source').id;
    var trgId = cell.get('target').id || cell.previous('target').id;
    var srcPort = cell.get('source').port || cell.previous('source').port;
    var trgPort = cell.get('target').port || cell.previous('target').port;

    // If one of the ends is not a model, the link has no siblings.
    if (!srcId || !trgId) return;

    var siblings = graph.getLinks().filter(function (sibling) {
        if (sibling.hidden) return false;
        var _srcId = sibling.get('source').id;
        var _trgId = sibling.get('target').id;
        var _srcPort = sibling.get('source').port;
        var _trgPort = sibling.get('target').port;

        var sameEndsSameDirection = _srcId === srcId && _trgId === trgId && _srcPort === srcPort && _trgPort === trgPort;
        var sameEndsSameOppositeDirection = _srcId === trgId && _trgId === srcId && _srcPort === trgPort && _trgPort === srcPort;
        return sameEndsSameDirection || sameEndsSameOppositeDirection;
    });

    switch (siblings.length) {
        case 0:
        case 1:
            break;
        default:
            {
                // There is more than one siblings. We need to create vertices.
                // First of all we'll find the middle point of the link.
                var srcCell = graph.getCell(srcId);
                var srcPosition = srcCell.position();
                var _srcPort2 = srcCell.attr('.' + cell.get('source').port);
                if (!_srcPort2) return;
                var srcPortPosition = {
                    x: _srcPort2['ref-x'] + srcPosition.x,
                    y: _srcPort2['ref-y'] + srcPosition.y,
                    theta: joint.g.point.prototype.theta
                };
                var trgCell = graph.getCell(trgId);
                var trgPosition = trgCell.position();
                var _trgPort2 = trgCell.attr('.' + cell.get('target').port);
                if (!_trgPort2) return;
                var trgPortPosition = {
                    x: _trgPort2['ref-x'] + trgPosition.x,
                    y: _trgPort2['ref-y'] + trgPosition.y
                };
                var midPoint = joint.g.line(srcPortPosition, trgPortPosition).midpoint();

                // Then find the angle it forms.
                var theta = srcPortPosition.theta(trgPortPosition);
                var cellIndex = siblings.indexOf(cell);

                // We want the offset values to be calculated as follows 0, 20, 20, 40, 40, 60, 60 ..
                var offset = GAP * Math.ceil((cellIndex + (siblings.length % 2 === 0 ? 1 : 0)) / 2);

                // Now we need the vertices to be placed at points which are 'offset' pixels distant
                // from the first link and forms a perpendicular angle to it. And as index goes up
                // alternate left and right.
                //
                //  ^  odd indexes 
                //  |
                //  |---->  index 0 line (straight line between a source center and a target center.
                //  |
                //  v  even indexes
                var sign = cellIndex % 2 ? 1 : -1;
                var angle = joint.g.toRad(theta + sign * 90);

                // We found the vertex.
                var vertex = joint.g.point.fromPolar(offset, angle, midPoint);

                cell.set('vertices', [{ x: vertex.x, y: vertex.y }]);
            }}
}

function getPath(selectedElement, dataContainer) {
    var sourceMap = dataContainer.maps.sourceMap;
    var targetMap = dataContainer.maps.targetMap;
    var nodeMap = dataContainer.maps.nodeMap;

    var pathNodes = {};
    var pathLinksWest = {};
    var pathLinksEast = {};

    if (nodeMap[selectedElement.id]) {
        selectNode(selectedElement, true);
        selectNode(selectedElement, false);
    } else {
        pathLinksWest[selectedElement.id] = selectedElement;
        pathLinksEast[selectedElement.id] = selectedElement;
        selectNode(nodeMap[selectedElement.model.target], true);
        selectNode(nodeMap[selectedElement.model.source], false);
    }

    function selectNode(curNode, direction) {
        pathNodes[curNode.id] = curNode;
        curNode.aspects.forEach(function (aspect) {
            return pathNodes[aspect.id] = aspect;
        });
        var links = direction ? targetMap[curNode.id] : sourceMap[curNode.id];
        if (links) {
            links.forEach(function (link) {
                if (!pathLinksEast[link.id] && direction || !pathLinksWest[link.id] && !direction) {
                    if (direction) {
                        pathLinksEast[link.id] = link;
                    } else {
                        pathLinksWest[link.id] = link;
                    }
                    selectNode(nodeMap[direction ? link.model.target : link.model.source], direction);
                }
            });
        }
    }

    return _.merge(pathLinksEast, pathLinksWest, pathNodes);
}

},{"lodash":"lodash","rappid":"rappid"}],69:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.limitPointPosition = limitPointPosition;
exports.getScaledViewFramePosition = getScaledViewFramePosition;
exports.getGlobalViewPortPosition = getGlobalViewPortPosition;
exports.getGlobalNodePosition = getGlobalNodePosition;
exports.getScaledNodePosition = getScaledNodePosition;
exports.getLocalNodePosition = getLocalNodePosition;
exports.getGlobalNodeSize = getGlobalNodeSize;
exports.getScaledNodeSize = getScaledNodeSize;
exports.globalToScaledPoint = globalToScaledPoint;
exports.scaledToGlobalPoint = scaledToGlobalPoint;
exports.globalToLocalPoint = globalToLocalPoint;
exports.localToGlobalPoint = localToGlobalPoint;
exports.localToScaledPoint = localToScaledPoint;
exports.scaledToLocalPoint = scaledToLocalPoint;
exports.globalToScaledSize = globalToScaledSize;
exports.scaledToGlobalSize = scaledToGlobalSize;
exports.globalToScaledBounds = globalToScaledBounds;
exports.scaledToGlobalBounds = scaledToGlobalBounds;
exports.shrinkBounds = shrinkBounds;
exports.extendBounds = extendBounds;
exports.getElementSize = getElementSize;
exports.arrayToMap = arrayToMap;
exports.mapToArray = mapToArray;
exports.getDist = getDist;
exports.getDiff = getDiff;
exports.onDragStart = onDragStart;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * Returns limitted by bounds point value
 * @param {Point} point 
 * @param {Bounds} bounds 
 */
function limitPointPosition(point, bounds) {
    if (!bounds) return point;

    var x = Math.max(Math.min(point.x, bounds.maxX), bounds.minX);
    var y = Math.max(Math.min(point.y, bounds.maxY), bounds.minY);

    return { x: x, y: y };
}

// global = {
//     x: 1,
//     y: 1,
// }
// scaled = {
//     x: global.x * scale,
//     y: global.y * scale,
// }
// local = {
//     x: scaled.x + viewFrameScaledPos.x - viewFrameViewPortPosition.x,
//     y: scaled.y + viewFrameScaledPos.y - viewFrameViewPortPosition.y,
// }
// ====================================================
function getScaledViewFramePosition(viewFrame) {
    if (viewFrame.position instanceof Function) {
        return viewFrame.position();
    } else if (viewFrame.position) {
        return viewFrame.position;
    } else {
        throw new Error('Incorrect parameter!');
    }
}

function getGlobalViewPortPosition(viewFrame) {
    if (viewFrame.positionViewPort) {
        return viewFrame.positionViewPort();
    } else if (viewFrame.viewPortPosition) {
        return viewFrame.viewPortPosition;
    } else {
        throw new Error('Incorrect parameter!');
    }
}

function getGlobalNodePosition(node) {
    return _.clone(node.model.position);
}

function getScaledNodePosition(node, scale) {
    if (!scale) throw new Error('Scale is undefined!');

    var position = getGlobalNodePosition(node);
    return globalToScaledPoint(position, scale);
}

function getLocalNodePosition(node, scale, viewFrame) {
    if (!scale) throw new Error('Scale is undefined!');

    var position = getGlobalNodePosition(node);
    return globalToLocalPoint(position, scale, viewFrame);
}

function getGlobalNodeSize(node, scale) {
    var scaledSize = getScaledNodeSize(node);

    return scaledToGlobalSize(scaledSize, scale);
}

function getScaledNodeSize(node) {
    return node.get('size');
}

function globalToScaledPoint(point, scale) {
    if (!scale) throw new Error('Scale is undefined!');

    return {
        x: point.x * scale.x,
        y: point.y * scale.y
    };
}

function scaledToGlobalPoint(point, scale) {
    if (!scale) throw new Error('Scale is undefined!');

    return {
        x: point.x / scale.x,
        y: point.y / scale.y
    };
}

function globalToLocalPoint(point, scale, viewFrame) {
    if (!scale) throw new Error('Scale is undefined!');
    var scaledPoint = globalToScaledPoint(point, scale);

    return scaledToLocalPoint(scaledPoint, scale, viewFrame);
}

function localToGlobalPoint(point, scale, viewFrame) {
    if (!scale) throw new Error('Scale is undefined!');
    var scaledPoint = localToScaledPoint(point, scale, viewFrame);

    return scaledToGlobalPoint(scaledPoint, scale, viewFrame);
}

function localToScaledPoint(point, scale, viewFrame) {
    if (!scale) throw new Error('Scale is undefined!');

    var scaledViewFrameOffset = getScaledViewFramePosition(viewFrame);
    var globalViewPortOffset = getGlobalViewPortPosition(viewFrame);
    var scaledViewPortOffset = globalToScaledPoint(globalViewPortOffset, scale);

    return {
        x: point.x - scaledViewFrameOffset.x + scaledViewPortOffset.x,
        y: point.y - scaledViewFrameOffset.y + scaledViewPortOffset.y
    };
}

function scaledToLocalPoint(point, scale, viewFrame) {
    if (!scale) throw new Error('Scale is undefined!');

    var scaledViewFrameOffset = getScaledViewFramePosition(viewFrame);
    var globalViewPortOffset = getGlobalViewPortPosition(viewFrame);
    var scaledViewPortOffset = globalToScaledPoint(globalViewPortOffset, scale);

    return {
        x: point.x + scaledViewFrameOffset.x - scaledViewPortOffset.x,
        y: point.y + scaledViewFrameOffset.y - scaledViewPortOffset.y
    };
}

function globalToScaledSize(size, scale) {
    if (!scale) throw new Error('Scale is undefined!');
    return {
        width: size.width * scale.x,
        height: size.height * scale.y
    };
}

function scaledToGlobalSize(size, scale) {
    if (!scale) throw new Error('Scale is undefined!');
    return {
        width: size.width / scale.x,
        height: size.height / scale.y
    };
}

function globalToScaledBounds(bounds, scale) {
    var scaledMinPosition = globalToScaledPoint({ x: bounds.minX, y: bounds.minY }, scale);
    var scaledMaxPosition = globalToScaledPoint({ x: bounds.maxX, y: bounds.maxY }, scale);
    return {
        minX: scaledMinPosition.x,
        maxX: scaledMaxPosition.x,
        minY: scaledMinPosition.y,
        maxY: scaledMaxPosition.y,
        width: scaledMaxPosition.x - scaledMinPosition.x,
        height: scaledMaxPosition.y - scaledMinPosition.y
    };
}

function scaledToGlobalBounds(bounds, scale) {
    var scaledMinPosition = scaledToGlobalPoint({ x: bounds.minX, y: bounds.minY }, scale);
    var scaledMaxPosition = scaledToGlobalPoint({ x: bounds.maxX, y: bounds.maxY }, scale);
    return {
        minX: scaledMinPosition.x,
        maxX: scaledMaxPosition.x,
        minY: scaledMinPosition.y,
        maxY: scaledMaxPosition.y,
        width: scaledMaxPosition.x - scaledMinPosition.x,
        height: scaledMaxPosition.y - scaledMinPosition.y
    };
}

function shrinkBounds(bounds, paddingRectangle) {
    return {
        minX: bounds.minX + paddingRectangle.x,
        maxX: bounds.maxX - paddingRectangle.x,
        minY: bounds.minY + paddingRectangle.y,
        maxY: bounds.maxY - paddingRectangle.y,
        width: bounds.maxX - bounds.minX - paddingRectangle.x * 2,
        height: bounds.maxY - bounds.minY - paddingRectangle.y * 2
    };
}

function extendBounds(bounds, extendBy) {
    return {
        minX: bounds.minX - extendBy.x,
        maxX: bounds.maxX + extendBy.x,
        minY: bounds.minY - extendBy.y,
        maxY: bounds.maxY + extendBy.y,
        width: bounds.maxX + extendBy.x * 2 - bounds.minX,
        height: bounds.maxY + extendBy.y * 2 - bounds.minY
    };
}

// ====================================================

function getElementSize(rootId) {
    var paper = document.getElementById(rootId);
    return {
        width: paper.clientWidth,
        height: paper.clientHeight
    };
}

function arrayToMap(array, useAsId) {
    useAsId = useAsId || 'id';
    var map = {};
    array.forEach(function (el) {
        map[el[useAsId]] = el;
    });
    return map;
}

function mapToArray(map) {
    return Object.keys(map).map(function (key) {
        return map[key];
    });
}

function getDist(p1, p2) {
    var x1 = p1.x;
    var y1 = p1.y;

    var x2 = p2.x;
    var y2 = p2.y;

    var minX = Math.min(x1, x2);
    var minY = Math.min(y1, y2);

    if (minX < 0) {
        x1 += -minX;
        x2 += -minX;
    }
    if (minY < 0) {
        y1 += -minY;
        y2 += -minY;
    }
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

function getDiff(n1, n2) {
    var min = Math.min(n1, n2);
    if (min < 0) {
        n1 += -min;
        n2 += -min;
    }
    return Math.abs(n2 - n1);
}

function onDragStart(event, moveCallback, releaseCallback) {
    var startX = 0;
    var startY = 0;

    var pointProvider = event instanceof MouseEvent ? event : event.touches[0];

    if (pointProvider.pageX) startX = pointProvider.pageX;else if (pointProvider.clientX) startX = pointProvider.clientX;

    if (pointProvider.pageY) startY = pointProvider.pageY;else if (pointProvider.clientY) startY = pointProvider.clientY;

    window.getSelection().removeAllRanges();

    document.body.addEventListener('mousemove', _onchange);
    document.body.addEventListener('mouseup', _onend);
    document.body.addEventListener('touchmove', _onchange);
    document.body.addEventListener('touchend', _onend);

    function _onchange(event) {
        var pointProvider = event instanceof MouseEvent ? event : event.touches[0];

        var endX = 0;
        if (pointProvider.pageX) endX = pointProvider.pageX;else if (pointProvider.clientX) endX = pointProvider.clientX;

        var diffX = endX - startX;
        startX = endX;

        var endY = 0;
        if (pointProvider.pageY) endY = pointProvider.pageY;else if (pointProvider.clientY) endY = pointProvider.clientY;

        var diffY = endY - startY;
        startY = endY;

        moveCallback({ x: diffX, y: diffY });
    }

    function _onend() {
        document.body.onmousemove = document.body.onmouseup = null;
        document.body.removeEventListener('mousemove', _onchange);
        document.body.removeEventListener('mouseup', _onend);
        document.body.removeEventListener('touchmove', _onchange);
        document.body.removeEventListener('touchend', _onend);
        if (releaseCallback) releaseCallback();
    }
}

},{"lodash":"lodash"}]},{},[59])(59)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9maWxlLXNhdmVyanMvRmlsZVNhdmVyLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zaWdtYS9idWlsZC9zaWdtYS5yZXF1aXJlLmpzIiwibm9kZV9tb2R1bGVzL3Zpc3VhbGl6YXRpb25zLWxpYnJhcnkvYnVpbGQvanMvbWFpbi5taW4uanMiLCJub2RlX21vZHVsZXMvd2ViY29sYS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvYWRhcHRvci5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL2JhdGNoLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvZDNhZGFwdG9yLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvZDN2M2FkYXB0b3IuanMiLCJub2RlX21vZHVsZXMvd2ViY29sYS9kaXN0L3NyYy9kM3Y0YWRhcHRvci5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL2Rlc2NlbnQuanMiLCJub2RlX21vZHVsZXMvd2ViY29sYS9kaXN0L3NyYy9nZW9tLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvZ3JpZHJvdXRlci5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL2hhbmRsZWRpc2Nvbm5lY3RlZC5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL2xheW91dC5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL2xheW91dDNkLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvbGlua2xlbmd0aHMuanMiLCJub2RlX21vZHVsZXMvd2ViY29sYS9kaXN0L3NyYy9wb3dlcmdyYXBoLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvcHF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvcmJ0cmVlLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvcmVjdGFuZ2xlLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvc2hvcnRlc3RwYXRocy5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL3Zwc2MuanMiLCJub2RlX21vZHVsZXMvd2hhdHdnLWZldGNoL2ZldGNoLmpzIiwic3JjL2pzL2RhdGEvYmFzZTY0SW1hZ2VzLmpzIiwic3JjL2pzL2RhdGEvZGF0YUNvbnRhaW5lci5qcyIsInNyYy9qcy9kYXRhL2RhdGFQcm9jZXNzaW5nLmpzIiwic3JjL2pzL2RhdGEvZGVmYXVsdERhdGFQcm92aWRlci5qcyIsInNyYy9qcy9kYXRhL3Jlc291cmNlUHJvdmlkZXIuanMiLCJzcmMvanMvaHRtbFVJL2RlZmF1bHRVSS5qcyIsInNyYy9qcy9odG1sVUkvZG1EZWZhdWx0VUkuanMiLCJzcmMvanMvaHRtbFVJL2RtSW5mb1BhbmVsLmpzIiwic3JjL2pzL2h0bWxVSS9pbmZvUGFuZWwuanMiLCJzcmMvanMvaHRtbFVJL21hcC5qcyIsInNyYy9qcy9odG1sVUkvb3B0aW9uc1BhbmVsLmpzIiwic3JjL2pzL2h0bWxVSS9zcGxpdHRlci5qcyIsInNyYy9qcy9odG1sVUkvdmlld0ZyYW1lQnV0dG9ucy5qcyIsInNyYy9qcy9odG1sVUkvdmlld0ZyYW1lc1VJLmpzIiwic3JjL2pzL2pvaW50Vmlld3MvZGVyaXZhdGlvbk1hcC9kYXRhUHJvY2Vzc2luZy5qcyIsInNyYy9qcy9qb2ludFZpZXdzL2Rlcml2YXRpb25NYXAvZGVyaXZhdGlvbk1hcC5qcyIsInNyYy9qcy9qb2ludFZpZXdzL2Rlcml2YXRpb25NYXAvbWFwRWxlbWVudHMuanMiLCJzcmMvanMvam9pbnRWaWV3cy9kZXJpdmF0aW9uTWFwL21hcExheW91dC5qcyIsInNyYy9qcy9qb2ludFZpZXdzL2Rlcml2YXRpb25NYXAvbWFwVmlld3MuanMiLCJzcmMvanMvam9pbnRWaWV3cy9ncmFwaEVsZW1lbnRzL2FzcGVjdExpbmsuanMiLCJzcmMvanMvam9pbnRWaWV3cy9ncmFwaEVsZW1lbnRzL2VsZW1lbnRzLmpzIiwic3JjL2pzL2pvaW50Vmlld3MvZ3JhcGhFbGVtZW50cy9saW5rLmpzIiwic3JjL2pzL2pvaW50Vmlld3MvZ3JhcGhFbGVtZW50cy9ub2RlLmpzIiwic3JjL2pzL2pvaW50Vmlld3MvZ3JhcGhFbGVtZW50cy90ZXJtaW5hdGlvbkxpbmsuanMiLCJzcmMvanMvam9pbnRWaWV3cy9ncmFwaEVsZW1lbnRzL3Rlcm1pbmF0aW9uTm9kZS5qcyIsInNyYy9qcy9qb2ludFZpZXdzL2xpbmVhZ2VEaWFncmFtLmpzIiwic3JjL2pzL2pvaW50Vmlld3MvbGlua1JvdXRpbmdNYW5hZ2VyL3JvdXRpbmdNYW5hZ2VyLmpzIiwic3JjL2pzL2pvaW50Vmlld3MvdG9TdmcuanMiLCJzcmMvanMvam9pbnRWaWV3cy92aWV3RnJhbWUuanMiLCJzcmMvanMvam9pbnRWaWV3cy92aWV3TWFuYWdlci5qcyIsInNyYy9qcy9sYXlvdXQvbGF5b3V0LmpzIiwic3JjL2pzL2xheW91dC9zYW5rZXkuanMiLCJzcmMvanMvbGluZWFnZUdyYW0uanMiLCJzcmMvanMvbWFpbi5qcyIsInNyYy9qcy9zaWdtYVZpZXdzL2JpcmRFeWUuanMiLCJzcmMvanMvc2lnbWFWaWV3cy9ncmFwaE1hcC5qcyIsInNyYy9qcy9zaWdtYVZpZXdzL3NpZ21hQmFzZS5qcyIsInNyYy9qcy9zaWdtYVZpZXdzL3NpZ21hUGxhZ2lucy9zaWdtYS5yZW5kZXJlcnMuc25hcHNob3Qvc2lnbWEucmVuZGVyZXJzLnNuYXBzaG90LmpzIiwic3JjL2pzL3N0YXRlU3RvcmFnZS5qcyIsInNyYy9qcy9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZS5qcyIsInNyYy9qcy91dGlscy9kYXRhVXRpbHMuanMiLCJzcmMvanMvdXRpbHMvbGF5b3V0VXRpbHMuanMiLCJzcmMvanMvdXRpbHMvbGluZWFnZURpYWdyYW1VdGlscy5qcyIsInNyYy9qcy91dGlscy91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDam9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1eVhBOzs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFJLE9BQU8sQ0FBWDtBQUNBLFlBQUksY0FBYyxLQUFsQixFQUF5QixPQUFPLGNBQWMsS0FBckIsQ0FBekIsS0FDSyxJQUFJLGNBQWMsT0FBbEIsRUFBMkIsT0FBTyxjQUFjLE9BQXJCOztBQUVoQyxZQUFNLFFBQVEsT0FBTyxNQUFyQjtBQUNBLGlCQUFTLElBQVQ7O0FBRUEsWUFBSSxPQUFPLENBQVg7QUFDQSxZQUFJLGNBQWMsS0FBbEIsRUFBeUIsT0FBTyxjQUFjLEtBQXJCLENBQXpCLEtBQ0ssSUFBSSxjQUFjLE9BQWxCLEVBQTJCLE9BQU8sY0FBYyxPQUFyQjs7QUFFaEMsWUFBTSxRQUFRLE9BQU8sTUFBckI7QUFDQSxpQkFBUyxJQUFUOztBQUVBLHFCQUFhLEVBQUUsR0FBRyxLQUFMLEVBQVksR0FBRyxLQUFmLEVBQWI7QUFDSDs7QUFFRCxhQUFTLE1BQVQsR0FBbUI7QUFDZixpQkFBUyxJQUFULENBQWMsV0FBZCxHQUE0QixTQUFTLElBQVQsQ0FBYyxTQUFkLEdBQTBCLElBQXREO0FBQ0EsaUJBQVMsSUFBVCxDQUFjLG1CQUFkLENBQWtDLFdBQWxDLEVBQStDLFNBQS9DO0FBQ0EsaUJBQVMsSUFBVCxDQUFjLG1CQUFkLENBQWtDLFNBQWxDLEVBQTZDLE1BQTdDO0FBQ0EsaUJBQVMsSUFBVCxDQUFjLG1CQUFkLENBQWtDLFdBQWxDLEVBQStDLFNBQS9DO0FBQ0EsaUJBQVMsSUFBVCxDQUFjLG1CQUFkLENBQWtDLFVBQWxDLEVBQThDLE1BQTlDO0FBQ0EsWUFBSSxlQUFKLEVBQXFCO0FBQ3hCO0FBQ0YiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIDMuMy4xXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsLkVTNlByb21pc2UgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cbnZhciBfaXNBcnJheSA9IHVuZGVmaW5lZDtcbmlmICghQXJyYXkuaXNBcnJheSkge1xuICBfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn0gZWxzZSB7XG4gIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbn1cblxudmFyIGlzQXJyYXkgPSBfaXNBcnJheTtcblxudmFyIGxlbiA9IDA7XG52YXIgdmVydHhOZXh0ID0gdW5kZWZpbmVkO1xudmFyIGN1c3RvbVNjaGVkdWxlckZuID0gdW5kZWZpbmVkO1xuXG52YXIgYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICBxdWV1ZVtsZW5dID0gY2FsbGJhY2s7XG4gIHF1ZXVlW2xlbiArIDFdID0gYXJnO1xuICBsZW4gKz0gMjtcbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICBpZiAoY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgIGN1c3RvbVNjaGVkdWxlckZuKGZsdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2NoZWR1bGVyKHNjaGVkdWxlRm4pIHtcbiAgY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xufVxuXG5mdW5jdGlvbiBzZXRBc2FwKGFzYXBGbikge1xuICBhc2FwID0gYXNhcEZuO1xufVxuXG52YXIgYnJvd3NlcldpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xudmFyIGJyb3dzZXJHbG9iYWwgPSBicm93c2VyV2luZG93IHx8IHt9O1xudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBpc05vZGUgPSB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICh7fSkudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4vLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxudmFyIGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuLy8gbm9kZVxuZnVuY3Rpb24gdXNlTmV4dFRpY2soKSB7XG4gIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG59XG5cbi8vIHZlcnR4XG5mdW5jdGlvbiB1c2VWZXJ0eFRpbWVyKCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZlcnR4TmV4dChmbHVzaCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgbm9kZS5kYXRhID0gaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDI7XG4gIH07XG59XG5cbi8vIHdlYiB3b3JrZXJcbmZ1bmN0aW9uIHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBlczYtcHJvbWlzZSB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbiAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG4gIHZhciBnbG9iYWxTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsU2V0VGltZW91dChmbHVzaCwgMSk7XG4gIH07XG59XG5cbnZhciBxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbmZ1bmN0aW9uIGZsdXNoKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG4gICAgdmFyIGFyZyA9IHF1ZXVlW2kgKyAxXTtcblxuICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICBxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICBxdWV1ZVtpICsgMV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0VmVydHgoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHIgPSByZXF1aXJlO1xuICAgIHZhciB2ZXJ0eCA9IHIoJ3ZlcnR4Jyk7XG4gICAgdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICByZXR1cm4gdXNlVmVydHhUaW1lcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG52YXIgc2NoZWR1bGVGbHVzaCA9IHVuZGVmaW5lZDtcbi8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG5pZiAoaXNOb2RlKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xufSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xufSBlbHNlIGlmIChpc1dvcmtlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTWVzc2FnZUNoYW5uZWwoKTtcbn0gZWxzZSBpZiAoYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSBhdHRlbXB0VmVydHgoKTtcbn0gZWxzZSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHM7XG5cbiAgdmFyIHBhcmVudCA9IHRoaXM7XG5cbiAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9vcCk7XG5cbiAgaWYgKGNoaWxkW1BST01JU0VfSURdID09PSB1bmRlZmluZWQpIHtcbiAgICBtYWtlUHJvbWlzZShjaGlsZCk7XG4gIH1cblxuICB2YXIgX3N0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuICBpZiAoX3N0YXRlKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IF9hcmd1bWVudHNbX3N0YXRlIC0gMV07XG4gICAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZUNhbGxiYWNrKF9zdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCBwYXJlbnQuX3Jlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZXNvbHZlYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlc29sdmVkIHdpdGggdGhlXG4gIHBhc3NlZCBgdmFsdWVgLiBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVzb2x2ZSgxKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZXNvbHZlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gIGB2YWx1ZWBcbiovXG5mdW5jdGlvbiByZXNvbHZlKG9iamVjdCkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgX3Jlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbnZhciBQUk9NSVNFX0lEID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDE2KTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBQRU5ESU5HID0gdm9pZCAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xuXG52YXIgR0VUX1RIRU5fRVJST1IgPSBuZXcgRXJyb3JPYmplY3QoKTtcblxuZnVuY3Rpb24gc2VsZkZ1bGZpbGxtZW50KCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG59XG5cbmZ1bmN0aW9uIGNhbm5vdFJldHVybk93bigpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGhlbihwcm9taXNlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBHRVRfVEhFTl9FUlJPUi5lcnJvciA9IGVycm9yO1xuICAgIHJldHVybiBHRVRfVEhFTl9FUlJPUjtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlUaGVuKHRoZW4sIHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcbiAgdHJ5IHtcbiAgICB0aGVuLmNhbGwodmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4pIHtcbiAgYXNhcChmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IgPSB0cnlUaGVuKHRoZW4sIHRoZW5hYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGVuYWJsZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICBfcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgX3JlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgfVxuICB9LCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUpIHtcbiAgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgX3JlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiBfcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQpIHtcbiAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IgJiYgdGhlbiQkID09PSB0aGVuICYmIG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gcmVzb2x2ZSkge1xuICAgIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGVuJCQgPT09IEdFVF9USEVOX0VSUk9SKSB7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIEdFVF9USEVOX0VSUk9SLmVycm9yKTtcbiAgICB9IGVsc2UgaWYgKHRoZW4kJCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGVuJCQpKSB7XG4gICAgICBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgX3JlamVjdChwcm9taXNlLCBzZWxmRnVsZmlsbG1lbnQoKSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCBnZXRUaGVuKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3JlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb21pc2UuX3N0YXRlID0gUkVKRUNURUQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcblxuICBhc2FwKHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIF9zdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gIHZhciBsZW5ndGggPSBfc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gIHBhcmVudC5fb25lcnJvciA9IG51bGw7XG5cbiAgX3N1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIEZVTEZJTExFRF0gPSBvbkZ1bGZpbGxtZW50O1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgUkVKRUNURURdID0gb25SZWplY3Rpb247XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCAmJiBwYXJlbnQuX3N0YXRlKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwYXJlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2gocHJvbWlzZSkge1xuICB2YXIgc3Vic2NyaWJlcnMgPSBwcm9taXNlLl9zdWJzY3JpYmVycztcbiAgdmFyIHNldHRsZWQgPSBwcm9taXNlLl9zdGF0ZTtcblxuICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gdW5kZWZpbmVkLFxuICAgICAgY2FsbGJhY2sgPSB1bmRlZmluZWQsXG4gICAgICBkZXRhaWwgPSBwcm9taXNlLl9yZXN1bHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICB9XG4gIH1cblxuICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBFcnJvck9iamVjdCgpIHtcbiAgdGhpcy5lcnJvciA9IG51bGw7XG59XG5cbnZhciBUUllfQ0FUQ0hfRVJST1IgPSBuZXcgRXJyb3JPYmplY3QoKTtcblxuZnVuY3Rpb24gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICByZXR1cm4gVFJZX0NBVENIX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICB2YWx1ZSA9IHVuZGVmaW5lZCxcbiAgICAgIGVycm9yID0gdW5kZWZpbmVkLFxuICAgICAgc3VjY2VlZGVkID0gdW5kZWZpbmVkLFxuICAgICAgZmFpbGVkID0gdW5kZWZpbmVkO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHZhbHVlID0gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCk7XG5cbiAgICBpZiAodmFsdWUgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgIGVycm9yID0gdmFsdWUuZXJyb3I7XG4gICAgICB2YWx1ZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIC8vIG5vb3BcbiAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICAgIF9yZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgICAgX3JlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBGVUxGSUxMRUQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgdHJ5IHtcbiAgICByZXNvbHZlcihmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSkge1xuICAgICAgX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBfcmVqZWN0KHByb21pc2UsIGUpO1xuICB9XG59XG5cbnZhciBpZCA9IDA7XG5mdW5jdGlvbiBuZXh0SWQoKSB7XG4gIHJldHVybiBpZCsrO1xufVxuXG5mdW5jdGlvbiBtYWtlUHJvbWlzZShwcm9taXNlKSB7XG4gIHByb21pc2VbUFJPTUlTRV9JRF0gPSBpZCsrO1xuICBwcm9taXNlLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9zdWJzY3JpYmVycyA9IFtdO1xufVxuXG5mdW5jdGlvbiBFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuICB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoIXRoaXMucHJvbWlzZVtQUk9NSVNFX0lEXSkge1xuICAgIG1ha2VQcm9taXNlKHRoaXMucHJvbWlzZSk7XG4gIH1cblxuICBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIHRoaXMuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgICB0aGlzLl9lbnVtZXJhdGUoKTtcbiAgICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIF9yZWplY3QodGhpcy5wcm9taXNlLCB2YWxpZGF0aW9uRXJyb3IoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbn07XG5cbkVudW1lcmF0b3IucHJvdG90eXBlLl9lbnVtZXJhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgdmFyIF9pbnB1dCA9IHRoaXMuX2lucHV0O1xuXG4gIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl9lYWNoRW50cnkoX2lucHV0W2ldLCBpKTtcbiAgfVxufTtcblxuRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSwgaSkge1xuICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gIHZhciByZXNvbHZlJCQgPSBjLnJlc29sdmU7XG5cbiAgaWYgKHJlc29sdmUkJCA9PT0gcmVzb2x2ZSkge1xuICAgIHZhciBfdGhlbiA9IGdldFRoZW4oZW50cnkpO1xuXG4gICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgdGhpcy5fc2V0dGxlZEF0KGVudHJ5Ll9zdGF0ZSwgaSwgZW50cnkuX3Jlc3VsdCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgX3RoZW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgdGhpcy5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgfSBlbHNlIGlmIChjID09PSBQcm9taXNlKSB7XG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBjKG5vb3ApO1xuICAgICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBlbnRyeSwgX3RoZW4pO1xuICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHByb21pc2UsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQobmV3IGMoZnVuY3Rpb24gKHJlc29sdmUkJCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSQkKGVudHJ5KTtcbiAgICAgIH0pLCBpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fd2lsbFNldHRsZUF0KHJlc29sdmUkJChlbnRyeSksIGkpO1xuICB9XG59O1xuXG5FbnVtZXJhdG9yLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24gKHN0YXRlLCBpLCB2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcblxuICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgIGlmIChzdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICB9XG59O1xuXG5FbnVtZXJhdG9yLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24gKHByb21pc2UsIGkpIHtcbiAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gIHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KFJFSkVDVEVELCBpLCByZWFzb24pO1xuICB9KTtcbn07XG5cbi8qKlxuICBgUHJvbWlzZS5hbGxgIGFjY2VwdHMgYW4gYXJyYXkgb2YgcHJvbWlzZXMsIGFuZCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2hcbiAgaXMgZnVsZmlsbGVkIHdpdGggYW4gYXJyYXkgb2YgZnVsZmlsbG1lbnQgdmFsdWVzIGZvciB0aGUgcGFzc2VkIHByb21pc2VzLCBvclxuICByZWplY3RlZCB3aXRoIHRoZSByZWFzb24gb2YgdGhlIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIGJlIHJlamVjdGVkLiBJdCBjYXN0cyBhbGxcbiAgZWxlbWVudHMgb2YgdGhlIHBhc3NlZCBpdGVyYWJsZSB0byBwcm9taXNlcyBhcyBpdCBydW5zIHRoaXMgYWxnb3JpdGhtLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZXNvbHZlKDIpO1xuICBsZXQgcHJvbWlzZTMgPSByZXNvbHZlKDMpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gVGhlIGFycmF5IGhlcmUgd291bGQgYmUgWyAxLCAyLCAzIF07XG4gIH0pO1xuICBgYGBcblxuICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYGFsbGAgYXJlIHJlamVjdGVkLCB0aGUgZmlyc3QgcHJvbWlzZVxuICB0aGF0IGlzIHJlamVjdGVkIHdpbGwgYmUgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIHJldHVybmVkIHByb21pc2VzJ3NcbiAgcmVqZWN0aW9uIGhhbmRsZXIuIEZvciBleGFtcGxlOlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZWplY3QobmV3IEVycm9yKFwiMlwiKSk7XG4gIGxldCBwcm9taXNlMyA9IHJlamVjdChuZXcgRXJyb3IoXCIzXCIpKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgIC8vIGVycm9yLm1lc3NhZ2UgPT09IFwiMlwiXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIGFsbFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IGVudHJpZXMgYXJyYXkgb2YgcHJvbWlzZXNcbiAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgbGFiZWxpbmcgdGhlIHByb21pc2UuXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiAgQHN0YXRpY1xuKi9cbmZ1bmN0aW9uIGFsbChlbnRyaWVzKSB7XG4gIHJldHVybiBuZXcgRW51bWVyYXRvcih0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xufVxuXG4vKipcbiAgYFByb21pc2UucmFjZWAgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoIGlzIHNldHRsZWQgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZVxuICBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBzZXR0bGUuXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDInKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyByZXN1bHQgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgaXQgd2FzIHJlc29sdmVkIGJlZm9yZSBwcm9taXNlMVxuICAgIC8vIHdhcyByZXNvbHZlZC5cbiAgfSk7XG4gIGBgYFxuXG4gIGBQcm9taXNlLnJhY2VgIGlzIGRldGVybWluaXN0aWMgaW4gdGhhdCBvbmx5IHRoZSBzdGF0ZSBvZiB0aGUgZmlyc3RcbiAgc2V0dGxlZCBwcm9taXNlIG1hdHRlcnMuIEZvciBleGFtcGxlLCBldmVuIGlmIG90aGVyIHByb21pc2VzIGdpdmVuIHRvIHRoZVxuICBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50IGFyZSByZXNvbHZlZCwgYnV0IHRoZSBmaXJzdCBzZXR0bGVkIHByb21pc2UgaGFzXG4gIGJlY29tZSByZWplY3RlZCBiZWZvcmUgdGhlIG90aGVyIHByb21pc2VzIGJlY2FtZSBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICBwcm9taXNlIHdpbGwgYmVjb21lIHJlamVjdGVkOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3Byb21pc2UgMicpKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVuc1xuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIHByb21pc2UgMiBiZWNhbWUgcmVqZWN0ZWQgYmVmb3JlXG4gICAgLy8gcHJvbWlzZSAxIGJlY2FtZSBmdWxmaWxsZWRcbiAgfSk7XG4gIGBgYFxuXG4gIEFuIGV4YW1wbGUgcmVhbC13b3JsZCB1c2UgY2FzZSBpcyBpbXBsZW1lbnRpbmcgdGltZW91dHM6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBQcm9taXNlLnJhY2UoW2FqYXgoJ2Zvby5qc29uJyksIHRpbWVvdXQoNTAwMCldKVxuICBgYGBcblxuICBAbWV0aG9kIHJhY2VcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyB0byBvYnNlcnZlXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHdoaWNoIHNldHRsZXMgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZSBmaXJzdCBwYXNzZWRcbiAgcHJvbWlzZSB0byBzZXR0bGUuXG4qL1xuZnVuY3Rpb24gcmFjZShlbnRyaWVzKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKCFpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZWplY3RgIHJldHVybnMgYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIHBhc3NlZCBgcmVhc29uYC5cbiAgSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVqZWN0XG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHJlYXNvbiB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aC5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgZ2l2ZW4gYHJlYXNvbmAuXG4qL1xuZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgX3JlamVjdChwcm9taXNlLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbmVlZHNSZXNvbHZlcigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05ldygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbn1cblxuLyoqXG4gIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gIFRlcm1pbm9sb2d5XG4gIC0tLS0tLS0tLS0tXG5cbiAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgQmFzaWMgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLVxuXG4gIGBgYGpzXG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gb24gc3VjY2Vzc1xuICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgLy8gb24gZmFpbHVyZVxuICAgIHJlamVjdChyZWFzb24pO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIEFkdmFuY2VkIFVzYWdlOlxuICAtLS0tLS0tLS0tLS0tLS1cblxuICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICBgYGBqc1xuICBQcm9taXNlLmFsbChbXG4gICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KTtcbiAgYGBgXG5cbiAgQGNsYXNzIFByb21pc2VcbiAgQHBhcmFtIHtmdW5jdGlvbn0gcmVzb2x2ZXJcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAY29uc3RydWN0b3JcbiovXG5mdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gIHRoaXNbUFJPTUlTRV9JRF0gPSBuZXh0SWQoKTtcbiAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgaWYgKG5vb3AgIT09IHJlc29sdmVyKSB7XG4gICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIG5lZWRzUmVzb2x2ZXIoKTtcbiAgICB0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSA/IGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKSA6IG5lZWRzTmV3KCk7XG4gIH1cbn1cblxuUHJvbWlzZS5hbGwgPSBhbGw7XG5Qcm9taXNlLnJhY2UgPSByYWNlO1xuUHJvbWlzZS5yZXNvbHZlID0gcmVzb2x2ZTtcblByb21pc2UucmVqZWN0ID0gcmVqZWN0O1xuUHJvbWlzZS5fc2V0U2NoZWR1bGVyID0gc2V0U2NoZWR1bGVyO1xuUHJvbWlzZS5fc2V0QXNhcCA9IHNldEFzYXA7XG5Qcm9taXNlLl9hc2FwID0gYXNhcDtcblxuUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQcm9taXNlLFxuXG4gIC8qKlxuICAgIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICAgIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gICAgcmVhc29uIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAgIC8vIHVzZXIgaXMgYXZhaWxhYmxlXG4gICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIENoYWluaW5nXG4gICAgLS0tLS0tLS1cbiAgXG4gICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gICAgb3IgcmVqZWN0aW9uIGhhbmRsZXIsIG9yIHJlamVjdGVkIGlmIHRoZSBoYW5kbGVyIHRocm93cyBhbiBleGNlcHRpb24uXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICByZXR1cm4gdXNlci5uYW1lO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh1c2VyTmFtZSkge1xuICAgICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gICAgfSk7XG4gIFxuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICAgIH0pO1xuICAgIGBgYFxuICAgIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgdGhyb3cgbmV3IFBlZGFnb2dpY2FsRXhjZXB0aW9uKCdVcHN0cmVhbSBlcnJvcicpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAvLyBUaGUgYFBlZGdhZ29jaWFsRXhjZXB0aW9uYCBpcyBwcm9wYWdhdGVkIGFsbCB0aGUgd2F5IGRvd24gdG8gaGVyZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBBc3NpbWlsYXRpb25cbiAgICAtLS0tLS0tLS0tLS1cbiAgXG4gICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gICAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgU2ltcGxlIEV4YW1wbGVcbiAgICAtLS0tLS0tLS0tLS0tLVxuICBcbiAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gIFxuICAgIGBgYGphdmFzY3JpcHRcbiAgICBsZXQgcmVzdWx0O1xuICBcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBFcnJiYWNrIEV4YW1wbGVcbiAgXG4gICAgYGBganNcbiAgICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBQcm9taXNlIEV4YW1wbGU7XG4gIFxuICAgIGBgYGphdmFzY3JpcHRcbiAgICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgICAtLS0tLS0tLS0tLS0tLVxuICBcbiAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gIFxuICAgIGBgYGphdmFzY3JpcHRcbiAgICBsZXQgYXV0aG9yLCBib29rcztcbiAgXG4gICAgdHJ5IHtcbiAgICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9XG4gICAgYGBgXG4gIFxuICAgIEVycmJhY2sgRXhhbXBsZVxuICBcbiAgICBgYGBqc1xuICBcbiAgICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG4gIFxuICAgIH1cbiAgXG4gICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcbiAgXG4gICAgfVxuICBcbiAgICBmaW5kQXV0aG9yKGZ1bmN0aW9uKGF1dGhvciwgZXJyKXtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZpbmRCb29va3NCeUF1dGhvcihhdXRob3IsIGZ1bmN0aW9uKGJvb2tzLCBlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIFByb21pc2UgRXhhbXBsZTtcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGZpbmRBdXRob3IoKS5cbiAgICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAgIC8vIGZvdW5kIGJvb2tzXG4gICAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgdGhlblxuICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZFxuICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICB0aGVuOiB0aGVuLFxuXG4gIC8qKlxuICAgIGBjYXRjaGAgaXMgc2ltcGx5IHN1Z2FyIGZvciBgdGhlbih1bmRlZmluZWQsIG9uUmVqZWN0aW9uKWAgd2hpY2ggbWFrZXMgaXQgdGhlIHNhbWVcbiAgICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuICBcbiAgICBgYGBqc1xuICAgIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICAgIH1cbiAgXG4gICAgLy8gc3luY2hyb25vdXNcbiAgICB0cnkge1xuICAgICAgZmluZEF1dGhvcigpO1xuICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIH1cbiAgXG4gICAgLy8gYXN5bmMgd2l0aCBwcm9taXNlc1xuICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQG1ldGhvZCBjYXRjaFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0aW9uXG4gICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gICdjYXRjaCc6IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgICB2YXIgbG9jYWwgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbG9jYWwgPSBnbG9iYWw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbG9jYWwgPSBzZWxmO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgICBpZiAoUCkge1xuICAgICAgICB2YXIgcHJvbWlzZVRvU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb21pc2VUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIHNpbGVudGx5IGlnbm9yZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9taXNlVG9TdHJpbmcgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb2NhbC5Qcm9taXNlID0gUHJvbWlzZTtcbn1cblxucG9seWZpbGwoKTtcbi8vIFN0cmFuZ2UgY29tcGF0Li5cblByb21pc2UucG9seWZpbGwgPSBwb2x5ZmlsbDtcblByb21pc2UuUHJvbWlzZSA9IFByb21pc2U7XG5cbnJldHVybiBQcm9taXNlO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXM2LXByb21pc2UubWFwIiwiLyohIEZpbGVTYXZlci5qcyB2MS4zLjZcbiAqXG4gKiBBIHNhdmVBcygpIEZpbGVTYXZlciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBCeSBUcmF2aXMgQ2xhcmtlLCBodHRwczovL3RyYXZpc21jbGFya2UuY29tXG4gKiBCeSBFbGkgR3JleSwgaHR0cDovL2VsaWdyZXkuY29tXG4gKlxuICogTGljZW5zZTogTUlUIChodHRwczovL2dpdGh1Yi5jb20vY2xhcmtldG0vRmlsZVNhdmVyLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQpXG4gKi9cblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cG9ydHMubm9kZU5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gcm9vdC5kb2N1bWVudCA/IGZhY3Rvcnkocm9vdCwgdHJ1ZSkgOiBmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgaWYgKCF3LmRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlsZVNhdmVyIHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KHcpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3Rvcnkocm9vdCk7XG4gICAgfVxufSh3aW5kb3cgfHwgdGhpcywgZnVuY3Rpb24gKHdpbmRvdywgbm9HbG9iYWwpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIC8vIElFIDwxMCBpcyBleHBsaWNpdGx5IHVuc3VwcG9ydGVkXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgL01TSUUgWzEtOV1cXC4vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXJcbiAgICAgICAgICAgIGRvYyA9IHdpbmRvdy5kb2N1bWVudFxuICAgICAgICAgICAgLy8gb25seSBnZXQgVVJMIHdoZW4gbmVjZXNzYXJ5IGluIGNhc2UgQmxvYi5qcyBoYXNuJ3Qgb3ZlcnJpZGRlbiBpdCB5ZXRcbiAgICAgICAgICAgICwgZ2V0X1VSTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICwgc2F2ZV9saW5rID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgXCJhXCIpXG4gICAgICAgICAgICAsIGNhbl91c2Vfc2F2ZV9saW5rID0gXCJkb3dubG9hZFwiIGluIHNhdmVfbGlua1xuICAgICAgICAgICAgLCBjbGljayA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKTtcbiAgICAgICAgICAgICAgICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLCBpc19zYWZhcmkgPSAvY29uc3RydWN0b3IvaS50ZXN0KHdpbmRvdy5IVE1MRWxlbWVudCkgfHwgd2luZG93LnNhZmFyaVxuICAgICAgICAgICAgLCBpc19jaHJvbWVfaW9zID0gL0NyaU9TXFwvW1xcZF0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgICAgICAgICAsIHRocm93X291dHNpZGUgPSBmdW5jdGlvbiAoZXgpIHtcbiAgICAgICAgICAgICAgICAod2luZG93LnNldEltbWVkaWF0ZSB8fCB3aW5kb3cuc2V0VGltZW91dCkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICwgZm9yY2Vfc2F2ZWFibGVfdHlwZSA9IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJcbiAgICAgICAgICAgIC8vIHRoZSBCbG9iIEFQSSBpcyBmdW5kYW1lbnRhbGx5IGJyb2tlbiBhcyB0aGVyZSBpcyBubyBcImRvd25sb2FkZmluaXNoZWRcIiBldmVudCB0byBzdWJzY3JpYmUgdG9cbiAgICAgICAgICAgICwgYXJiaXRyYXJ5X3Jldm9rZV90aW1lb3V0ID0gMTAwMCAqIDQwIC8vIGluIG1zXG4gICAgICAgICAgICAsIHJldm9rZSA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldm9rZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gXCJzdHJpbmdcIikgeyAvLyBmaWxlIGlzIGFuIG9iamVjdCBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldF9VUkwoKS5yZXZva2VPYmplY3RVUkwoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGZpbGUgaXMgYSBGaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJldm9rZXIsIGFyYml0cmFyeV9yZXZva2VfdGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAsIGRpc3BhdGNoID0gZnVuY3Rpb24gKGZpbGVzYXZlciwgZXZlbnRfdHlwZXMsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnRfdHlwZXMgPSBbXS5jb25jYXQoZXZlbnRfdHlwZXMpO1xuICAgICAgICAgICAgICAgIHZhciBpID0gZXZlbnRfdHlwZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZmlsZXNhdmVyW1wib25cIiArIGV2ZW50X3R5cGVzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwoZmlsZXNhdmVyLCBldmVudCB8fCBmaWxlc2F2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd19vdXRzaWRlKGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICwgYXV0b19ib20gPSBmdW5jdGlvbiAoYmxvYikge1xuICAgICAgICAgICAgICAgIC8vIHByZXBlbmQgQk9NIGZvciBVVEYtOCBYTUwgYW5kIHRleHQvKiB0eXBlcyAoaW5jbHVkaW5nIEhUTUwpXG4gICAgICAgICAgICAgICAgLy8gbm90ZTogeW91ciBicm93c2VyIHdpbGwgYXV0b21hdGljYWxseSBjb252ZXJ0IFVURi0xNiBVK0ZFRkYgdG8gRUYgQkIgQkZcbiAgICAgICAgICAgICAgICBpZiAoL15cXHMqKD86dGV4dFxcL1xcUyp8YXBwbGljYXRpb25cXC94bWx8XFxTKlxcL1xcUypcXCt4bWwpXFxzKjsuKmNoYXJzZXRcXHMqPVxccyp1dGYtOC9pLnRlc3QoYmxvYi50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2IoW1N0cmluZy5mcm9tQ2hhckNvZGUoMHhGRUZGKSwgYmxvYl0sIHt0eXBlOiBibG9iLnR5cGV9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAsIEZpbGVTYXZlciA9IGZ1bmN0aW9uIChibG9iLCBuYW1lLCBub19hdXRvX2JvbSkge1xuICAgICAgICAgICAgICAgIGlmICghbm9fYXV0b19ib20pIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvYiA9IGF1dG9fYm9tKGJsb2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaXJzdCB0cnkgYS5kb3dubG9hZCwgdGhlbiB3ZWIgZmlsZXN5c3RlbSwgdGhlbiBvYmplY3QgVVJMc1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBmaWxlc2F2ZXIgPSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICwgdHlwZSA9IGJsb2IudHlwZVxuICAgICAgICAgICAgICAgICAgICAsIGZvcmNlID0gdHlwZSA9PT0gZm9yY2Vfc2F2ZWFibGVfdHlwZVxuICAgICAgICAgICAgICAgICAgICAsIG9iamVjdF91cmxcbiAgICAgICAgICAgICAgICAgICAgLCBkaXNwYXRjaF9hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChmaWxlc2F2ZXIsIFwid3JpdGVzdGFydCBwcm9ncmVzcyB3cml0ZSB3cml0ZWVuZFwiLnNwbGl0KFwiIFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gb24gYW55IGZpbGVzeXMgZXJyb3JzIHJldmVydCB0byBzYXZpbmcgd2l0aCBvYmplY3QgVVJMc1xuICAgICAgICAgICAgICAgICAgICAsIGZzX2Vycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpc19jaHJvbWVfaW9zIHx8IChmb3JjZSAmJiBpc19zYWZhcmkpKSAmJiB3aW5kb3cuRmlsZVJlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IGFsbG93IGRvd25sb2FkaW5nIG9mIGJsb2IgdXJsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBpc19jaHJvbWVfaW9zID8gcmVhZGVyLnJlc3VsdCA6IHJlYWRlci5yZXN1bHQucmVwbGFjZSgvXmRhdGE6W147XSo7LywgJ2RhdGE6YXR0YWNobWVudC9maWxlOycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9wdXAgPSB3aW5kb3cub3Blbih1cmwsICdfYmxhbmsnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwb3B1cCkgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHVuZGVmaW5lZDsgLy8gcmVsZWFzZSByZWZlcmVuY2UgYmVmb3JlIGRpc3BhdGNoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLkRPTkU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoX2FsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuSU5JVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBjcmVhdGUgbW9yZSBvYmplY3QgVVJMcyB0aGFuIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvYmplY3RfdXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0X3VybCA9IGdldF9VUkwoKS5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IG9iamVjdF91cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVuZWQgPSB3aW5kb3cub3BlbihvYmplY3RfdXJsLCBcIl9ibGFua1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wZW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBsZSBkb2VzIG5vdCBhbGxvdyB3aW5kb3cub3Blbiwgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L3NhZmFyaS9kb2N1bWVudGF0aW9uL1Rvb2xzL0NvbmNlcHR1YWwvU2FmYXJpRXh0ZW5zaW9uR3VpZGUvV29ya2luZ3dpdGhXaW5kb3dzYW5kVGFicy9Xb3JraW5nd2l0aFdpbmRvd3NhbmRUYWJzLmh0bWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBvYmplY3RfdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLkRPTkU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaF9hbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldm9rZShvYmplY3RfdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuSU5JVDtcblxuICAgICAgICAgICAgICAgIGlmIChjYW5fdXNlX3NhdmVfbGluaykge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RfdXJsID0gZ2V0X1VSTCgpLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlX2xpbmsuaHJlZiA9IG9iamVjdF91cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlX2xpbmsuZG93bmxvYWQgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2soc2F2ZV9saW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoX2FsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV2b2tlKG9iamVjdF91cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmc19lcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLCBGU19wcm90byA9IEZpbGVTYXZlci5wcm90b3R5cGVcbiAgICAgICAgICAgICwgc2F2ZUFzID0gZnVuY3Rpb24gKGJsb2IsIG5hbWUsIG5vX2F1dG9fYm9tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWxlU2F2ZXIoYmxvYiwgbmFtZSB8fCBibG9iLm5hbWUgfHwgXCJkb3dubG9hZFwiLCBub19hdXRvX2JvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA7XG4gICAgICAgIC8vIElFIDEwKyAobmF0aXZlIHNhdmVBcylcbiAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IpIHtcbiAgICAgICAgICAgIHNhdmVBcyA9IGZ1bmN0aW9uIChibG9iLCBuYW1lLCBub19hdXRvX2JvbSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lIHx8IGJsb2IubmFtZSB8fCBcImRvd25sb2FkXCI7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5vX2F1dG9fYm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2IgPSBhdXRvX2JvbShibG9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKGJsb2IsIG5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIEZTX3Byb3RvLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB9O1xuICAgICAgICBGU19wcm90by5yZWFkeVN0YXRlID0gRlNfcHJvdG8uSU5JVCA9IDA7XG4gICAgICAgIEZTX3Byb3RvLldSSVRJTkcgPSAxO1xuICAgICAgICBGU19wcm90by5ET05FID0gMjtcblxuICAgICAgICBGU19wcm90by5lcnJvciA9XG4gICAgICAgICAgICBGU19wcm90by5vbndyaXRlc3RhcnQgPVxuICAgICAgICAgICAgICAgIEZTX3Byb3RvLm9ucHJvZ3Jlc3MgPVxuICAgICAgICAgICAgICAgICAgICBGU19wcm90by5vbndyaXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIEZTX3Byb3RvLm9uYWJvcnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZTX3Byb3RvLm9uZXJyb3IgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGU19wcm90by5vbndyaXRlZW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgICAgICBkZWZpbmUoXCJmaWxlLXNhdmVyanNcIiwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2F2ZUFzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5vR2xvYmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgd2luZG93LnNhdmVBcyA9IHNhdmVBcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2F2ZUFzO1xuICAgIH1cbikpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX19pbnN0YW5jZXMgPSB7fTtcblxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgc2lnbWEgaW5zdGFuY2VzIGNvbnN0cnVjdG9yLiBPbmUgaW5zdGFuY2Ugb2Ygc2lnbWEgcmVwcmVzZW50XG4gICAqIG9uZSBncmFwaC4gSXQgaXMgcG9zc2libGUgdG8gcmVwcmVzZW50IHRoaXMgZ3JhcMSlIHdpdGggc2V2ZXJhbCByZW5kZXJlcnNcbiAgICogYXQgdGhlIHNhbWUgdGltZS4gQnkgZGVmYXVsdCwgdGhlIGRlZmF1bHQgcmVuZGVyZXIgKFdlYkdMICsgQ2FudmFzXG4gICAqIHBvbHlmaWxsKSB3aWxsIGJlIHVzZWQgYXMgdGhlIG9ubHkgcmVuZGVyZXIsIHdpdGggdGhlIGNvbnRhaW5lciBzcGVjaWZpZWRcbiAgICogaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSAgez8qfSAgICBjb25mIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBpbnN0YW5jZS4gVGhlcmUgYXJlIGEgbG90IG9mXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGRpZmZlcmVudCByZWNvZ25pemVkIGZvcm1zIHRvIGluc3RhbnRpYXRlIHNpZ21hLCBjaGVja1xuICAgKiAgICAgICAgICAgICAgICAgICAgICBleGFtcGxlIGZpbGVzLCBkb2N1bWVudGF0aW9uIGluIHRoaXMgZmlsZSBhbmQgdW5pdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICB0ZXN0cyB0byBrbm93IG1vcmUuXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgIFRoZSBmcmVzaCBuZXcgc2lnbWEgaW5zdGFuY2UuXG4gICAqXG4gICAqIEluc3RhbmNpYXRpbmcgc2lnbWE6XG4gICAqICoqKioqKioqKioqKioqKioqKioqXG4gICAqIElmIG5vIHBhcmFtZXRlciBpcyBnaXZlbiB0byB0aGUgY29uc3RydWN0b3IsIHRoZSBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWRcbiAgICogd2l0aG91dCBhbnkgcmVuZGVyZXIgb3IgY2FtZXJhLiBJdCB3aWxsIGp1c3QgaW5zdGFudGlhdGUgdGhlIGdyYXBoLCBhbmRcbiAgICogb3RoZXIgbW9kdWxlcyB3aWxsIGhhdmUgdG8gYmUgaW5zdGFudGlhdGVkIHRocm91Z2ggdGhlIHB1YmxpYyBtZXRob2RzLFxuICAgKiBsaWtlIFwiYWRkUmVuZGVyZXJcIiBldGM6XG4gICAqXG4gICAqICA+IHMwID0gbmV3IHNpZ21hKCk7XG4gICAqICA+IHMwLmFkZFJlbmRlcmVyKHtcbiAgICogID4gICB0eXBlOiAnY2FudmFzJyxcbiAgICogID4gICBjb250YWluZXI6ICdteS1jb250YWluZXItaWQnXG4gICAqICA+IH0pO1xuICAgKlxuICAgKiBJbiBtb3N0IG9mIHRoZSBjYXNlcywgc2lnbWEgd2lsbCBzaW1wbHkgYmUgdXNlZCB3aXRoIHRoZSBkZWZhdWx0IHJlbmRlcmVyLlxuICAgKiBUaGVuLCBzaW5jZSB0aGUgb25seSByZXF1aXJlZCBwYXJhbWV0ZXIgaXMgdGhlIERPTSBjb250YWluZXIsIHRoZXJlIGFyZVxuICAgKiBzb21lIHNpbXBsZXIgd2F5IHRvIGNhbGwgdGhlIGNvbnN0cnVjdG9yLiBUaGUgZm91ciBmb2xsb3dpbmcgY2FsbHMgZG8gdGhlXG4gICAqIGV4YWN0IHNhbWUgdGhpbmdzOlxuICAgKlxuICAgKiAgPiBzMSA9IG5ldyBzaWdtYSgnbXktY29udGFpbmVyLWlkJyk7XG4gICAqICA+IHMyID0gbmV3IHNpZ21hKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteS1jb250YWluZXItaWQnKSk7XG4gICAqICA+IHMzID0gbmV3IHNpZ21hKHtcbiAgICogID4gICBjb250YWluZXI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteS1jb250YWluZXItaWQnKVxuICAgKiAgPiB9KTtcbiAgICogID4gczQgPSBuZXcgc2lnbWEoe1xuICAgKiAgPiAgIHJlbmRlcmVyczogW3tcbiAgICogID4gICAgIGNvbnRhaW5lcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215LWNvbnRhaW5lci1pZCcpXG4gICAqICA+ICAgfV1cbiAgICogID4gfSk7XG4gICAqXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycywgd2hlbiBjYWxsaW5nIHRoZVxuICAgKiBjb25zdHJ1Y3RvciB3aXRoIHRvIHRvcCBsZXZlbCBjb25maWd1cmF0aW9uIG9iamVjdCAoZm91cnRoIGNhc2UgaW4gdGhlXG4gICAqIHByZXZpb3VzIGV4YW1wbGVzKTpcbiAgICpcbiAgICogICB7P3N0cmluZ30gaWQgICAgICAgIFRoZSBpZCBvZiB0aGUgaW5zdGFuY2UuIEl0IHdpbGwgYmUgZ2VuZXJhdGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGlmIG5vdCBzcGVjaWZpZWQuXG4gICAqICAgez9hcnJheX0gIHJlbmRlcmVycyBBbiBhcnJheSBjb250YWluaW5nIG9iamVjdHMgZGVzY3JpYmluZyByZW5kZXJlcnMuXG4gICAqICAgez9vYmplY3R9IGdyYXBoICAgICBBbiBvYmplY3QgY29udGFpbmluZyBhbiBhcnJheSBvZiBub2RlcyBhbmQgYW4gYXJyYXlcbiAgICogICAgICAgICAgICAgICAgICAgICAgIG9mIGVkZ2VzLCB0byBhdm9pZCBoYXZpbmcgdG8gYWRkIHRoZW0gYnkgaGFuZCBsYXRlci5cbiAgICogICB7P29iamVjdH0gc2V0dGluZ3MgIEFuIG9iamVjdCBjb250YWluaW5nIGluc3RhbmNlIHNwZWNpZmljIHNldHRpbmdzIHRoYXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb25lcyBkZWZpbmVkIGluIHRoZSBvYmplY3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHNpZ21hLnNldHRpbmdzLlxuICAgKi9cbiAgdmFyIHNpZ21hID0gZnVuY3Rpb24oY29uZikge1xuICAgIC8vIExvY2FsIHZhcmlhYmxlczpcbiAgICAvLyAqKioqKioqKioqKioqKioqXG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIGMsXG4gICAgICAgIG8sXG4gICAgICAgIGlkO1xuXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIC8vIFByaXZhdGUgYXR0cmlidXRlczpcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqXG4gICAgdmFyIF9zZWxmID0gdGhpcyxcbiAgICAgICAgX2NvbmYgPSBjb25mIHx8IHt9O1xuXG4gICAgLy8gTGl0dGxlIHNob3J0Y3V0OlxuICAgIC8vICoqKioqKioqKioqKioqKipcbiAgICAvLyBUaGUgY29uZmlndXJhdGlvbiBpcyBzdXBwb3NlZCB0byBoYXZlIGEgbGlzdCBvZiB0aGUgY29uZmlndXJhdGlvblxuICAgIC8vIG9iamVjdHMgZm9yIGVhY2ggcmVuZGVyZXIuXG4gICAgLy8gIC0gSWYgdGhlcmUgYXJlIG5vIGNvbmZpZ3VyYXRpb24gYXQgYWxsLCB0aGVuIG5vdGhpbmcgaXMgZG9uZS5cbiAgICAvLyAgLSBJZiB0aGVyZSBhcmUgbm8gcmVuZGVyZXIgbGlzdCwgdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdpbGwgYmVcbiAgICAvLyAgICBjb25zaWRlcmVkIGFzIGRlc2NyaWJpbmcgdGhlIGZpcnN0IGFuZCBvbmx5IHJlbmRlcmVyLlxuICAgIC8vICAtIElmIHRoZXJlIGFyZSBubyByZW5kZXJlciBsaXN0IG5vciBcImNvbnRhaW5lclwiIG9iamVjdCwgaXQgd2lsbCBiZVxuICAgIC8vICAgIGNvbnNpZGVyZWQgYXMgdGhlIGNvbnRhaW5lciBpdHNlbGYgKGEgRE9NIGVsZW1lbnQpLlxuICAgIC8vICAtIElmIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gc2lnbWEoKSBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSBjb25zaWRlcmVkXG4gICAgLy8gICAgYXMgdGhlIElEIG9mIHRoZSBET00gY29udGFpbmVyLlxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBfY29uZiA9PT0gJ3N0cmluZycgfHxcbiAgICAgIF9jb25mIGluc3RhbmNlb2YgSFRNTEVsZW1lbnRcbiAgICApXG4gICAgICBfY29uZiA9IHtcbiAgICAgICAgcmVuZGVyZXJzOiBbX2NvbmZdXG4gICAgICB9O1xuICAgIGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChfY29uZikgPT09ICdbb2JqZWN0IEFycmF5XScpXG4gICAgICBfY29uZiA9IHtcbiAgICAgICAgcmVuZGVyZXJzOiBfY29uZlxuICAgICAgfTtcblxuICAgIC8vIEFsc28gY2hlY2sgXCJyZW5kZXJlclwiIGFuZCBcImNvbnRhaW5lclwiIGtleXM6XG4gICAgbyA9IF9jb25mLnJlbmRlcmVycyB8fCBfY29uZi5yZW5kZXJlciB8fCBfY29uZi5jb250YWluZXI7XG4gICAgaWYgKCFfY29uZi5yZW5kZXJlcnMgfHwgX2NvbmYucmVuZGVyZXJzLmxlbmd0aCA9PT0gMClcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIG8gPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fFxuICAgICAgICAodHlwZW9mIG8gPT09ICdvYmplY3QnICYmICdjb250YWluZXInIGluIG8pXG4gICAgICApXG4gICAgICAgIF9jb25mLnJlbmRlcmVycyA9IFtvXTtcblxuICAgIC8vIFJlY2Vuc2UgdGhlIGluc3RhbmNlOlxuICAgIGlmIChfY29uZi5pZCkge1xuICAgICAgaWYgKF9faW5zdGFuY2VzW19jb25mLmlkXSlcbiAgICAgICAgdGhyb3cgJ3NpZ21hOiBJbnN0YW5jZSBcIicgKyBfY29uZi5pZCArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZCcsIHtcbiAgICAgICAgdmFsdWU6IF9jb25mLmlkXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWQgPSAwO1xuICAgICAgd2hpbGUgKF9faW5zdGFuY2VzW2lkXSlcbiAgICAgICAgaWQrKztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaWQnLCB7XG4gICAgICAgIHZhbHVlOiAnJyArIGlkXG4gICAgICB9KTtcbiAgICB9XG4gICAgX19pbnN0YW5jZXNbdGhpcy5pZF0gPSB0aGlzO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBzZXR0aW5ncyBmdW5jdGlvbjpcbiAgICB0aGlzLnNldHRpbmdzID0gbmV3IHNpZ21hLmNsYXNzZXMuY29uZmlndXJhYmxlKFxuICAgICAgc2lnbWEuc2V0dGluZ3MsXG4gICAgICBfY29uZi5zZXR0aW5ncyB8fCB7fVxuICAgICk7XG5cbiAgICAvLyBJbml0aWFsaXplIGxvY2tlZCBhdHRyaWJ1dGVzOlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZ3JhcGgnLCB7XG4gICAgICB2YWx1ZTogbmV3IHNpZ21hLmNsYXNzZXMuZ3JhcGgodGhpcy5zZXR0aW5ncyksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21pZGRsZXdhcmVzJywge1xuICAgICAgdmFsdWU6IFtdLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjYW1lcmFzJywge1xuICAgICAgdmFsdWU6IHt9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZW5kZXJlcnMnLCB7XG4gICAgICB2YWx1ZToge30sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JlbmRlcmVyc1BlckNhbWVyYScsIHtcbiAgICAgIHZhbHVlOiB7fSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY2FtZXJhRnJhbWVzJywge1xuICAgICAgdmFsdWU6IHt9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjYW1lcmEnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW1lcmFzWzBdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZXZlbnRzJywge1xuICAgICAgdmFsdWU6IFtcbiAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgJ3JpZ2h0Q2xpY2snLFxuICAgICAgICAnY2xpY2tTdGFnZScsXG4gICAgICAgICdkb3VibGVDbGlja1N0YWdlJyxcbiAgICAgICAgJ3JpZ2h0Q2xpY2tTdGFnZScsXG4gICAgICAgICdjbGlja05vZGUnLFxuICAgICAgICAnY2xpY2tOb2RlcycsXG4gICAgICAgICdkb3VibGVDbGlja05vZGUnLFxuICAgICAgICAnZG91YmxlQ2xpY2tOb2RlcycsXG4gICAgICAgICdyaWdodENsaWNrTm9kZScsXG4gICAgICAgICdyaWdodENsaWNrTm9kZXMnLFxuICAgICAgICAnb3Zlck5vZGUnLFxuICAgICAgICAnb3Zlck5vZGVzJyxcbiAgICAgICAgJ291dE5vZGUnLFxuICAgICAgICAnb3V0Tm9kZXMnLFxuICAgICAgICAnZG93bk5vZGUnLFxuICAgICAgICAnZG93bk5vZGVzJyxcbiAgICAgICAgJ3VwTm9kZScsXG4gICAgICAgICd1cE5vZGVzJ1xuICAgICAgXSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgLy8gQWRkIGEgY3VzdG9tIGhhbmRsZXIsIHRvIHJlZGlzcGF0Y2ggZXZlbnRzIGZyb20gcmVuZGVyZXJzOlxuICAgIHRoaXMuX2hhbmRsZXIgPSAoZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGssXG4gICAgICAgICAgZGF0YSA9IHt9O1xuXG4gICAgICBmb3IgKGsgaW4gZS5kYXRhKVxuICAgICAgICBkYXRhW2tdID0gZS5kYXRhW2tdO1xuXG4gICAgICBkYXRhLnJlbmRlcmVyID0gZS50YXJnZXQ7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZS50eXBlLCBkYXRhKTtcbiAgICB9KS5iaW5kKHRoaXMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSByZW5kZXJlcnM6XG4gICAgYSA9IF9jb25mLnJlbmRlcmVycyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICB0aGlzLmFkZFJlbmRlcmVyKGFbaV0pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBtaWRkbGV3YXJlczpcbiAgICBhID0gX2NvbmYubWlkZGxld2FyZXMgfHwgW107XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgdGhpcy5taWRkbGV3YXJlcy5wdXNoKFxuICAgICAgICB0eXBlb2YgYVtpXSA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgIHNpZ21hLm1pZGRsZXdhcmVzW2FbaV1dIDpcbiAgICAgICAgICBhW2ldXG4gICAgICApO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYWxyZWFkeSBhIGdyYXBoIHRvIGZpbGwgaW46XG4gICAgaWYgKHR5cGVvZiBfY29uZi5ncmFwaCA9PT0gJ29iamVjdCcgJiYgX2NvbmYuZ3JhcGgpIHtcbiAgICAgIHRoaXMuZ3JhcGgucmVhZChfY29uZi5ncmFwaCk7XG5cbiAgICAgIC8vIElmIGEgZ3JhcGggaXMgZ2l2ZW4gdG8gdGhlIHRvIHRoZSBpbnN0YW5jZSwgdGhlIFwicmVmcmVzaFwiIG1ldGhvZCBpc1xuICAgICAgLy8gZGlyZWN0bHkgY2FsbGVkOlxuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfVxuXG4gICAgLy8gRGVhbCB3aXRoIHJlc2l6ZTpcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoX3NlbGYuc2V0dGluZ3MpXG4gICAgICAgIF9zZWxmLnJlZnJlc2goKTtcbiAgICB9KTtcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2RzIHdpbGwgaW5zdGFudGlhdGUgYW5kIHJlZmVyZW5jZSBhIG5ldyBjYW1lcmEuIElmIG5vIGlkIGlzXG4gICAqIHNwZWNpZmllZCwgdGhlbiBhbiBhdXRvbWF0aWMgaWQgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9ICAgICAgICAgICAgICBpZCBFdmVudHVhbGx5IHRoZSBjYW1lcmEgaWQuXG4gICAqIEByZXR1cm4ge3NpZ21hLmNsYXNzZXMuY2FtZXJhfSAgICBUaGUgZnJlc2ggbmV3IGNhbWVyYSBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5hZGRDYW1lcmEgPSBmdW5jdGlvbihpZCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgY2FtZXJhO1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBpZCA9IDA7XG4gICAgICB3aGlsZSAodGhpcy5jYW1lcmFzWycnICsgaWRdKVxuICAgICAgICBpZCsrO1xuICAgICAgaWQgPSAnJyArIGlkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNhbWVyYXNbaWRdKVxuICAgICAgdGhyb3cgJ3NpZ21hLmFkZENhbWVyYTogVGhlIGNhbWVyYSBcIicgKyBpZCArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xuXG4gICAgY2FtZXJhID0gbmV3IHNpZ21hLmNsYXNzZXMuY2FtZXJhKGlkLCB0aGlzLmdyYXBoLCB0aGlzLnNldHRpbmdzKTtcbiAgICB0aGlzLmNhbWVyYXNbaWRdID0gY2FtZXJhO1xuXG4gICAgLy8gQWRkIGEgcXVhZHRyZWUgdG8gdGhlIGNhbWVyYTpcbiAgICBjYW1lcmEucXVhZHRyZWUgPSBuZXcgc2lnbWEuY2xhc3Nlcy5xdWFkKCk7XG5cbiAgICAvLyBBZGQgYW4gZWRnZXF1YWR0cmVlIHRvIHRoZSBjYW1lcmE6XG4gICAgaWYgKHNpZ21hLmNsYXNzZXMuZWRnZXF1YWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FtZXJhLmVkZ2VxdWFkdHJlZSA9IG5ldyBzaWdtYS5jbGFzc2VzLmVkZ2VxdWFkKCk7XG4gICAgfVxuXG4gICAgY2FtZXJhLmJpbmQoJ2Nvb3JkaW5hdGVzVXBkYXRlZCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHNlbGYucmVuZGVyQ2FtZXJhKGNhbWVyYSwgY2FtZXJhLmlzQW5pbWF0ZWQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbaWRdID0gW107XG5cbiAgICByZXR1cm4gY2FtZXJhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBraWxscyBhIGNhbWVyYSwgYW5kIGV2ZXJ5IHJlbmRlcmVyIGF0dGFjaGVkIHRvIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8Y2FtZXJhfSB2IFRoZSBjYW1lcmEgdG8ga2lsbCBvciBpdHMgSUQuXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUua2lsbENhbWVyYSA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2ID0gdHlwZW9mIHYgPT09ICdzdHJpbmcnID8gdGhpcy5jYW1lcmFzW3ZdIDogdjtcblxuICAgIGlmICghdilcbiAgICAgIHRocm93ICdzaWdtYS5raWxsQ2FtZXJhOiBUaGUgY2FtZXJhIGlzIHVuZGVmaW5lZC4nO1xuXG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEgPSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVt2LmlkXTtcblxuICAgIGZvciAobCA9IGEubGVuZ3RoLCBpID0gbCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgdGhpcy5raWxsUmVuZGVyZXIoYVtpXSk7XG5cbiAgICBkZWxldGUgdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbdi5pZF07XG4gICAgZGVsZXRlIHRoaXMuY2FtZXJhRnJhbWVzW3YuaWRdO1xuICAgIGRlbGV0ZSB0aGlzLmNhbWVyYXNbdi5pZF07XG5cbiAgICBpZiAodi5raWxsKVxuICAgICAgdi5raWxsKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2RzIHdpbGwgaW5zdGFudGlhdGUgYW5kIHJlZmVyZW5jZSBhIG5ldyByZW5kZXJlci4gVGhlIFwidHlwZVwiXG4gICAqIGFyZ3VtZW50IGNhbiBiZSB0aGUgY29uc3RydWN0b3Igb3IgaXRzIG5hbWUgaW4gdGhlIFwic2lnbWEucmVuZGVyZXJzXCJcbiAgICogcGFja2FnZS4gSWYgbm8gdHlwZSBpcyBzcGVjaWZpZWQsIHRoZW4gXCJzaWdtYS5yZW5kZXJlcnMuZGVmXCIgd2lsbCBiZSB1c2VkLlxuICAgKiBJZiBubyBpZCBpcyBzcGVjaWZpZWQsIHRoZW4gYW4gYXV0b21hdGljIGlkIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSAgb3B0aW9ucyBFdmVudHVhbGx5IHNvbWUgb3B0aW9ucyB0byBnaXZlIHRvIHRoZSByZW5kZXJlclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvci5cbiAgICogQHJldHVybiB7cmVuZGVyZXJ9ICAgICAgICAgVGhlIGZyZXNoIG5ldyByZW5kZXJlciBpbnN0YW5jZS5cbiAgICpcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzIGluIHRoZSBcIm9wdGlvbnNcIlxuICAgKiBvYmplY3Q6XG4gICAqXG4gICAqICAgez9zdHJpbmd9ICAgICAgICAgICAgaWQgICAgIEV2ZW50dWFsbHkgdGhlIHJlbmRlcmVyIGlkLlxuICAgKiAgIHs/KGZ1bmN0aW9ufHN0cmluZyl9IHR5cGUgICBFdmVudHVhbGx5IHRoZSByZW5kZXJlciBjb25zdHJ1Y3RvciBvciBpdHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSBpbiB0aGUgXCJzaWdtYS5yZW5kZXJlcnNcIiBwYWNrYWdlLlxuICAgKiAgIHs/KGNhbWVyYXxzdHJpbmcpfSAgIGNhbWVyYSBFdmVudHVhbGx5IHRoZSByZW5kZXJlciBjYW1lcmEgb3IgaXRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmFkZFJlbmRlcmVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBpZCxcbiAgICAgICAgZm4sXG4gICAgICAgIGNhbWVyYSxcbiAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgIG8gPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gUG9seW1vcnBoaXNtOlxuICAgIGlmICh0eXBlb2YgbyA9PT0gJ3N0cmluZycpXG4gICAgICBvID0ge1xuICAgICAgICBjb250YWluZXI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG8pXG4gICAgICB9O1xuICAgIGVsc2UgaWYgKG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudClcbiAgICAgIG8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogb1xuICAgICAgfTtcblxuICAgIC8vIElmIHRoZSBjb250YWluZXIgc3RpbGwgaXMgYSBzdHJpbmcsIHdlIGdldCBpdCBieSBpZFxuICAgIGlmICh0eXBlb2Ygby5jb250YWluZXIgPT09ICdzdHJpbmcnKVxuICAgICAgby5jb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvLmNvbnRhaW5lcik7XG5cbiAgICAvLyBSZWZlcmVuY2UgdGhlIG5ldyByZW5kZXJlcjpcbiAgICBpZiAoISgnaWQnIGluIG8pKSB7XG4gICAgICBpZCA9IDA7XG4gICAgICB3aGlsZSAodGhpcy5yZW5kZXJlcnNbJycgKyBpZF0pXG4gICAgICAgIGlkKys7XG4gICAgICBpZCA9ICcnICsgaWQ7XG4gICAgfSBlbHNlXG4gICAgICBpZCA9IG8uaWQ7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJlcnNbaWRdKVxuICAgICAgdGhyb3cgJ3NpZ21hLmFkZFJlbmRlcmVyOiBUaGUgcmVuZGVyZXIgXCInICsgaWQgKyAnXCIgYWxyZWFkeSBleGlzdHMuJztcblxuICAgIC8vIEZpbmQgdGhlIGdvb2QgY29uc3RydWN0b3I6XG4gICAgZm4gPSB0eXBlb2Ygby50eXBlID09PSAnZnVuY3Rpb24nID8gby50eXBlIDogc2lnbWEucmVuZGVyZXJzW28udHlwZV07XG4gICAgZm4gPSBmbiB8fCBzaWdtYS5yZW5kZXJlcnMuZGVmO1xuXG4gICAgLy8gRmluZCB0aGUgZ29vZCBjYW1lcmE6XG4gICAgY2FtZXJhID0gJ2NhbWVyYScgaW4gbyA/XG4gICAgICAoXG4gICAgICAgIG8uY2FtZXJhIGluc3RhbmNlb2Ygc2lnbWEuY2xhc3Nlcy5jYW1lcmEgP1xuICAgICAgICAgIG8uY2FtZXJhIDpcbiAgICAgICAgICB0aGlzLmNhbWVyYXNbby5jYW1lcmFdIHx8IHRoaXMuYWRkQ2FtZXJhKG8uY2FtZXJhKVxuICAgICAgKSA6XG4gICAgICB0aGlzLmFkZENhbWVyYSgpO1xuXG4gICAgaWYgKHRoaXMuY2FtZXJhc1tjYW1lcmEuaWRdICE9PSBjYW1lcmEpXG4gICAgICB0aHJvdyAnc2lnbWEuYWRkUmVuZGVyZXI6IFRoZSBjYW1lcmEgaXMgbm90IHByb3Blcmx5IHJlZmVyZW5jZWQuJztcblxuICAgIC8vIEluc3RhbnRpYXRlOlxuICAgIHJlbmRlcmVyID0gbmV3IGZuKHRoaXMuZ3JhcGgsIGNhbWVyYSwgdGhpcy5zZXR0aW5ncywgbyk7XG4gICAgdGhpcy5yZW5kZXJlcnNbaWRdID0gcmVuZGVyZXI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlbmRlcmVyLCAnaWQnLCB7XG4gICAgICB2YWx1ZTogaWRcbiAgICB9KTtcblxuICAgIC8vIEJpbmQgZXZlbnRzOlxuICAgIGlmIChyZW5kZXJlci5iaW5kKVxuICAgICAgcmVuZGVyZXIuYmluZChcbiAgICAgICAgW1xuICAgICAgICAgICdjbGljaycsXG4gICAgICAgICAgJ3JpZ2h0Q2xpY2snLFxuICAgICAgICAgICdjbGlja1N0YWdlJyxcbiAgICAgICAgICAnZG91YmxlQ2xpY2tTdGFnZScsXG4gICAgICAgICAgJ3JpZ2h0Q2xpY2tTdGFnZScsXG4gICAgICAgICAgJ2NsaWNrTm9kZScsXG4gICAgICAgICAgJ2NsaWNrTm9kZXMnLFxuICAgICAgICAgICdjbGlja0VkZ2UnLFxuICAgICAgICAgICdjbGlja0VkZ2VzJyxcbiAgICAgICAgICAnZG91YmxlQ2xpY2tOb2RlJyxcbiAgICAgICAgICAnZG91YmxlQ2xpY2tOb2RlcycsXG4gICAgICAgICAgJ2RvdWJsZUNsaWNrRWRnZScsXG4gICAgICAgICAgJ2RvdWJsZUNsaWNrRWRnZXMnLFxuICAgICAgICAgICdyaWdodENsaWNrTm9kZScsXG4gICAgICAgICAgJ3JpZ2h0Q2xpY2tOb2RlcycsXG4gICAgICAgICAgJ3JpZ2h0Q2xpY2tFZGdlJyxcbiAgICAgICAgICAncmlnaHRDbGlja0VkZ2VzJyxcbiAgICAgICAgICAnb3Zlck5vZGUnLFxuICAgICAgICAgICdvdmVyTm9kZXMnLFxuICAgICAgICAgICdvdmVyRWRnZScsXG4gICAgICAgICAgJ292ZXJFZGdlcycsXG4gICAgICAgICAgJ291dE5vZGUnLFxuICAgICAgICAgICdvdXROb2RlcycsXG4gICAgICAgICAgJ291dEVkZ2UnLFxuICAgICAgICAgICdvdXRFZGdlcycsXG4gICAgICAgICAgJ2Rvd25Ob2RlJyxcbiAgICAgICAgICAnZG93bk5vZGVzJyxcbiAgICAgICAgICAnZG93bkVkZ2UnLFxuICAgICAgICAgICdkb3duRWRnZXMnLFxuICAgICAgICAgICd1cE5vZGUnLFxuICAgICAgICAgICd1cE5vZGVzJyxcbiAgICAgICAgICAndXBFZGdlJyxcbiAgICAgICAgICAndXBFZGdlcydcbiAgICAgICAgXSxcbiAgICAgICAgdGhpcy5faGFuZGxlclxuICAgICAgKTtcblxuICAgIC8vIFJlZmVyZW5jZSB0aGUgcmVuZGVyZXIgYnkgaXRzIGNhbWVyYTpcbiAgICB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjYW1lcmEuaWRdLnB1c2gocmVuZGVyZXIpO1xuXG4gICAgcmV0dXJuIHJlbmRlcmVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBraWxscyBhIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8cmVuZGVyZXJ9IHYgVGhlIHJlbmRlcmVyIHRvIGtpbGwgb3IgaXRzIElELlxuICAgKiBAcmV0dXJuIHtzaWdtYX0gICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUua2lsbFJlbmRlcmVyID0gZnVuY3Rpb24odikge1xuICAgIHYgPSB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyB0aGlzLnJlbmRlcmVyc1t2XSA6IHY7XG5cbiAgICBpZiAoIXYpXG4gICAgICB0aHJvdyAnc2lnbWEua2lsbFJlbmRlcmVyOiBUaGUgcmVuZGVyZXIgaXMgdW5kZWZpbmVkLic7XG5cbiAgICB2YXIgYSA9IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW3YuY2FtZXJhLmlkXSxcbiAgICAgICAgaSA9IGEuaW5kZXhPZih2KTtcblxuICAgIGlmIChpID49IDApXG4gICAgICBhLnNwbGljZShpLCAxKTtcblxuICAgIGlmICh2LmtpbGwpXG4gICAgICB2LmtpbGwoKTtcblxuICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVyc1t2LmlkXTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgXCJyZW5kZXJcIiBtZXRob2Qgb2YgZWFjaCByZW5kZXJlciwgd2l0aCB0aGUgc2FtZVxuICAgKiBhcmd1bWVudHMgdGhhbiB0aGUgXCJyZW5kZXJcIiBtZXRob2QsIGJ1dCB3aWxsIGFsc28gY2hlY2sgaWYgdGhlIHJlbmRlcmVyXG4gICAqIGhhcyBhIFwicHJvY2Vzc1wiIG1ldGhvZCwgYW5kIGNhbGwgaXQgaWYgaXQgZXhpc3RzLlxuICAgKlxuICAgKiBJdCBpcyB1c2VmdWwgZm9yIHF1YWR0cmVlcyBvciBXZWJHTCBwcm9jZXNzaW5nLCBmb3IgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICBvcHRpb25zIEV2ZW50dWFsbHkgc29tZSBvcHRpb25zIHRvIGdpdmUgdG8gdGhlIHJlZnJlc2hcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLlxuICAgKiBAcmV0dXJuIHtzaWdtYX0gICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycyBpbiB0aGUgXCJvcHRpb25zXCJcbiAgICogb2JqZWN0OlxuICAgKlxuICAgKiAgIHs/Ym9vbGVhbn0gc2tpcEluZGV4YXRpb24gQSBmbGFnIHNwZWNpZnlpbmcgd2V0aGVyIG9yIG5vdCB0aGUgcmVmcmVzaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2hvdWxkIHJlaW5kZXggdGhlIGdyYXBoIGluIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhZHRyZWVzIG9yIG5vdCAoZGVmYXVsdDogZmFsc2UpLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGssXG4gICAgICAgIGEsXG4gICAgICAgIGMsXG4gICAgICAgIGJvdW5kcyxcbiAgICAgICAgcHJlZml4ID0gMDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gQ2FsbCBlYWNoIG1pZGRsZXdhcmU6XG4gICAgYSA9IHRoaXMubWlkZGxld2FyZXMgfHwgW107XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgYVtpXS5jYWxsKFxuICAgICAgICB0aGlzLFxuICAgICAgICAoaSA9PT0gMCkgPyAnJyA6ICd0bXAnICsgcHJlZml4ICsgJzonLFxuICAgICAgICAoaSA9PT0gbCAtIDEpID8gJ3JlYWR5OicgOiAoJ3RtcCcgKyAoKytwcmVmaXgpICsgJzonKVxuICAgICAgKTtcblxuICAgIC8vIFRoZW4sIGZvciBlYWNoIGNhbWVyYSwgY2FsbCB0aGUgXCJyZXNjYWxlXCIgbWlkZGxld2FyZSwgdW5sZXNzIHRoZVxuICAgIC8vIHNldHRpbmdzIHNwZWNpZnkgbm90IHRvOlxuICAgIGZvciAoayBpbiB0aGlzLmNhbWVyYXMpIHtcbiAgICAgIGMgPSB0aGlzLmNhbWVyYXNba107XG4gICAgICBpZiAoXG4gICAgICAgIGMuc2V0dGluZ3MoJ2F1dG9SZXNjYWxlJykgJiZcbiAgICAgICAgdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbYy5pZF0gJiZcbiAgICAgICAgdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbYy5pZF0ubGVuZ3RoXG4gICAgICApXG4gICAgICAgIHNpZ21hLm1pZGRsZXdhcmVzLnJlc2NhbGUuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGEubGVuZ3RoID8gJ3JlYWR5OicgOiAnJyxcbiAgICAgICAgICBjLnJlYWRQcmVmaXgsXG4gICAgICAgICAge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2MuaWRdWzBdLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjLmlkXVswXS5oZWlnaHRcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICBlbHNlXG4gICAgICAgIHNpZ21hLm1pZGRsZXdhcmVzLmNvcHkuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGEubGVuZ3RoID8gJ3JlYWR5OicgOiAnJyxcbiAgICAgICAgICBjLnJlYWRQcmVmaXhcbiAgICAgICAgKTtcblxuICAgICAgaWYgKCFvcHRpb25zLnNraXBJbmRleGF0aW9uKSB7XG4gICAgICAgIC8vIEZpbmQgZ3JhcGggYm91bmRhcmllczpcbiAgICAgICAgYm91bmRzID0gc2lnbWEudXRpbHMuZ2V0Qm91bmRhcmllcyhcbiAgICAgICAgICB0aGlzLmdyYXBoLFxuICAgICAgICAgIGMucmVhZFByZWZpeFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFJlZnJlc2ggcXVhZHRyZWU6XG4gICAgICAgIGMucXVhZHRyZWUuaW5kZXgodGhpcy5ncmFwaC5ub2RlcygpLCB7XG4gICAgICAgICAgcHJlZml4OiBjLnJlYWRQcmVmaXgsXG4gICAgICAgICAgYm91bmRzOiB7XG4gICAgICAgICAgICB4OiBib3VuZHMubWluWCxcbiAgICAgICAgICAgIHk6IGJvdW5kcy5taW5ZLFxuICAgICAgICAgICAgd2lkdGg6IGJvdW5kcy5tYXhYIC0gYm91bmRzLm1pblgsXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kcy5tYXhZIC0gYm91bmRzLm1pbllcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlZnJlc2ggZWRnZXF1YWR0cmVlOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgYy5lZGdlcXVhZHRyZWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIGMuc2V0dGluZ3MoJ2RyYXdFZGdlcycpICYmXG4gICAgICAgICAgYy5zZXR0aW5ncygnZW5hYmxlRWRnZUhvdmVyaW5nJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgYy5lZGdlcXVhZHRyZWUuaW5kZXgodGhpcy5ncmFwaCwge1xuICAgICAgICAgICAgcHJlZml4OiBjLnJlYWRQcmVmaXgsXG4gICAgICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICAgICAgeDogYm91bmRzLm1pblgsXG4gICAgICAgICAgICAgIHk6IGJvdW5kcy5taW5ZLFxuICAgICAgICAgICAgICB3aWR0aDogYm91bmRzLm1heFggLSBib3VuZHMubWluWCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZHMubWF4WSAtIGJvdW5kcy5taW5ZXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDYWxsIGVhY2ggcmVuZGVyZXI6XG4gICAgYSA9IE9iamVjdC5rZXlzKHRoaXMucmVuZGVyZXJzKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpZiAodGhpcy5yZW5kZXJlcnNbYVtpXV0ucHJvY2Vzcykge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncygnc2tpcEVycm9ycycpKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyc1thW2ldXS5wcm9jZXNzKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICdXYXJuaW5nOiBUaGUgcmVuZGVyZXIgXCInICsgYVtpXSArICdcIiBjcmFzaGVkIG9uIFwiLnByb2Nlc3MoKVwiJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyc1thW2ldXS5wcm9jZXNzKCk7XG4gICAgICB9XG5cbiAgICB0aGlzLnJlbmRlcigpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBcInJlbmRlclwiIG1ldGhvZCBvZiBlYWNoIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzaWdtYX0gUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBhLFxuICAgICAgICBwcmVmaXggPSAwO1xuXG4gICAgLy8gQ2FsbCBlYWNoIHJlbmRlcmVyOlxuICAgIGEgPSBPYmplY3Qua2V5cyh0aGlzLnJlbmRlcmVycyk7XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3NraXBFcnJvcnMnKSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyc1thW2ldXS5yZW5kZXIoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCd2ZXJib3NlJykpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgJ1dhcm5pbmc6IFRoZSByZW5kZXJlciBcIicgKyBhW2ldICsgJ1wiIGNyYXNoZWQgb24gXCIucmVuZGVyKClcIidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5yZW5kZXJlcnNbYVtpXV0ucmVuZGVyKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIFwicmVuZGVyXCIgbWV0aG9kIG9mIGVhY2ggcmVuZGVyZXIgdGhhdCBpcyBib3VuZCB0b1xuICAgKiB0aGUgc3BlY2lmaWVkIGNhbWVyYS4gVG8gaW1wcm92ZSB0aGUgcGVyZm9ybWFuY2VzLCBpZiB0aGlzIG1ldGhvZCBpc1xuICAgKiBjYWxsZWQgdG9vIG9mdGVuLCB0aGUgbnVtYmVyIG9mIGVmZmVjdGl2ZSByZW5kZXJpbmdzIGlzIGxpbWl0YXRlZCB0byBvbmVcbiAgICogcGVyIGZyYW1lLCB1bmxlc3MgeW91IGFyZSB1c2luZyB0aGUgXCJmb3JjZVwiIGZsYWcuXG4gICAqXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuY2FtZXJhfSBjYW1lcmEgVGhlIGNhbWVyYSB0byByZW5kZXIuXG4gICAqIEBwYXJhbSAgez9ib29sZWFufSAgICAgICAgICAgICBmb3JjZSAgSWYgdHJ1ZSwgd2lsbCByZW5kZXIgdGhlIGNhbWVyYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGx5LlxuICAgKiBAcmV0dXJuIHtzaWdtYX0gICAgICAgICAgICAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5yZW5kZXJDYW1lcmEgPSBmdW5jdGlvbihjYW1lcmEsIGZvcmNlKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKGZvcmNlKSB7XG4gICAgICBhID0gdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbY2FtZXJhLmlkXTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3NraXBFcnJvcnMnKSlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYVtpXS5yZW5kZXIoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncygndmVyYm9zZScpKVxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAnV2FybmluZzogVGhlIHJlbmRlcmVyIFwiJyArIGFbaV0uaWQgKyAnXCIgY3Jhc2hlZCBvbiBcIi5yZW5kZXIoKVwiJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGFbaV0ucmVuZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5jYW1lcmFGcmFtZXNbY2FtZXJhLmlkXSkge1xuICAgICAgICBhID0gdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbY2FtZXJhLmlkXTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCdza2lwRXJyb3JzJykpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhW2ldLnJlbmRlcigpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncygndmVyYm9zZScpKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgJ1dhcm5pbmc6IFRoZSByZW5kZXJlciBcIicgK1xuICAgICAgICAgICAgICAgICAgICBhW2ldLmlkICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIGNyYXNoZWQgb24gXCIucmVuZGVyKClcIidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFbaV0ucmVuZGVyKCk7XG5cbiAgICAgICAgdGhpcy5jYW1lcmFGcmFtZXNbY2FtZXJhLmlkXSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBkZWxldGUgc2VsZi5jYW1lcmFGcmFtZXNbY2FtZXJhLmlkXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBcImtpbGxcIiBtZXRob2Qgb2YgZWFjaCBtb2R1bGUgYW5kIGRlc3Ryb3lzIGFueVxuICAgKiByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrO1xuXG4gICAgLy8gRGlzcGF0Y2hpbmcgZXZlbnRcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2tpbGwnKTtcblxuICAgIC8vIEtpbGwgZ3JhcGg6XG4gICAgdGhpcy5ncmFwaC5raWxsKCk7XG5cbiAgICAvLyBLaWxsIG1pZGRsZXdhcmVzOlxuICAgIGRlbGV0ZSB0aGlzLm1pZGRsZXdhcmVzO1xuXG4gICAgLy8gS2lsbCBlYWNoIHJlbmRlcmVyOlxuICAgIGZvciAoayBpbiB0aGlzLnJlbmRlcmVycylcbiAgICAgIHRoaXMua2lsbFJlbmRlcmVyKHRoaXMucmVuZGVyZXJzW2tdKTtcblxuICAgIC8vIEtpbGwgZWFjaCBjYW1lcmE6XG4gICAgZm9yIChrIGluIHRoaXMuY2FtZXJhcylcbiAgICAgIHRoaXMua2lsbENhbWVyYSh0aGlzLmNhbWVyYXNba10pO1xuXG4gICAgZGVsZXRlIHRoaXMucmVuZGVyZXJzO1xuICAgIGRlbGV0ZSB0aGlzLmNhbWVyYXM7XG5cbiAgICAvLyBLaWxsIGV2ZXJ5dGhpbmcgZWxzZTpcbiAgICBmb3IgKGsgaW4gdGhpcylcbiAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGspKVxuICAgICAgICBkZWxldGUgdGhpc1trXTtcblxuICAgIGRlbGV0ZSBfX2luc3RhbmNlc1t0aGlzLmlkXTtcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBpbnN0YW5jZXMgb2JqZWN0IG9yIGEgc3BlY2lmaWMgcnVubmluZyBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtICB7P3N0cmluZ30gaWQgRXZlbnR1YWxseSBhbiBpbnN0YW5jZSBJRC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgVGhlIHJlbGF0ZWQgaW5zdGFuY2Ugb3IgYSBjbG9uZSBvZiB0aGUgaW5zdGFuY2VzXG4gICAqICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5cbiAgICovXG4gIHNpZ21hLmluc3RhbmNlcyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggP1xuICAgICAgX19pbnN0YW5jZXNbaWRdIDpcbiAgICAgIHNpZ21hLnV0aWxzLmV4dGVuZCh7fSwgX19pbnN0YW5jZXMpO1xuICB9O1xuXG5cblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBzaWdtYTpcbiAgICovXG4gIHNpZ21hLnZlcnNpb24gPSAnMS4yLjEnO1xuXG5cblxuXG4gIC8qKlxuICAgKiBFWFBPUlQ6XG4gICAqICoqKioqKipcbiAgICovXG4gIGlmICh0eXBlb2YgdGhpcy5zaWdtYSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ0FuIG9iamVjdCBjYWxsZWQgc2lnbWEgaXMgYWxyZWFkeSBpbiB0aGUgZ2xvYmFsIHNjb3BlLic7XG5cbiAgdGhpcy5zaWdtYSA9IHNpZ21hO1xuXG59KS5jYWxsKHRoaXMpO1xuXG4vKipcbiAqIGNvbnJhZC5qcyBpcyBhIHRpbnkgSmF2YVNjcmlwdCBqb2JzIHNjaGVkdWxlcixcbiAqXG4gKiBWZXJzaW9uOiAwLjEuMFxuICogU291cmNlczogaHR0cDovL2dpdGh1Yi5jb20vamFjb215YWwvY29ucmFkLmpzXG4gKiBEb2M6ICAgICBodHRwOi8vZ2l0aHViLmNvbS9qYWNvbXlhbC9jb25yYWQuanMjcmVhZG1lXG4gKlxuICogTGljZW5zZTpcbiAqIC0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgwqkgMjAxMyBBbGV4aXMgSmFjb215LCBTY2llbmNlcy1QbyBtw6lkaWFsYWJcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0b1xuICogZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbiAqIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuICogc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRoZSBTb2Z0d2FyZSBpcyBwcm92aWRlZCBcImFzIGlzXCIsIHdpdGhvdXQgd2FycmFudHkgb2YgYW55IGtpbmQsIGV4cHJlc3Mgb3JcbiAqIGltcGxpZWQsIGluY2x1ZGluZyBidXQgbm90IGxpbWl0ZWQgdG8gdGhlIHdhcnJhbnRpZXMgb2YgbWVyY2hhbnRhYmlsaXR5LFxuICogZml0bmVzcyBmb3IgYSBwYXJ0aWN1bGFyIHB1cnBvc2UgYW5kIG5vbmluZnJpbmdlbWVudC4gSW4gbm8gZXZlbnQgc2hhbGwgdGhlXG4gKiBhdXRob3JzIG9yIGNvcHlyaWdodCBob2xkZXJzIGJlIGxpYWJsZSBmb3IgYW55IGNsYWltLCBkYW1hZ2VzIG9yIG90aGVyXG4gKiBsaWFiaWxpdHksIHdoZXRoZXIgaW4gYW4gYWN0aW9uIG9mIGNvbnRyYWN0LCB0b3J0IG9yIG90aGVyd2lzZSwgYXJpc2luZ1xuICogZnJvbSwgb3V0IG9mIG9yIGluIGNvbm5lY3Rpb24gd2l0aCB0aGUgc29mdHdhcmUgb3IgdGhlIHVzZSBvciBvdGhlciBkZWFsaW5nc1xuICogaW4gdGhlIFNvZnR3YXJlLlxuICovXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBDaGVjayB0aGF0IGNvbnJhZC5qcyBoYXMgbm90IGJlZW4gbG9hZGVkIHlldDpcbiAgaWYgKGdsb2JhbC5jb25yYWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb25yYWQgYWxyZWFkeSBleGlzdHMnKTtcblxuXG4gIC8qKlxuICAgKiBQUklWQVRFIFZBUklBQkxFUzpcbiAgICogKioqKioqKioqKioqKioqKioqXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIGNvbnJhZCBpcyBydW5uaW5nIG9yIG5vdC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHZhciBfbGFzdEZyYW1lVGltZTtcblxuICAvKipcbiAgICogQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciBjb25yYWQgaXMgcnVubmluZyBvciBub3QuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgdmFyIF9pc1J1bm5pbmcgPSBmYWxzZTtcblxuICAvKipcbiAgICogVGhlIGhhc2ggb2YgcmVnaXN0ZXJlZCBqb2JzLiBFYWNoIGpvYiBtdXN0IGF0IGxlYXN0IGhhdmUgYSB1bmlxdWUgSURcbiAgICogdW5kZXIgdGhlIGtleSBcImlkXCIgYW5kIGEgZnVuY3Rpb24gdW5kZXIgdGhlIGtleSBcImpvYlwiLiBUaGlzIGhhc2hcbiAgICogY29udGFpbnMgZWFjaCBydW5uaW5nIGpvYiBhbmQgZWFjaCB3YWl0aW5nIGpvYi5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHZhciBfam9icyA9IHt9O1xuXG4gIC8qKlxuICAgKiBUaGUgaGFzaCBvZiBjdXJyZW50bHkgcnVubmluZyBqb2JzLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIF9ydW5uaW5nSm9icyA9IHt9O1xuXG4gIC8qKlxuICAgKiBUaGUgYXJyYXkgb2YgY3VycmVudGx5IHJ1bm5pbmcgam9icywgc29ydGVkIGJ5IHByaW9yaXR5LlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuICB2YXIgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzID0gW107XG5cbiAgLyoqXG4gICAqIFRoZSBhcnJheSBvZiBjdXJyZW50bHkgd2FpdGluZyBqb2JzLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIF93YWl0aW5nSm9icyA9IHt9O1xuXG4gIC8qKlxuICAgKiBUaGUgYXJyYXkgb2YgZmluaXNoZWQgam9icy4gVGhleSBhcmUgc3RvcmVkIGluIGFuIGFycmF5LCBzaW5jZSB0d28gam9ic1xuICAgKiB3aXRoIHRoZSBzYW1lIFwiaWRcIiBjYW4gaGFwcGVuIGF0IHR3byBkaWZmZXJlbnQgdGltZXMuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG4gIHZhciBfZG9uZUpvYnMgPSBbXTtcblxuICAvKipcbiAgICogQSBkaXJ0eSBmbGFnIHRvIGtlZXAgY29ucmFkIGZyb20gc3RhcnRpbmc6IEluZGVlZCwgd2hlbiBhZGRKb2IoKSBpcyBjYWxsZWRcbiAgICogd2l0aCBzZXZlcmFsIGpvYnMsIGNvbnJhZCBtdXN0IGJlIHN0YXJ0ZWQgb25seSBhdCB0aGUgZW5kLiBUaGlzIGZsYWcga2VlcHNcbiAgICogbWUgZnJvbSBkdXBsaWNhdGluZyB0aGUgY29kZSB0aGF0IGVmZmVjdGl2ZWx5IGFkZHMgYSBqb2IuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgdmFyIF9ub1N0YXJ0ID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEFuIGhhc2ggY29udGFpbmluZyBzb21lIGdsb2JhbCBzZXR0aW5ncyBhYm91dCBob3cgY29ucmFkLmpzIHNob3VsZFxuICAgKiBiZWhhdmUuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgX3BhcmFtZXRlcnMgPSB7XG4gICAgZnJhbWVEdXJhdGlvbjogMjAsXG4gICAgaGlzdG9yeTogdHJ1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG9iamVjdCBjb250YWlucyBldmVyeSBoYW5kbGVycyBib3VuZCB0byBjb25yYWQgZXZlbnRzLiBJdCBkb2VzIG5vdFxuICAgKiByZXF1aXJlYSBhbnkgRE9NIGltcGxlbWVudGF0aW9uLCBzaW5jZSB0aGUgZXZlbnRzIGFyZSBhbGwgSmF2YVNjcmlwdC5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHZhciBfaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cbiAgLyoqXG4gICAqIFBSSVZBVEUgRlVOQ1RJT05TOlxuICAgKiAqKioqKioqKioqKioqKioqKipcbiAgICovXG5cbiAgLyoqXG4gICAqIFdpbGwgZXhlY3V0ZSB0aGUgaGFuZGxlciBldmVyeXRpbWUgdGhhdCB0aGUgaW5kaWNhdGVkIGV2ZW50IChvciB0aGVcbiAgICogaW5kaWNhdGVkIGV2ZW50cykgd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xhcnJheXxvYmplY3R9IGV2ZW50cyAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChvciB0aGUgZXZlbnRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdGVkIGJ5IHNwYWNlcykuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9uKE9iamVjdCl9ICAgIGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gYmluZC5cbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICBSZXR1cm5zIGNvbnJhZC5cbiAgICovXG4gIGZ1bmN0aW9uIF9iaW5kKGV2ZW50cywgaGFuZGxlcikge1xuICAgIHZhciBpLFxuICAgICAgICBpX2VuZCxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGVBcnJheTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICBlbHNlIGlmIChcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgIE9iamVjdChhcmd1bWVudHNbMF0pID09PSBhcmd1bWVudHNbMF1cbiAgICApXG4gICAgICBmb3IgKGV2ZW50cyBpbiBhcmd1bWVudHNbMF0pXG4gICAgICAgIF9iaW5kKGV2ZW50cywgYXJndW1lbnRzWzBdW2V2ZW50c10pO1xuICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBlQXJyYXkgPVxuICAgICAgICBBcnJheS5pc0FycmF5KGV2ZW50cykgP1xuICAgICAgICAgIGV2ZW50cyA6XG4gICAgICAgICAgZXZlbnRzLnNwbGl0KC8gLyk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGlfZW5kID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gaV9lbmQ7IGkgKz0gMSkge1xuICAgICAgICBldmVudCA9IGVBcnJheVtpXTtcblxuICAgICAgICBpZiAoIV9oYW5kbGVyc1tldmVudF0pXG4gICAgICAgICAgX2hhbmRsZXJzW2V2ZW50XSA9IFtdO1xuXG4gICAgICAgIC8vIFVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGRpcmVjdGx5IHRoZSBoYW5kbGVyIHdpbGwgbWFrZSBwb3NzaWJsZVxuICAgICAgICAvLyBsYXRlciB0byBhZGQgZmxhZ3NcbiAgICAgICAgX2hhbmRsZXJzW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBoYW5kbGVyIGZyb20gYSBzcGVjaWZpZWQgZXZlbnQgKG9yIHNwZWNpZmllZCBldmVudHMpLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSAgICAgICAgICAgZXZlbnRzICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdGVkIGJ5IHNwYWNlcykuIElmIHVuZGVmaW5lZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBhbGwgaGFuZGxlcnMgYXJlIHJlbW92ZWQuXG4gICAqIEBwYXJhbSAgez9mdW5jdGlvbihPYmplY3QpfSBoYW5kbGVyIFRoZSBoYW5kbGVyIHRvIHVuYmluZC4gSWYgdW5kZWZpbmVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoIGhhbmRsZXIgYm91bmQgdG8gdGhlIGV2ZW50IG9yIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMgd2lsbCBiZSByZW1vdmVkLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgUmV0dXJucyBjb25yYWQuXG4gICAqL1xuICBmdW5jdGlvbiBfdW5iaW5kKGV2ZW50cywgaGFuZGxlcikge1xuICAgIHZhciBpLFxuICAgICAgICBpX2VuZCxcbiAgICAgICAgaixcbiAgICAgICAgal9lbmQsXG4gICAgICAgIGEsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBlQXJyYXkgPSBBcnJheS5pc0FycmF5KGV2ZW50cykgP1xuICAgICAgICAgICAgICAgICAgIGV2ZW50cyA6XG4gICAgICAgICAgICAgICAgICAgZXZlbnRzLnNwbGl0KC8gLyk7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICBfaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGVsc2UgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlfZW5kID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gaV9lbmQ7IGkgKz0gMSkge1xuICAgICAgICBldmVudCA9IGVBcnJheVtpXTtcbiAgICAgICAgaWYgKF9oYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICBhID0gW107XG4gICAgICAgICAgZm9yIChqID0gMCwgal9lbmQgPSBfaGFuZGxlcnNbZXZlbnRdLmxlbmd0aDsgaiAhPT0gal9lbmQ7IGogKz0gMSlcbiAgICAgICAgICAgIGlmIChfaGFuZGxlcnNbZXZlbnRdW2pdLmhhbmRsZXIgIT09IGhhbmRsZXIpXG4gICAgICAgICAgICAgIGEucHVzaChfaGFuZGxlcnNbZXZlbnRdW2pdKTtcblxuICAgICAgICAgIF9oYW5kbGVyc1tldmVudF0gPSBhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9oYW5kbGVyc1tldmVudF0gJiYgX2hhbmRsZXJzW2V2ZW50XS5sZW5ndGggPT09IDApXG4gICAgICAgICAgZGVsZXRlIF9oYW5kbGVyc1tldmVudF07XG4gICAgICB9XG4gICAgfSBlbHNlXG4gICAgICBmb3IgKGkgPSAwLCBpX2VuZCA9IGVBcnJheS5sZW5ndGg7IGkgIT09IGlfZW5kOyBpICs9IDEpXG4gICAgICAgIGRlbGV0ZSBfaGFuZGxlcnNbZUFycmF5W2ldXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBlYWNoIGhhbmRsZXIgYm91bmQgdG8gdGhlIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBldmVudHMgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChvciB0aGUgZXZlbnRzIHNlcGFyYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgc3BhY2VzKS5cbiAgICogQHBhcmFtICB7P09iamVjdH0gZGF0YSAgIFRoZSBjb250ZW50IG9mIHRoZSBldmVudCAob3B0aW9uYWwpLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgUmV0dXJucyBjb25yYWQuXG4gICAqL1xuICBmdW5jdGlvbiBfZGlzcGF0Y2goZXZlbnRzLCBkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGosXG4gICAgICAgIGlfZW5kLFxuICAgICAgICBqX2VuZCxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgZUFycmF5ID0gQXJyYXkuaXNBcnJheShldmVudHMpID9cbiAgICAgICAgICAgICAgICAgICBldmVudHMgOlxuICAgICAgICAgICAgICAgICAgIGV2ZW50cy5zcGxpdCgvIC8pO1xuXG4gICAgZGF0YSA9IGRhdGEgPT09IHVuZGVmaW5lZCA/IHt9IDogZGF0YTtcblxuICAgIGZvciAoaSA9IDAsIGlfZW5kID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gaV9lbmQ7IGkgKz0gMSkge1xuICAgICAgZXZlbnROYW1lID0gZUFycmF5W2ldO1xuXG4gICAgICBpZiAoX2hhbmRsZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogZXZlbnROYW1lLFxuICAgICAgICAgIGRhdGE6IGRhdGEgfHwge31cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGogPSAwLCBqX2VuZCA9IF9oYW5kbGVyc1tldmVudE5hbWVdLmxlbmd0aDsgaiAhPT0gal9lbmQ7IGogKz0gMSlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgX2hhbmRsZXJzW2V2ZW50TmFtZV1bal0uaGFuZGxlcihldmVudCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIG1vc3QgcHJpb3JpdGFyeSBqb2Igb25jZSwgYW5kIGRlYWxzIHdpdGggZmlsbGluZyB0aGUgc3RhdHNcbiAgICogKGRvbmUsIHRpbWUsIGF2ZXJhZ2VUaW1lLCBjdXJyZW50VGltZSwgZXRjLi4uKS5cbiAgICpcbiAgICogQHJldHVybiB7P09iamVjdH0gUmV0dXJucyB0aGUgam9iIG9iamVjdCBpZiBpdCBoYXMgdG8gYmUga2lsbGVkLCBudWxsIGVsc2UuXG4gICAqL1xuICBmdW5jdGlvbiBfZXhlY3V0ZUZpcnN0Sm9iKCkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICB0ZXN0LFxuICAgICAgICBraWxsLFxuICAgICAgICBwdXNoZWQgPSBmYWxzZSxcbiAgICAgICAgdGltZSA9IF9fZGF0ZU5vdygpLFxuICAgICAgICBqb2IgPSBfc29ydGVkQnlQcmlvcml0eUpvYnMuc2hpZnQoKTtcblxuICAgIC8vIEV4ZWN1dGUgdGhlIGpvYiBhbmQgbG9vayBhdCB0aGUgcmVzdWx0OlxuICAgIHRlc3QgPSBqb2Iuam9iKCk7XG5cbiAgICAvLyBEZWFsIHdpdGggc3RhdHM6XG4gICAgdGltZSA9IF9fZGF0ZU5vdygpIC0gdGltZTtcbiAgICBqb2IuZG9uZSsrO1xuICAgIGpvYi50aW1lICs9IHRpbWU7XG4gICAgam9iLmN1cnJlbnRUaW1lICs9IHRpbWU7XG4gICAgam9iLndlaWdodFRpbWUgPSBqb2IuY3VycmVudFRpbWUgLyAoam9iLndlaWdodCB8fCAxKTtcbiAgICBqb2IuYXZlcmFnZVRpbWUgPSBqb2IudGltZSAvIGpvYi5kb25lO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGpvYiBoYXMgdG8gYmUga2lsbGVkOlxuICAgIGtpbGwgPSBqb2IuY291bnQgPyAoam9iLmNvdW50IDw9IGpvYi5kb25lKSA6ICF0ZXN0O1xuXG4gICAgLy8gUmVzZXQgcHJpb3JpdGllczpcbiAgICBpZiAoIWtpbGwpIHtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBfc29ydGVkQnlQcmlvcml0eUpvYnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAoX3NvcnRlZEJ5UHJpb3JpdHlKb2JzW2ldLndlaWdodFRpbWUgPiBqb2Iud2VpZ2h0VGltZSkge1xuICAgICAgICAgIF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5zcGxpY2UoaSwgMCwgam9iKTtcbiAgICAgICAgICBwdXNoZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGlmICghcHVzaGVkKVxuICAgICAgICBfc29ydGVkQnlQcmlvcml0eUpvYnMucHVzaChqb2IpO1xuICAgIH1cblxuICAgIHJldHVybiBraWxsID8gam9iIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgYSBqb2IsIGJ5IGFkZGluZyBpdCB0byB0aGUgX3J1bm5pbmdKb2JzIG9iamVjdCBhbmQgdGhlXG4gICAqIF9zb3J0ZWRCeVByaW9yaXR5Sm9icyBhcnJheS4gSXQgYWxzbyBpbml0aWFsaXplcyBpdHMgY3VycmVudFRpbWUgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gam9iIFRoZSBqb2IgdG8gYWN0aXZhdGUuXG4gICAqL1xuICBmdW5jdGlvbiBfYWN0aXZhdGVKb2Ioam9iKSB7XG4gICAgdmFyIGwgPSBfc29ydGVkQnlQcmlvcml0eUpvYnMubGVuZ3RoO1xuXG4gICAgLy8gQWRkIHRoZSBqb2IgdG8gdGhlIHJ1bm5pbmcgam9iczpcbiAgICBfcnVubmluZ0pvYnNbam9iLmlkXSA9IGpvYjtcbiAgICBqb2Iuc3RhdHVzID0gJ3J1bm5pbmcnO1xuXG4gICAgLy8gQWRkIHRoZSBqb2IgdG8gdGhlIHByaW9yaXRpZXM6XG4gICAgaWYgKGwpIHtcbiAgICAgIGpvYi53ZWlnaHRUaW1lID0gX3NvcnRlZEJ5UHJpb3JpdHlKb2JzW2wgLSAxXS53ZWlnaHRUaW1lO1xuICAgICAgam9iLmN1cnJlbnRUaW1lID0gam9iLndlaWdodFRpbWUgKiAoam9iLndlaWdodCB8fCAxKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBqb2IgYW5kIGRpc3BhdGNoOlxuICAgIGpvYi5zdGFydFRpbWUgPSBfX2RhdGVOb3coKTtcbiAgICBfZGlzcGF0Y2goJ2pvYlN0YXJ0ZWQnLCBfX2Nsb25lKGpvYikpO1xuXG4gICAgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLnB1c2goam9iKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbWFpbiBsb29wIG9mIGNvbnJhZC5qczpcbiAgICogIC4gSXQgZXhlY3V0ZXMgam9iIHN1Y2ggdGhhdCB0aGV5IGFsbCBvY2N1cGF0ZSB0aGUgc2FtZSBwcm9jZXNzaW5nIHRpbWUuXG4gICAqICAuIEl0IHN0b3BzIGpvYnMgdGhhdCBkbyBub3QgbmVlZCB0byBiZSBleGVjdXRlZCBhbnltb3JlLlxuICAgKiAgLiBJdCB0cmlnZ2VycyBjYWxsYmFja3Mgd2hlbiBpdCBpcyByZWxldmFudC5cbiAgICogIC4gSXQgc3RhcnRzIHdhaXRpbmcgam9icyB3aGVuIHRoZXkgbmVlZCB0byBiZSBzdGFydGVkLlxuICAgKiAgLiBJdCBpbmplY3RzIGZyYW1lcyB0byBrZWVwIGEgY29uc3RhbnQgZnJhcGVzIHBlciBzZWNvbmQgcmF0aW8uXG4gICAqICAuIEl0IHN0b3BzIGl0c2VsZiB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIGpvYnMgdG8gZXhlY3V0ZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9sb29wKCkge1xuICAgIHZhciBrLFxuICAgICAgICBvLFxuICAgICAgICBsLFxuICAgICAgICBqb2IsXG4gICAgICAgIHRpbWUsXG4gICAgICAgIGRlYWRKb2I7XG5cbiAgICAvLyBEZWFsIHdpdGggdGhlIG5ld2x5IGFkZGVkIGpvYnMgKHRoZSBfam9icyBvYmplY3QpOlxuICAgIGZvciAoayBpbiBfam9icykge1xuICAgICAgam9iID0gX2pvYnNba107XG5cbiAgICAgIGlmIChqb2IuYWZ0ZXIpXG4gICAgICAgIF93YWl0aW5nSm9ic1trXSA9IGpvYjtcbiAgICAgIGVsc2VcbiAgICAgICAgX2FjdGl2YXRlSm9iKGpvYik7XG5cbiAgICAgIGRlbGV0ZSBfam9ic1trXTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIF9pc1J1bm5pbmcgZmxhZyB0byBmYWxzZSBpZiB0aGVyZSBhcmUgbm8gcnVubmluZyBqb2I6XG4gICAgX2lzUnVubmluZyA9ICEhX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLmxlbmd0aDtcblxuICAgIC8vIERlYWwgd2l0aCB0aGUgcnVubmluZyBqb2JzICh0aGUgX3J1bm5pbmdKb2JzIG9iamVjdCk6XG4gICAgd2hpbGUgKFxuICAgICAgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLmxlbmd0aCAmJlxuICAgICAgX19kYXRlTm93KCkgLSBfbGFzdEZyYW1lVGltZSA8IF9wYXJhbWV0ZXJzLmZyYW1lRHVyYXRpb25cbiAgICApIHtcbiAgICAgIGRlYWRKb2IgPSBfZXhlY3V0ZUZpcnN0Sm9iKCk7XG5cbiAgICAgIC8vIERlYWwgd2l0aCB0aGUgY2FzZSB3aGVyZSB0aGUgam9iIGhhcyBlbmRlZDpcbiAgICAgIGlmIChkZWFkSm9iKSB7XG4gICAgICAgIF9raWxsSm9iKGRlYWRKb2IuaWQpO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciB3YWl0aW5nIGpvYnM6XG4gICAgICAgIGZvciAoayBpbiBfd2FpdGluZ0pvYnMpXG4gICAgICAgICAgaWYgKF93YWl0aW5nSm9ic1trXS5hZnRlciA9PT0gZGVhZEpvYi5pZCkge1xuICAgICAgICAgICAgX2FjdGl2YXRlSm9iKF93YWl0aW5nSm9ic1trXSk7XG4gICAgICAgICAgICBkZWxldGUgX3dhaXRpbmdKb2JzW2tdO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBjb25yYWQgc3RpbGwgaGFzIGpvYnMgdG8gZGVhbCB3aXRoLCBhbmQga2lsbCBpdCBpZiBub3Q6XG4gICAgaWYgKF9pc1J1bm5pbmcpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgX2xhc3RGcmFtZVRpbWU6XG4gICAgICBfbGFzdEZyYW1lVGltZSA9IF9fZGF0ZU5vdygpO1xuXG4gICAgICBfZGlzcGF0Y2goJ2VudGVyRnJhbWUnKTtcbiAgICAgIHNldFRpbWVvdXQoX2xvb3AsIDApO1xuICAgIH0gZWxzZVxuICAgICAgX2Rpc3BhdGNoKCdzdG9wJyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBvbmUgb3IgbW9yZSBqb2JzLCBhbmQgc3RhcnRzIHRoZSBsb29wIGlmIG5vIGpvYiB3YXMgcnVubmluZyBiZWZvcmUuIEFcbiAgICogam9iIGlzIGF0IGxlYXN0IGEgdW5pcXVlIHN0cmluZyBcImlkXCIgYW5kIGEgZnVuY3Rpb24sIGFuZCB0aGVyZSBhcmUgc29tZVxuICAgKiBwYXJhbWV0ZXJzIHRoYXQgeW91IGNhbiBzcGVjaWZ5IGZvciBlYWNoIGpvYiB0byBtb2RpZnkgdGhlIHdheSBjb25yYWQgd2lsbFxuICAgKiBleGVjdXRlIGl0LiBJZiBhIGpvYiBpcyBhZGRlZCB3aXRoIHRoZSBcImlkXCIgb2YgYW5vdGhlciBqb2IgdGhhdCBpcyB3YWl0aW5nXG4gICAqIG9yIHN0aWxsIHJ1bm5pbmcsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgKlxuICAgKiBXaGVuIGEgam9iIGlzIGFkZGVkLCBpdCBpcyByZWZlcmVuY2VkIGluIHRoZSBfam9icyBvYmplY3QsIGJ5IGl0cyBpZC5cbiAgICogVGhlbiwgaWYgaXQgaGFzIHRvIGJlIGV4ZWN1dGVkIHJpZ2h0IG5vdywgaXQgd2lsbCBiZSBhbHNvIHJlZmVyZW5jZWQgaW5cbiAgICogdGhlIF9ydW5uaW5nSm9icyBvYmplY3QuIElmIGl0IGhhcyB0byB3YWl0LCB0aGVuIGl0IHdpbGwgYmUgYWRkZWQgaW50byB0aGVcbiAgICogX3dhaXRpbmdKb2JzIG9iamVjdCwgdW50aWwgaXQgY2FuIHN0YXJ0LlxuICAgKlxuICAgKiBLZWVwIHJlYWRpbmcgdGhpcyBkb2N1bWVudGF0aW9uIHRvIHNlZSBob3cgdG8gY2FsbCB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGNvbnJhZC5cbiAgICpcbiAgICogQWRkaW5nIG9uZSBqb2I6XG4gICAqICoqKioqKioqKioqKioqKlxuICAgKiBCYXNpY2FsbHksIGEgam9iIGlzIGRlZmluZWQgYnkgaXRzIHN0cmluZyBpZCBhbmQgYSBmdW5jdGlvbiAodGhlIGpvYikuIEl0XG4gICAqIGlzIGFsc28gcG9zc2libGUgdG8gYWRkIHNvbWUgcGFyYW1ldGVyczpcbiAgICpcbiAgICogID4gY29ucmFkLmFkZEpvYignbXlKb2JJZCcsIG15Sm9iRnVuY3Rpb24pO1xuICAgKiAgPiBjb25yYWQuYWRkSm9iKCdteUpvYklkJywge1xuICAgKiAgPiAgIGpvYjogbXlKb2JGdW5jdGlvbixcbiAgICogID4gICBzb21lUGFyYW1ldGVyOiBzb21lVmFsdWVcbiAgICogID4gfSk7XG4gICAqICA+IGNvbnJhZC5hZGRKb2Ioe1xuICAgKiAgPiAgIGlkOiAnbXlKb2JJZCcsXG4gICAqICA+ICAgam9iOiBteUpvYkZ1bmN0aW9uLFxuICAgKiAgPiAgIHNvbWVQYXJhbWV0ZXI6IHNvbWVWYWx1ZVxuICAgKiAgPiB9KTtcbiAgICpcbiAgICogQWRkaW5nIHNldmVyYWwgam9iczpcbiAgICogKioqKioqKioqKioqKioqKioqKipcbiAgICogV2hlbiBhZGRpbmcgc2V2ZXJhbCBqb2JzIGF0IHRoZSBzYW1lIHRpbWUsIGl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnlcbiAgICogcGFyYW1ldGVycyBmb3IgZWFjaCBvbmUgaW5kaXZpZHVhbGx5IG9yIGZvciBhbGw6XG4gICAqXG4gICAqICA+IGNvbnJhZC5hZGRKb2IoW1xuICAgKiAgPiAgIHtcbiAgICogID4gICAgIGlkOiAnbXlKb2JJZDEnLFxuICAgKiAgPiAgICAgam9iOiBteUpvYkZ1bmN0aW9uMSxcbiAgICogID4gICAgIHNvbWVQYXJhbWV0ZXIxOiBzb21lVmFsdWUxXG4gICAqICA+ICAgfSxcbiAgICogID4gICB7XG4gICAqICA+ICAgICBpZDogJ215Sm9iSWQyJyxcbiAgICogID4gICAgIGpvYjogbXlKb2JGdW5jdGlvbjIsXG4gICAqICA+ICAgICBzb21lUGFyYW1ldGVyMjogc29tZVZhbHVlMlxuICAgKiAgPiAgIH1cbiAgICogID4gXSwge1xuICAgKiAgPiAgIHNvbWVDb21tb25QYXJhbWV0ZXI6IHNvbWVDb21tb25WYWx1ZVxuICAgKiAgPiB9KTtcbiAgICogID4gY29ucmFkLmFkZEpvYih7XG4gICAqICA+ICAgbXlKb2JJZDE6IHssXG4gICAqICA+ICAgICBqb2I6IG15Sm9iRnVuY3Rpb24xLFxuICAgKiAgPiAgICAgc29tZVBhcmFtZXRlcjE6IHNvbWVWYWx1ZTFcbiAgICogID4gICB9LFxuICAgKiAgPiAgIG15Sm9iSWQyOiB7LFxuICAgKiAgPiAgICAgam9iOiBteUpvYkZ1bmN0aW9uMixcbiAgICogID4gICAgIHNvbWVQYXJhbWV0ZXIyOiBzb21lVmFsdWUyXG4gICAqICA+ICAgfVxuICAgKiAgPiB9LCB7XG4gICAqICA+ICAgc29tZUNvbW1vblBhcmFtZXRlcjogc29tZUNvbW1vblZhbHVlXG4gICAqICA+IH0pO1xuICAgKiAgPiBjb25yYWQuYWRkSm9iKHtcbiAgICogID4gICBteUpvYklkMTogbXlKb2JGdW5jdGlvbjEsXG4gICAqICA+ICAgbXlKb2JJZDI6IG15Sm9iRnVuY3Rpb24yXG4gICAqICA+IH0sIHtcbiAgICogID4gICBzb21lQ29tbW9uUGFyYW1ldGVyOiBzb21lQ29tbW9uVmFsdWVcbiAgICogID4gfSk7XG4gICAqXG4gICAqICBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XG4gICAqICAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqICBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVyczpcbiAgICpcbiAgICogICAgez9GdW5jdGlvbn0gZW5kICAgICAgQSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIGpvYiBpcyBlbmRlZC4gSXQgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgbm90IGV4ZWN1dGVkIGlmIHRoZSBqb2IgaXMga2lsbGVkIGluc3RlYWQgb2YgZW5kZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgXCJuYXR1cmFsbHlcIi5cbiAgICogICAgez9JbnRlZ2VyfSAgY291bnQgICAgVGhlIG51bWJlciBvZiB0aW1lIHRoZSBqb2IgaGFzIHRvIGJlIGV4ZWN1dGVkLlxuICAgKiAgICB7P051bWJlcn0gICB3ZWlnaHQgICBJZiBzcGVjaWZpZWQsIHRoZSBqb2Igd2lsbCBiZSBleGVjdXRlZCBhcyBpdCB3YXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWQgXCJ3ZWlnaHRcIiB0aW1lcy5cbiAgICogICAgez9TdHJpbmd9ICAgYWZ0ZXIgICAgVGhlIGlkIG9mIGFub3RoZXIgam9iIChldmVudHVhbGx5IG5vdCBhZGRlZCB5ZXQpLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBJZiBzcGVjaWZpZWQsIHRoaXMgam9iIHdpbGwgc3RhcnQgb25seSB3aGVuIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZWQgXCJhZnRlclwiIGpvYiBpcyBlbmRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIF9hZGRKb2IodjEsIHYyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIG87XG5cbiAgICAvLyBBcnJheSBvZiBqb2JzOlxuICAgIGlmIChBcnJheS5pc0FycmF5KHYxKSkge1xuICAgICAgLy8gS2VlcCBjb25yYWQgdG8gc3RhcnQgdW50aWwgdGhlIGxhc3Qgam9iIGlzIGFkZGVkOlxuICAgICAgX25vU3RhcnQgPSB0cnVlO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdjEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBfYWRkSm9iKHYxW2ldLmlkLCBfX2V4dGVuZCh2MVtpXSwgdjIpKTtcblxuICAgICAgX25vU3RhcnQgPSBmYWxzZTtcbiAgICAgIGlmICghX2lzUnVubmluZykge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIF9sYXN0RnJhbWVUaW1lOlxuICAgICAgICBfbGFzdEZyYW1lVGltZSA9IF9fZGF0ZU5vdygpO1xuXG4gICAgICAgIF9kaXNwYXRjaCgnc3RhcnQnKTtcbiAgICAgICAgX2xvb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2MSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIE9uZSBqb2IgKG9iamVjdCk6XG4gICAgICBpZiAodHlwZW9mIHYxLmlkID09PSAnc3RyaW5nJylcbiAgICAgICAgX2FkZEpvYih2MS5pZCwgdjEpO1xuXG4gICAgICAvLyBIYXNoIG9mIGpvYnM6XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gS2VlcCBjb25yYWQgdG8gc3RhcnQgdW50aWwgdGhlIGxhc3Qgam9iIGlzIGFkZGVkOlxuICAgICAgICBfbm9TdGFydCA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpIGluIHYxKVxuICAgICAgICAgIGlmICh0eXBlb2YgdjFbaV0gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBfYWRkSm9iKGksIF9fZXh0ZW5kKHtcbiAgICAgICAgICAgICAgam9iOiB2MVtpXVxuICAgICAgICAgICAgfSwgdjIpKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBfYWRkSm9iKGksIF9fZXh0ZW5kKHYxW2ldLCB2MikpO1xuXG4gICAgICAgIF9ub1N0YXJ0ID0gZmFsc2U7XG4gICAgICAgIGlmICghX2lzUnVubmluZykge1xuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgX2xhc3RGcmFtZVRpbWU6XG4gICAgICAgICAgX2xhc3RGcmFtZVRpbWUgPSBfX2RhdGVOb3coKTtcblxuICAgICAgICAgIF9kaXNwYXRjaCgnc3RhcnQnKTtcbiAgICAgICAgICBfbG9vcCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAvLyBPbmUgam9iIChzdHJpbmcsICopOlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYxID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKF9oYXNKb2IodjEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1tjb25yYWQuYWRkSm9iXSBKb2Igd2l0aCBpZCBcIicgKyB2MSArICdcIiBhbHJlYWR5IGV4aXN0cy4nXG4gICAgICAgICk7XG5cbiAgICAgIC8vIE9uZSBqb2IgKHN0cmluZywgZnVuY3Rpb24pOlxuICAgICAgaWYgKHR5cGVvZiB2MiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvID0ge1xuICAgICAgICAgIGlkOiB2MSxcbiAgICAgICAgICBkb25lOiAwLFxuICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgc3RhdHVzOiAnd2FpdGluZycsXG4gICAgICAgICAgY3VycmVudFRpbWU6IDAsXG4gICAgICAgICAgYXZlcmFnZVRpbWU6IDAsXG4gICAgICAgICAgd2VpZ2h0VGltZTogMCxcbiAgICAgICAgICBqb2I6IHYyXG4gICAgICAgIH07XG5cbiAgICAgIC8vIE9uZSBqb2IgKHN0cmluZywgb2JqZWN0KTpcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHYyID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvID0gX19leHRlbmQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6IHYxLFxuICAgICAgICAgICAgZG9uZTogMCxcbiAgICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgICBzdGF0dXM6ICd3YWl0aW5nJyxcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lOiAwLFxuICAgICAgICAgICAgYXZlcmFnZVRpbWU6IDAsXG4gICAgICAgICAgICB3ZWlnaHRUaW1lOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2MlxuICAgICAgICApO1xuXG4gICAgICAvLyBJZiBub25lIG9mIHRob3NlIGNhc2VzLCB0aHJvdyBhbiBlcnJvcjpcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tjb25yYWQuYWRkSm9iXSBXcm9uZyBhcmd1bWVudHMuJyk7XG5cbiAgICAgIC8vIEVmZmVjdGl2ZWx5IGFkZCB0aGUgam9iOlxuICAgICAgX2pvYnNbdjFdID0gbztcbiAgICAgIF9kaXNwYXRjaCgnam9iQWRkZWQnLCBfX2Nsb25lKG8pKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGxvb3AgaGFzIHRvIGJlIHN0YXJ0ZWQ6XG4gICAgICBpZiAoIV9pc1J1bm5pbmcgJiYgIV9ub1N0YXJ0KSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgX2xhc3RGcmFtZVRpbWU6XG4gICAgICAgIF9sYXN0RnJhbWVUaW1lID0gX19kYXRlTm93KCk7XG5cbiAgICAgICAgX2Rpc3BhdGNoKCdzdGFydCcpO1xuICAgICAgICBfbG9vcCgpO1xuICAgICAgfVxuXG4gICAgLy8gSWYgbm9uZSBvZiB0aG9zZSBjYXNlcywgdGhyb3cgYW4gZXJyb3I6XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tjb25yYWQuYWRkSm9iXSBXcm9uZyBhcmd1bWVudHMuJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBLaWxscyBvbmUgb3IgbW9yZSBqb2JzLCBpbmRpY2F0ZWQgYnkgdGhlaXIgaWRzLiBJdCBpcyBvbmx5IHBvc3NpYmxlIHRvXG4gICAqIGtpbGwgcnVubmluZyBqb2JzIG9yIHdhaXRpbmcgam9icy4gSWYgeW91IHRyeSB0byBraWxsIGEgam9iIHRoYXQgZG9lcyBub3RcbiAgICogZXhpc3Qgb3IgdGhhdCBpcyBhbHJlYWR5IGtpbGxlZCwgYSB3YXJuaW5nIHdpbGwgYmUgdGhyb3duLlxuICAgKlxuICAgKiBAcGFyYW0gIHtBcnJheXxTdHJpbmd9IHYxIEEgc3RyaW5nIGpvYiBpZCBvciBhbiBhcnJheSBvZiBqb2IgaWRzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2tpbGxKb2IodjEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgayxcbiAgICAgICAgYSxcbiAgICAgICAgam9iLFxuICAgICAgICBmb3VuZCA9IGZhbHNlO1xuXG4gICAgLy8gQXJyYXkgb2Ygam9iIGlkczpcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2MSkpXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdjEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBfa2lsbEpvYih2MVtpXSk7XG5cbiAgICAvLyBPbmUgam9iJ3MgaWQ6XG4gICAgZWxzZSBpZiAodHlwZW9mIHYxID09PSAnc3RyaW5nJykge1xuICAgICAgYSA9IFtfcnVubmluZ0pvYnMsIF93YWl0aW5nSm9icywgX2pvYnNdO1xuXG4gICAgICAvLyBSZW1vdmUgdGhlIGpvYiBmcm9tIHRoZSBoYXNoZXM6XG4gICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICh2MSBpbiBhW2ldKSB7XG4gICAgICAgICAgam9iID0gYVtpXVt2MV07XG5cbiAgICAgICAgICBpZiAoX3BhcmFtZXRlcnMuaGlzdG9yeSkge1xuICAgICAgICAgICAgam9iLnN0YXR1cyA9ICdkb25lJztcbiAgICAgICAgICAgIF9kb25lSm9icy5wdXNoKGpvYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2Rpc3BhdGNoKCdqb2JFbmRlZCcsIF9fY2xvbmUoam9iKSk7XG4gICAgICAgICAgZGVsZXRlIGFbaV1bdjFdO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBqb2IuZW5kID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgam9iLmVuZCgpO1xuXG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgcHJpb3JpdGllcyBhcnJheTpcbiAgICAgIGEgPSBfc29ydGVkQnlQcmlvcml0eUpvYnM7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmIChhW2ldLmlkID09PSB2MSkge1xuICAgICAgICAgIGEuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGlmICghZm91bmQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5raWxsSm9iXSBKb2IgXCInICsgdjEgKyAnXCIgbm90IGZvdW5kLicpO1xuXG4gICAgLy8gSWYgbm9uZSBvZiB0aG9zZSBjYXNlcywgdGhyb3cgYW4gZXJyb3I6XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tjb25yYWQua2lsbEpvYl0gV3JvbmcgYXJndW1lbnRzLicpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogS2lsbHMgZXZlcnkgcnVubmluZywgd2FpdGluZywgYW5kIGp1c3QgYWRkZWQgam9icy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGNvbnJhZC5cbiAgICovXG4gIGZ1bmN0aW9uIF9raWxsQWxsKCkge1xuICAgIHZhciBrLFxuICAgICAgICBqb2JzID0gX19leHRlbmQoX2pvYnMsIF9ydW5uaW5nSm9icywgX3dhaXRpbmdKb2JzKTtcblxuICAgIC8vIFRha2UgZXZlcnkgam9icyBhbmQgcHVzaCB0aGVtIGludG8gdGhlIF9kb25lSm9icyBvYmplY3Q6XG4gICAgaWYgKF9wYXJhbWV0ZXJzLmhpc3RvcnkpXG4gICAgICBmb3IgKGsgaW4gam9icykge1xuICAgICAgICBqb2JzW2tdLnN0YXR1cyA9ICdkb25lJztcbiAgICAgICAgX2RvbmVKb2JzLnB1c2goam9ic1trXSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBqb2JzW2tdLmVuZCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBqb2JzW2tdLmVuZCgpO1xuICAgICAgfVxuXG4gICAgLy8gUmVpbml0aWFsaXplIHRoZSBkaWZmZXJlbnQgam9icyBsaXN0czpcbiAgICBfam9icyA9IHt9O1xuICAgIF93YWl0aW5nSm9icyA9IHt9O1xuICAgIF9ydW5uaW5nSm9icyA9IHt9O1xuICAgIF9zb3J0ZWRCeVByaW9yaXR5Sm9icyA9IFtdO1xuXG4gICAgLy8gSW4gY2FzZSBzb21lIGpvYnMgYXJlIGFkZGVkIHJpZ2h0IGFmdGVyIHRoZSBraWxsOlxuICAgIF9pc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIGpvYiB3aXRoIHRoZSBzcGVjaWZpZWQgaWQgaXMgY3VycmVudGx5IHJ1bm5pbmcgb3JcbiAgICogd2FpdGluZywgYW5kIGZhbHNlIGVsc2UuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gIGlkIFRoZSBpZCBvZiB0aGUgam9iLlxuICAgKiBAcmV0dXJuIHs/T2JqZWN0fSBSZXR1cm5zIHRoZSBqb2Igb2JqZWN0IGlmIGl0IGV4aXN0cy5cbiAgICovXG4gIGZ1bmN0aW9uIF9oYXNKb2IoaWQpIHtcbiAgICB2YXIgam9iID0gX2pvYnNbaWRdIHx8IF9ydW5uaW5nSm9ic1tpZF0gfHwgX3dhaXRpbmdKb2JzW2lkXTtcbiAgICByZXR1cm4gam9iID8gX19leHRlbmQoam9iKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBzZXQgdGhlIHNldHRpbmcgc3BlY2lmaWVkIGJ5IFwidjFcIiB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG4gICAqIGJ5IFwidjJcIiBpZiBib3RoIGFyZSBnaXZlbiwgYW5kIGVsc2UgcmV0dXJuIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZVxuICAgKiBzZXR0aW5ncyBcInYxXCIuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICB2MSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gICAqIEBwYXJhbSAgez8qfSAgICAgICB2MiBFdmVudHVhbGx5LCBhIHZhbHVlIHRvIHNldCB0byB0aGUgc3BlY2lmaWVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS5cbiAgICogQHJldHVybiB7T2JqZWN0fCp9IFJldHVybnMgdGhlIHNwZWNpZmllZCBzZXR0aW5ncyB2YWx1ZSBpZiBcInYyXCIgaXMgbm90XG4gICAqICAgICAgICAgICAgICAgICAgICBnaXZlbiwgYW5kIGNvbnJhZCBlbHNlLlxuICAgKi9cbiAgZnVuY3Rpb24gX3NldHRpbmdzKHYxLCB2Mikge1xuICAgIHZhciBvO1xuXG4gICAgaWYgKHR5cGVvZiBhMSA9PT0gJ3N0cmluZycgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSlcbiAgICAgIHJldHVybiBfcGFyYW1ldGVyc1thMV07XG4gICAgZWxzZSB7XG4gICAgICBvID0gKHR5cGVvZiBhMSA9PT0gJ29iamVjdCcgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgP1xuICAgICAgICBhMSB8fCB7fSA6XG4gICAgICAgIHt9O1xuICAgICAgaWYgKHR5cGVvZiBhMSA9PT0gJ3N0cmluZycpXG4gICAgICAgIG9bYTFdID0gYTI7XG5cbiAgICAgIGZvciAodmFyIGsgaW4gbylcbiAgICAgICAgaWYgKG9ba10gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICBfcGFyYW1ldGVyc1trXSA9IG9ba107XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBkZWxldGUgX3BhcmFtZXRlcnNba107XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY29ucmFkIGlzIGN1cnJlbnRseSBydW5uaW5nLCBhbmQgZmFsc2UgZWxzZS5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBfaXNSdW5uaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gX2dldElzUnVubmluZygpIHtcbiAgICByZXR1cm4gX2lzUnVubmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZmVyZW5jZSBldmVyeSBqb2IgdGhhdCBpcyBzdG9yZWQgaW4gdGhlIF9kb25lSm9icyBvYmplY3QuIEl0IHdpbGxcbiAgICogbm90IGJlIHBvc3NpYmxlIGFueW1vcmUgdG8gZ2V0IHN0YXRzIGFib3V0IHRoZXNlIGpvYnMsIGJ1dCBpdCB3aWxsIHJlbGVhc2VcbiAgICogdGhlIG1lbW9yeS5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGNvbnJhZC5cbiAgICovXG4gIGZ1bmN0aW9uIF9jbGVhckhpc3RvcnkoKSB7XG4gICAgX2RvbmVKb2JzID0gW107XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHNuYXBzaG90IG9mIGV2ZXJ5IGRhdGEgYWJvdXQgam9icyB0aGF0IHdhaXQgdG8gYmUgc3RhcnRlZCwgYXJlXG4gICAqIGN1cnJlbnRseSBydW5uaW5nIG9yIGFyZSBkb25lLlxuICAgKlxuICAgKiBJdCBpcyBwb3NzaWJsZSB0byBnZXQgb25seSBydW5uaW5nLCB3YWl0aW5nIG9yIGRvbmUgam9icyBieSBnaXZpbmdcbiAgICogXCJydW5uaW5nXCIsIFwid2FpdGluZ1wiIG9yIFwiZG9uZVwiIGFzIGZpc3QgYXJndW1lbnQuXG4gICAqXG4gICAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gZ2V0IGV2ZXJ5IGpvYiB3aXRoIGEgc3BlY2lmaWVkIGlkIGJ5IGdpdmluZyBpdCBhc1xuICAgKiBmaXJzdCBhcmd1bWVudC4gQWxzbywgdXNpbmcgYSBSZWdFeHAgaW5zdGVhZCBvZiBhbiBpZCB3aWxsIHJldHVybiBldmVyeVxuICAgKiBqb2JzIHdob3NlIGlkcyBtYXRjaCB0aGUgUmVnRXhwLiBBbmQgdGhlc2UgdHdvIGxhc3QgdXNlIGNhc2VzIHdvcmsgYXMgd2VsbFxuICAgKiBieSBnaXZpbmcgYmVmb3JlIFwicnVubmluZ1wiLCBcIndhaXRpbmdcIiBvciBcImRvbmVcIi5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBhcnJheSBvZiB0aGUgbWF0Y2hpbmcgam9icy5cbiAgICpcbiAgICogU29tZSBjYWxsIGV4YW1wbGVzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygncnVubmluZycpXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygnd2FpdGluZycpXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygnZG9uZScpXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygnbXlKb2InKVxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoL3Rlc3QvKVxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ3J1bm5pbmcnLCAnbXlSdW5uaW5nSm9iJylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdydW5uaW5nJywgL3Rlc3QvKVxuICAgKi9cbiAgZnVuY3Rpb24gX2dldFN0YXRzKHYxLCB2Mikge1xuICAgIHZhciBhLFxuICAgICAgICBrLFxuICAgICAgICBpLFxuICAgICAgICBsLFxuICAgICAgICBzdGF0cyxcbiAgICAgICAgcGF0dGVybixcbiAgICAgICAgaXNQYXR0ZXJuU3RyaW5nO1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBzdGF0cyA9IFtdO1xuXG4gICAgICBmb3IgKGsgaW4gX2pvYnMpXG4gICAgICAgIHN0YXRzLnB1c2goX2pvYnNba10pO1xuXG4gICAgICBmb3IgKGsgaW4gX3dhaXRpbmdKb2JzKVxuICAgICAgICBzdGF0cy5wdXNoKF93YWl0aW5nSm9ic1trXSk7XG5cbiAgICAgIGZvciAoayBpbiBfcnVubmluZ0pvYnMpXG4gICAgICAgIHN0YXRzLnB1c2goX3J1bm5pbmdKb2JzW2tdKTtcblxuICAgICAgc3RhdHMgPSBzdGF0cy5jb25jYXQoX2RvbmVKb2JzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHYxID09PSAnc3RyaW5nJylcbiAgICAgIHN3aXRjaCAodjEpIHtcbiAgICAgICAgY2FzZSAnd2FpdGluZyc6XG4gICAgICAgICAgc3RhdHMgPSBfX29iamVjdFZhbHVlcyhfd2FpdGluZ0pvYnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdydW5uaW5nJzpcbiAgICAgICAgICBzdGF0cyA9IF9fb2JqZWN0VmFsdWVzKF9ydW5uaW5nSm9icyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RvbmUnOlxuICAgICAgICAgIHN0YXRzID0gX2RvbmVKb2JzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHBhdHRlcm4gPSB2MTtcbiAgICAgIH1cblxuICAgIGlmICh2MSBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgIHBhdHRlcm4gPSB2MTtcblxuICAgIGlmICghcGF0dGVybiAmJiAodHlwZW9mIHYyID09PSAnc3RyaW5nJyB8fCB2MiBpbnN0YW5jZW9mIFJlZ0V4cCkpXG4gICAgICBwYXR0ZXJuID0gdjI7XG5cbiAgICAvLyBGaWx0ZXIgam9icyBpZiBhIHBhdHRlcm4gaXMgZ2l2ZW46XG4gICAgaWYgKHBhdHRlcm4pIHtcbiAgICAgIGlzUGF0dGVyblN0cmluZyA9IHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJztcblxuICAgICAgaWYgKHN0YXRzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgYSA9IHN0YXRzO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGEgPSBbXTtcblxuICAgICAgICBmb3IgKGsgaW4gc3RhdHMpXG4gICAgICAgICAgYSA9IGEuY29uY2F0KHN0YXRzW2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGEgPSBbXTtcblxuICAgICAgICBmb3IgKGsgaW4gX2pvYnMpXG4gICAgICAgICAgYS5wdXNoKF9qb2JzW2tdKTtcblxuICAgICAgICBmb3IgKGsgaW4gX3dhaXRpbmdKb2JzKVxuICAgICAgICAgIGEucHVzaChfd2FpdGluZ0pvYnNba10pO1xuXG4gICAgICAgIGZvciAoayBpbiBfcnVubmluZ0pvYnMpXG4gICAgICAgICAgYS5wdXNoKF9ydW5uaW5nSm9ic1trXSk7XG5cbiAgICAgICAgYSA9IGEuY29uY2F0KF9kb25lSm9icyk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRzID0gW107XG4gICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmIChpc1BhdHRlcm5TdHJpbmcgPyBhW2ldLmlkID09PSBwYXR0ZXJuIDogYVtpXS5pZC5tYXRjaChwYXR0ZXJuKSlcbiAgICAgICAgICBzdGF0cy5wdXNoKGFbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBfX2Nsb25lKHN0YXRzKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFRPT0xTIEZVTkNUSU9OUzpcbiAgICogKioqKioqKioqKioqKioqKlxuICAgKi9cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbnkgbnVtYmVyIG9mIG9iamVjdHMgYXMgYXJndW1lbnRzLCBjb3BpZXMgZnJvbSBlYWNoXG4gICAqIG9mIHRoZXNlIG9iamVjdHMgZWFjaCBwYWlyIGtleS92YWx1ZSBpbnRvIGEgbmV3IG9iamVjdCwgYW5kIGZpbmFsbHlcbiAgICogcmV0dXJucyB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogVGhlIGFyZ3VtZW50cyBhcmUgcGFyc2VkIGZyb20gdGhlIGxhc3Qgb25lIHRvIHRoZSBmaXJzdCBvbmUsIHN1Y2ggdGhhdFxuICAgKiB3aGVuIHR3byBvYmplY3RzIGhhdmUga2V5cyBpbiBjb21tb24sIHRoZSBcImVhcmxpZXN0XCIgb2JqZWN0IHdpbnMuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqICoqKioqKioqXG4gICAqICA+IHZhciBvMSA9IHtcbiAgICogID4gICAgICAgYTogMSxcbiAgICogID4gICAgICAgYjogMixcbiAgICogID4gICAgICAgYzogJzMnXG4gICAqICA+ICAgICB9LFxuICAgKiAgPiAgICAgbzIgPSB7XG4gICAqICA+ICAgICAgIGM6ICc0JyxcbiAgICogID4gICAgICAgZDogWyA1IF1cbiAgICogID4gICAgIH07XG4gICAqICA+IF9fZXh0ZW5kKG8xLCBvMik7XG4gICAqICA+IC8vIFJldHVybnM6IHtcbiAgICogID4gLy8gICBhOiAxLFxuICAgKiAgPiAvLyAgIGI6IDIsXG4gICAqICA+IC8vICAgYzogJzMnLFxuICAgKiAgPiAvLyAgIGQ6IFsgNSBdXG4gICAqICA+IC8vIH07XG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdCt9IEFueSBudW1iZXIgb2Ygb2JqZWN0cy5cbiAgICogQHJldHVybiB7T2JqZWN0fSAgVGhlIG1lcmdlZCBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBfX2V4dGVuZCgpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgayxcbiAgICAgICAgcmVzID0ge30sXG4gICAgICAgIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gbCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgZm9yIChrIGluIGFyZ3VtZW50c1tpXSlcbiAgICAgICAgcmVzW2tdID0gYXJndW1lbnRzW2ldW2tdO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNpbXBseSBjbG9uZXMgYW4gb2JqZWN0LiBUaGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gb25seVxuICAgKiBvYmplY3RzLCBhcnJheXMgYW5kIGltbXV0YWJsZSB2YWx1ZXMuIFNpbmNlIGl0IGlzIG5vdCBwdWJsaWMsIGl0IGRvZXMgbm90XG4gICAqIGRlYWwgd2l0aCBjeWNsaWMgcmVmZXJlbmNlcywgRE9NIGVsZW1lbnRzIGFuZCBpbnN0YW50aWF0ZWQgb2JqZWN0cyAtIHNvXG4gICAqIHVzZSBpdCBjYXJlZnVsbHkuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG4gICAqL1xuICBmdW5jdGlvbiBfX2Nsb25lKGl0ZW0pIHtcbiAgICB2YXIgcmVzdWx0LCBpLCBrLCBsO1xuXG4gICAgaWYgKCFpdGVtKVxuICAgICAgcmV0dXJuIGl0ZW07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGkgPSAwLCBsID0gaXRlbS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIHJlc3VsdC5wdXNoKF9fY2xvbmUoaXRlbVtpXSkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoaSBpbiBpdGVtKVxuICAgICAgICByZXN1bHRbaV0gPSBfX2Nsb25lKGl0ZW1baV0pO1xuICAgIH0gZWxzZVxuICAgICAgcmVzdWx0ID0gaXRlbTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFRoZSBvYmplY3QuXG4gICAqIEByZXR1cm4ge0FycmF5fSAgVGhlIGFycmF5IG9mIHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIF9fb2JqZWN0VmFsdWVzKG8pIHtcbiAgICB2YXIgayxcbiAgICAgICAgYSA9IFtdO1xuXG4gICAgZm9yIChrIGluIG8pXG4gICAgICBhLnB1c2gob1trXSk7XG5cbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNob3J0IFwiRGF0ZS5ub3coKVwiIHBvbHlmaWxsLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjdXJyZW50IHRpbWUgKGluIG1zKS5cbiAgICovXG4gIGZ1bmN0aW9uIF9fZGF0ZU5vdygpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogUG9seWZpbGwgZm9yIHRoZSBBcnJheS5pc0FycmF5IGZ1bmN0aW9uOlxuICAgKi9cbiAgaWYgKCFBcnJheS5pc0FycmF5KVxuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG5cblxuICAvKipcbiAgICogRVhQT1JUIFBVQkxJQyBBUEk6XG4gICAqICoqKioqKioqKioqKioqKioqKlxuICAgKi9cbiAgdmFyIGNvbnJhZCA9IHtcbiAgICBoYXNKb2I6IF9oYXNKb2IsXG4gICAgYWRkSm9iOiBfYWRkSm9iLFxuICAgIGtpbGxKb2I6IF9raWxsSm9iLFxuICAgIGtpbGxBbGw6IF9raWxsQWxsLFxuICAgIHNldHRpbmdzOiBfc2V0dGluZ3MsXG4gICAgZ2V0U3RhdHM6IF9nZXRTdGF0cyxcbiAgICBpc1J1bm5pbmc6IF9nZXRJc1J1bm5pbmcsXG4gICAgY2xlYXJIaXN0b3J5OiBfY2xlYXJIaXN0b3J5LFxuXG4gICAgLy8gRXZlbnRzIG1hbmFnZW1lbnQ6XG4gICAgYmluZDogX2JpbmQsXG4gICAgdW5iaW5kOiBfdW5iaW5kLFxuXG4gICAgLy8gVmVyc2lvbjpcbiAgICB2ZXJzaW9uOiAnMC4xLjAnXG4gIH07XG5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbnJhZDtcbiAgICBleHBvcnRzLmNvbnJhZCA9IGNvbnJhZDtcbiAgfVxuICBnbG9iYWwuY29ucmFkID0gY29ucmFkO1xufSkodGhpcyk7XG5cbi8vIEhhcmRjb2RlZCBleHBvcnQgZm9yIHRoZSBub2RlLmpzIHZlcnNpb246XG52YXIgc2lnbWEgPSB0aGlzLnNpZ21hLFxuICAgIGNvbnJhZCA9IHRoaXMuY29ucmFkO1xuXG5zaWdtYS5jb25yYWQgPSBjb25yYWQ7XG5cbi8vIERpcnR5IHBvbHlmaWxscyB0byBwZXJtaXQgc2lnbWEgdXNhZ2UgaW4gbm9kZVxuaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcpXG4gIEhUTUxFbGVtZW50ID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKVxuICB3aW5kb3cgPSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oKSB7fVxuICB9O1xuXG5pZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzaWdtYTtcbiAgZXhwb3J0cy5zaWdtYSA9IHNpZ21hO1xufVxuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgdmFyIF9yb290ID0gdGhpcztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscyA9IHNpZ21hLnV0aWxzIHx8IHt9O1xuXG4gIC8qKlxuICAgKiBNSVNDIFVUSUxTOlxuICAgKi9cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW55IG51bWJlciBvZiBvYmplY3RzIGFzIGFyZ3VtZW50cywgY29waWVzIGZyb20gZWFjaFxuICAgKiBvZiB0aGVzZSBvYmplY3RzIGVhY2ggcGFpciBrZXkvdmFsdWUgaW50byBhIG5ldyBvYmplY3QsIGFuZCBmaW5hbGx5XG4gICAqIHJldHVybnMgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIFRoZSBhcmd1bWVudHMgYXJlIHBhcnNlZCBmcm9tIHRoZSBsYXN0IG9uZSB0byB0aGUgZmlyc3Qgb25lLCBzdWNoIHRoYXRcbiAgICogd2hlbiBzZXZlcmFsIG9iamVjdHMgaGF2ZSBrZXlzIGluIGNvbW1vbiwgdGhlIFwiZWFybGllc3RcIiBvYmplY3Qgd2lucy5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogKioqKioqKipcbiAgICogID4gdmFyIG8xID0ge1xuICAgKiAgPiAgICAgICBhOiAxLFxuICAgKiAgPiAgICAgICBiOiAyLFxuICAgKiAgPiAgICAgICBjOiAnMydcbiAgICogID4gICAgIH0sXG4gICAqICA+ICAgICBvMiA9IHtcbiAgICogID4gICAgICAgYzogJzQnLFxuICAgKiAgPiAgICAgICBkOiBbIDUgXVxuICAgKiAgPiAgICAgfTtcbiAgICogID4gc2lnbWEudXRpbHMuZXh0ZW5kKG8xLCBvMik7XG4gICAqICA+IC8vIFJldHVybnM6IHtcbiAgICogID4gLy8gICBhOiAxLFxuICAgKiAgPiAvLyAgIGI6IDIsXG4gICAqICA+IC8vICAgYzogJzMnLFxuICAgKiAgPiAvLyAgIGQ6IFsgNSBdXG4gICAqICA+IC8vIH07XG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdCt9IEFueSBudW1iZXIgb2Ygb2JqZWN0cy5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgVGhlIG1lcmdlZCBvYmplY3QuXG4gICAqL1xuICBzaWdtYS51dGlscy5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgayxcbiAgICAgICAgcmVzID0ge30sXG4gICAgICAgIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gbCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgZm9yIChrIGluIGFyZ3VtZW50c1tpXSlcbiAgICAgICAgcmVzW2tdID0gYXJndW1lbnRzW2ldW2tdO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvKipcbiAgICogQSBzaG9ydCBcIkRhdGUubm93KClcIiBwb2x5ZmlsbC5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY3VycmVudCB0aW1lIChpbiBtcykuXG4gICAqL1xuICBzaWdtYS51dGlscy5kYXRlTm93ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUYWtlcyBhIHBhY2thZ2UgbmFtZSBhcyBwYXJhbWV0ZXIgYW5kIGNoZWNrcyBhdCBlYWNoIGxlYmVsIGlmIGl0IGV4aXN0cyxcbiAgICogYW5kIGlmIGl0IGRvZXMgbm90LCBjcmVhdGVzIGl0LlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiAqKioqKioqKlxuICAgKiAgPiBzaWdtYS51dGlscy5wa2coJ2EuYi5jJyk7XG4gICAqICA+IGEuYi5jO1xuICAgKiAgPiAvLyBPYmplY3Qge307XG4gICAqICA+XG4gICAqICA+IHNpZ21hLnV0aWxzLnBrZygnYS5iLmQnKTtcbiAgICogID4gYS5iO1xuICAgKiAgPiAvLyBPYmplY3QgeyBjOiB7fSwgZDoge30gfTtcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBwa2dOYW1lIFRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRvIGNyZWF0ZS9maW5kLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgVGhlIHJlbGF0ZWQgcGFja2FnZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZyA9IGZ1bmN0aW9uKHBrZ05hbWUpIHtcbiAgICByZXR1cm4gKHBrZ05hbWUgfHwgJycpLnNwbGl0KCcuJykucmVkdWNlKGZ1bmN0aW9uKGNvbnRleHQsIG9iak5hbWUpIHtcbiAgICAgIHJldHVybiAob2JqTmFtZSBpbiBjb250ZXh0KSA/XG4gICAgICAgIGNvbnRleHRbb2JqTmFtZV0gOlxuICAgICAgICAoY29udGV4dFtvYmpOYW1lXSA9IHt9KTtcbiAgICB9LCBfcm9vdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB1bmlxdWUgaW5jcmVtZW50YWwgbnVtYmVyIElELlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiAqKioqKioqKlxuICAgKiAgPiBzaWdtYS51dGlscy5pZCgpO1xuICAgKiAgPiAvLyAxO1xuICAgKiAgPlxuICAgKiAgPiBzaWdtYS51dGlscy5pZCgpO1xuICAgKiAgPiAvLyAyO1xuICAgKiAgPlxuICAgKiAgPiBzaWdtYS51dGlscy5pZCgpO1xuICAgKiAgPiAvLyAzO1xuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHBrZ05hbWUgVGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdG8gY3JlYXRlL2ZpbmQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBUaGUgcmVsYXRlZCBwYWNrYWdlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuaWQgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiArK2k7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBoZXhhIGNvbG9yIChmb3IgaW5zdGFuY2UgXCIjZmZjYzAwXCIgb3IgXCIjZmMwXCIpIG9yIGFcbiAgICogcmdiIC8gcmdiYSBjb2xvciAobGlrZSBcInJnYigyNTUsMjU1LDEyKVwiIG9yIFwicmdiYSgyNTUsMjU1LDEyLDEpXCIpIGFuZFxuICAgKiByZXR1cm5zIGFuIGludGVnZXIgZXF1YWwgdG8gXCJyICogMjU1ICogMjU1ICsgZyAqIDI1NSArIGJcIiwgdG8gZ2FpbiBzb21lXG4gICAqIG1lbW9yeSBpbiB0aGUgZGF0YSBnaXZlbiB0byBXZWJHTCBzaGFkZXJzLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGZ1bmN0aW9uIGFjdHVhbGx5IGNhY2hlcyBpdHMgcmVzdWx0cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZhbCBUaGUgaGV4YSBvciByZ2JhIGNvbG9yLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICBUaGUgbnVtYmVyIHZhbHVlLlxuICAgKi9cbiAgdmFyIGZsb2F0Q29sb3JDYWNoZSA9IHt9O1xuXG4gIHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IgPSBmdW5jdGlvbih2YWwpIHtcblxuICAgIC8vIElzIHRoZSBjb2xvciBhbHJlYWR5IGNvbXB1dGVkP1xuICAgIGlmIChmbG9hdENvbG9yQ2FjaGVbdmFsXSlcbiAgICAgIHJldHVybiBmbG9hdENvbG9yQ2FjaGVbdmFsXTtcblxuICAgIHZhciBvcmlnaW5hbCA9IHZhbCxcbiAgICAgICAgciA9IDAsXG4gICAgICAgIGcgPSAwLFxuICAgICAgICBiID0gMDtcblxuICAgIGlmICh2YWxbMF0gPT09ICcjJykge1xuICAgICAgdmFsID0gdmFsLnNsaWNlKDEpO1xuXG4gICAgICBpZiAodmFsLmxlbmd0aCA9PT0gMykge1xuICAgICAgICByID0gcGFyc2VJbnQodmFsLmNoYXJBdCgwKSArIHZhbC5jaGFyQXQoMCksIDE2KTtcbiAgICAgICAgZyA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMSkgKyB2YWwuY2hhckF0KDEpLCAxNik7XG4gICAgICAgIGIgPSBwYXJzZUludCh2YWwuY2hhckF0KDIpICsgdmFsLmNoYXJBdCgyKSwgMTYpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHIgPSBwYXJzZUludCh2YWwuY2hhckF0KDApICsgdmFsLmNoYXJBdCgxKSwgMTYpO1xuICAgICAgICBnID0gcGFyc2VJbnQodmFsLmNoYXJBdCgyKSArIHZhbC5jaGFyQXQoMyksIDE2KTtcbiAgICAgICAgYiA9IHBhcnNlSW50KHZhbC5jaGFyQXQoNCkgKyB2YWwuY2hhckF0KDUpLCAxNik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWwubWF0Y2goL14gKnJnYmE/ICpcXCgvKSkge1xuICAgICAgdmFsID0gdmFsLm1hdGNoKFxuICAgICAgICAvXiAqcmdiYT8gKlxcKCAqKFswLTldKikgKiwgKihbMC05XSopICosICooWzAtOV0qKSAqKCwuKik/XFwpICokL1xuICAgICAgKTtcbiAgICAgIHIgPSArdmFsWzFdO1xuICAgICAgZyA9ICt2YWxbMl07XG4gICAgICBiID0gK3ZhbFszXTtcbiAgICB9XG5cbiAgICB2YXIgY29sb3IgPSAoXG4gICAgICByICogMjU2ICogMjU2ICtcbiAgICAgIGcgKiAyNTYgK1xuICAgICAgYlxuICAgICk7XG5cbiAgICAvLyBDYWNoaW5nIHRoZSBjb2xvclxuICAgIGZsb2F0Q29sb3JDYWNoZVtvcmlnaW5hbF0gPSBjb2xvcjtcblxuICAgIHJldHVybiBjb2xvcjtcbiAgfTtcblxuICAgIC8qKlxuICAgKiBQZXJmb3JtIGEgem9vbSBpbnRvIGEgY2FtZXJhLCB3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uLCB0byB0aGVcbiAgICogY29vcmRpbmF0ZXMgaW5kaWNhdGVkIHVzaW5nIGEgc3BlY2lmaWVkIHJhdGlvLlxuICAgKlxuICAgKiBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMgaW4gdGhlIGFuaW1hdGlvblxuICAgKiBvYmplY3Q6XG4gICAqXG4gICAqICAgez9udW1iZXJ9IGR1cmF0aW9uICAgICBBbiBhbW91bnQgb2YgdGltZSB0aGF0IG1lYW5zIHRoZSBkdXJhdGlvbiBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi4gSWYgdGhpcyBwYXJhbWV0ZXIgZG9lc24ndCBleGlzdCB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHpvb20gd2lsbCBiZSBwZXJmb3JtZWQgd2l0aG91dCBhbmltYXRpb24uXG4gICAqICAgez9mdW5jdGlvbn0gb25Db21wbGV0ZSBBIGZ1bmN0aW9uIHRvIHBlcmZvcm0gaXQgYWZ0ZXIgdGhlIGFuaW1hdGlvbi4gSXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgcGVyZm9ybWVkIGV2ZW4gaWYgdGhlcmUgaXMgbm8gZHVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7Y2FtZXJhfSAgICAgVGhlIGNhbWVyYSB3aGVyZSBwZXJmb3JtIHRoZSB6b29tLlxuICAgKiBAcGFyYW0ge3h9ICAgICAgICAgIFRoZSBYIGNvb3JkaWFudGlvbiB3aGVyZSB0aGUgem9vbSBnb2VzLlxuICAgKiBAcGFyYW0ge3l9ICAgICAgICAgIFRoZSBZIGNvb3JkaWFudGlvbiB3aGVyZSB0aGUgem9vbSBnb2VzLlxuICAgKiBAcGFyYW0ge3JhdGlvfSAgICAgIFRoZSByYXRpbyB0byBhcHBseSBpdCB0byB0aGUgY3VycmVudCBjYW1lcmEgcmF0aW8uXG4gICAqIEBwYXJhbSB7P2FuaW1hdGlvbn0gQSBkaWN0aW9uYXJ5IHdpdGggb3B0aW9ucyBmb3IgYSBwb3NzaWJsZSBhbmltYXRpb24uXG4gICAqL1xuICBzaWdtYS51dGlscy56b29tVG8gPSBmdW5jdGlvbihjYW1lcmEsIHgsIHksIHJhdGlvLCBhbmltYXRpb24pIHtcbiAgICB2YXIgc2V0dGluZ3MgPSBjYW1lcmEuc2V0dGluZ3MsXG4gICAgICAgIGNvdW50LFxuICAgICAgICBuZXdSYXRpbyxcbiAgICAgICAgYW5pbWF0aW9uU2V0dGluZ3MsXG4gICAgICAgIGNvb3JkaW5hdGVzO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBuZXdSYXRpbyBkZWFsaW5nIHdpdGggbWluIC8gbWF4OlxuICAgIG5ld1JhdGlvID0gTWF0aC5tYXgoXG4gICAgICBzZXR0aW5ncygnem9vbU1pbicpLFxuICAgICAgTWF0aC5taW4oXG4gICAgICAgIHNldHRpbmdzKCd6b29tTWF4JyksXG4gICAgICAgIGNhbWVyYS5yYXRpbyAqIHJhdGlvXG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIENoZWNrIHRoYXQgdGhlIG5ldyByYXRpbyBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgaW5pdGlhbCBvbmU6XG4gICAgaWYgKG5ld1JhdGlvICE9PSBjYW1lcmEucmF0aW8pIHtcbiAgICAgIC8vIENyZWF0ZSB0aGUgY29vcmRpbmF0ZXMgdmFyaWFibGU6XG4gICAgICByYXRpbyA9IG5ld1JhdGlvIC8gY2FtZXJhLnJhdGlvO1xuICAgICAgY29vcmRpbmF0ZXMgPSB7XG4gICAgICAgIHg6IHggKiAoMSAtIHJhdGlvKSArIGNhbWVyYS54LFxuICAgICAgICB5OiB5ICogKDEgLSByYXRpbykgKyBjYW1lcmEueSxcbiAgICAgICAgcmF0aW86IG5ld1JhdGlvXG4gICAgICB9O1xuXG4gICAgICBpZiAoYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5kdXJhdGlvbikge1xuICAgICAgICAvLyBDb21wbGV0ZSB0aGUgYW5pbWF0aW9uIHNldGluZ3M6XG4gICAgICAgIGNvdW50ID0gc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbEFsbChjYW1lcmEpO1xuICAgICAgICBhbmltYXRpb24gPSBzaWdtYS51dGlscy5leHRlbmQoXG4gICAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVhc2luZzogY291bnQgPyAncXVhZHJhdGljT3V0JyA6ICdxdWFkcmF0aWNJbk91dCdcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgc2lnbWEubWlzYy5hbmltYXRpb24uY2FtZXJhKGNhbWVyYSwgY29vcmRpbmF0ZXMsIGFuaW1hdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW1lcmEuZ29Ubyhjb29yZGluYXRlcyk7XG4gICAgICAgIGlmIChhbmltYXRpb24gJiYgYW5pbWF0aW9uLm9uQ29tcGxldGUpXG4gICAgICAgICAgYW5pbWF0aW9uLm9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29udHJvbCBwb2ludCBjb29yZGluYXRlcyBmb3IgYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgcG9pbnQuXG4gICAqIEBwYXJhbSAge251bWJlcn0geDIgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MiAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcmV0dXJuIHt4LHl9ICAgICAgICBUaGUgY29udHJvbCBwb2ludCBjb29yZGluYXRlcy5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludCA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6ICh4MSArIHgyKSAvIDIgKyAoeTIgLSB5MSkgLyA0LFxuICAgICAgeTogKHkxICsgeTIpIC8gMiArICh4MSAtIHgyKSAvIDRcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgICogQ29tcHV0ZSB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IHBvc2l0aW9uZWRcbiAgICAqIGF0IGxlbmd0aCB0IGluIHRoZSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlLlxuICAgICpcbiAgICAqIEBwYXJhbSAge251bWJlcn0gdCAgSW4gWzAsMV0gdGhlIHN0ZXAgcGVyY2VudGFnZSB0byByZWFjaFxuICAgICogICAgICAgICAgICAgICAgICAgICB0aGUgcG9pbnQgaW4gdGhlIGN1cnZlIGZyb20gdGhlIGNvbnRleHQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRleHQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRleHQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGVuZGluZyBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kaW5nIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4aSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5aSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuICAgICogQHJldHVybiB7b2JqZWN0fSAgICB7eCx5fS5cbiAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0UG9pbnRPblF1YWRyYXRpY0N1cnZlID0gZnVuY3Rpb24odCwgeDEsIHkxLCB4MiwgeTIsIHhpLCB5aSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU2MzQ1MjhcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5wb3coMSAtIHQsIDIpICogeDEgKyAyICogKDEgLSB0KSAqIHQgKiB4aSArIE1hdGgucG93KHQsIDIpICogeDIsXG4gICAgICB5OiBNYXRoLnBvdygxIC0gdCwgMikgKiB5MSArIDIgKiAoMSAtIHQpICogdCAqIHlpICsgTWF0aC5wb3codCwgMikgKiB5MlxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAgKiBDb21wdXRlIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgcG9zaXRpb25lZFxuICAgICogYXQgbGVuZ3RoIHQgaW4gdGhlIGN1YmljIGJlemllciBjdXJ2ZS5cbiAgICAqXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQgIEluIFswLDFdIHRoZSBzdGVwIHBlcmNlbnRhZ2UgdG8gcmVhY2hcbiAgICAqICAgICAgICAgICAgICAgICAgICAgdGhlIHBvaW50IGluIHRoZSBjdXJ2ZSBmcm9tIHRoZSBjb250ZXh0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjb250ZXh0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjb250ZXh0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MiBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3ggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3kgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gZHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgICogQHJldHVybiB7b2JqZWN0fSAgICB7eCx5fSBUaGUgcG9pbnQgYXQgdC5cbiAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0UG9pbnRPbkJlemllckN1cnZlID1cbiAgICBmdW5jdGlvbih0LCB4MSwgeTEsIHgyLCB5MiwgY3gsIGN5LCBkeCwgZHkpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNTM5NzU5NlxuICAgIC8vIEJsZW5kaW5nIGZ1bmN0aW9uczpcbiAgICB2YXIgQjBfdCA9IE1hdGgucG93KDEgLSB0LCAzKSxcbiAgICAgICAgQjFfdCA9IDMgKiB0ICogTWF0aC5wb3coMSAtIHQsIDIpLFxuICAgICAgICBCMl90ID0gMyAqIE1hdGgucG93KHQsIDIpICogKDEgLSB0KSxcbiAgICAgICAgQjNfdCA9IE1hdGgucG93KHQsIDMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IChCMF90ICogeDEpICsgKEIxX3QgKiBjeCkgKyAoQjJfdCAqIGR4KSArIChCM190ICogeDIpLFxuICAgICAgeTogKEIwX3QgKiB5MSkgKyAoQjFfdCAqIGN5KSArIChCMl90ICogZHkpICsgKEIzX3QgKiB5MilcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSB0d28gY29udHJvbCBwb2ludHMgZm9yIGEgc2VsZiBsb29wIChpLmUuXG4gICAqIHdoZXJlIHRoZSBzdGFydCBwb2ludCBpcyBhbHNvIHRoZSBlbmQgcG9pbnQpIGNvbXB1dGVkIGFzIGEgY3ViaWMgYmV6aWVyXG4gICAqIGN1cnZlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgbm9kZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5ICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIG5vZGUuXG4gICAqIEBwYXJhbSAge251bWJlcn0gc2l6ZSBUaGUgbm9kZSBzaXplLlxuICAgKiBAcmV0dXJuIHt4MSx5MSx4Mix5Mn0gVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSB0d28gY29udHJvbCBwb2ludHMuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMgPSBmdW5jdGlvbih4ICwgeSwgc2l6ZSkge1xuICAgIHJldHVybiB7XG4gICAgICB4MTogeCAtIHNpemUgKiA3LFxuICAgICAgeTE6IHksXG4gICAgICB4MjogeCxcbiAgICAgIHkyOiB5ICsgc2l6ZSAqIDdcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMgb2YgYSBwbGFuZVxuICAgKiB3aXRoIGFuIG9ydGhvbm9ybWFsIGJhc2lzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgcG9pbnQuXG4gICAqIEBwYXJhbSAge251bWJlcn0geDIgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MiAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICBUaGUgZXVjbGlkaWFuIGRpc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSkge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MCwgMikgKyBNYXRoLnBvdyh5MSAtIHkwLCAyKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGludGVyc2VjdGlvbiBwb2ludHMgb2YgdHdvIGNpcmNsZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geDAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgY2VudGVyIGxvY2F0aW9uIG9mIHRoZSBmaXJzdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUuXG4gICAqIEBwYXJhbSAge251bWJlcn0geTAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgY2VudGVyIGxvY2F0aW9uIG9mIHRoZSBmaXJzdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUuXG4gICAqIEBwYXJhbSAge251bWJlcn0gcjAgIFRoZSByYWRpdXMgb2YgdGhlIGZpcnN0IGNpcmNsZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAgVGhlIFggY29vcmRpbmF0ZSBvZiBjZW50ZXIgbG9jYXRpb24gb2YgdGhlIHNlY29uZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUuXG4gICAqIEBwYXJhbSAge251bWJlcn0geTEgIFRoZSBZIGNvb3JkaW5hdGUgb2YgY2VudGVyIGxvY2F0aW9uIG9mIHRoZSBzZWNvbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgY2lyY2xlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHIxICBUaGUgcmFkaXVzIG9mIHRoZSBzZWNvbmQgY2lyY2xlLlxuICAgKiBAcmV0dXJuIHt4aSx5aX0gICAgICBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIGludGVyc2VjdGlvbiBwb2ludHMuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXRDaXJjbGVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbih4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTIyMTk4MDJcbiAgICB2YXIgYSwgZHgsIGR5LCBkLCBoLCByeCwgcnksIHgyLCB5MjtcblxuICAgIC8vIGR4IGFuZCBkeSBhcmUgdGhlIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIGRpc3RhbmNlcyBiZXR3ZWVuIHRoZSBjaXJjbGVcbiAgICAvLyBjZW50ZXJzOlxuICAgIGR4ID0geDEgLSB4MDtcbiAgICBkeSA9IHkxIC0geTA7XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHN0cmFpZ2h0LWxpbmUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgY2VudGVyczpcbiAgICBkID0gTWF0aC5zcXJ0KChkeSAqIGR5KSArIChkeCAqIGR4KSk7XG5cbiAgICAvLyBDaGVjayBmb3Igc29sdmFiaWxpdHk6XG4gICAgaWYgKGQgPiAocjAgKyByMSkpIHtcbiAgICAgICAgLy8gTm8gc29sdXRpb24uIGNpcmNsZXMgZG8gbm90IGludGVyc2VjdC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZCA8IE1hdGguYWJzKHIwIC0gcjEpKSB7XG4gICAgICAgIC8vIE5vIHNvbHV0aW9uLiBvbmUgY2lyY2xlIGlzIGNvbnRhaW5lZCBpbiB0aGUgb3RoZXIuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLydwb2ludCAyJyBpcyB0aGUgcG9pbnQgd2hlcmUgdGhlIGxpbmUgdGhyb3VnaCB0aGUgY2lyY2xlIGludGVyc2VjdGlvblxuICAgIC8vIHBvaW50cyBjcm9zc2VzIHRoZSBsaW5lIGJldHdlZW4gdGhlIGNpcmNsZSBjZW50ZXJzLlxuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBmcm9tIHBvaW50IDAgdG8gcG9pbnQgMjpcbiAgICBhID0gKChyMCAqIHIwKSAtIChyMSAqIHIxKSArIChkICogZCkpIC8gKDIuMCAqIGQpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBjb29yZGluYXRlcyBvZiBwb2ludCAyOlxuICAgIHgyID0geDAgKyAoZHggKiBhIC8gZCk7XG4gICAgeTIgPSB5MCArIChkeSAqIGEgLyBkKTtcblxuICAgIC8vIERldGVybWluZSB0aGUgZGlzdGFuY2UgZnJvbSBwb2ludCAyIHRvIGVpdGhlciBvZiB0aGUgaW50ZXJzZWN0aW9uXG4gICAgLy8gcG9pbnRzOlxuICAgIGggPSBNYXRoLnNxcnQoKHIwICogcjApIC0gKGEgKiBhKSk7XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIG9mZnNldHMgb2YgdGhlIGludGVyc2VjdGlvbiBwb2ludHMgZnJvbSBwb2ludCAyOlxuICAgIHJ4ID0gLWR5ICogKGggLyBkKTtcbiAgICByeSA9IGR4ICogKGggLyBkKTtcblxuICAgIC8vIERldGVybWluZSB0aGUgYWJzb2x1dGUgaW50ZXJzZWN0aW9uIHBvaW50czpcbiAgICB2YXIgeGkgPSB4MiArIHJ4O1xuICAgIHZhciB4aV9wcmltZSA9IHgyIC0gcng7XG4gICAgdmFyIHlpID0geTIgKyByeTtcbiAgICB2YXIgeWlfcHJpbWUgPSB5MiAtIHJ5O1xuXG4gICAgcmV0dXJuIHt4aTogeGksIHhpX3ByaW1lOiB4aV9wcmltZSwgeWk6IHlpLCB5aV9wcmltZTogeWlfcHJpbWV9O1xuICB9O1xuXG4gIC8qKlxuICAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBvbiBhIGxpbmUgc2VnbWVudC5cbiAgICAqXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gY2hlY2suXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gY2hlY2suXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgbGluZSBzdGFydCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBsaW5lIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGxpbmUgZW5kIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGxpbmUgZW5kIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBlcHNpbG9uIFRoZSBwcmVjaXNpb24gKGNvbnNpZGVyIHRoZSBsaW5lIHRoaWNrbmVzcykuXG4gICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgVHJ1ZSBpZiBwb2ludCBpcyBcImNsb3NlIHRvXCIgdGhlIGxpbmVcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50LCBmYWxzZSBvdGhlcndpc2UuXG4gICovXG4gIHNpZ21hLnV0aWxzLmlzUG9pbnRPblNlZ21lbnQgPSBmdW5jdGlvbih4LCB5LCB4MSwgeTEsIHgyLCB5MiwgZXBzaWxvbikge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMyODEyMlxuICAgIHZhciBjcm9zc1Byb2R1Y3QgPSBNYXRoLmFicygoeSAtIHkxKSAqICh4MiAtIHgxKSAtICh4IC0geDEpICogKHkyIC0geTEpKSxcbiAgICAgICAgZCA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSxcbiAgICAgICAgbkNyb3NzUHJvZHVjdCA9IGNyb3NzUHJvZHVjdCAvIGQ7IC8vIG5vcm1hbGl6ZWQgY3Jvc3MgcHJvZHVjdFxuXG4gICAgcmV0dXJuIChuQ3Jvc3NQcm9kdWN0IDwgZXBzaWxvbiAmJlxuICAgICBNYXRoLm1pbih4MSwgeDIpIDw9IHggJiYgeCA8PSBNYXRoLm1heCh4MSwgeDIpICYmXG4gICAgIE1hdGgubWluKHkxLCB5MikgPD0geSAmJiB5IDw9IE1hdGgubWF4KHkxLCB5MikpO1xuICB9O1xuXG4gIC8qKlxuICAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBvbiBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUgc2VnbWVudCB3aXRoIGEgdGhpY2tuZXNzLlxuICAgICpcbiAgICAqIEBwYXJhbSAge251bWJlcn0geCAgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geSAgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBzdGFydCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBzdGFydCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgZW5kIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHggICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweSAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gZXBzaWxvbiBUaGUgcHJlY2lzaW9uIChjb25zaWRlciB0aGUgbGluZSB0aGlja25lc3MpLlxuICAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgIFRydWUgaWYgKHgseSkgaXMgb24gdGhlIGN1cnZlIHNlZ21lbnQsXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2Ugb3RoZXJ3aXNlLlxuICAqL1xuICBzaWdtYS51dGlscy5pc1BvaW50T25RdWFkcmF0aWNDdXJ2ZSA9XG4gICAgZnVuY3Rpb24oeCwgeSwgeDEsIHkxLCB4MiwgeTIsIGNweCwgY3B5LCBlcHNpbG9uKSB7XG4gICAgLy8gRmFpbHMgaWYgdGhlIHBvaW50IGlzIHRvbyBmYXIgZnJvbSB0aGUgZXh0cmVtaXRpZXMgb2YgdGhlIHNlZ21lbnQsXG4gICAgLy8gcHJldmVudGluZyBmb3IgbW9yZSBjb3N0bHkgY29tcHV0YXRpb246XG4gICAgdmFyIGRQMVAyID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpO1xuICAgIGlmIChNYXRoLmFicyh4IC0geDEpID4gZFAxUDIgfHwgTWF0aC5hYnMoeSAtIHkxKSA+IGRQMVAyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGRQMSA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgsIHksIHgxLCB5MSksXG4gICAgICAgIGRQMiA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgsIHksIHgyLCB5MiksXG4gICAgICAgIHQgPSAwLjUsXG4gICAgICAgIHIgPSAoZFAxIDwgZFAyKSA/IC0wLjAxIDogMC4wMSxcbiAgICAgICAgclRocmVzaG9sZCA9IDAuMDAxLFxuICAgICAgICBpID0gMTAwLFxuICAgICAgICBwdCA9IHNpZ21hLnV0aWxzLmdldFBvaW50T25RdWFkcmF0aWNDdXJ2ZSh0LCB4MSwgeTEsIHgyLCB5MiwgY3B4LCBjcHkpLFxuICAgICAgICBkdCA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgsIHksIHB0LngsIHB0LnkpLFxuICAgICAgICBvbGRfZHQ7XG5cbiAgICAvLyBUaGlzIGFsZ29yaXRobSBtaW5pbWl6ZXMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHBvaW50IHRvIHRoZSBjdXJ2ZS4gSXRcbiAgICAvLyBmaW5kIHRoZSBvcHRpbWFsIHQgdmFsdWUgd2hlcmUgdD0wIGlzIHRoZSBzdGFydCBwb2ludCBhbmQgdD0xIGlzIHRoZSBlbmRcbiAgICAvLyBwb2ludCBvZiB0aGUgY3VydmUsIHN0YXJ0aW5nIGZyb20gdD0wLjUuXG4gICAgLy8gSXQgdGVybWluYXRlcyBiZWNhdXNlIGl0IHJ1bnMgYSBtYXhpbXVtIG9mIGkgaW50ZXJhdGlvbnMuXG4gICAgd2hpbGUgKGktLSA+IDAgJiZcbiAgICAgIHQgPj0gMCAmJiB0IDw9IDEgJiZcbiAgICAgIChkdCA+IGVwc2lsb24pICYmXG4gICAgICAociA+IHJUaHJlc2hvbGQgfHwgciA8IC1yVGhyZXNob2xkKSkge1xuICAgICAgb2xkX2R0ID0gZHQ7XG4gICAgICBwdCA9IHNpZ21hLnV0aWxzLmdldFBvaW50T25RdWFkcmF0aWNDdXJ2ZSh0LCB4MSwgeTEsIHgyLCB5MiwgY3B4LCBjcHkpO1xuICAgICAgZHQgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCBwdC54LCBwdC55KTtcblxuICAgICAgaWYgKGR0ID4gb2xkX2R0KSB7XG4gICAgICAgIC8vIG5vdCB0aGUgcmlnaHQgZGlyZWN0aW9uOlxuICAgICAgICAvLyBoYWxmc3RlcCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gICAgICAgIHIgPSAtciAvIDI7XG4gICAgICAgIHQgKz0gcjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHQgKyByIDwgMCB8fCB0ICsgciA+IDEpIHtcbiAgICAgICAgLy8gb29wcywgd2UndmUgZ29uZSB0b28gZmFyOlxuICAgICAgICAvLyByZXZlcnQgd2l0aCBhIGhhbGZzdGVwXG4gICAgICAgIHIgPSByIC8gMjtcbiAgICAgICAgZHQgPSBvbGRfZHQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gcHJvZ3Jlc3M6XG4gICAgICAgIHQgKz0gcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZHQgPCBlcHNpbG9uO1xuICB9O1xuXG5cbiAgLyoqXG4gICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIG9uIGEgY3ViaWMgYmV6aWVyIGN1cnZlIHNlZ21lbnQgd2l0aCBhIHRoaWNrbmVzcy5cbiAgICAqXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gY2hlY2suXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gY2hlY2suXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgc3RhcnQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgc3RhcnQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgZW5kIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3B4MSAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSAxc3QgY3VydmUgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3B5MSAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSAxc3QgY3VydmUgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3B4MiAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSAybmQgY3VydmUgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3B5MiAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSAybmQgY3VydmUgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gZXBzaWxvbiBUaGUgcHJlY2lzaW9uIChjb25zaWRlciB0aGUgbGluZSB0aGlja25lc3MpLlxuICAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgIFRydWUgaWYgKHgseSkgaXMgb24gdGhlIGN1cnZlIHNlZ21lbnQsXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2Ugb3RoZXJ3aXNlLlxuICAqL1xuICBzaWdtYS51dGlscy5pc1BvaW50T25CZXppZXJDdXJ2ZSA9XG4gICAgZnVuY3Rpb24oeCwgeSwgeDEsIHkxLCB4MiwgeTIsIGNweDEsIGNweTEsIGNweDIsIGNweTIsIGVwc2lsb24pIHtcbiAgICAvLyBGYWlscyBpZiB0aGUgcG9pbnQgaXMgdG9vIGZhciBmcm9tIHRoZSBleHRyZW1pdGllcyBvZiB0aGUgc2VnbWVudCxcbiAgICAvLyBwcmV2ZW50aW5nIGZvciBtb3JlIGNvc3RseSBjb21wdXRhdGlvbjpcbiAgICB2YXIgZFAxQ1AxID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeDEsIHkxLCBjcHgxLCBjcHkxKTtcbiAgICBpZiAoTWF0aC5hYnMoeCAtIHgxKSA+IGRQMUNQMSB8fCBNYXRoLmFicyh5IC0geTEpID4gZFAxQ1AxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGRQMSA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgsIHksIHgxLCB5MSksXG4gICAgICAgIGRQMiA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgsIHksIHgyLCB5MiksXG4gICAgICAgIHQgPSAwLjUsXG4gICAgICAgIHIgPSAoZFAxIDwgZFAyKSA/IC0wLjAxIDogMC4wMSxcbiAgICAgICAgclRocmVzaG9sZCA9IDAuMDAxLFxuICAgICAgICBpID0gMTAwLFxuICAgICAgICBwdCA9IHNpZ21hLnV0aWxzLmdldFBvaW50T25CZXppZXJDdXJ2ZShcbiAgICAgICAgICB0LCB4MSwgeTEsIHgyLCB5MiwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiksXG4gICAgICAgIGR0ID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgcHQueCwgcHQueSksXG4gICAgICAgIG9sZF9kdDtcblxuICAgIC8vIFRoaXMgYWxnb3JpdGhtIG1pbmltaXplcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgdG8gdGhlIGN1cnZlLiBJdFxuICAgIC8vIGZpbmQgdGhlIG9wdGltYWwgdCB2YWx1ZSB3aGVyZSB0PTAgaXMgdGhlIHN0YXJ0IHBvaW50IGFuZCB0PTEgaXMgdGhlIGVuZFxuICAgIC8vIHBvaW50IG9mIHRoZSBjdXJ2ZSwgc3RhcnRpbmcgZnJvbSB0PTAuNS5cbiAgICAvLyBJdCB0ZXJtaW5hdGVzIGJlY2F1c2UgaXQgcnVucyBhIG1heGltdW0gb2YgaSBpbnRlcmF0aW9ucy5cbiAgICB3aGlsZSAoaS0tID4gMCAmJlxuICAgICAgdCA+PSAwICYmIHQgPD0gMSAmJlxuICAgICAgKGR0ID4gZXBzaWxvbikgJiZcbiAgICAgIChyID4gclRocmVzaG9sZCB8fCByIDwgLXJUaHJlc2hvbGQpKSB7XG4gICAgICBvbGRfZHQgPSBkdDtcbiAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPbkJlemllckN1cnZlKFxuICAgICAgICB0LCB4MSwgeTEsIHgyLCB5MiwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5Mik7XG4gICAgICBkdCA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgsIHksIHB0LngsIHB0LnkpO1xuXG4gICAgICBpZiAoZHQgPiBvbGRfZHQpIHtcbiAgICAgICAgLy8gbm90IHRoZSByaWdodCBkaXJlY3Rpb246XG4gICAgICAgIC8vIGhhbGZzdGVwIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgICAgICAgciA9IC1yIC8gMjtcbiAgICAgICAgdCArPSByO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodCArIHIgPCAwIHx8IHQgKyByID4gMSkge1xuICAgICAgICAvLyBvb3BzLCB3ZSd2ZSBnb25lIHRvbyBmYXI6XG4gICAgICAgIC8vIHJldmVydCB3aXRoIGEgaGFsZnN0ZXBcbiAgICAgICAgciA9IHIgLyAyO1xuICAgICAgICBkdCA9IG9sZF9kdDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBwcm9ncmVzczpcbiAgICAgICAgdCArPSByO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkdCA8IGVwc2lsb247XG4gIH07XG5cblxuICAvKipcbiAgICogKioqKioqKioqKioqXG4gICAqIEVWRU5UUyBVVElMUzpcbiAgICogKioqKioqKioqKioqXG4gICAqL1xuICAvKipcbiAgICogSGVyZSBhcmUgc29tZSB1c2VmdWwgZnVuY3Rpb25zIHRvIHVuaWZ5IGV4dHJhY3Rpb24gb2YgdGhlIGluZm9ybWF0aW9uIHdlXG4gICAqIG5lZWQgd2l0aCBtb3VzZSBldmVudHMgYW5kIHRvdWNoIGV2ZW50cywgZnJvbSBkaWZmZXJlbnQgYnJvd3NlcnM6XG4gICAqL1xuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSBsb2NhbCBYIHBvc2l0aW9uIGZyb20gYSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICBUaGUgbG9jYWwgWCB2YWx1ZSBvZiB0aGUgbW91c2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXRYID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiAoXG4gICAgICAoZS5vZmZzZXRYICE9PSB1bmRlZmluZWQgJiYgZS5vZmZzZXRYKSB8fFxuICAgICAgKGUubGF5ZXJYICE9PSB1bmRlZmluZWQgJiYgZS5sYXllclgpIHx8XG4gICAgICAoZS5jbGllbnRYICE9PSB1bmRlZmluZWQgJiYgZS5jbGllbnRYKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIGxvY2FsIFkgcG9zaXRpb24gZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgIFRoZSBsb2NhbCBZIHZhbHVlIG9mIHRoZSBtb3VzZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldFkgPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChlLm9mZnNldFkgIT09IHVuZGVmaW5lZCAmJiBlLm9mZnNldFkpIHx8XG4gICAgICAoZS5sYXllclkgIT09IHVuZGVmaW5lZCAmJiBlLmxheWVyWSkgfHxcbiAgICAgIChlLmNsaWVudFkgIT09IHVuZGVmaW5lZCAmJiBlLmNsaWVudFkpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHBpeGVsIHJhdGlvIG9mIHRoZSBzY3JlZW4uIFRha2luZyB6b29tIGludG8gYWNjb3VudFxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICBQaXhlbCByYXRpbyBvZiB0aGUgc2NyZWVuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJhdGlvID0gMTtcbiAgICBpZiAod2luZG93LnNjcmVlbi5kZXZpY2VYRFBJICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgd2luZG93LnNjcmVlbi5kZXZpY2VYRFBJID4gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSkge1xuICAgICAgICByYXRpbyA9IHdpbmRvdy5zY3JlZW4uc3lzdGVtWERQSSAvIHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG4gICAgcmV0dXJuIHJhdGlvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSB3aWR0aCBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge2V2ZW50fSAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgVGhlIHdpZHRoIG9mIHRoZSBldmVudCdzIHRhcmdldC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldFdpZHRoID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciB3ID0gKCFlLnRhcmdldC5vd25lclNWR0VsZW1lbnQpID9cbiAgICAgICAgICAgICAgZS50YXJnZXQud2lkdGggOlxuICAgICAgICAgICAgICBlLnRhcmdldC5vd25lclNWR0VsZW1lbnQud2lkdGg7XG5cbiAgICByZXR1cm4gKFxuICAgICAgKHR5cGVvZiB3ID09PSAnbnVtYmVyJyAmJiB3KSB8fFxuICAgICAgKHcgIT09IHVuZGVmaW5lZCAmJiB3LmJhc2VWYWwgIT09IHVuZGVmaW5lZCAmJiB3LmJhc2VWYWwudmFsdWUpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgY2VudGVyIGZyb20gYSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgY2VudGVyIG9mIHRoZSBldmVudCdzIHRhcmdldC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldENlbnRlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgcmF0aW8gPSBlLnRhcmdldC5uYW1lc3BhY2VVUkkuaW5kZXhPZignc3ZnJykgIT09IC0xID8gMSA6XG4gICAgICAgIHNpZ21hLnV0aWxzLmdldFBpeGVsUmF0aW8oKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogc2lnbWEudXRpbHMuZ2V0V2lkdGgoZSkgLyAoMiAqIHJhdGlvKSxcbiAgICAgIHk6IHNpZ21hLnV0aWxzLmdldEhlaWdodChlKSAvICgyICogcmF0aW8pXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBtb3VzZSBjb29yZHMgdG8gc2lnbWEgY29vcmRzXG4gICAqXG4gICAqIEBwYXJhbSAge2V2ZW50fSAgIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHBhcmFtICB7bnVtYmVyP30geCBUaGUgeCBjb29yZCB0byBjb252ZXJ0XG4gICAqIEBwYXJhbSAge251bWJlcj99IHggVGhlIHkgY29vcmQgdG8gY29udmVydFxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIFRoZSBzdGFuZGFyZGl6ZWQgZXZlbnRcbiAgICovXG4gIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzID0gZnVuY3Rpb24oZSwgeCwgeSkge1xuICAgIHggPSB4IHx8IHNpZ21hLnV0aWxzLmdldFgoZSk7XG4gICAgeSA9IHkgfHwgc2lnbWEudXRpbHMuZ2V0WShlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4IC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLngsXG4gICAgICAgIHk6IHkgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueSxcbiAgICAgICAgY2xpZW50WDogZS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiBlLmNsaWVudFksXG4gICAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcbiAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxuICAgICAgICBhbHRLZXk6IGUuYWx0S2V5LFxuICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIGhlaWdodCBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge2V2ZW50fSAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgVGhlIGhlaWdodCBvZiB0aGUgZXZlbnQncyB0YXJnZXQuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXRIZWlnaHQgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGggPSAoIWUudGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCkgP1xuICAgICAgICAgICAgICBlLnRhcmdldC5oZWlnaHQgOlxuICAgICAgICAgICAgICBlLnRhcmdldC5vd25lclNWR0VsZW1lbnQuaGVpZ2h0O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICh0eXBlb2YgaCA9PT0gJ251bWJlcicgJiYgaCkgfHxcbiAgICAgIChoICE9PSB1bmRlZmluZWQgJiYgaC5iYXNlVmFsICE9PSB1bmRlZmluZWQgJiYgaC5iYXNlVmFsLnZhbHVlKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIHdoZWVsIGRlbHRhIGZyb20gYSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICBUaGUgd2hlZWwgZGVsdGEgb2YgdGhlIG1vdXNlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0RGVsdGEgPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChlLndoZWVsRGVsdGEgIT09IHVuZGVmaW5lZCAmJiBlLndoZWVsRGVsdGEpIHx8XG4gICAgICAoZS5kZXRhaWwgIT09IHVuZGVmaW5lZCAmJiAtZS5kZXRhaWwpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0IG9mIGEgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IGRvbSBUaGUgZWxlbWVudCB0byByZXRyaWV2ZSB0aGUgcG9zaXRpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBUaGUgb2Zmc2V0IG9mIHRoZSBET00gZWxlbWVudCAodG9wLCBsZWZ0KS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldE9mZnNldCA9IGZ1bmN0aW9uKGRvbSkge1xuICAgIHZhciBsZWZ0ID0gMCxcbiAgICAgICAgdG9wID0gMDtcblxuICAgIHdoaWxlIChkb20pIHtcbiAgICAgIHRvcCA9IHRvcCArIHBhcnNlSW50KGRvbS5vZmZzZXRUb3ApO1xuICAgICAgbGVmdCA9IGxlZnQgKyBwYXJzZUludChkb20ub2Zmc2V0TGVmdCk7XG4gICAgICBkb20gPSBkb20ub2Zmc2V0UGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHRvcCxcbiAgICAgIGxlZnQ6IGxlZnRcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaW11bGF0ZXMgYSBcImRvdWJsZSBjbGlja1wiIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gdGFyZ2V0ICAgVGhlIGV2ZW50IHRhcmdldC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgIHR5cGUgICAgIFRoZSBldmVudCB0eXBlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gICAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUuXG4gICAqL1xuICBzaWdtYS51dGlscy5kb3VibGVDbGljayA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgY2xpY2tzID0gMCxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGhhbmRsZXJzO1xuXG4gICAgdGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXIgPSB0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlciB8fCB7fTtcbiAgICB0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlclt0eXBlXSA9IHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyW3R5cGVdIHx8IFtdO1xuICAgIGhhbmRsZXJzID0gdGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXJbdHlwZV07XG5cbiAgICBoYW5kbGVycy5wdXNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgIGNsaWNrcysrO1xuXG4gICAgICBpZiAoY2xpY2tzID09PSAyKSB7XG4gICAgICAgIGNsaWNrcyA9IDA7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2xpY2tzID09PSAxKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xpY2tzID0gMDtcbiAgICAgICAgfSwgc2lnbWEuc2V0dGluZ3MuZG91YmxlQ2xpY2tUaW1lb3V0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXJzW2hhbmRsZXJzLmxlbmd0aCAtIDFdLCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVuYmluZCBzaW11bGF0ZWQgXCJkb3VibGUgY2xpY2tcIiBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSB0YXJnZXQgICBUaGUgZXZlbnQgdGFyZ2V0LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgdHlwZSAgICAgVGhlIGV2ZW50IHR5cGUuXG4gICAqL1xuICBzaWdtYS51dGlscy51bmJpbmREb3VibGVDbGljayA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSkge1xuICAgIHZhciBoYW5kbGVyLFxuICAgICAgICBoYW5kbGVycyA9ICh0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlciB8fCB7fSlbdHlwZV0gfHwgW107XG5cbiAgICB3aGlsZSAoKGhhbmRsZXIgPSBoYW5kbGVycy5wb3AoKSkpIHtcbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgIH1cblxuICAgIGRlbGV0ZSAodGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXIgfHwge30pW3R5cGVdO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBIZXJlIGFyZSBqdXN0IHNvbWUgb2YgdGhlIG1vc3QgYmFzaWMgZWFzaW5nIGZ1bmN0aW9ucywgdXNlZCBmb3IgdGhlXG4gICAqIGFuaW1hdGVkIGNhbWVyYSBcImdvVG9cIiBjYWxscy5cbiAgICpcbiAgICogSWYgeW91IG5lZWQgc29tZSBtb3JlIGVhc2luZ3MgZnVuY3Rpb25zLCBkb24ndCBoZXNpdGF0ZSB0byBhZGQgdGhlbSB0b1xuICAgKiBzaWdtYS51dGlscy5lYXNpbmdzLiBCdXQgSSB3aWxsIG5vdCBhZGQgc29tZSBtb3JlIGhlcmUgb3IgbWVyZ2UgUFJzXG4gICAqIGNvbnRhaW5pbmcsIGJlY2F1c2UgSSBkbyBub3Qgd2FudCBzaWdtYSBzb3VyY2VzIGZ1bGwgb2Ygb3ZlcmtpbGwgYW5kIG5ldmVyXG4gICAqIHVzZWQgc3R1ZmYuLi5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MgPSBzaWdtYS51dGlscy5lYXNpbmdzIHx8IHt9O1xuICBzaWdtYS51dGlscy5lYXNpbmdzLmxpbmVhck5vbmUgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIGs7XG4gIH07XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MucXVhZHJhdGljSW4gPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIGsgKiBrO1xuICB9O1xuICBzaWdtYS51dGlscy5lYXNpbmdzLnF1YWRyYXRpY091dCA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayAqICgyIC0gayk7XG4gIH07XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MucXVhZHJhdGljSW5PdXQgPSBmdW5jdGlvbihrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSlcbiAgICAgIHJldHVybiAwLjUgKiBrICogaztcbiAgICByZXR1cm4gLSAwLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xuICB9O1xuICBzaWdtYS51dGlscy5lYXNpbmdzLmN1YmljSW4gPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIGsgKiBrICogaztcbiAgfTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5jdWJpY091dCA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gLS1rICogayAqIGsgKyAxO1xuICB9O1xuICBzaWdtYS51dGlscy5lYXNpbmdzLmN1YmljSW5PdXQgPSBmdW5jdGlvbihrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSlcbiAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGs7XG4gICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICsgMik7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqICoqKioqKioqKioqKlxuICAgKiBXRUJHTCBVVElMUzpcbiAgICogKioqKioqKioqKioqXG4gICAqL1xuICAvKipcbiAgICogTG9hZHMgYSBXZWJHTCBzaGFkZXIgYW5kIHJldHVybnMgaXQuXG4gICAqXG4gICAqIEBwYXJhbSAge1dlYkdMQ29udGV4dH0gICAgICAgICAgIGdsICAgICAgICAgICBUaGUgV2ViR0xDb250ZXh0IHRvIHVzZS5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICAgICAgc2hhZGVyU291cmNlIFRoZSBzaGFkZXIgc291cmNlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgICBzaGFkZXJUeXBlICAgVGhlIHR5cGUgb2Ygc2hhZGVyLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbihzdHJpbmcpOiB2b2lkfSBlcnJvciAgICAgICAgQ2FsbGJhY2sgZm9yIGVycm9ycy5cbiAgICogQHJldHVybiB7V2ViR0xTaGFkZXJ9ICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBjcmVhdGVkIHNoYWRlci5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIgPSBmdW5jdGlvbihnbCwgc2hhZGVyU291cmNlLCBzaGFkZXJUeXBlLCBlcnJvcikge1xuICAgIHZhciBjb21waWxlZCxcbiAgICAgICAgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xuXG4gICAgLy8gTG9hZCB0aGUgc2hhZGVyIHNvdXJjZVxuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XG5cbiAgICAvLyBDb21waWxlIHRoZSBzaGFkZXJcbiAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG5cbiAgICAvLyBDaGVjayB0aGUgY29tcGlsZSBzdGF0dXNcbiAgICBjb21waWxlZCA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKTtcblxuICAgIC8vIElmIHNvbWV0aGluZyB3ZW50IHdyb25nOlxuICAgIGlmICghY29tcGlsZWQpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBlcnJvcihcbiAgICAgICAgICAnRXJyb3IgY29tcGlsaW5nIHNoYWRlciBcIicgKyBzaGFkZXIgKyAnXCI6JyArXG4gICAgICAgICAgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYWRlcjtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHByb2dyYW0sIGF0dGFjaGVzIHNoYWRlcnMsIGJpbmRzIGF0dHJpYiBsb2NhdGlvbnMsIGxpbmtzIHRoZVxuICAgKiBwcm9ncmFtIGFuZCBjYWxscyB1c2VQcm9ncmFtLlxuICAgKlxuICAgKiBAcGFyYW0gIHtBcnJheS48V2ViR0xTaGFkZXI+fSAgICBzaGFkZXJzICAgVGhlIHNoYWRlcnMgdG8gYXR0YWNoLlxuICAgKiBAcGFyYW0gIHtBcnJheS48c3RyaW5nPn0gICAgICAgICBhdHRyaWJzICAgVGhlIGF0dHJpYnMgbmFtZXMuXG4gICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSAgICAgICAgIGxvY2F0aW9ucyBUaGUgbG9jYXRpb25zIGZvciB0aGUgYXR0cmlicy5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb24oc3RyaW5nKTogdm9pZH0gZXJyb3IgICAgIENhbGxiYWNrIGZvciBlcnJvcnMuXG4gICAqIEByZXR1cm4ge1dlYkdMUHJvZ3JhbX0gICAgICAgICAgICAgICAgICAgICBUaGUgY3JlYXRlZCBwcm9ncmFtLlxuICAgKi9cbiAgc2lnbWEudXRpbHMubG9hZFByb2dyYW0gPSBmdW5jdGlvbihnbCwgc2hhZGVycywgYXR0cmlicywgbG9jLCBlcnJvcikge1xuICAgIHZhciBpLFxuICAgICAgICBsaW5rZWQsXG4gICAgICAgIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2hhZGVycy5sZW5ndGg7ICsraSlcbiAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBzaGFkZXJzW2ldKTtcblxuICAgIGlmIChhdHRyaWJzKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGF0dHJpYnMubGVuZ3RoOyArK2kpXG4gICAgICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbihcbiAgICAgICAgICBwcm9ncmFtLFxuICAgICAgICAgIGxvY2F0aW9ucyA/IGxvY2F0aW9uc1tpXSA6IGksXG4gICAgICAgICAgb3B0X2F0dHJpYnNbaV1cbiAgICAgICAgKTtcblxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGxpbmsgc3RhdHVzXG4gICAgbGlua2VkID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyk7XG4gICAgaWYgKCFsaW5rZWQpIHtcbiAgICAgIGlmIChlcnJvcilcbiAgICAgICAgZXJyb3IoJ0Vycm9yIGluIHByb2dyYW0gbGlua2luZzogJyArIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcblxuICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9ncmFtO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiAqKioqKioqKipcbiAgICogTUFUUklDRVM6XG4gICAqICoqKioqKioqKlxuICAgKiBUaGUgZm9sbG93aW5nIHV0aWxzIGFyZSBqdXN0IGhlcmUgdG8gaGVscCBnZW5lcmF0aW5nIHRoZSB0cmFuc2Zvcm1hdGlvblxuICAgKiBtYXRyaWNlcyBmb3IgdGhlIFdlYkdMIHJlbmRlcmVycy5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEudXRpbHMubWF0cmljZXMnKTtcblxuICAvKipcbiAgICogVGhlIHJldHVybnMgYSAzeDMgdHJhbnNsYXRpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR4IFRoZSBYIHRyYW5zbGF0aW9uLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR5IFRoZSBZIHRyYW5zbGF0aW9uLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgIFJldHVybnMgdGhlIG1hdHJpeC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnRyYW5zbGF0aW9uID0gZnVuY3Rpb24oZHgsIGR5KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIDEsIDAsIDAsXG4gICAgICAwLCAxLCAwLFxuICAgICAgZHgsIGR5LCAxXG4gICAgXTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHJldHVybnMgYSAzeDMgb3IgMngyIHJvdGF0aW9uIG1hdHJpeC5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgYW5nbGUgVGhlIHJvdGF0aW9uIGFuZ2xlLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBtMiAgICBJZiB0cnVlLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSAyeDIgbWF0cml4LlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICBSZXR1cm5zIHRoZSBtYXRyaXguXG4gICAqL1xuICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbiA9IGZ1bmN0aW9uKGFuZ2xlLCBtMikge1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblxuICAgIHJldHVybiBtMiA/IFtcbiAgICAgIGNvcywgLXNpbixcbiAgICAgIHNpbiwgY29zXG4gICAgXSA6IFtcbiAgICAgIGNvcywgLXNpbiwgMCxcbiAgICAgIHNpbiwgY29zLCAwLFxuICAgICAgMCwgMCwgMVxuICAgIF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSByZXR1cm5zIGEgM3gzIG9yIDJ4MiBob21vdGhldGljIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgcmF0aW8gVGhlIHNjYWxpbmcgcmF0aW8uXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IG0yICAgIElmIHRydWUsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBhIDJ4MiBtYXRyaXguXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgIFJldHVybnMgdGhlIG1hdHJpeC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnNjYWxlID0gZnVuY3Rpb24ocmF0aW8sIG0yKSB7XG4gICAgcmV0dXJuIG0yID8gW1xuICAgICAgcmF0aW8sIDAsXG4gICAgICAwLCByYXRpb1xuICAgIF0gOiBbXG4gICAgICByYXRpbywgMCwgMCxcbiAgICAgIDAsIHJhdGlvLCAwLFxuICAgICAgMCwgMCwgMVxuICAgIF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSByZXR1cm5zIGEgM3gzIG9yIDJ4MiBob21vdGhldGljIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cbiAgICpcbiAgICogQHBhcmFtICB7YXJyYXl9ICAgYSAgVGhlIGZpcnN0IG1hdHJpeC5cbiAgICogQHBhcmFtICB7YXJyYXl9ICAgYiAgVGhlIHNlY29uZCBtYXRyaXguXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IG0yIElmIHRydWUsIHRoZSBmdW5jdGlvbiB3aWxsIGFzc3VtZSBib3RoIG1hdHJpY2VzIGFyZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAyeDIuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgIFJldHVybnMgdGhlIG1hdHJpeC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLm1hdHJpY2VzLm11bHRpcGx5ID0gZnVuY3Rpb24oYSwgYiwgbTIpIHtcbiAgICB2YXIgbCA9IG0yID8gMiA6IDMsXG4gICAgICAgIGEwMCA9IGFbMCAqIGwgKyAwXSxcbiAgICAgICAgYTAxID0gYVswICogbCArIDFdLFxuICAgICAgICBhMDIgPSBhWzAgKiBsICsgMl0sXG4gICAgICAgIGExMCA9IGFbMSAqIGwgKyAwXSxcbiAgICAgICAgYTExID0gYVsxICogbCArIDFdLFxuICAgICAgICBhMTIgPSBhWzEgKiBsICsgMl0sXG4gICAgICAgIGEyMCA9IGFbMiAqIGwgKyAwXSxcbiAgICAgICAgYTIxID0gYVsyICogbCArIDFdLFxuICAgICAgICBhMjIgPSBhWzIgKiBsICsgMl0sXG4gICAgICAgIGIwMCA9IGJbMCAqIGwgKyAwXSxcbiAgICAgICAgYjAxID0gYlswICogbCArIDFdLFxuICAgICAgICBiMDIgPSBiWzAgKiBsICsgMl0sXG4gICAgICAgIGIxMCA9IGJbMSAqIGwgKyAwXSxcbiAgICAgICAgYjExID0gYlsxICogbCArIDFdLFxuICAgICAgICBiMTIgPSBiWzEgKiBsICsgMl0sXG4gICAgICAgIGIyMCA9IGJbMiAqIGwgKyAwXSxcbiAgICAgICAgYjIxID0gYlsyICogbCArIDFdLFxuICAgICAgICBiMjIgPSBiWzIgKiBsICsgMl07XG5cbiAgICByZXR1cm4gbTIgPyBbXG4gICAgICBhMDAgKiBiMDAgKyBhMDEgKiBiMTAsXG4gICAgICBhMDAgKiBiMDEgKyBhMDEgKiBiMTEsXG4gICAgICBhMTAgKiBiMDAgKyBhMTEgKiBiMTAsXG4gICAgICBhMTAgKiBiMDEgKyBhMTEgKiBiMTFcbiAgICBdIDogW1xuICAgICAgYTAwICogYjAwICsgYTAxICogYjEwICsgYTAyICogYjIwLFxuICAgICAgYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxLFxuICAgICAgYTAwICogYjAyICsgYTAxICogYjEyICsgYTAyICogYjIyLFxuICAgICAgYTEwICogYjAwICsgYTExICogYjEwICsgYTEyICogYjIwLFxuICAgICAgYTEwICogYjAxICsgYTExICogYjExICsgYTEyICogYjIxLFxuICAgICAgYTEwICogYjAyICsgYTExICogYjEyICsgYTEyICogYjIyLFxuICAgICAgYTIwICogYjAwICsgYTIxICogYjEwICsgYTIyICogYjIwLFxuICAgICAgYTIwICogYjAxICsgYTIxICogYjExICsgYTIyICogYjIxLFxuICAgICAgYTIwICogYjAyICsgYTIxICogYjEyICsgYTIyICogYjIyXG4gICAgXTtcbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbiAgICogaHR0cDovL215Lm9wZXJhLmNvbS9lbW9sbGVyL2Jsb2cvMjAxMS8xMi8yMC9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWVyLWFuaW1hdGluZ1xuICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgYnkgRXJpayBNw7ZsbGVyLlxuICAgKiBmaXhlcyBmcm9tIFBhdWwgSXJpc2ggYW5kIFRpbm8gWmlqZGVsXG4gICAqIE1JVCBsaWNlbnNlXG4gICAqL1xuICB2YXIgeCxcbiAgICAgIGxhc3RUaW1lID0gMCxcbiAgICAgIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xuXG4gIGZvciAoeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZTsgeCsrKSB7XG4gICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9XG4gICAgICBnbG9iYWxbdmVuZG9yc1t4XSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPVxuICAgICAgZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fFxuICAgICAgZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gIH1cblxuICBpZiAoIWdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXG4gICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBlbGVtZW50KSB7XG4gICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpLFxuICAgICAgICAgIGlkID0gZ2xvYmFsLnNldFRpbWVvdXQoXG4gICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aW1lVG9DYWxsXG4gICAgICAgICAgKTtcblxuICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfTtcblxuICBpZiAoIWdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSlcbiAgICBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihpZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBwb2x5ZmlsbCBmb3VuZCBvbiBNRE4uXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQjQ29tcGF0aWJpbGl0eVxuICAgKiBQdWJsaWMgZG9tYWluXG4gICAqL1xuICBpZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKVxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24ob1RoaXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgLy8gQ2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1IGludGVybmFsIElzQ2FsbGFibGVcbiAgICAgICAgLy8gZnVuY3Rpb246XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlJ1xuICAgICAgICApO1xuXG4gICAgICB2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgIGZUb0JpbmQgPSB0aGlzLFxuICAgICAgICAgIGZOT1AsXG4gICAgICAgICAgZkJvdW5kO1xuXG4gICAgICBmTk9QID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgIGZCb3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZlRvQmluZC5hcHBseShcbiAgICAgICAgICB0aGlzIGluc3RhbmNlb2YgZk5PUCAmJiBvVGhpcyA/XG4gICAgICAgICAgICB0aGlzIDpcbiAgICAgICAgICAgIG9UaGlzLFxuICAgICAgICAgIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xuXG4gICAgICByZXR1cm4gZkJvdW5kO1xuICAgIH07XG59KSh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIFBhY2thZ2VzIGluaXRpYWxpemF0aW9uOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnNldHRpbmdzJyk7XG5cbiAgdmFyIHNldHRpbmdzID0ge1xuICAgIC8qKlxuICAgICAqIEdSQVBIIFNFVFRJTkdTOlxuICAgICAqICoqKioqKioqKioqKioqKlxuICAgICAqL1xuICAgIC8vIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgdGhlIGRhdGEgaGF2ZSB0byBiZSBjbG9uZWQgaW4gbWV0aG9kcyB0byBhZGRcbiAgICAvLyAgICAgICAgICAgbm9kZXMgb3IgZWRnZXMuXG4gICAgY2xvbmU6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IEluZGljYXRlcyBpZiBub2RlcyBcImlkXCIgdmFsdWVzIGFuZCBlZGdlcyBcImlkXCIsIFwic291cmNlXCIgYW5kXG4gICAgLy8gICAgICAgICAgIFwidGFyZ2V0XCIgdmFsdWVzIG11c3QgYmUgc2V0IGFzIGltbXV0YWJsZS5cbiAgICBpbW11dGFibGU6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IEluZGljYXRlcyBpZiBzaWdtYSBjYW4gbG9nIGl0cyBlcnJvcnMgYW5kIHdhcm5pbmdzLlxuICAgIHZlcmJvc2U6IGZhbHNlLFxuXG5cbiAgICAvKipcbiAgICAgKiBSRU5ERVJFUlMgU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqKioqKlxuICAgICAqL1xuICAgIC8vIHtzdHJpbmd9XG4gICAgY2xhc3NQcmVmaXg6ICdzaWdtYScsXG4gICAgLy8ge3N0cmluZ31cbiAgICBkZWZhdWx0Tm9kZVR5cGU6ICdkZWYnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdEVkZ2VUeXBlOiAnZGVmJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRMYWJlbENvbG9yOiAnIzAwMCcsXG4gICAgLy8ge3N0cmluZ31cbiAgICBkZWZhdWx0RWRnZUNvbG9yOiAnIzAwMCcsXG4gICAgLy8ge3N0cmluZ31cbiAgICBkZWZhdWx0Tm9kZUNvbG9yOiAnIzAwMCcsXG4gICAgLy8ge3N0cmluZ31cbiAgICBkZWZhdWx0TGFiZWxTaXplOiAxNCxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgZWRnZXMgY29sb3IuIEF2YWlsYWJsZSB2YWx1ZXM6XG4gICAgLy8gICAgICAgICAgXCJzb3VyY2VcIiwgXCJ0YXJnZXRcIiwgXCJkZWZhdWx0XCJcbiAgICBlZGdlQ29sb3I6ICdzb3VyY2UnLFxuICAgIC8vIHtudW1iZXJ9IERlZmluZXMgdGhlIG1pbmltYWwgZWRnZSdzIGFycm93IGRpc3BsYXkgc2l6ZS5cbiAgICBtaW5BcnJvd1NpemU6IDAsXG4gICAgLy8ge3N0cmluZ31cbiAgICBmb250OiAnYXJpYWwnLFxuICAgIC8vIHtzdHJpbmd9IEV4YW1wbGU6ICdib2xkJ1xuICAgIGZvbnRTdHlsZTogJycsXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGxhYmVscyBjb2xvci4gQXZhaWxhYmxlIHZhbHVlczpcbiAgICAvLyAgICAgICAgICBcIm5vZGVcIiwgXCJkZWZhdWx0XCJcbiAgICBsYWJlbENvbG9yOiAnZGVmYXVsdCcsXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGxhYmVscyBzaXplLiBBdmFpbGFibGUgdmFsdWVzOlxuICAgIC8vICAgICAgICAgIFwiZml4ZWRcIiwgXCJwcm9wb3J0aW9uYWxcIlxuICAgIGxhYmVsU2l6ZTogJ2ZpeGVkJyxcbiAgICAvLyB7c3RyaW5nfSBUaGUgcmF0aW8gYmV0d2VlbiB0aGUgZm9udCBzaXplIG9mIHRoZSBsYWJlbCBhbmQgdGhlIG5vZGUgc2l6ZS5cbiAgICBsYWJlbFNpemVSYXRpbzogMSxcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWluaW11bSBzaXplIGEgbm9kZSBtdXN0IGhhdmUgdG8gc2VlIGl0cyBsYWJlbCBkaXNwbGF5ZWQuXG4gICAgbGFiZWxUaHJlc2hvbGQ6IDgsXG4gICAgLy8ge251bWJlcn0gVGhlIG92ZXJzYW1wbGluZyBmYWN0b3IgdXNlZCBpbiBXZWJHTCByZW5kZXJlci5cbiAgICB3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvOiAyLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBzaXplIG9mIHRoZSBib3JkZXIgb2YgaG92ZXJlZCBub2Rlcy5cbiAgICBib3JkZXJTaXplOiAwLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBkZWZhdWx0IGhvdmVyZWQgbm9kZSBib3JkZXIncyBjb2xvci5cbiAgICBkZWZhdWx0Tm9kZUJvcmRlckNvbG9yOiAnIzAwMCcsXG4gICAgLy8ge251bWJlcn0gVGhlIGhvdmVyZWQgbm9kZSdzIGxhYmVsIGZvbnQuIElmIG5vdCBzcGVjaWZpZWQsIHdpbGwgaGVyaXRhdGVcbiAgICAvLyAgICAgICAgICB0aGUgXCJmb250XCIgdmFsdWUuXG4gICAgaG92ZXJGb250OiAnJyxcbiAgICAvLyB7Ym9vbGVhbn0gSWYgdHJ1ZSwgdGhlbiBvbmx5IG9uZSBub2RlIGNhbiBiZSBob3ZlcmVkIGF0IGEgdGltZS5cbiAgICBzaW5nbGVIb3ZlcjogdHJ1ZSxcbiAgICAvLyB7c3RyaW5nfSBFeGFtcGxlOiAnYm9sZCdcbiAgICBob3ZlckZvbnRTdHlsZTogJycsXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGhvdmVyZWQgbm9kZXMgc2hhZG93IGNvbG9yLlxuICAgIC8vICAgICAgICAgIEF2YWlsYWJsZSB2YWx1ZXM6IFwibm9kZVwiLCBcImRlZmF1bHRcIlxuICAgIGxhYmVsSG92ZXJTaGFkb3c6ICdkZWZhdWx0JyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGxhYmVsSG92ZXJTaGFkb3dDb2xvcjogJyMwMDAnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBob3ZlcmVkIG5vZGVzIGNvbG9yLlxuICAgIC8vICAgICAgICAgIEF2YWlsYWJsZSB2YWx1ZXM6IFwibm9kZVwiLCBcImRlZmF1bHRcIlxuICAgIG5vZGVIb3ZlckNvbG9yOiAnbm9kZScsXG4gICAgLy8ge3N0cmluZ31cbiAgICBkZWZhdWx0Tm9kZUhvdmVyQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgaG92ZXJlZCBub2RlcyBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgIC8vICAgICAgICAgIEF2YWlsYWJsZSB2YWx1ZXM6IFwibm9kZVwiLCBcImRlZmF1bHRcIlxuICAgIGxhYmVsSG92ZXJCR0NvbG9yOiAnZGVmYXVsdCcsXG4gICAgLy8ge3N0cmluZ31cbiAgICBkZWZhdWx0SG92ZXJMYWJlbEJHQ29sb3I6ICcjZmZmJyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgaG92ZXJlZCBsYWJlbHMgY29sb3IuXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJub2RlXCIsIFwiZGVmYXVsdFwiXG4gICAgbGFiZWxIb3ZlckNvbG9yOiAnZGVmYXVsdCcsXG4gICAgLy8ge3N0cmluZ31cbiAgICBkZWZhdWx0TGFiZWxIb3ZlckNvbG9yOiAnIzAwMCcsXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGVkZ2VzIGhvdmVyIGNvbG9yLiBBdmFpbGFibGUgdmFsdWVzOlxuICAgIC8vICAgICAgICAgIFwiZWRnZVwiLCBcImRlZmF1bHRcIlxuICAgIGVkZ2VIb3ZlckNvbG9yOiAnZWRnZScsXG4gICAgLy8ge251bWJlcn0gVGhlIHNpemUgbXVsdGlwbGljYXRvciBvZiBob3ZlcmVkIGVkZ2VzLlxuICAgIGVkZ2VIb3ZlclNpemVSYXRpbzogMSxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRFZGdlSG92ZXJDb2xvcjogJyMwMDAnLFxuICAgIC8vIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgdGhlIGVkZ2UgZXh0cmVtaXRpZXMgbXVzdCBiZSBob3ZlcmVkIHdoZW4gdGhlXG4gICAgLy8gICAgICAgICAgIGVkZ2UgaXMgaG92ZXJlZC5cbiAgICBlZGdlSG92ZXJFeHRyZW1pdGllczogZmFsc2UsXG4gICAgLy8ge2Jvb2xlYW5zfSBUaGUgZGlmZmVyZW50IGRyYXdpbmcgbW9kZXM6XG4gICAgLy8gICAgICAgICAgIGZhbHNlOiBMYXllcmVkIG5vdCBkaXNwbGF5ZWQuXG4gICAgLy8gICAgICAgICAgIHRydWU6IExheWVyZWQgZGlzcGxheWVkLlxuICAgIGRyYXdFZGdlczogdHJ1ZSxcbiAgICBkcmF3Tm9kZXM6IHRydWUsXG4gICAgZHJhd0xhYmVsczogdHJ1ZSxcbiAgICBkcmF3RWRnZUxhYmVsczogZmFsc2UsXG4gICAgLy8ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB0aGUgZWRnZXMgbXVzdCBiZSBkcmF3biBpbiBzZXZlcmFsIGZyYW1lcyBvciBpblxuICAgIC8vICAgICAgICAgICBvbmUgZnJhbWUsIGFzIHRoZSBub2RlcyBhbmQgbGFiZWxzIGFyZSBkcmF3bi5cbiAgICBiYXRjaEVkZ2VzRHJhd2luZzogZmFsc2UsXG4gICAgLy8ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB0aGUgZWRnZXMgbXVzdCBiZSBoaWRkZW4gZHVyaW5nIGRyYWdnaW5nIGFuZFxuICAgIC8vICAgICAgICAgICBhbmltYXRpb25zLlxuICAgIGhpZGVFZGdlc09uTW92ZTogZmFsc2UsXG4gICAgLy8ge251bWJlcnN9IFRoZSBkaWZmZXJlbnQgYmF0Y2ggc2l6ZXMsIHdoZW4gZWxlbWVudHMgYXJlIGRpc3BsYXllZCBpblxuICAgIC8vICAgICAgICAgICBzZXZlcmFsIGZyYW1lcy5cbiAgICBjYW52YXNFZGdlc0JhdGNoU2l6ZTogNTAwLFxuICAgIHdlYmdsRWRnZXNCYXRjaFNpemU6IDEwMDAsXG5cblxuXG5cbiAgICAvKipcbiAgICAgKiBSRVNDQUxFIFNFVFRJTkdTOlxuICAgICAqICoqKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIG9mIHRvIHNjYWxlIHRoZSBncmFwaCByZWxhdGl2ZWx5IHRvIGl0cyBjb250YWluZXIuXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJpbnNpZGVcIiwgXCJvdXRzaWRlXCJcbiAgICBzY2FsaW5nTW9kZTogJ2luc2lkZScsXG4gICAgLy8ge251bWJlcn0gVGhlIG1hcmdpbiB0byBrZWVwIGFyb3VuZCB0aGUgZ3JhcGguXG4gICAgc2lkZU1hcmdpbjogMCxcbiAgICAvLyB7bnVtYmVyfSBEZXRlcm1pbmUgdGhlIHNpemUgb2YgdGhlIHNtYWxsZXN0IGFuZCB0aGUgYmlnZ2VzdCBub2RlIC8gZWRnZXNcbiAgICAvLyAgICAgICAgICBvbiB0aGUgc2NyZWVuLiBUaGlzIG1hcHBpbmcgbWFrZXMgZWFzaWVyIHRvIGRpc3BsYXkgdGhlIGdyYXBoLFxuICAgIC8vICAgICAgICAgIGF2b2lkaW5nIHRvbyBiaWcgbm9kZXMgdGhhdCB0YWtlIGhhbGYgb2YgdGhlIHNjcmVlbiwgb3IgdG9vXG4gICAgLy8gICAgICAgICAgc21hbGwgb25lcyB0aGF0IGFyZSBub3QgcmVhZGFibGUuIElmIHRoZSB0d28gcGFyYW1ldGVycyBhcmVcbiAgICAvLyAgICAgICAgICBlcXVhbHMsIHRoZW4gdGhlIG1pbmltYWwgZGlzcGxheSBzaXplIHdpbGwgYmUgMC4gQW5kIGlmIHRoZXlcbiAgICAvLyAgICAgICAgICBhcmUgYm90aCBlcXVhbCB0byAwLCB0aGVuIHRoZXJlIGlzIG5vIG1hcHBpbmcsIGFuZCB0aGUgcmFkaXVzXG4gICAgLy8gICAgICAgICAgb2YgdGhlIG5vZGVzIHdpbGwgYmUgdGhlaXIgc2l6ZS5cbiAgICBtaW5FZGdlU2l6ZTogMC41LFxuICAgIG1heEVkZ2VTaXplOiAxLFxuICAgIG1pbk5vZGVTaXplOiAxLFxuICAgIG1heE5vZGVTaXplOiA4LFxuXG5cblxuXG4gICAgLyoqXG4gICAgICogQ0FQVE9SUyBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKioqKlxuICAgICAqL1xuICAgIC8vIHtib29sZWFufVxuICAgIHRvdWNoRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn1cbiAgICBtb3VzZUVuYWJsZWQ6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59XG4gICAgbW91c2VXaGVlbEVuYWJsZWQ6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59XG4gICAgZG91YmxlQ2xpY2tFbmFibGVkOiB0cnVlLFxuICAgIC8vIHtib29sZWFufSBEZWZpbmVzIHdoZXRoZXIgdGhlIGN1c3RvbSBldmVudHMgc3VjaCBhcyBcImNsaWNrTm9kZVwiIGNhbiBiZVxuICAgIC8vICAgICAgICAgICB1c2VkLlxuICAgIGV2ZW50c0VuYWJsZWQ6IHRydWUsXG4gICAgLy8ge251bWJlcn0gRGVmaW5lcyBieSBob3cgbXVjaCBtdWx0aXBsaWNhdGluZyB0aGUgem9vbWluZyBsZXZlbCB3aGVuIHRoZVxuICAgIC8vICAgICAgICAgIHVzZXIgem9vbXMgd2l0aCB0aGUgbW91c2Utd2hlZWwuXG4gICAgem9vbWluZ1JhdGlvOiAxLjcsXG4gICAgLy8ge251bWJlcn0gRGVmaW5lcyBieSBob3cgbXVjaCBtdWx0aXBsaWNhdGluZyB0aGUgem9vbWluZyBsZXZlbCB3aGVuIHRoZVxuICAgIC8vICAgICAgICAgIHVzZXIgem9vbXMgYnkgZG91YmxlIGNsaWNraW5nLlxuICAgIGRvdWJsZUNsaWNrWm9vbWluZ1JhdGlvOiAyLjIsXG4gICAgLy8ge251bWJlcn0gVGhlIG1pbmltdW0gem9vbWluZyBsZXZlbC5cbiAgICB6b29tTWluOiAwLjA2MjUsXG4gICAgLy8ge251bWJlcn0gVGhlIG1heGltdW0gem9vbWluZyBsZXZlbC5cbiAgICB6b29tTWF4OiAyLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBkdXJhdGlvbiBvZiBhbmltYXRpb25zIGZvbGxvd2luZyBhIG1vdXNlIHNjcm9sbGluZy5cbiAgICBtb3VzZVpvb21EdXJhdGlvbjogMjAwLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBkdXJhdGlvbiBvZiBhbmltYXRpb25zIGZvbGxvd2luZyBhIG1vdXNlIGRvdWJsZSBjbGljay5cbiAgICBkb3VibGVDbGlja1pvb21EdXJhdGlvbjogMjAwLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBkdXJhdGlvbiBvZiBhbmltYXRpb25zIGZvbGxvd2luZyBhIG1vdXNlIGRyb3BwaW5nLlxuICAgIG1vdXNlSW5lcnRpYUR1cmF0aW9uOiAyMDAsXG4gICAgLy8ge251bWJlcn0gVGhlIGluZXJ0aWEgcG93ZXIgKG1vdXNlIGNhcHRvcikuXG4gICAgbW91c2VJbmVydGlhUmF0aW86IDMsXG4gICAgLy8ge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbnMgZm9sbG93aW5nIGEgdG91Y2ggZHJvcHBpbmcuXG4gICAgdG91Y2hJbmVydGlhRHVyYXRpb246IDIwMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgaW5lcnRpYSBwb3dlciAodG91Y2ggY2FwdG9yKS5cbiAgICB0b3VjaEluZXJ0aWFSYXRpbzogMyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWF4aW11bSB0aW1lIGJldHdlZW4gdHdvIGNsaWNrcyB0byBtYWtlIGl0IGEgZG91YmxlIGNsaWNrLlxuICAgIGRvdWJsZUNsaWNrVGltZW91dDogMzAwLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHRpbWUgYmV0d2VlbiB0d28gdGFwcyB0byBtYWtlIGl0IGEgZG91YmxlIHRhcC5cbiAgICBkb3VibGVUYXBUaW1lb3V0OiAzMDAsXG4gICAgLy8ge251bWJlcn0gVGhlIG1heGltdW0gdGltZSBvZiBkcmFnZ2luZyB0byB0cmlnZ2VyIGludGVydGlhLlxuICAgIGRyYWdUaW1lb3V0OiAyMDAsXG5cblxuXG5cbiAgICAvKipcbiAgICAgKiBHTE9CQUwgU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqKlxuICAgICAqL1xuICAgIC8vIHtib29sZWFufSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGluc3RhbmNlIGhhcyB0byByZWZyZXNoIGl0c2VsZlxuICAgIC8vICAgICAgICAgICBhdXRvbWF0aWNhbGx5IHdoZW4gYSBcInJlc2l6ZVwiIGV2ZW50IGlzIGRpc3BhdGNoZWQgZnJvbSB0aGVcbiAgICAvLyAgICAgICAgICAgd2luZG93IG9iamVjdC5cbiAgICBhdXRvUmVzaXplOiB0cnVlLFxuICAgIC8vIHtib29sZWFufSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIFwicmVzY2FsZVwiIG1pZGRsZXdhcmUgaGFzIHRvIGJlIGNhbGxlZFxuICAgIC8vICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGZvciBlYWNoIGNhbWVyYSBvbiByZWZyZXNoLlxuICAgIGF1dG9SZXNjYWxlOiB0cnVlLFxuICAgIC8vIHtib29sZWFufSBJZiBzZXQgdG8gZmFsc2UsIHRoZSBjYW1lcmEgbWV0aG9kIFwiZ29Ub1wiIHdpbGwgYmFzaWNhbGx5IGRvXG4gICAgLy8gICAgICAgICAgIG5vdGhpbmcuXG4gICAgZW5hYmxlQ2FtZXJhOiB0cnVlLFxuICAgIC8vIHtib29sZWFufSBJZiBzZXQgdG8gZmFsc2UsIHRoZSBub2RlcyBjYW5ub3QgYmUgaG92ZXJlZC5cbiAgICBlbmFibGVIb3ZlcmluZzogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gSWYgc2V0IHRvIHRydWUsIHRoZSBlZGdlcyBjYW4gYmUgaG92ZXJlZC5cbiAgICBlbmFibGVFZGdlSG92ZXJpbmc6IGZhbHNlLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBzaXplIG9mIHRoZSBhcmVhIGFyb3VuZCB0aGUgZWRnZXMgdG8gYWN0aXZhdGUgaG92ZXJpbmcuXG4gICAgZWRnZUhvdmVyUHJlY2lzaW9uOiA1LFxuICAgIC8vIHtib29sZWFufSBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHJlc2NhbGUgbWlkZGxld2FyZSB3aWxsIGlnbm9yZSBub2RlIHNpemVzXG4gICAgLy8gICAgICAgICAgIHRvIGRldGVybWluZSB0aGUgZ3JhcGhzIGJvdW5kaW5ncy5cbiAgICByZXNjYWxlSWdub3JlU2l6ZTogZmFsc2UsXG4gICAgLy8ge2Jvb2xlYW59IERldGVybWluZXMgaWYgdGhlIGNvcmUgaGFzIHRvIHRyeSB0byBjYXRjaCBlcnJvcnMgb25cbiAgICAvLyAgICAgICAgICAgcmVuZGVyaW5nLlxuICAgIHNraXBFcnJvcnM6IGZhbHNlLFxuXG5cblxuXG4gICAgLyoqXG4gICAgICogQ0FNRVJBIFNFVFRJTkdTOlxuICAgICAqICoqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7bnVtYmVyfSBUaGUgcG93ZXIgZGVncmVlcyBhcHBsaWVkIHRvIHRoZSBub2Rlcy9lZGdlcyBzaXplIHJlbGF0aXZlbHkgdG9cbiAgICAvLyAgICAgICAgICB0aGUgem9vbWluZyBsZXZlbC4gQmFzaWNhbGx5OlxuICAgIC8vICAgICAgICAgICA+IG9uU2NyZWVuUiA9IE1hdGgucG93KHpvb20sIG5vZGVzUG93UmF0aW8pICogUlxuICAgIC8vICAgICAgICAgICA+IG9uU2NyZWVuVCA9IE1hdGgucG93KHpvb20sIGVkZ2VzUG93UmF0aW8pICogVFxuICAgIG5vZGVzUG93UmF0aW86IDAuNSxcbiAgICBlZGdlc1Bvd1JhdGlvOiAwLjUsXG5cblxuXG5cbiAgICAvKipcbiAgICAgKiBBTklNQVRJT05TIFNFVFRJTkdTOlxuICAgICAqICoqKioqKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge251bWJlcn0gVGhlIGRlZmF1bHQgYW5pbWF0aW9uIHRpbWUuXG4gICAgYW5pbWF0aW9uc1RpbWU6IDIwMFxuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgcHJldmlvdXNseSBkZXNpZ25lZCBzZXR0aW5nczpcbiAgc2lnbWEuc2V0dGluZ3MgPSBzaWdtYS51dGlscy5leHRlbmQoc2lnbWEuc2V0dGluZ3MgfHwge30sIHNldHRpbmdzKTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogRGlzcGF0Y2hlciBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHJldHVybiB7ZGlzcGF0Y2hlcn0gVGhlIG5ldyBkaXNwYXRjaGVyIGluc3RhbmNlLlxuICAgKi9cbiAgdmFyIGRpc3BhdGNoZXIgPSBmdW5jdGlvbigpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19oYW5kbGVycycsIHtcbiAgICAgIHZhbHVlOiB7fVxuICAgIH0pO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBXaWxsIGV4ZWN1dGUgdGhlIGhhbmRsZXIgZXZlcnl0aW1lIHRoYXQgdGhlIGluZGljYXRlZCBldmVudCAob3IgdGhlXG4gICAqIGluZGljYXRlZCBldmVudHMpIHdpbGwgYmUgdHJpZ2dlcmVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICBldmVudHMgIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRlZCBieSBzcGFjZXMpLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbihPYmplY3QpfSBoYW5kbGVyIFRoZSBoYW5kbGVyIHRvIGJpbmQuXG4gICAqIEByZXR1cm4ge2Rpc3BhdGNoZXJ9ICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgZGlzcGF0Y2hlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZUFycmF5O1xuXG4gICAgaWYgKFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCdcbiAgICApXG4gICAgICBmb3IgKGV2ZW50cyBpbiBhcmd1bWVudHNbMF0pXG4gICAgICAgIHRoaXMuYmluZChldmVudHMsIGFyZ3VtZW50c1swXVtldmVudHNdKTtcbiAgICBlbHNlIGlmIChcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiZcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIGVBcnJheSA9IHR5cGVvZiBldmVudHMgPT09ICdzdHJpbmcnID8gZXZlbnRzLnNwbGl0KCcgJykgOiBldmVudHM7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBsOyBpICs9IDEpIHtcbiAgICAgICAgZXZlbnQgPSBlQXJyYXlbaV07XG5cbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBldmVudCBpcyBub3QgJyc6XG4gICAgICAgIGlmICghZXZlbnQpXG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyc1tldmVudF0pXG4gICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnRdID0gW107XG5cbiAgICAgICAgLy8gVXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgZGlyZWN0bHkgdGhlIGhhbmRsZXIgd2lsbCBtYWtlIHBvc3NpYmxlXG4gICAgICAgIC8vIGxhdGVyIHRvIGFkZCBmbGFnc1xuICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudF0ucHVzaCh7XG4gICAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIHRocm93ICdiaW5kOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBoYW5kbGVyIGZyb20gYSBzcGVjaWZpZWQgZXZlbnQgKG9yIHNwZWNpZmllZCBldmVudHMpLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSAgICAgICAgICAgZXZlbnRzICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdGVkIGJ5IHNwYWNlcykuIElmIHVuZGVmaW5lZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBhbGwgaGFuZGxlcnMgYXJlIHJlbW92ZWQuXG4gICAqIEBwYXJhbSAgez9mdW5jdGlvbihvYmplY3QpfSBoYW5kbGVyIFRoZSBoYW5kbGVyIHRvIHVuYmluZC4gSWYgdW5kZWZpbmVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoIGhhbmRsZXIgYm91bmQgdG8gdGhlIGV2ZW50IG9yIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMgd2lsbCBiZSByZW1vdmVkLlxuICAgKiBAcmV0dXJuIHtkaXNwYXRjaGVyfSAgICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBkaXNwYXRjaGVyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbixcbiAgICAgICAgaixcbiAgICAgICAgbSxcbiAgICAgICAgayxcbiAgICAgICAgYSxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGVBcnJheSA9IHR5cGVvZiBldmVudHMgPT09ICdzdHJpbmcnID8gZXZlbnRzLnNwbGl0KCcgJykgOiBldmVudHM7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGZvciAoayBpbiB0aGlzLl9oYW5kbGVycylcbiAgICAgICAgZGVsZXRlIHRoaXMuX2hhbmRsZXJzW2tdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGZvciAoaSA9IDAsIG4gPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBuOyBpICs9IDEpIHtcbiAgICAgICAgZXZlbnQgPSBlQXJyYXlbaV07XG4gICAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICBhID0gW107XG4gICAgICAgICAgZm9yIChqID0gMCwgbSA9IHRoaXMuX2hhbmRsZXJzW2V2ZW50XS5sZW5ndGg7IGogIT09IG07IGogKz0gMSlcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudF1bal0uaGFuZGxlciAhPT0gaGFuZGxlcilcbiAgICAgICAgICAgICAgYS5wdXNoKHRoaXMuX2hhbmRsZXJzW2V2ZW50XVtqXSk7XG5cbiAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudF0gPSBhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLl9oYW5kbGVyc1tldmVudF0ubGVuZ3RoID09PSAwKVxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oYW5kbGVyc1tldmVudF07XG4gICAgICB9XG4gICAgfSBlbHNlXG4gICAgICBmb3IgKGkgPSAwLCBuID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gbjsgaSArPSAxKVxuICAgICAgICBkZWxldGUgdGhpcy5faGFuZGxlcnNbZUFycmF5W2ldXTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBlYWNoIGhhbmRsZXIgYm91bmQgdG8gdGhlIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGV2ZW50cyBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHMgc2VwYXJhdGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSBzcGFjZXMpLlxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSAgICBkYXRhICAgVGhlIGNvbnRlbnQgb2YgdGhlIGV2ZW50IChvcHRpb25hbCkuXG4gICAqIEByZXR1cm4ge2Rpc3BhdGNoZXJ9ICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBkaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnRzLCBkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4sXG4gICAgICAgIGosXG4gICAgICAgIG0sXG4gICAgICAgIGEsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBldmVudE5hbWUsXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBlQXJyYXkgPSB0eXBlb2YgZXZlbnRzID09PSAnc3RyaW5nJyA/IGV2ZW50cy5zcGxpdCgnICcpIDogZXZlbnRzO1xuXG4gICAgZGF0YSA9IGRhdGEgPT09IHVuZGVmaW5lZCA/IHt9IDogZGF0YTtcblxuICAgIGZvciAoaSA9IDAsIG4gPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBuOyBpICs9IDEpIHtcbiAgICAgIGV2ZW50TmFtZSA9IGVBcnJheVtpXTtcblxuICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgZXZlbnQgPSBzZWxmLmdldEV2ZW50KGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgICAgIGEgPSBbXTtcblxuICAgICAgICBmb3IgKGogPSAwLCBtID0gdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5sZW5ndGg7IGogIT09IG07IGogKz0gMSkge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV1bal0uaGFuZGxlcihldmVudCk7XG4gICAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdW2pdLm9uZSlcbiAgICAgICAgICAgIGEucHVzaCh0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdW2pdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0gPSBhO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gZXZlbnQgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBldmVudHMgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSBkYXRhICAgVGhlIGNvbnRlbnQgb2YgdGhlIGV2ZW50IChvcHRpb25hbCkuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBkaXNwYXRjaGVyLnByb3RvdHlwZS5nZXRFdmVudCA9IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGV2ZW50LFxuICAgICAgZGF0YTogZGF0YSB8fCB7fSxcbiAgICAgIHRhcmdldDogdGhpc1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgdXNlZnVsIGZ1bmN0aW9uIHRvIGRlYWwgd2l0aCBpbmhlcml0YW5jZS4gSXQgd2lsbCBtYWtlIHRoZSB0YXJnZXRcbiAgICogaW5oZXJpdCB0aGUgcHJvdG90eXBlIG9mIHRoZSBjbGFzcyBkaXNwYXRjaGVyIGFzIHdlbGwgYXMgaXRzIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQuXG4gICAqL1xuICBkaXNwYXRjaGVyLmV4dGVuZCA9IGZ1bmN0aW9uKHRhcmdldCwgYXJncykge1xuICAgIHZhciBrO1xuXG4gICAgZm9yIChrIGluIGRpc3BhdGNoZXIucHJvdG90eXBlKVxuICAgICAgaWYgKGRpc3BhdGNoZXIucHJvdG90eXBlLmhhc093blByb3BlcnR5KGspKVxuICAgICAgICB0YXJnZXRba10gPSBkaXNwYXRjaGVyLnByb3RvdHlwZVtrXTtcblxuICAgIGRpc3BhdGNoZXIuYXBwbHkodGFyZ2V0LCBhcmdzKTtcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogRVhQT1JUOlxuICAgKiAqKioqKioqXG4gICAqL1xuICBpZiAodHlwZW9mIHRoaXMuc2lnbWEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzID0gdGhpcy5zaWdtYS5jbGFzc2VzIHx8IHt9O1xuICAgIHRoaXMuc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkaXNwYXRjaGVyO1xuICAgIGV4cG9ydHMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG4gIH0gZWxzZVxuICAgIHRoaXMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFRoaXMgdXRpbHMgYWltcyB0byBmYWNpbGl0YXRlIHRoZSBtYW5pcHVsYXRpb24gb2YgZWFjaCBpbnN0YW5jZSBzZXR0aW5nLlxuICAgKiBVc2luZyBhIGZ1bmN0aW9uIGluc3RlYWQgb2YgYW4gb2JqZWN0IGJyaW5ncyB0d28gbWFpbiBhZHZhbnRhZ2VzOiBGaXJzdCxcbiAgICogaXQgd2lsbCBiZSBlYXNpZXIgaW4gdGhlIGZ1dHVyZSB0byBjYXRjaCBzZXR0aW5ncyB1cGRhdGVzIHRocm91Z2ggYVxuICAgKiBmdW5jdGlvbiB0aGFuIGFuIG9iamVjdC4gU2Vjb25kLCBnaXZpbmcgaXQgYSBmdWxsIG9iamVjdCB3aWxsIFwibWVyZ2VcIiBpdFxuICAgKiB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IHByb3Blcmx5LCBrZWVwaW5nIHVzIHRvIGhhdmUgdG8gYWx3YXlzIGFkZCBhIGxvb3AuXG4gICAqXG4gICAqIEByZXR1cm4ge2NvbmZpZ3VyYWJsZX0gVGhlIFwic2V0dGluZ3NcIiBmdW5jdGlvbi5cbiAgICovXG4gIHZhciBjb25maWd1cmFibGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgZGF0YSA9IHt9LFxuICAgICAgICBkYXRhcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIHRvIHVzZSB0byBzZXQgb3IgZ2V0IGFueSBwcm9wZXJ0eSBvZiB0aGlzIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfG9iamVjdH0gICAgYTEgSWYgaXQgaXMgYSBzdHJpbmcgYW5kIGlmIGEyIGlzIHVuZGVmaW5lZCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIGl0IHdpbGwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuIElmIGl0IGlzIGEgc3RyaW5nIGFuZCBpZiBhMiBpc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldCwgdGhlbiBpdCB3aWxsIHNldCBhMiBhcyB0aGUgcHJvcGVydHlcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kaW5nIHRvIGExLCBhbmQgcmV0dXJuIHRoaXMuIElmXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQgaXMgYW4gb2JqZWN0LCB0aGVuIGVhY2ggcGFpciBzdHJpbmcgK1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdChvciBhbnkgb3RoZXIgdHlwZSkgd2lsbCBiZSBzZXQgYXMgYVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSAgeyo/fSAgICAgICAgICAgICAgIGEyIFRoZSBuZXcgcHJvcGVydHkgY29ycmVzcG9uZGluZyB0byBhMSBpZiBhMVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGEgc3RyaW5nLlxuICAgICAqIEByZXR1cm4geyp8Y29uZmlndXJhYmxlfSAgICAgIFJldHVybnMgaXRzZWxmIG9yIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBQb2x5bW9ycGhpc206XG4gICAgICogKioqKioqKioqKioqKlxuICAgICAqIEhlcmUgYXJlIHNvbWUgYmFzaWMgdXNlIGV4YW1wbGVzOlxuICAgICAqXG4gICAgICogID4gc2V0dGluZ3MgPSBuZXcgY29uZmlndXJhYmxlKCk7XG4gICAgICogID4gc2V0dGluZ3MoJ215U2V0dGluZycsIDQyKTtcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJyk7IC8vIExvZ3M6IDQyXG4gICAgICogID4gc2V0dGluZ3MoJ215U2V0dGluZycsIDEyMyk7XG4gICAgICogID4gc2V0dGluZ3MoJ215U2V0dGluZycpOyAvLyBMb2dzOiAxMjNcbiAgICAgKiAgPiBzZXR0aW5ncyh7bXlTZXR0aW5nOiA0NTZ9KTtcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJyk7IC8vIExvZ3M6IDQ1NlxuICAgICAqXG4gICAgICogQWxzbywgaXQgaXMgcG9zc2libGUgdG8gdXNlIHRoZSBmdW5jdGlvbiBhcyBhIGZhbGxiYWNrOlxuICAgICAqICA+IHNldHRpbmdzKHtteVNldHRpbmc6ICdhYmMnfSwgJ215U2V0dGluZycpOyAgLy8gTG9nczogJ2FiYydcbiAgICAgKiAgPiBzZXR0aW5ncyh7aGlzU2V0dGluZzogJ2FiYyd9LCAnbXlTZXR0aW5nJyk7IC8vIExvZ3M6IDQ1NlxuICAgICAqL1xuICAgIHZhciBzZXR0aW5ncyA9IGZ1bmN0aW9uKGExLCBhMikge1xuICAgICAgdmFyIG8sXG4gICAgICAgICAgaSxcbiAgICAgICAgICBsLFxuICAgICAgICAgIGs7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhMSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRhdGFbYTFdICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuIGRhdGFbYTFdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZGF0YXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGlmIChkYXRhc1tpXVthMV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBkYXRhc1tpXVthMV07XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhMSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGEyID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gKGExIHx8IHt9KVthMl0gIT09IHVuZGVmaW5lZCA/IGExW2EyXSA6IHNldHRpbmdzKGEyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG8gPSAodHlwZW9mIGExID09PSAnb2JqZWN0JyAmJiBhMiA9PT0gdW5kZWZpbmVkKSA/IGExIDoge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhMSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgb1thMV0gPSBhMjtcblxuICAgICAgICBmb3IgKGkgPSAwLCBrID0gT2JqZWN0LmtleXMobyksIGwgPSBrLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBkYXRhW2tbaV1dID0gb1trW2ldXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBjb25maWd1cmFibGUgZnVuY3Rpb24sIHdpdGggbmV3IG9iamVjdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdCp9ICBBbnkgbnVtYmVyIG9mIG9iamVjdHMgdG8gc2VhcmNoIGluLlxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBmdW5jdGlvbi4gQ2hlY2sgaXRzIGRvY3VtZW50YXRpb24gdG8ga25vd1xuICAgICAqICAgICAgICAgICAgICAgICAgICBtb3JlIGFib3V0IGhvdyBpdCB3b3Jrcy5cbiAgICAgKi9cbiAgICBzZXR0aW5ncy5lbWJlZE9iamVjdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gZGF0YXMuY29uY2F0KFxuICAgICAgICBkYXRhXG4gICAgICApLmNvbmNhdChcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyZ3VtZW50cywgMClcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBjb25maWd1cmFibGUuYXBwbHkoe30sIGFyZ3MpO1xuICAgIH07XG5cbiAgICAvLyBJbml0aWFsaXplXG4gICAgZm9yIChpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBzZXR0aW5ncyhhcmd1bWVudHNbaV0pO1xuXG4gICAgcmV0dXJuIHNldHRpbmdzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFWFBPUlQ6XG4gICAqICoqKioqKipcbiAgICovXG4gIGlmICh0eXBlb2YgdGhpcy5zaWdtYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMgPSB0aGlzLnNpZ21hLmNsYXNzZXMgfHwge307XG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzLmNvbmZpZ3VyYWJsZSA9IGNvbmZpZ3VyYWJsZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjb25maWd1cmFibGU7XG4gICAgZXhwb3J0cy5jb25maWd1cmFibGUgPSBjb25maWd1cmFibGU7XG4gIH0gZWxzZVxuICAgIHRoaXMuY29uZmlndXJhYmxlID0gY29uZmlndXJhYmxlO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfbWV0aG9kcyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBfaW5kZXhlcyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBfaW5pdEJpbmRpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIF9tZXRob2RCaW5kaW5ncyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBfbWV0aG9kQmVmb3JlQmluZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgX2RlZmF1bHRTZXR0aW5ncyA9IHtcbiAgICAgICAgaW1tdXRhYmxlOiB0cnVlLFxuICAgICAgICBjbG9uZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIF9kZWZhdWx0U2V0dGluZ3NGdW5jdGlvbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHRTZXR0aW5nc1trZXldO1xuICAgICAgfTtcblxuICAvKipcbiAgICogVGhlIGdyYXBoIGNvbnN0cnVjdG9yLiBJdCBpbml0aWFsaXplcyB0aGUgZGF0YSBhbmQgdGhlIGluZGV4ZXMsIGFuZCBiaW5kc1xuICAgKiB0aGUgY3VzdG9tIGluZGV4ZXMgYW5kIG1ldGhvZHMgdG8gaXRzIG93biBzY29wZS5cbiAgICpcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzIGluIHRoZSBzZXR0aW5nc1xuICAgKiBvYmplY3Q6XG4gICAqXG4gICAqICAge2Jvb2xlYW59IGNsb25lICAgICBJbmRpY2F0ZXMgaWYgdGhlIGRhdGEgaGF2ZSB0byBiZSBjbG9uZWQgaW4gbWV0aG9kc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgdG8gYWRkIG5vZGVzIG9yIGVkZ2VzLlxuICAgKiAgIHtib29sZWFufSBpbW11dGFibGUgSW5kaWNhdGVzIGlmIG5vZGVzIFwiaWRcIiB2YWx1ZXMgYW5kIGVkZ2VzIFwiaWRcIixcbiAgICogICAgICAgICAgICAgICAgICAgICAgIFwic291cmNlXCIgYW5kIFwidGFyZ2V0XCIgdmFsdWVzIG11c3QgYmUgc2V0IGFzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBpbW11dGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSAgez9jb25maWd1cmFibGV9IHNldHRpbmdzIEV2ZW50dWFsbHkgYSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7Z3JhcGh9ICAgICAgICAgICAgICAgICAgVGhlIG5ldyBncmFwaCBpbnN0YW5jZS5cbiAgICovXG4gIHZhciBncmFwaCA9IGZ1bmN0aW9uKHNldHRpbmdzKSB7XG4gICAgdmFyIGssXG4gICAgICAgIGZuLFxuICAgICAgICBkYXRhO1xuXG4gICAgLyoqXG4gICAgICogREFUQTpcbiAgICAgKiAqKioqKlxuICAgICAqIEV2ZXJ5IGRhdGEgdGhhdCBpcyBjYWxsYWJsZSBmcm9tIGdyYXBoIG1ldGhvZHMgYXJlIHN0b3JlZCBpbiB0aGlzIFwiZGF0YVwiXG4gICAgICogb2JqZWN0LiBUaGlzIG9iamVjdCB3aWxsIGJlIHNlcnZlZCBhcyBjb250ZXh0IGZvciBhbGwgdGhlc2UgbWV0aG9kcyxcbiAgICAgKiBhbmQgaXQgaXMgcG9zc2libGUgdG8gYWRkIG90aGVyIHR5cGUgb2YgZGF0YSBpbiBpdC5cbiAgICAgKi9cbiAgICBkYXRhID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBTRVRUSU5HUyBGVU5DVElPTjpcbiAgICAgICAqICoqKioqKioqKioqKioqKioqKlxuICAgICAgICovXG4gICAgICBzZXR0aW5nczogc2V0dGluZ3MgfHwgX2RlZmF1bHRTZXR0aW5nc0Z1bmN0aW9uLFxuXG4gICAgICAvKipcbiAgICAgICAqIE1BSU4gREFUQTpcbiAgICAgICAqICoqKioqKioqKipcbiAgICAgICAqL1xuICAgICAgbm9kZXNBcnJheTogW10sXG4gICAgICBlZGdlc0FycmF5OiBbXSxcblxuICAgICAgLyoqXG4gICAgICAgKiBHTE9CQUwgSU5ERVhFUzpcbiAgICAgICAqICoqKioqKioqKioqKioqKlxuICAgICAgICogVGhlc2UgaW5kZXhlcyBqdXN0IGluZGV4IGRhdGEgYnkgaWRzLlxuICAgICAgICovXG4gICAgICBub2Rlc0luZGV4OiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgZWRnZXNJbmRleDogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBMT0NBTCBJTkRFWEVTOlxuICAgICAgICogKioqKioqKioqKioqKipcbiAgICAgICAqIFRoZXNlIGluZGV4ZXMgcmVmZXIgZnJvbSBub2RlIHRvIG5vZGVzLiBFYWNoIGtleSBpcyBhbiBpZCwgYW5kIGVhY2hcbiAgICAgICAqIHZhbHVlIGlzIHRoZSBhcnJheSBvZiB0aGUgaWRzIG9mIHJlbGF0ZWQgbm9kZXMuXG4gICAgICAgKi9cbiAgICAgIGluTmVpZ2hib3JzSW5kZXg6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBvdXROZWlnaGJvcnNJbmRleDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGFsbE5laWdoYm9yc0luZGV4OiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgICBpbk5laWdoYm9yc0NvdW50OiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgb3V0TmVpZ2hib3JzQ291bnQ6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBhbGxOZWlnaGJvcnNDb3VudDogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIH07XG5cbiAgICAvLyBFeGVjdXRlIGJpbmRpbmdzOlxuICAgIGZvciAoayBpbiBfaW5pdEJpbmRpbmdzKVxuICAgICAgX2luaXRCaW5kaW5nc1trXS5jYWxsKGRhdGEpO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYm90aCB0aGUgc2NvcGUgYW5kIHRoZSBkYXRhIG9iamVjdHM6XG4gICAgZm9yIChrIGluIF9tZXRob2RzKSB7XG4gICAgICBmbiA9IF9fYmluZEdyYXBoTWV0aG9kKGssIGRhdGEsIF9tZXRob2RzW2tdKTtcbiAgICAgIHRoaXNba10gPSBmbjtcbiAgICAgIGRhdGFba10gPSBmbjtcbiAgICB9XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIEEgY3VzdG9tIHRvb2wgdG8gYmluZCBtZXRob2RzIHN1Y2ggdGhhdCBmdW5jdGlvbiB0aGF0IGFyZSBib3VuZCB0byBpdCB3aWxsXG4gICAqIGJlIGV4ZWN1dGVkIGFueXRpbWUgdGhlIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gYmluZC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgIHNjb3BlICAgICAgVGhlIHNjb3BlIHdoZXJlIHRoZSBtZXRob2QgbXVzdCBiZSBleGVjdXRlZC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGZuICAgICAgICAgVGhlIG1ldGhvZCBpdHNlbGYuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSAgICAgICAgICAgIFRoZSBuZXcgbWV0aG9kLlxuICAgKi9cbiAgZnVuY3Rpb24gX19iaW5kR3JhcGhNZXRob2QobWV0aG9kTmFtZSwgc2NvcGUsIGZuKSB7XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGssXG4gICAgICAgICAgcmVzO1xuXG4gICAgICAvLyBFeGVjdXRlIFwiYmVmb3JlXCIgYm91bmQgZnVuY3Rpb25zOlxuICAgICAgZm9yIChrIGluIF9tZXRob2RCZWZvcmVCaW5kaW5nc1ttZXRob2ROYW1lXSlcbiAgICAgICAgX21ldGhvZEJlZm9yZUJpbmRpbmdzW21ldGhvZE5hbWVdW2tdLmFwcGx5KHNjb3BlLCBhcmd1bWVudHMpO1xuXG4gICAgICAvLyBBcHBseSB0aGUgbWV0aG9kOlxuICAgICAgcmVzID0gZm4uYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyk7XG5cbiAgICAgIC8vIEV4ZWN1dGUgYm91bmQgZnVuY3Rpb25zOlxuICAgICAgZm9yIChrIGluIF9tZXRob2RCaW5kaW5nc1ttZXRob2ROYW1lXSlcbiAgICAgICAgX21ldGhvZEJpbmRpbmdzW21ldGhvZE5hbWVdW2tdLmFwcGx5KHNjb3BlLCBhcmd1bWVudHMpO1xuXG4gICAgICAvLyBSZXR1cm4gcmVzOlxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGN1c3RvbSB0b29sIGZ1bmN0aW9uIHJlbW92ZXMgZXZlcnkgcGFpciBrZXkvdmFsdWUgZnJvbSBhbiBoYXNoLiBUaGVcbiAgICogZ29hbCBpcyB0byBhdm9pZCBjcmVhdGluZyBhIG5ldyBvYmplY3Qgd2hpbGUgc29tZSBvdGhlciByZWZlcmVuY2VzIGFyZVxuICAgKiBzdGlsbCBoYW5naW5nIGluIHNvbWUgc2NvcGVzLi4uXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZW1wdHkuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgIFRoZSBlbXB0eSBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBfX2VtcHR5T2JqZWN0KG9iaikge1xuICAgIHZhciBrO1xuXG4gICAgZm9yIChrIGluIG9iailcbiAgICAgIGlmICghKCdoYXNPd25Qcm9wZXJ0eScgaW4gb2JqKSB8fCBvYmouaGFzT3duUHJvcGVydHkoaykpXG4gICAgICAgIGRlbGV0ZSBvYmpba107XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZ2xvYmFsIG1ldGhvZCBhZGRzIGEgbWV0aG9kIHRoYXQgd2lsbCBiZSBib3VuZCB0byB0aGUgZnV0dXJseSBjcmVhdGVkXG4gICAqIGdyYXBoIGluc3RhbmNlcy5cbiAgICpcbiAgICogU2luY2UgdGhlc2UgbWV0aG9kcyB3aWxsIGJlIGJvdW5kIHRvIHRoZWlyIHNjb3BlIHdoZW4gdGhlIGluc3RhbmNlcyBhcmVcbiAgICogY3JlYXRlZCwgaXQgZG9lcyBub3QgdXNlIHRoZSBwcm90b3R5cGUuIEJlY2F1c2Ugb2YgdGhhdCwgbWV0aG9kcyBoYXZlIHRvXG4gICAqIGJlIGFkZGVkIGJlZm9yZSBpbnN0YW5jZXMgYXJlIGNyZWF0ZWQgdG8gbWFrZSB0aGVtIGF2YWlsYWJsZS5cbiAgICpcbiAgICogSGVyZSBpcyBhbiBleGFtcGxlOlxuICAgKlxuICAgKiAgPiBncmFwaC5hZGRNZXRob2QoJ2dldE5vZGVzQ291bnQnLCBmdW5jdGlvbigpIHtcbiAgICogID4gICByZXR1cm4gdGhpcy5ub2Rlc0FycmF5Lmxlbmd0aDtcbiAgICogID4gfSk7XG4gICAqICA+XG4gICAqICA+IHZhciBteUdyYXBoID0gbmV3IGdyYXBoKCk7XG4gICAqICA+IGNvbnNvbGUubG9nKG15R3JhcGguZ2V0Tm9kZXNDb3VudCgpKTsgLy8gb3V0cHV0cyAwXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBmbiAgICAgICAgIFRoZSBtZXRob2QgaXRzZWxmLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICBUaGUgZ2xvYmFsIGdyYXBoIGNvbnN0cnVjdG9yLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kTmFtZSwgZm4pIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgbWV0aG9kTmFtZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCAhPT0gMlxuICAgIClcbiAgICAgIHRocm93ICdhZGRNZXRob2Q6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKF9tZXRob2RzW21ldGhvZE5hbWVdIHx8IGdyYXBoW21ldGhvZE5hbWVdKVxuICAgICAgdGhyb3cgJ1RoZSBtZXRob2QgXCInICsgbWV0aG9kTmFtZSArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xuXG4gICAgX21ldGhvZHNbbWV0aG9kTmFtZV0gPSBmbjtcbiAgICBfbWV0aG9kQmluZGluZ3NbbWV0aG9kTmFtZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIF9tZXRob2RCZWZvcmVCaW5kaW5nc1ttZXRob2ROYW1lXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnbG9iYWwgbWV0aG9kIHJldHVybnMgdHJ1ZSBpZiB0aGUgbWV0aG9kIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQsIGFuZFxuICAgKiBmYWxzZSBlbHNlLlxuICAgKlxuICAgKiBIZXJlIGFyZSBzb21lIGV4YW1wbGVzOlxuICAgKlxuICAgKiAgPiBncmFwaC5oYXNNZXRob2QoJ2FkZE5vZGUnKTsgLy8gcmV0dXJucyB0cnVlXG4gICAqICA+IGdyYXBoLmhhc01ldGhvZCgnaGFzTWV0aG9kJyk7IC8vIHJldHVybnMgdHJ1ZVxuICAgKiAgPiBncmFwaC5oYXNNZXRob2QoJ3VuZXhpc3RpbmdNZXRob2QnKTsgLy8gcmV0dXJucyBmYWxzZVxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICAgICAgVGhlIHJlc3VsdC5cbiAgICovXG4gIGdyYXBoLmhhc01ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICByZXR1cm4gISEoX21ldGhvZHNbbWV0aG9kTmFtZV0gfHwgZ3JhcGhbbWV0aG9kTmFtZV0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdsb2JhbCBtZXRob2RzIGF0dGFjaGVzIGEgZnVuY3Rpb24gdG8gYSBtZXRob2QuIEFueXRpbWUgdGhlIHNwZWNpZmllZFxuICAgKiBtZXRob2QgaXMgY2FsbGVkLCB0aGUgYXR0YWNoZWQgZnVuY3Rpb24gaXMgY2FsbGVkIHJpZ2h0IGFmdGVyLCB3aXRoIHRoZVxuICAgKiBzYW1lIGFyZ3VtZW50cyBhbmQgaW4gdGhlIHNhbWUgc2NvcGUuIFRoZSBhdHRhY2hlZCBmdW5jdGlvbiBpcyBjYWxsZWRcbiAgICogcmlnaHQgYmVmb3JlIGlmIHRoZSBsYXN0IGFyZ3VtZW50IGlzIHRydWUsIHVubGVzcyB0aGUgbWV0aG9kIGlzIHRoZSBncmFwaFxuICAgKiBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogVG8gYXR0YWNoIGEgZnVuY3Rpb24gdG8gdGhlIGdyYXBoIGNvbnN0cnVjdG9yLCB1c2UgJ2NvbnN0cnVjdG9yJyBhcyB0aGVcbiAgICogbWV0aG9kIG5hbWUgKGZpcnN0IGFyZ3VtZW50KS5cbiAgICpcbiAgICogVGhlIG1haW4gaWRlYSBpcyB0byBoYXZlIGEgY2xlYW4gd2F5IHRvIGtlZXAgY3VzdG9tIGluZGV4ZXMgdXAgdG8gZGF0ZSxcbiAgICogZm9yIGluc3RhbmNlOlxuICAgKlxuICAgKiAgPiB2YXIgdGltZXNBZGROb2RlQ2FsbGVkID0gMDtcbiAgICogID4gZ3JhcGguYXR0YWNoKCdhZGROb2RlJywgJ3RpbWVzQWRkTm9kZUNhbGxlZEluYycsIGZ1bmN0aW9uKCkge1xuICAgKiAgPiAgIHRpbWVzQWRkTm9kZUNhbGxlZCsrO1xuICAgKiAgPiB9KTtcbiAgICogID5cbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgZ3JhcGgoKTtcbiAgICogID4gY29uc29sZS5sb2codGltZXNBZGROb2RlQ2FsbGVkKTsgLy8gb3V0cHV0cyAwXG4gICAqICA+XG4gICAqICA+IG15R3JhcGguYWRkTm9kZSh7IGlkOiAnMScgfSkuYWRkTm9kZSh7IGlkOiAnMicgfSk7XG4gICAqICA+IGNvbnNvbGUubG9nKHRpbWVzQWRkTm9kZUNhbGxlZCk7IC8vIG91dHB1dHMgMlxuICAgKlxuICAgKiBUaGUgaWRlYSBmb3IgY2FsbGluZyBhIGZ1bmN0aW9uIGJlZm9yZSBpcyB0byBwcm92aWRlIHByZS1wcm9jZXNzb3JzLCBmb3JcbiAgICogaW5zdGFuY2U6XG4gICAqXG4gICAqICA+IHZhciBjb2xvclBhbGV0dGUgPSB7IFBlcnNvbjogJyNDM0NCRTEnLCBQbGFjZTogJyM5QkRFQkQnIH07XG4gICAqICA+IGdyYXBoLmF0dGFjaCgnYWRkTm9kZScsICdhcHBseU5vZGVDb2xvclBhbGV0dGUnLCBmdW5jdGlvbihuKSB7XG4gICAqICA+ICAgbi5jb2xvciA9IGNvbG9yUGFsZXR0ZVtuLmNhdGVnb3J5XTtcbiAgICogID4gfSwgdHJ1ZSk7XG4gICAqICA+XG4gICAqICA+IHZhciBteUdyYXBoID0gbmV3IGdyYXBoKCk7XG4gICAqICA+IG15R3JhcGguYWRkTm9kZSh7IGlkOiAnbjAnLCBjYXRlZ29yeTogJ1BlcnNvbicgfSk7XG4gICAqICA+IGNvbnNvbGUubG9nKG15R3JhcGgubm9kZXMoJ24wJykuY29sb3IpOyAvLyBvdXRwdXRzICcjQzNDQkUxJ1xuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgcmVsYXRlZCBtZXRob2Qgb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb25zdHJ1Y3RvclwiLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAga2V5ICAgICAgICBUaGUga2V5IHRvIGlkZW50aWZ5IHRoZSBmdW5jdGlvbiB0byBhdHRhY2guXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBmbiAgICAgICAgIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgYmVmb3JlICAgICBJZiB0cnVlIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgcmlnaHQgYmVmb3JlLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICBUaGUgZ2xvYmFsIGdyYXBoIGNvbnN0cnVjdG9yLlxuICAgKi9cbiAgZ3JhcGguYXR0YWNoID0gZnVuY3Rpb24obWV0aG9kTmFtZSwga2V5LCBmbiwgYmVmb3JlKSB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG1ldGhvZE5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICBhcmd1bWVudHMubGVuZ3RoIDwgMyB8fFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDRcbiAgICApXG4gICAgICB0aHJvdyAnYXR0YWNoOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIHZhciBiaW5kaW5ncztcblxuICAgIGlmIChtZXRob2ROYW1lID09PSAnY29uc3RydWN0b3InKVxuICAgICAgYmluZGluZ3MgPSBfaW5pdEJpbmRpbmdzO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICBpZiAoIV9tZXRob2RCZWZvcmVCaW5kaW5nc1ttZXRob2ROYW1lXSlcbiAgICAgICAgdGhyb3cgJ1RoZSBtZXRob2QgXCInICsgbWV0aG9kTmFtZSArICdcIiBkb2VzIG5vdCBleGlzdC4nO1xuXG4gICAgICAgIGJpbmRpbmdzID0gX21ldGhvZEJlZm9yZUJpbmRpbmdzW21ldGhvZE5hbWVdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICghX21ldGhvZEJpbmRpbmdzW21ldGhvZE5hbWVdKVxuICAgICAgICAgIHRocm93ICdUaGUgbWV0aG9kIFwiJyArIG1ldGhvZE5hbWUgKyAnXCIgZG9lcyBub3QgZXhpc3QuJztcblxuICAgICAgICBiaW5kaW5ncyA9IF9tZXRob2RCaW5kaW5nc1ttZXRob2ROYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmluZGluZ3Nba2V5XSlcbiAgICAgIHRocm93ICdBIGZ1bmN0aW9uIFwiJyArIGtleSArICdcIiBpcyBhbHJlYWR5IGF0dGFjaGVkICcgK1xuICAgICAgICAgICAgJ3RvIHRoZSBtZXRob2QgXCInICsgbWV0aG9kTmFtZSArICdcIi4nO1xuXG4gICAgYmluZGluZ3Nba2V5XSA9IGZuO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsaWFzIG9mIGF0dGFjaChtZXRob2ROYW1lLCBrZXksIGZuLCB0cnVlKS5cbiAgICovXG4gIGdyYXBoLmF0dGFjaEJlZm9yZSA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGtleSwgZm4pIHtcbiAgICByZXR1cm4gdGhpcy5hdHRhY2gobWV0aG9kTmFtZSwga2V5LCBmbiwgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kcyBpcyBqdXN0IGFuIGhlbHBlciB0byBkZWFsIHdpdGggY3VzdG9tIGluZGV4ZXMuIEl0IHRha2VzIGFzXG4gICAqIGFyZ3VtZW50cyB0aGUgbmFtZSBvZiB0aGUgaW5kZXggYW5kIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgZGlmZmVyZW50XG4gICAqIGZ1bmN0aW9ucyB0byBiaW5kIHRvIHRoZSBtZXRob2RzLlxuICAgKlxuICAgKiBIZXJlIGlzIGEgYmFzaWMgZXhhbXBsZSwgdGhhdCBjcmVhdGVzIGFuIGluZGV4IHRvIGtlZXAgdGhlIG51bWJlciBvZiBub2Rlc1xuICAgKiBpbiB0aGUgY3VycmVudCBncmFwaC4gSXQgYWxzbyBhZGRzIGEgbWV0aG9kIHRvIHByb3ZpZGUgYSBnZXR0ZXIgb24gdGhhdFxuICAgKiBuZXcgaW5kZXg6XG4gICAqXG4gICAqICA+IHNpZ21hLmNsYXNzZXMuZ3JhcGguYWRkSW5kZXgoJ25vZGVzQ291bnQnLCB7XG4gICAqICA+ICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgKiAgPiAgICAgdGhpcy5ub2Rlc0NvdW50ID0gMDtcbiAgICogID4gICB9LFxuICAgKiAgPiAgIGFkZE5vZGU6IGZ1bmN0aW9uKCkge1xuICAgKiAgPiAgICAgdGhpcy5ub2Rlc0NvdW50Kys7XG4gICAqICA+ICAgfSxcbiAgICogID4gICBkcm9wTm9kZTogZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgICB0aGlzLm5vZGVzQ291bnQtLTtcbiAgICogID4gICB9XG4gICAqICA+IH0pO1xuICAgKiAgPlxuICAgKiAgPiBzaWdtYS5jbGFzc2VzLmdyYXBoLmFkZE1ldGhvZCgnZ2V0Tm9kZXNDb3VudCcsIGZ1bmN0aW9uKCkge1xuICAgKiAgPiAgIHJldHVybiB0aGlzLm5vZGVzQ291bnQ7XG4gICAqICA+IH0pO1xuICAgKiAgPlxuICAgKiAgPiB2YXIgbXlHcmFwaCA9IG5ldyBzaWdtYS5jbGFzc2VzLmdyYXBoKCk7XG4gICAqICA+IGNvbnNvbGUubG9nKG15R3JhcGguZ2V0Tm9kZXNDb3VudCgpKTsgLy8gb3V0cHV0cyAwXG4gICAqICA+XG4gICAqICA+IG15R3JhcGguYWRkTm9kZSh7IGlkOiAnMScgfSkuYWRkTm9kZSh7IGlkOiAnMicgfSk7XG4gICAqICA+IGNvbnNvbGUubG9nKG15R3JhcGguZ2V0Tm9kZXNDb3VudCgpKTsgLy8gb3V0cHV0cyAyXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSAgICAgVGhlIG5hbWUgb2YgdGhlIGluZGV4LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGJpbmRpbmdzIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgZnVuY3Rpb25zIHRvIGJpbmQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgVGhlIGdsb2JhbCBncmFwaCBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGdyYXBoLmFkZEluZGV4ID0gZnVuY3Rpb24obmFtZSwgYmluZGluZ3MpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIE9iamVjdChiaW5kaW5ncykgIT09IGJpbmRpbmdzIHx8XG4gICAgICBhcmd1bWVudHMubGVuZ3RoICE9PSAyXG4gICAgKVxuICAgICAgdGhyb3cgJ2FkZEluZGV4OiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmIChfaW5kZXhlc1tuYW1lXSlcbiAgICAgIHRocm93ICdUaGUgaW5kZXggXCInICsgbmFtZSArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xuXG4gICAgdmFyIGs7XG5cbiAgICAvLyBTdG9yZSB0aGUgYmluZGluZ3M6XG4gICAgX2luZGV4ZXNbbmFtZV0gPSBiaW5kaW5ncztcblxuICAgIC8vIEF0dGFjaCB0aGUgYmluZGluZ3M6XG4gICAgZm9yIChrIGluIGJpbmRpbmdzKVxuICAgICAgaWYgKHR5cGVvZiBiaW5kaW5nc1trXSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ1RoZSBiaW5kaW5ncyBtdXN0IGJlIGZ1bmN0aW9ucy4nO1xuICAgICAgZWxzZVxuICAgICAgICBncmFwaC5hdHRhY2goaywgbmFtZSwgYmluZGluZ3Nba10pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGFkZHMgYSBub2RlIHRvIHRoZSBncmFwaC4gVGhlIG5vZGUgbXVzdCBiZSBhbiBvYmplY3QsIHdpdGggYVxuICAgKiBzdHJpbmcgdW5kZXIgdGhlIGtleSBcImlkXCIuIEV4Y2VwdCBmb3IgdGhpcywgaXQgaXMgcG9zc2libGUgdG8gYWRkIGFueVxuICAgKiBvdGhlciBhdHRyaWJ1dGUsIHRoYXQgd2lsbCBiZSBwcmVzZXJ2ZWQgYWxsIGFsb25nIHRoZSBtYW5pcHVsYXRpb25zLlxuICAgKlxuICAgKiBJZiB0aGUgZ3JhcGggb3B0aW9uIFwiY2xvbmVcIiBoYXMgYSB0cnV0aHkgdmFsdWUsIHRoZSBub2RlIHdpbGwgYmUgY2xvbmVkXG4gICAqIHdoZW4gYWRkZWQgdG8gdGhlIGdyYXBoLiBBbHNvLCBpZiB0aGUgZ3JhcGggb3B0aW9uIFwiaW1tdXRhYmxlXCIgaGFzIGFcbiAgICogdHJ1dGh5IHZhbHVlLCBpdHMgaWQgd2lsbCBiZSBkZWZpbmVkIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBub2RlIFRoZSBub2RlIHRvIGFkZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgIFRoZSBncmFwaCBpbnN0YW5jZS5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnYWRkTm9kZScsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBub2RlIGlzIGFuIG9iamVjdCBhbmQgaGFzIGFuIGlkOlxuICAgIGlmIChPYmplY3Qobm9kZSkgIT09IG5vZGUgfHwgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSlcbiAgICAgIHRocm93ICdhZGROb2RlOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmICh0eXBlb2Ygbm9kZS5pZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIG5vZGUuaWQgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgJ1RoZSBub2RlIG11c3QgaGF2ZSBhIHN0cmluZyBvciBudW1iZXIgaWQuJztcblxuICAgIGlmICh0aGlzLm5vZGVzSW5kZXhbbm9kZS5pZF0pXG4gICAgICB0aHJvdyAnVGhlIG5vZGUgXCInICsgbm9kZS5pZCArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xuXG4gICAgdmFyIGssXG4gICAgICAgIGlkID0gbm9kZS5pZCxcbiAgICAgICAgdmFsaWROb2RlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8vIENoZWNrIHRoZSBcImNsb25lXCIgb3B0aW9uOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKCdjbG9uZScpKSB7XG4gICAgICBmb3IgKGsgaW4gbm9kZSlcbiAgICAgICAgaWYgKGsgIT09ICdpZCcpXG4gICAgICAgICAgdmFsaWROb2RlW2tdID0gbm9kZVtrXTtcbiAgICB9IGVsc2VcbiAgICAgIHZhbGlkTm9kZSA9IG5vZGU7XG5cbiAgICAvLyBDaGVjayB0aGUgXCJpbW11dGFibGVcIiBvcHRpb246XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MoJ2ltbXV0YWJsZScpKVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkTm9kZSwgJ2lkJywge1xuICAgICAgICB2YWx1ZTogaWQsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIHZhbGlkTm9kZS5pZCA9IGlkO1xuXG4gICAgLy8gQWRkIGVtcHR5IGNvbnRhaW5lcnMgZm9yIGVkZ2VzIGluZGV4ZXM6XG4gICAgdGhpcy5pbk5laWdoYm9yc0luZGV4W2lkXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5vdXROZWlnaGJvcnNJbmRleFtpZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbaWRdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHRoaXMuaW5OZWlnaGJvcnNDb3VudFtpZF0gPSAwO1xuICAgIHRoaXMub3V0TmVpZ2hib3JzQ291bnRbaWRdID0gMDtcbiAgICB0aGlzLmFsbE5laWdoYm9yc0NvdW50W2lkXSA9IDA7XG5cbiAgICAvLyBBZGQgdGhlIG5vZGUgdG8gaW5kZXhlczpcbiAgICB0aGlzLm5vZGVzQXJyYXkucHVzaCh2YWxpZE5vZGUpO1xuICAgIHRoaXMubm9kZXNJbmRleFt2YWxpZE5vZGUuaWRdID0gdmFsaWROb2RlO1xuXG4gICAgLy8gUmV0dXJuIHRoZSBjdXJyZW50IGluc3RhbmNlOlxuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgYWRkcyBhbiBlZGdlIHRvIHRoZSBncmFwaC4gVGhlIGVkZ2UgbXVzdCBiZSBhbiBvYmplY3QsIHdpdGggYVxuICAgKiBzdHJpbmcgdW5kZXIgdGhlIGtleSBcImlkXCIsIGFuZCBzdHJpbmdzIHVuZGVyIHRoZSBrZXlzIFwic291cmNlXCIgYW5kXG4gICAqIFwidGFyZ2V0XCIgdGhhdCBkZXNpZ24gZXhpc3Rpbmcgbm9kZXMuIEV4Y2VwdCBmb3IgdGhpcywgaXQgaXMgcG9zc2libGUgdG9cbiAgICogYWRkIGFueSBvdGhlciBhdHRyaWJ1dGUsIHRoYXQgd2lsbCBiZSBwcmVzZXJ2ZWQgYWxsIGFsb25nIHRoZVxuICAgKiBtYW5pcHVsYXRpb25zLlxuICAgKlxuICAgKiBJZiB0aGUgZ3JhcGggb3B0aW9uIFwiY2xvbmVcIiBoYXMgYSB0cnV0aHkgdmFsdWUsIHRoZSBlZGdlIHdpbGwgYmUgY2xvbmVkXG4gICAqIHdoZW4gYWRkZWQgdG8gdGhlIGdyYXBoLiBBbHNvLCBpZiB0aGUgZ3JhcGggb3B0aW9uIFwiaW1tdXRhYmxlXCIgaGFzIGFcbiAgICogdHJ1dGh5IHZhbHVlLCBpdHMgaWQsIHNvdXJjZSBhbmQgdGFyZ2V0IHdpbGwgYmUgZGVmaW5lZCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gZWRnZSBUaGUgZWRnZSB0byBhZGQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICBUaGUgZ3JhcGggaW5zdGFuY2UuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ2FkZEVkZ2UnLCBmdW5jdGlvbihlZGdlKSB7XG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgZWRnZSBpcyBhbiBvYmplY3QgYW5kIGhhcyBhbiBpZDpcbiAgICBpZiAoT2JqZWN0KGVkZ2UpICE9PSBlZGdlIHx8IGFyZ3VtZW50cy5sZW5ndGggIT09IDEpXG4gICAgICB0aHJvdyAnYWRkRWRnZTogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAodHlwZW9mIGVkZ2UuaWQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBlZGdlLmlkICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93ICdUaGUgZWRnZSBtdXN0IGhhdmUgYSBzdHJpbmcgb3IgbnVtYmVyIGlkLic7XG5cbiAgICBpZiAoKHR5cGVvZiBlZGdlLnNvdXJjZSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGVkZ2Uuc291cmNlICE9PSAnbnVtYmVyJykgfHxcbiAgICAgICAgIXRoaXMubm9kZXNJbmRleFtlZGdlLnNvdXJjZV0pXG4gICAgICB0aHJvdyAnVGhlIGVkZ2Ugc291cmNlIG11c3QgaGF2ZSBhbiBleGlzdGluZyBub2RlIGlkLic7XG5cbiAgICBpZiAoKHR5cGVvZiBlZGdlLnRhcmdldCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGVkZ2UudGFyZ2V0ICE9PSAnbnVtYmVyJykgfHxcbiAgICAgICAgIXRoaXMubm9kZXNJbmRleFtlZGdlLnRhcmdldF0pXG4gICAgICB0aHJvdyAnVGhlIGVkZ2UgdGFyZ2V0IG11c3QgaGF2ZSBhbiBleGlzdGluZyBub2RlIGlkLic7XG5cbiAgICBpZiAodGhpcy5lZGdlc0luZGV4W2VkZ2UuaWRdKVxuICAgICAgdGhyb3cgJ1RoZSBlZGdlIFwiJyArIGVkZ2UuaWQgKyAnXCIgYWxyZWFkeSBleGlzdHMuJztcblxuICAgIHZhciBrLFxuICAgICAgICB2YWxpZEVkZ2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIFwiY2xvbmVcIiBvcHRpb246XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MoJ2Nsb25lJykpIHtcbiAgICAgIGZvciAoayBpbiBlZGdlKVxuICAgICAgICBpZiAoayAhPT0gJ2lkJyAmJiBrICE9PSAnc291cmNlJyAmJiBrICE9PSAndGFyZ2V0JylcbiAgICAgICAgICB2YWxpZEVkZ2Vba10gPSBlZGdlW2tdO1xuICAgIH0gZWxzZVxuICAgICAgdmFsaWRFZGdlID0gZWRnZTtcblxuICAgIC8vIENoZWNrIHRoZSBcImltbXV0YWJsZVwiIG9wdGlvbjpcbiAgICBpZiAodGhpcy5zZXR0aW5ncygnaW1tdXRhYmxlJykpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZEVkZ2UsICdpZCcsIHtcbiAgICAgICAgdmFsdWU6IGVkZ2UuaWQsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRFZGdlLCAnc291cmNlJywge1xuICAgICAgICB2YWx1ZTogZWRnZS5zb3VyY2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRFZGdlLCAndGFyZ2V0Jywge1xuICAgICAgICB2YWx1ZTogZWRnZS50YXJnZXQsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZEVkZ2UuaWQgPSBlZGdlLmlkO1xuICAgICAgdmFsaWRFZGdlLnNvdXJjZSA9IGVkZ2Uuc291cmNlO1xuICAgICAgdmFsaWRFZGdlLnRhcmdldCA9IGVkZ2UudGFyZ2V0O1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZWRnZSB0byBpbmRleGVzOlxuICAgIHRoaXMuZWRnZXNBcnJheS5wdXNoKHZhbGlkRWRnZSk7XG4gICAgdGhpcy5lZGdlc0luZGV4W3ZhbGlkRWRnZS5pZF0gPSB2YWxpZEVkZ2U7XG5cbiAgICBpZiAoIXRoaXMuaW5OZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2UudGFyZ2V0XVt2YWxpZEVkZ2Uuc291cmNlXSlcbiAgICAgIHRoaXMuaW5OZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2UudGFyZ2V0XVt2YWxpZEVkZ2Uuc291cmNlXSA9XG4gICAgICAgIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5pbk5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS5pZF0gPVxuICAgICAgdmFsaWRFZGdlO1xuXG4gICAgaWYgKCF0aGlzLm91dE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdKVxuICAgICAgdGhpcy5vdXROZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2Uuc291cmNlXVt2YWxpZEVkZ2UudGFyZ2V0XSA9XG4gICAgICAgIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5vdXROZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2Uuc291cmNlXVt2YWxpZEVkZ2UudGFyZ2V0XVt2YWxpZEVkZ2UuaWRdID1cbiAgICAgIHZhbGlkRWRnZTtcblxuICAgIGlmICghdGhpcy5hbGxOZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2Uuc291cmNlXVt2YWxpZEVkZ2UudGFyZ2V0XSlcbiAgICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLnRhcmdldF0gPVxuICAgICAgICBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLmlkXSA9XG4gICAgICB2YWxpZEVkZ2U7XG5cbiAgICBpZiAodmFsaWRFZGdlLnRhcmdldCAhPT0gdmFsaWRFZGdlLnNvdXJjZSkge1xuICAgICAgaWYgKCF0aGlzLmFsbE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5zb3VyY2VdKVxuICAgICAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5zb3VyY2VdID1cbiAgICAgICAgICBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2UudGFyZ2V0XVt2YWxpZEVkZ2Uuc291cmNlXVt2YWxpZEVkZ2UuaWRdID1cbiAgICAgICAgdmFsaWRFZGdlO1xuICAgIH1cblxuICAgIC8vIEtlZXAgY291bnRzIHVwIHRvIGRhdGU6XG4gICAgdGhpcy5pbk5laWdoYm9yc0NvdW50W3ZhbGlkRWRnZS50YXJnZXRdKys7XG4gICAgdGhpcy5vdXROZWlnaGJvcnNDb3VudFt2YWxpZEVkZ2Uuc291cmNlXSsrO1xuICAgIHRoaXMuYWxsTmVpZ2hib3JzQ291bnRbdmFsaWRFZGdlLnRhcmdldF0rKztcbiAgICB0aGlzLmFsbE5laWdoYm9yc0NvdW50W3ZhbGlkRWRnZS5zb3VyY2VdKys7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGRyb3BzIGEgbm9kZSBmcm9tIHRoZSBncmFwaC4gSXQgYWxzbyByZW1vdmVzIGVhY2ggZWRnZSB0aGF0IGlzXG4gICAqIGJvdW5kIHRvIGl0LCB0aHJvdWdoIHRoZSBkcm9wRWRnZSBtZXRob2QuIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgbm9kZVxuICAgKiBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZCBUaGUgbm9kZSBpZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICBUaGUgZ3JhcGggaW5zdGFuY2UuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ2Ryb3BOb2RlJywgZnVuY3Rpb24oaWQpIHtcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBhcmd1bWVudHMgYXJlIHZhbGlkOlxuICAgIGlmICgodHlwZW9mIGlkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgaWQgIT09ICdudW1iZXInKSB8fFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoICE9PSAxKVxuICAgICAgdGhyb3cgJ2Ryb3BOb2RlOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmICghdGhpcy5ub2Rlc0luZGV4W2lkXSlcbiAgICAgIHRocm93ICdUaGUgbm9kZSBcIicgKyBpZCArICdcIiBkb2VzIG5vdCBleGlzdC4nO1xuXG4gICAgdmFyIGksIGssIGw7XG5cbiAgICAvLyBSZW1vdmUgdGhlIG5vZGUgZnJvbSBpbmRleGVzOlxuICAgIGRlbGV0ZSB0aGlzLm5vZGVzSW5kZXhbaWRdO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLm5vZGVzQXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaWYgKHRoaXMubm9kZXNBcnJheVtpXS5pZCA9PT0gaWQpIHtcbiAgICAgICAgdGhpcy5ub2Rlc0FycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAvLyBSZW1vdmUgcmVsYXRlZCBlZGdlczpcbiAgICBmb3IgKGkgPSB0aGlzLmVkZ2VzQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICBpZiAodGhpcy5lZGdlc0FycmF5W2ldLnNvdXJjZSA9PT0gaWQgfHwgdGhpcy5lZGdlc0FycmF5W2ldLnRhcmdldCA9PT0gaWQpXG4gICAgICAgIHRoaXMuZHJvcEVkZ2UodGhpcy5lZGdlc0FycmF5W2ldLmlkKTtcblxuICAgIC8vIFJlbW92ZSByZWxhdGVkIGVkZ2UgaW5kZXhlczpcbiAgICBkZWxldGUgdGhpcy5pbk5laWdoYm9yc0luZGV4W2lkXTtcbiAgICBkZWxldGUgdGhpcy5vdXROZWlnaGJvcnNJbmRleFtpZF07XG4gICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbaWRdO1xuXG4gICAgZGVsZXRlIHRoaXMuaW5OZWlnaGJvcnNDb3VudFtpZF07XG4gICAgZGVsZXRlIHRoaXMub3V0TmVpZ2hib3JzQ291bnRbaWRdO1xuICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0NvdW50W2lkXTtcblxuICAgIGZvciAoayBpbiB0aGlzLm5vZGVzSW5kZXgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzSW5kZXhba11baWRdO1xuICAgICAgZGVsZXRlIHRoaXMub3V0TmVpZ2hib3JzSW5kZXhba11baWRdO1xuICAgICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhba11baWRdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgZHJvcHMgYW4gZWRnZSBmcm9tIHRoZSBncmFwaC4gQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBlZGdlXG4gICAqIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIFRoZSBlZGdlIGlkLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIFRoZSBncmFwaCBpbnN0YW5jZS5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnZHJvcEVkZ2UnLCBmdW5jdGlvbihpZCkge1xuICAgIC8vIENoZWNrIHRoYXQgdGhlIGFyZ3VtZW50cyBhcmUgdmFsaWQ6XG4gICAgaWYgKCh0eXBlb2YgaWQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHx8XG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggIT09IDEpXG4gICAgICB0aHJvdyAnZHJvcEVkZ2U6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKCF0aGlzLmVkZ2VzSW5kZXhbaWRdKVxuICAgICAgdGhyb3cgJ1RoZSBlZGdlIFwiJyArIGlkICsgJ1wiIGRvZXMgbm90IGV4aXN0Lic7XG5cbiAgICB2YXIgaSwgbCwgZWRnZTtcblxuICAgIC8vIFJlbW92ZSB0aGUgZWRnZSBmcm9tIGluZGV4ZXM6XG4gICAgZWRnZSA9IHRoaXMuZWRnZXNJbmRleFtpZF07XG4gICAgZGVsZXRlIHRoaXMuZWRnZXNJbmRleFtpZF07XG4gICAgZm9yIChpID0gMCwgbCA9IHRoaXMuZWRnZXNBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpZiAodGhpcy5lZGdlc0FycmF5W2ldLmlkID09PSBpZCkge1xuICAgICAgICB0aGlzLmVkZ2VzQXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzSW5kZXhbZWRnZS50YXJnZXRdW2VkZ2Uuc291cmNlXVtlZGdlLmlkXTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuaW5OZWlnaGJvcnNJbmRleFtlZGdlLnRhcmdldF1bZWRnZS5zb3VyY2VdKS5sZW5ndGgpXG4gICAgICBkZWxldGUgdGhpcy5pbk5laWdoYm9yc0luZGV4W2VkZ2UudGFyZ2V0XVtlZGdlLnNvdXJjZV07XG5cbiAgICBkZWxldGUgdGhpcy5vdXROZWlnaGJvcnNJbmRleFtlZGdlLnNvdXJjZV1bZWRnZS50YXJnZXRdW2VkZ2UuaWRdO1xuICAgIGlmICghT2JqZWN0LmtleXModGhpcy5vdXROZWlnaGJvcnNJbmRleFtlZGdlLnNvdXJjZV1bZWRnZS50YXJnZXRdKS5sZW5ndGgpXG4gICAgICBkZWxldGUgdGhpcy5vdXROZWlnaGJvcnNJbmRleFtlZGdlLnNvdXJjZV1bZWRnZS50YXJnZXRdO1xuXG4gICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbZWRnZS5zb3VyY2VdW2VkZ2UudGFyZ2V0XVtlZGdlLmlkXTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbZWRnZS5zb3VyY2VdW2VkZ2UudGFyZ2V0XSkubGVuZ3RoKVxuICAgICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbZWRnZS5zb3VyY2VdW2VkZ2UudGFyZ2V0XTtcblxuICAgIGlmIChlZGdlLnRhcmdldCAhPT0gZWRnZS5zb3VyY2UpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4W2VkZ2UudGFyZ2V0XVtlZGdlLnNvdXJjZV1bZWRnZS5pZF07XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbZWRnZS50YXJnZXRdW2VkZ2Uuc291cmNlXSkubGVuZ3RoKVxuICAgICAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnRhcmdldF1bZWRnZS5zb3VyY2VdO1xuICAgIH1cblxuICAgIHRoaXMuaW5OZWlnaGJvcnNDb3VudFtlZGdlLnRhcmdldF0tLTtcbiAgICB0aGlzLm91dE5laWdoYm9yc0NvdW50W2VkZ2Uuc291cmNlXS0tO1xuICAgIHRoaXMuYWxsTmVpZ2hib3JzQ291bnRbZWRnZS5zb3VyY2VdLS07XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNDb3VudFtlZGdlLnRhcmdldF0tLTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgZGVzdHJveXMgdGhlIGN1cnJlbnQgaW5zdGFuY2UuIEl0IGJhc2ljYWxseSBlbXB0aWVzIGVhY2ggaW5kZXhcbiAgICogYW5kIG1ldGhvZHMgYXR0YWNoZWQgdG8gdGhlIGdyYXBoLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdraWxsJywgZnVuY3Rpb24oKSB7XG4gICAgLy8gRGVsZXRlIGFycmF5czpcbiAgICB0aGlzLm5vZGVzQXJyYXkubGVuZ3RoID0gMDtcbiAgICB0aGlzLmVkZ2VzQXJyYXkubGVuZ3RoID0gMDtcbiAgICBkZWxldGUgdGhpcy5ub2Rlc0FycmF5O1xuICAgIGRlbGV0ZSB0aGlzLmVkZ2VzQXJyYXk7XG5cbiAgICAvLyBEZWxldGUgaW5kZXhlczpcbiAgICBkZWxldGUgdGhpcy5ub2Rlc0luZGV4O1xuICAgIGRlbGV0ZSB0aGlzLmVkZ2VzSW5kZXg7XG4gICAgZGVsZXRlIHRoaXMuaW5OZWlnaGJvcnNJbmRleDtcbiAgICBkZWxldGUgdGhpcy5vdXROZWlnaGJvcnNJbmRleDtcbiAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleDtcbiAgICBkZWxldGUgdGhpcy5pbk5laWdoYm9yc0NvdW50O1xuICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0NvdW50O1xuICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0NvdW50O1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgZW1wdGllcyB0aGUgbm9kZXMgYW5kIGVkZ2VzIGFycmF5cywgYXMgd2VsbCBhcyB0aGUgZGlmZmVyZW50XG4gICAqIGluZGV4ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdjbGVhcicsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubm9kZXNBcnJheS5sZW5ndGggPSAwO1xuICAgIHRoaXMuZWRnZXNBcnJheS5sZW5ndGggPSAwO1xuXG4gICAgLy8gRHVlIHRvIEdDIGlzc3VlcywgSSBwcmVmZXIgbm90IHRvIGNyZWF0ZSBuZXcgb2JqZWN0LiBUaGVzZSBvYmplY3RzIGFyZVxuICAgIC8vIG9ubHkgYXZhaWxhYmxlIGZyb20gdGhlIG1ldGhvZHMgYW5kIGF0dGFjaGVkIGZ1bmN0aW9ucywgYnV0IHN0aWxsLCBpdCBpc1xuICAgIC8vIGJldHRlciB0byBwcmV2ZW50IGdob3N0IHJlZmVyZW5jZXMgdG8gdW5yZWxldmFudCBkYXRhLi4uXG4gICAgX19lbXB0eU9iamVjdCh0aGlzLm5vZGVzSW5kZXgpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5lZGdlc0luZGV4KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMubm9kZXNJbmRleCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLmluTmVpZ2hib3JzSW5kZXgpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5vdXROZWlnaGJvcnNJbmRleCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLmFsbE5laWdoYm9yc0luZGV4KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMuaW5OZWlnaGJvcnNDb3VudCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLm91dE5laWdoYm9yc0NvdW50KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMuYWxsTmVpZ2hib3JzQ291bnQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZWFkcyBhbiBvYmplY3QgYW5kIGFkZHMgdGhlIG5vZGVzIGFuZCBlZGdlcywgdGhyb3VnaCB0aGVcbiAgICogcHJvcGVyIG1ldGhvZHMgXCJhZGROb2RlXCIgYW5kIFwiYWRkRWRnZVwiLlxuICAgKlxuICAgKiBIZXJlIGlzIGFuIGV4YW1wbGU6XG4gICAqXG4gICAqICA+IHZhciBteUdyYXBoID0gbmV3IGdyYXBoKCk7XG4gICAqICA+IG15R3JhcGgucmVhZCh7XG4gICAqICA+ICAgbm9kZXM6IFtcbiAgICogID4gICAgIHsgaWQ6ICduMCcgfSxcbiAgICogID4gICAgIHsgaWQ6ICduMScgfVxuICAgKiAgPiAgIF0sXG4gICAqICA+ICAgZWRnZXM6IFtcbiAgICogID4gICAgIHtcbiAgICogID4gICAgICAgaWQ6ICdlMCcsXG4gICAqICA+ICAgICAgIHNvdXJjZTogJ24wJyxcbiAgICogID4gICAgICAgdGFyZ2V0OiAnbjEnXG4gICAqICA+ICAgICB9XG4gICAqICA+ICAgXVxuICAgKiAgPiB9KTtcbiAgICogID5cbiAgICogID4gY29uc29sZS5sb2coXG4gICAqICA+ICAgbXlHcmFwaC5ub2RlcygpLmxlbmd0aCxcbiAgICogID4gICBteUdyYXBoLmVkZ2VzKCkubGVuZ3RoXG4gICAqICA+ICk7IC8vIG91dHB1dHMgMiAxXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gZyBUaGUgZ3JhcGggb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgVGhlIGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdyZWFkJywgZnVuY3Rpb24oZykge1xuICAgIHZhciBpLFxuICAgICAgICBhLFxuICAgICAgICBsO1xuXG4gICAgYSA9IGcubm9kZXMgfHwgW107XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgdGhpcy5hZGROb2RlKGFbaV0pO1xuXG4gICAgYSA9IGcuZWRnZXMgfHwgW107XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgdGhpcy5hZGRFZGdlKGFbaV0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgcmV0dXJucyBvbmUgb3Igc2V2ZXJhbCBub2RlcywgZGVwZW5kaW5nIG9uIGhvdyBpdCBpcyBjYWxsZWQuXG4gICAqXG4gICAqIFRvIGdldCB0aGUgYXJyYXkgb2Ygbm9kZXMsIGNhbGwgXCJub2Rlc1wiIHdpdGhvdXQgYXJndW1lbnQuIFRvIGdldCBhXG4gICAqIHNwZWNpZmljIG5vZGUsIGNhbGwgaXQgd2l0aCB0aGUgaWQgb2YgdGhlIG5vZGUuIFRoZSBnZXQgbXVsdGlwbGUgbm9kZSxcbiAgICogY2FsbCBpdCB3aXRoIGFuIGFycmF5IG9mIGlkcywgYW5kIGl0IHdpbGwgcmV0dXJuIHRoZSBhcnJheSBvZiBub2RlcywgaW5cbiAgICogdGhlIHNhbWUgb3JkZXIuXG4gICAqXG4gICAqIEBwYXJhbSAgez8oc3RyaW5nfGFycmF5KX0gdiBFdmVudHVhbGx5IG9uZSBpZCwgYW4gYXJyYXkgb2YgaWRzLlxuICAgKiBAcmV0dXJuIHtvYmplY3R8YXJyYXl9ICAgICAgVGhlIHJlbGF0ZWQgbm9kZSBvciBhcnJheSBvZiBub2Rlcy5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnbm9kZXMnLCBmdW5jdGlvbih2KSB7XG4gICAgLy8gQ2xvbmUgdGhlIGFycmF5IG9mIG5vZGVzIGFuZCByZXR1cm4gaXQ6XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgcmV0dXJuIHRoaXMubm9kZXNBcnJheS5zbGljZSgwKTtcblxuICAgIC8vIFJldHVybiB0aGUgcmVsYXRlZCBub2RlOlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInKSlcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzSW5kZXhbdl07XG5cbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHJlbGF0ZWQgbm9kZTpcbiAgICBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICApIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgYSA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdi5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICh0eXBlb2YgdltpXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZbaV0gPT09ICdudW1iZXInKVxuICAgICAgICAgIGEucHVzaCh0aGlzLm5vZGVzSW5kZXhbdltpXV0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgJ25vZGVzOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdGhyb3cgJ25vZGVzOiBXcm9uZyBhcmd1bWVudHMuJztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kcyByZXR1cm5zIHRoZSBkZWdyZWUgb2Ygb25lIG9yIHNldmVyYWwgbm9kZXMsIGRlcGVuZGluZyBvbiBob3dcbiAgICogaXQgaXMgY2FsbGVkLiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGdldCBpbmNvbWluZyBvciBvdXRjb21pbmcgZGVncmVlc1xuICAgKiBpbnN0ZWFkIGJ5IHNwZWNpZnlpbmcgJ2luJyBvciAnb3V0JyBhcyBhIHNlY29uZCBhcmd1bWVudC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfGFycmF5fSB2ICAgICBPbmUgaWQsIGFuIGFycmF5IG9mIGlkcy5cbiAgICogQHBhcmFtICB7P3N0cmluZ30gICAgICB3aGljaCBXaGljaCBkZWdyZWUgaXMgcmVxdWlyZWQuIFZhbHVlcyBhcmUgJ2luJyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3V0JywgYW5kIGJ5IGRlZmF1bHQgdGhlIG5vcm1hbCBkZWdyZWUuXG4gICAqIEByZXR1cm4ge251bWJlcnxhcnJheX0gICAgICAgVGhlIHJlbGF0ZWQgZGVncmVlIG9yIGFycmF5IG9mIGRlZ3JlZXMuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ2RlZ3JlZScsIGZ1bmN0aW9uKHYsIHdoaWNoKSB7XG4gICAgLy8gQ2hlY2sgd2hpY2ggZGVncmVlIGlzIHJlcXVpcmVkOlxuICAgIHdoaWNoID0ge1xuICAgICAgJ2luJzogdGhpcy5pbk5laWdoYm9yc0NvdW50LFxuICAgICAgJ291dCc6IHRoaXMub3V0TmVpZ2hib3JzQ291bnRcbiAgICB9W3doaWNoIHx8ICcnXSB8fCB0aGlzLmFsbE5laWdoYm9yc0NvdW50O1xuXG4gICAgLy8gUmV0dXJuIHRoZSByZWxhdGVkIG5vZGU6XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcicpXG4gICAgICByZXR1cm4gd2hpY2hbdl07XG5cbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHJlbGF0ZWQgbm9kZTpcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBsLFxuICAgICAgICAgIGEgPSBbXTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IHYubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAodHlwZW9mIHZbaV0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2W2ldID09PSAnbnVtYmVyJylcbiAgICAgICAgICBhLnB1c2god2hpY2hbdltpXV0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgJ2RlZ3JlZTogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHRocm93ICdkZWdyZWU6IFdyb25nIGFyZ3VtZW50cy4nO1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2RzIHJldHVybnMgb25lIG9yIHNldmVyYWwgZWRnZXMsIGRlcGVuZGluZyBvbiBob3cgaXQgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBUbyBnZXQgdGhlIGFycmF5IG9mIGVkZ2VzLCBjYWxsIFwiZWRnZXNcIiB3aXRob3V0IGFyZ3VtZW50LiBUbyBnZXQgYVxuICAgKiBzcGVjaWZpYyBlZGdlLCBjYWxsIGl0IHdpdGggdGhlIGlkIG9mIHRoZSBlZGdlLiBUaGUgZ2V0IG11bHRpcGxlIGVkZ2UsXG4gICAqIGNhbGwgaXQgd2l0aCBhbiBhcnJheSBvZiBpZHMsIGFuZCBpdCB3aWxsIHJldHVybiB0aGUgYXJyYXkgb2YgZWRnZXMsIGluXG4gICAqIHRoZSBzYW1lIG9yZGVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/KHN0cmluZ3xhcnJheSl9IHYgRXZlbnR1YWxseSBvbmUgaWQsIGFuIGFycmF5IG9mIGlkcy5cbiAgICogQHJldHVybiB7b2JqZWN0fGFycmF5fSAgICAgIFRoZSByZWxhdGVkIGVkZ2Ugb3IgYXJyYXkgb2YgZWRnZXMuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ2VkZ2VzJywgZnVuY3Rpb24odikge1xuICAgIC8vIENsb25lIHRoZSBhcnJheSBvZiBlZGdlcyBhbmQgcmV0dXJuIGl0OlxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgIHJldHVybiB0aGlzLmVkZ2VzQXJyYXkuc2xpY2UoMCk7XG5cbiAgICAvLyBSZXR1cm4gdGhlIHJlbGF0ZWQgZWRnZTpcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAodHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJykpXG4gICAgICByZXR1cm4gdGhpcy5lZGdlc0luZGV4W3ZdO1xuXG4gICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIHRoZSByZWxhdGVkIGVkZ2U6XG4gICAgaWYgKFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBsLFxuICAgICAgICAgIGEgPSBbXTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IHYubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAodHlwZW9mIHZbaV0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2W2ldID09PSAnbnVtYmVyJylcbiAgICAgICAgICBhLnB1c2godGhpcy5lZGdlc0luZGV4W3ZbaV1dKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93ICdlZGdlczogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHRocm93ICdlZGdlczogV3JvbmcgYXJndW1lbnRzLic7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiBzaWdtYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzaWdtYS5jbGFzc2VzID0gc2lnbWEuY2xhc3NlcyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHNpZ21hLmNsYXNzZXMuZ3JhcGggPSBncmFwaDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBncmFwaDtcbiAgICBleHBvcnRzLmdyYXBoID0gZ3JhcGg7XG4gIH0gZWxzZVxuICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNsYXNzZXMnKTtcblxuICAvKipcbiAgICogVGhlIGNhbWVyYSBjb25zdHJ1Y3Rvci4gSXQganVzdCBpbml0aWFsaXplcyBpdHMgYXR0cmlidXRlcyBhbmQgbWV0aG9kcy5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICBpZCAgICAgICBUaGUgaWQuXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuZ3JhcGh9ICBncmFwaCAgICBUaGUgZ3JhcGguXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSAgICAgIG9wdGlvbnMgIEV2ZW50dWFsbHkgc29tZSBvdmVycmlkaW5nIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge2NhbWVyYX0gICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgZnJlc2ggbmV3IGNhbWVyYSBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhID0gZnVuY3Rpb24oaWQsIGdyYXBoLCBzZXR0aW5ncywgb3B0aW9ucykge1xuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2dyYXBoJywge1xuICAgICAgdmFsdWU6IGdyYXBoXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZCcsIHtcbiAgICAgIHZhbHVlOiBpZFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVhZFByZWZpeCcsIHtcbiAgICAgIHZhbHVlOiAncmVhZF9jYW0nICsgaWQgKyAnOidcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3ByZWZpeCcsIHtcbiAgICAgIHZhbHVlOiAnY2FtJyArIGlkICsgJzonXG4gICAgfSk7XG5cbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5yYXRpbyA9IDE7XG4gICAgdGhpcy5hbmdsZSA9IDA7XG4gICAgdGhpcy5pc0FuaW1hdGVkID0gZmFsc2U7XG4gICAgdGhpcy5zZXR0aW5ncyA9ICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucykgP1xuICAgICAgc2V0dGluZ3MuZW1iZWRPYmplY3Qob3B0aW9ucykgOlxuICAgICAgc2V0dGluZ3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNhbWVyYSBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBjb29yZGluYXRlcyBUaGUgbmV3IGNvb3JkaW5hdGVzIG9iamVjdC5cbiAgICogQHJldHVybiB7Y2FtZXJhfSAgICAgICAgICAgICBSZXR1cm5zIHRoZSBjYW1lcmEuXG4gICAqL1xuICBzaWdtYS5jbGFzc2VzLmNhbWVyYS5wcm90b3R5cGUuZ29UbyA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgaWYgKCF0aGlzLnNldHRpbmdzKCdlbmFibGVDYW1lcmEnKSlcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGMgPSBjb29yZGluYXRlcyB8fCB7fSxcbiAgICAgICAga2V5cyA9IFsneCcsICd5JywgJ3JhdGlvJywgJ2FuZ2xlJ107XG5cbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpZiAoY1trZXlzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY1trZXlzW2ldXSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGNba2V5c1tpXV0pKVxuICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBjW2tleXNbaV1dO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgJ1ZhbHVlIGZvciBcIicgKyBrZXlzW2ldICsgJ1wiIGlzIG5vdCBhIG51bWJlci4nO1xuICAgICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdjb29yZGluYXRlc1VwZGF0ZWQnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgdGFrZXMgYSBncmFwaCBhbmQgY29tcHV0ZXMgZm9yIGVhY2ggbm9kZSBhbmQgZWRnZXMgaXRzXG4gICAqIGNvb3JkaW5hdGVzIHJlbGF0aXZlbHkgdG8gdGhlIGNlbnRlciBvZiB0aGUgY2FtZXJhLiBCYXNpY2FsbHksIGl0IHdpbGxcbiAgICogY29tcHV0ZSB0aGUgY29vcmRpbmF0ZXMgdGhhdCB3aWxsIGJlIHVzZWQgYnkgdGhlIGdyYXBoaWMgcmVuZGVyZXJzLlxuICAgKlxuICAgKiBTaW5jZSBpdCBzaG91bGQgYmUgcG9zc2libGUgdG8gdXNlIGRpZmZlcmVudCBjYW1lcmFzIGFuZCBkaWZmZXJlbnRcbiAgICogcmVuZGVyZXJzLCBpdCBpcyBwb3NzaWJsZSB0byBzcGVjaWZ5IGEgcHJlZml4IHRvIHB1dCBiZWZvcmUgdGhlIG5ld1xuICAgKiBjb29yZGluYXRlcyAodG8gZ2V0IHNvbWV0aGluZyBsaWtlIFwibm9kZS5jYW1lcmExX3hcIilcbiAgICpcbiAgICogQHBhcmFtICB7P3N0cmluZ30gcmVhZCAgICBUaGUgcHJlZml4IG9mIHRoZSBjb29yZGluYXRlcyB0byByZWFkLlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSB3cml0ZSAgIFRoZSBwcmVmaXggb2YgdGhlIGNvb3JkaW5hdGVzIHRvIHdyaXRlLlxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSBvcHRpb25zIEV2ZW50dWFsbHkgYW4gb2JqZWN0IG9mIG9wdGlvbnMuIFRob3NlIGNhbiBiZTpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgcmVzdHJpY3RlZCBub2RlcyBhcnJheS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgcmVzdHJpY3RlZCBlZGdlcyBhcnJheS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgd2lkdGguXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBBIGhlaWdodC5cbiAgICogQHJldHVybiB7Y2FtZXJhfSAgICAgICAgUmV0dXJucyB0aGUgY2FtZXJhLlxuICAgKi9cbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmFwcGx5VmlldyA9IGZ1bmN0aW9uKHJlYWQsIHdyaXRlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgd3JpdGUgPSB3cml0ZSAhPT0gdW5kZWZpbmVkID8gd3JpdGUgOiB0aGlzLnByZWZpeDtcbiAgICByZWFkID0gcmVhZCAhPT0gdW5kZWZpbmVkID8gcmVhZCA6IHRoaXMucmVhZFByZWZpeDtcblxuICAgIHZhciBub2RlcyA9IG9wdGlvbnMubm9kZXMgfHwgdGhpcy5ncmFwaC5ub2RlcygpLFxuICAgICAgICBlZGdlcyA9IG9wdGlvbnMuZWRnZXMgfHwgdGhpcy5ncmFwaC5lZGdlcygpO1xuXG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHJlbENvcyA9IE1hdGguY29zKHRoaXMuYW5nbGUpIC8gdGhpcy5yYXRpbyxcbiAgICAgICAgcmVsU2luID0gTWF0aC5zaW4odGhpcy5hbmdsZSkgLyB0aGlzLnJhdGlvLFxuICAgICAgICBub2RlUmF0aW8gPSBNYXRoLnBvdyh0aGlzLnJhdGlvLCB0aGlzLnNldHRpbmdzKCdub2Rlc1Bvd1JhdGlvJykpLFxuICAgICAgICBlZGdlUmF0aW8gPSBNYXRoLnBvdyh0aGlzLnJhdGlvLCB0aGlzLnNldHRpbmdzKCdlZGdlc1Bvd1JhdGlvJykpLFxuICAgICAgICB4T2Zmc2V0ID0gKG9wdGlvbnMud2lkdGggfHwgMCkgLyAyIC0gdGhpcy54ICogcmVsQ29zIC0gdGhpcy55ICogcmVsU2luLFxuICAgICAgICB5T2Zmc2V0ID0gKG9wdGlvbnMuaGVpZ2h0IHx8IDApIC8gMiAtIHRoaXMueSAqIHJlbENvcyArIHRoaXMueCAqIHJlbFNpbjtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIG5vZGVbd3JpdGUgKyAneCddID1cbiAgICAgICAgKG5vZGVbcmVhZCArICd4J10gfHwgMCkgKiByZWxDb3MgK1xuICAgICAgICAobm9kZVtyZWFkICsgJ3knXSB8fCAwKSAqIHJlbFNpbiArXG4gICAgICAgIHhPZmZzZXQ7XG4gICAgICBub2RlW3dyaXRlICsgJ3knXSA9XG4gICAgICAgIChub2RlW3JlYWQgKyAneSddIHx8IDApICogcmVsQ29zIC1cbiAgICAgICAgKG5vZGVbcmVhZCArICd4J10gfHwgMCkgKiByZWxTaW4gK1xuICAgICAgICB5T2Zmc2V0O1xuICAgICAgbm9kZVt3cml0ZSArICdzaXplJ10gPVxuICAgICAgICAobm9kZVtyZWFkICsgJ3NpemUnXSB8fCAwKSAvXG4gICAgICAgIG5vZGVSYXRpbztcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gZWRnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBlZGdlc1tpXVt3cml0ZSArICdzaXplJ10gPVxuICAgICAgICAoZWRnZXNbaV1bcmVhZCArICdzaXplJ10gfHwgMCkgL1xuICAgICAgICBlZGdlUmF0aW87XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gY29udmVydHMgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgZnJvbSB0aGUgZnJhbWUgb2YgdGhlXG4gICAqIGNhbWVyYSB0byB0aGUgZnJhbWUgb2YgdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgaW4gdGhlIGZyYW1lIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgY2FtZXJhLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgaW4gdGhlIGZyYW1lIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgY2FtZXJhLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgVGhlIHBvaW50IGNvb3JkaW5hdGVzIGluIHRoZSBmcmFtZSBvZiB0aGUgZ3JhcGguXG4gICAqL1xuICBzaWdtYS5jbGFzc2VzLmNhbWVyYS5wcm90b3R5cGUuZ3JhcGhQb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHksIHZlY3Rvcikge1xuICAgIHZhciBYID0gMCxcbiAgICAgICAgWSA9IDAsXG4gICAgICAgIGNvcyA9IE1hdGguY29zKHRoaXMuYW5nbGUpLFxuICAgICAgICBzaW4gPSBNYXRoLnNpbih0aGlzLmFuZ2xlKTtcblxuICAgIC8vIFJldmVydCB0aGUgb3JpZ2luIGRpZmZlcmVudGlhbCB2ZWN0b3I6XG4gICAgaWYgKCF2ZWN0b3IpIHtcbiAgICAgIFggPSAtICh0aGlzLnggKiBjb3MgKyB0aGlzLnkgKiBzaW4pIC8gdGhpcy5yYXRpbztcbiAgICAgIFkgPSAtICh0aGlzLnkgKiBjb3MgLSB0aGlzLnggKiBzaW4pIC8gdGhpcy5yYXRpbztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogKHggKiBjb3MgKyB5ICogc2luKSAvIHRoaXMucmF0aW8gKyBYLFxuICAgICAgeTogKHkgKiBjb3MgLSB4ICogc2luKSAvIHRoaXMucmF0aW8gKyBZXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBmcm9tIHRoZSBmcmFtZSBvZiB0aGVcbiAgICogZ3JhcGggdG8gdGhlIGZyYW1lIG9mIHRoZSBjYW1lcmEuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBpbiB0aGUgZnJhbWUgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICBncmFwaC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IGluIHRoZSBmcmFtZSBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgIGdyYXBoLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgVGhlIHBvaW50IGNvb3JkaW5hdGVzIGluIHRoZSBmcmFtZSBvZiB0aGUgY2FtZXJhLlxuICAgKi9cbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmNhbWVyYVBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSwgdmVjdG9yKSB7XG4gICAgdmFyIFggPSAwLFxuICAgICAgICBZID0gMCxcbiAgICAgICAgY29zID0gTWF0aC5jb3ModGhpcy5hbmdsZSksXG4gICAgICAgIHNpbiA9IE1hdGguc2luKHRoaXMuYW5nbGUpO1xuXG4gICAgLy8gUmV2ZXJ0IHRoZSBvcmlnaW4gZGlmZmVyZW50aWFsIHZlY3RvcjpcbiAgICBpZiAoIXZlY3Rvcikge1xuICAgICAgWCA9IC0gKHRoaXMueCAqIGNvcyArIHRoaXMueSAqIHNpbikgLyB0aGlzLnJhdGlvO1xuICAgICAgWSA9IC0gKHRoaXMueSAqIGNvcyAtIHRoaXMueCAqIHNpbikgLyB0aGlzLnJhdGlvO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4OiAoKHggLSBYKSAqIGNvcyAtICh5IC0gWSkgKiBzaW4pICogdGhpcy5yYXRpbyxcbiAgICAgIHk6ICgoeSAtIFkpICogY29zICsgKHggLSBYKSAqIHNpbikgKiB0aGlzLnJhdGlvXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIHRoZSBjYW1lcmEuIFRoaXMgaXNcbiAgICogZXNwZWNpYWxseSB1c2VmdWwgdG8gYXBwbHkgdGhlIGNhbWVyYSB2aWV3IGRpcmVjdGx5IGluIHNoYWRlcnMsIGluIGNhc2Ugb2ZcbiAgICogV2ViR0wgcmVuZGVyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHthcnJheX0gVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5nZXRNYXRyaXggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NhbGUgPSBzaWdtYS51dGlscy5tYXRyaWNlcy5zY2FsZSgxIC8gdGhpcy5yYXRpbyksXG4gICAgICAgIHJvdGF0aW9uID0gc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24odGhpcy5hbmdsZSksXG4gICAgICAgIHRyYW5zbGF0aW9uID0gc2lnbWEudXRpbHMubWF0cmljZXMudHJhbnNsYXRpb24oLXRoaXMueCwgLXRoaXMueSksXG4gICAgICAgIG1hdHJpeCA9IHNpZ21hLnV0aWxzLm1hdHJpY2VzLm11bHRpcGx5KFxuICAgICAgICAgIHRyYW5zbGF0aW9uLFxuICAgICAgICAgIHNpZ21hLnV0aWxzLm1hdHJpY2VzLm11bHRpcGx5KFxuICAgICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgICBzY2FsZVxuICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgIHJldHVybiBtYXRyaXg7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRha2luZyBhIHdpZHRoIGFuZCBhIGhlaWdodCBhcyBwYXJhbWV0ZXJzLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZVxuICAgKiBjb29yZGluYXRlcyBvZiB0aGUgcmVjdGFuZ2xlIHJlcHJlc2VudGluZyB0aGUgY2FtZXJhIG9uIHNjcmVlbiwgaW4gdGhlXG4gICAqIGdyYXBoJ3MgcmVmZXJlbnRpZWwuXG4gICAqXG4gICAqIFRvIGtlZXAgZGlzcGxheWluZyBsYWJlbHMgb2Ygbm9kZXMgZ29pbmcgb3V0IG9mIHRoZSBzY3JlZW4sIHRoZSBtZXRob2RcbiAgICoga2VlcHMgYSBtYXJnaW4gYXJvdW5kIHRoZSBzY3JlZW4gaW4gdGhlIHJldHVybmVkIHJlY3RhbmdsZS5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB3aWR0aCAgVGhlIHdpZHRoIG9mIHRoZSBzY3JlZW4uXG4gICAqIEBwYXJhbSAge251bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHNjcmVlbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgVGhlIHJlY3RhbmdsZSBhcyB4MSwgeTEsIHgyIGFuZCB5MiwgcmVwcmVzZW50aW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHR3byBvcHBvc2l0ZSBwb2ludHMuXG4gICAqL1xuICBzaWdtYS5jbGFzc2VzLmNhbWVyYS5wcm90b3R5cGUuZ2V0UmVjdGFuZ2xlID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgIHZhciB3aWR0aFZlY3QgPSB0aGlzLmNhbWVyYVBvc2l0aW9uKHdpZHRoLCAwLCB0cnVlKSxcbiAgICAgICAgaGVpZ2h0VmVjdCA9IHRoaXMuY2FtZXJhUG9zaXRpb24oMCwgaGVpZ2h0LCB0cnVlKSxcbiAgICAgICAgY2VudGVyVmVjdCA9IHRoaXMuY2FtZXJhUG9zaXRpb24od2lkdGggLyAyLCBoZWlnaHQgLyAyLCB0cnVlKSxcbiAgICAgICAgbWFyZ2luWCA9IHRoaXMuY2FtZXJhUG9zaXRpb24od2lkdGggLyA0LCAwLCB0cnVlKS54LFxuICAgICAgICBtYXJnaW5ZID0gdGhpcy5jYW1lcmFQb3NpdGlvbigwLCBoZWlnaHQgLyA0LCB0cnVlKS55O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiB0aGlzLnggLSBjZW50ZXJWZWN0LnggLSBtYXJnaW5YLFxuICAgICAgeTE6IHRoaXMueSAtIGNlbnRlclZlY3QueSAtIG1hcmdpblksXG4gICAgICB4MjogdGhpcy54IC0gY2VudGVyVmVjdC54ICsgbWFyZ2luWCArIHdpZHRoVmVjdC54LFxuICAgICAgeTI6IHRoaXMueSAtIGNlbnRlclZlY3QueSAtIG1hcmdpblkgKyB3aWR0aFZlY3QueSxcbiAgICAgIGhlaWdodDogTWF0aC5zcXJ0KFxuICAgICAgICBNYXRoLnBvdyhoZWlnaHRWZWN0LngsIDIpICtcbiAgICAgICAgTWF0aC5wb3coaGVpZ2h0VmVjdC55ICsgMiAqIG1hcmdpblksIDIpXG4gICAgICApXG4gICAgfTtcbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogU2lnbWEgUXVhZHRyZWUgTW9kdWxlXG4gICAqID09PT09PT09PT09PT09PT09PT09PVxuICAgKlxuICAgKiBBdXRob3I6IEd1aWxsYXVtZSBQbGlxdWUgKFlvbWd1aXRoZXJlYWwpXG4gICAqIFZlcnNpb246IDAuMlxuICAgKi9cblxuXG5cbiAgLyoqXG4gICAqIFF1YWQgR2VvbWV0cmljIE9wZXJhdGlvbnNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBBIHVzZWZ1bCBiYXRjaCBvZiBnZW9tZXRyaWMgb3BlcmF0aW9ucyB1c2VkIGJ5IHRoZSBxdWFkdHJlZS5cbiAgICovXG5cbiAgdmFyIF9nZW9tID0ge1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhIGdyYXBoIG5vZGUgd2l0aCB4LCB5IGFuZCBzaXplIGludG8gYW5cbiAgICAgKiBheGlzLWFsaWduZWQgc3F1YXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIGdyYXBoIG5vZGUgd2l0aCBhdCBsZWFzdCBhIHBvaW50ICh4LCB5KSBhbmQgYSBzaXplLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQSBzcXVhcmU6IHR3byBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICovXG4gICAgcG9pbnRUb1NxdWFyZTogZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IG4ueCAtIG4uc2l6ZSxcbiAgICAgICAgeTE6IG4ueSAtIG4uc2l6ZSxcbiAgICAgICAgeDI6IG4ueCArIG4uc2l6ZSxcbiAgICAgICAgeTI6IG4ueSAtIG4uc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBuLnNpemUgKiAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhIHJlY3RhbmdsZSBpcyBheGlzLWFsaWduZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlIGlzIGF4aXMtYWxpZ25lZC5cbiAgICAgKi9cbiAgICBpc0F4aXNBbGlnbmVkOiBmdW5jdGlvbihyKSB7XG4gICAgICByZXR1cm4gci54MSA9PT0gci54MiB8fCByLnkxID09PSByLnkyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRvcCBwb2ludHMgb2YgYW4gYXhpcy1hbGlnbmVkIHJlY3RhbmdsZS4gVGhpcyBpcyB1c2VmdWwgaW5cbiAgICAgKiBjYXNlcyB3aGVuIHRoZSByZWN0YW5nbGUgaGFzIGJlZW4gcm90YXRlZCAobGVmdCwgcmlnaHQgb3IgYm90dG9tIHVwKSBhbmRcbiAgICAgKiBsYXRlciBvcGVyYXRpb25zIG5lZWQgdG8ga25vdyB0aGUgdG9wIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQW4gYXhpcy1hbGlnbmVkIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQSByZWN0YW5nbGU6IHR3byBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICovXG4gICAgYXhpc0FsaWduZWRUb3BQb2ludHM6IGZ1bmN0aW9uKHIpIHtcblxuICAgICAgLy8gQmFzaWNcbiAgICAgIGlmIChyLnkxID09PSByLnkyICYmIHIueDEgPCByLngyKVxuICAgICAgICByZXR1cm4gcjtcblxuICAgICAgLy8gUm90YXRlZCB0byByaWdodFxuICAgICAgaWYgKHIueDEgPT09IHIueDIgJiYgci55MiA+IHIueTEpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDE6IHIueDEgLSByLmhlaWdodCwgeTE6IHIueTEsXG4gICAgICAgICAgeDI6IHIueDEsIHkyOiByLnkxLFxuICAgICAgICAgIGhlaWdodDogci5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgLy8gUm90YXRlZCB0byBsZWZ0XG4gICAgICBpZiAoci54MSA9PT0gci54MiAmJiByLnkyIDwgci55MSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogci54MSwgeTE6IHIueTIsXG4gICAgICAgICAgeDI6IHIueDIgKyByLmhlaWdodCwgeTI6IHIueTIsXG4gICAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAvLyBCb3R0b20ncyB1cFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IHIueDIsIHkxOiByLnkxIC0gci5oZWlnaHQsXG4gICAgICAgIHgyOiByLngxLCB5Mjogci55MSAtIHIuaGVpZ2h0LFxuICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29vcmRpbmF0ZXMgb2YgYSByZWN0YW5nbGUncyBsb3dlciBsZWZ0IGNvcm5lciBmcm9tIGl0cyB0b3AgcG9pbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgdGhlIGNvcm5lciAoeCwgeSkuXG4gICAgICovXG4gICAgbG93ZXJMZWZ0Q29vcjogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIHdpZHRoID0gKFxuICAgICAgICBNYXRoLnNxcnQoXG4gICAgICAgICAgTWF0aC5wb3coci54MiAtIHIueDEsIDIpICtcbiAgICAgICAgICBNYXRoLnBvdyhyLnkyIC0gci55MSwgMilcbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogci54MSAtIChyLnkyIC0gci55MSkgKiByLmhlaWdodCAvIHdpZHRoLFxuICAgICAgICB5OiByLnkxICsgKHIueDIgLSByLngxKSAqIHIuaGVpZ2h0IC8gd2lkdGhcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjb29yZGluYXRlcyBvZiBhIHJlY3RhbmdsZSdzIGxvd2VyIHJpZ2h0IGNvcm5lciBmcm9tIGl0cyB0b3AgcG9pbnRzXG4gICAgICogYW5kIGl0cyBsb3dlciBsZWZ0IGNvcm5lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgY29ybmVyJ3MgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgdGhlIGNvcm5lciAoeCwgeSkuXG4gICAgICovXG4gICAgbG93ZXJSaWdodENvb3I6IGZ1bmN0aW9uKHIsIGxsYykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogbGxjLnggLSByLngxICsgci54MixcbiAgICAgICAgeTogbGxjLnkgLSByLnkxICsgci55MlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb29yZGluYXRlcyBvZiBhbGwgdGhlIGNvcm5lcnMgb2YgYSByZWN0YW5nbGUgZnJvbSBpdHMgdG9wIHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgb2YgdGhlIGZvdXIgY29ybmVycycgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgICAqL1xuICAgIHJlY3RhbmdsZUNvcm5lcnM6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciBsbGMgPSB0aGlzLmxvd2VyTGVmdENvb3IociksXG4gICAgICAgICAgbHJjID0gdGhpcy5sb3dlclJpZ2h0Q29vcihyLCBsbGMpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICB7eDogci54MSwgeTogci55MX0sXG4gICAgICAgIHt4OiByLngyLCB5OiByLnkyfSxcbiAgICAgICAge3g6IGxsYy54LCB5OiBsbGMueX0sXG4gICAgICAgIHt4OiBscmMueCwgeTogbHJjLnl9XG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTcGxpdCBhIHNxdWFyZSBkZWZpbmVkIGJ5IGl0cyBib3VuZGFyaWVzIGludG8gZm91ci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQm91bmRhcmllcyBvZiB0aGUgc3F1YXJlICh4LCB5LCB3aWR0aCwgaGVpZ2h0KS5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGZvdXIgbmV3IHNxdWFyZXMsIHRoZW1zZWx2ZXNcbiAgICAgKiAgICAgICAgICAgICAgICAgIGRlZmluZWQgYnkgYW4gYXJyYXkgb2YgdGhlaXIgZm91ciBjb3JuZXJzICh4LCB5KS5cbiAgICAgKi9cbiAgICBzcGxpdFNxdWFyZTogZnVuY3Rpb24oYikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgW1xuICAgICAgICAgIHt4OiBiLngsIHk6IGIueX0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLngsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9XG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueX0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueX0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9XG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnkgKyBiLmhlaWdodH0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodH1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55ICsgYi5oZWlnaHR9XG4gICAgICAgIF1cbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIGZvdXIgYXhpcyBiZXR3ZWVuIGNvcm5lcnMgb2YgcmVjdGFuZ2xlIEEgYW5kIGNvcm5lcnMgb2ZcbiAgICAgKiByZWN0YW5nbGUgQi4gVGhpcyBpcyBuZWVkZWQgbGF0ZXIgdG8gY2hlY2sgYW4gZXZlbnR1YWwgY29sbGlzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7YXJyYXl9IEFuIGFycmF5IG9mIHJlY3RhbmdsZSBBJ3MgZm91ciBjb3JuZXJzICh4LCB5KS5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gQW4gYXJyYXkgb2YgcmVjdGFuZ2xlIEIncyBmb3VyIGNvcm5lcnMgKHgsIHkpLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBmb3VyIGF4aXMgZGVmaW5lZCBieSB0aGVpciBjb29yZGluYXRlcyAoeCx5KS5cbiAgICAgKi9cbiAgICBheGlzOiBmdW5jdGlvbihjMSwgYzIpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt4OiBjMVsxXS54IC0gYzFbMF0ueCwgeTogYzFbMV0ueSAtIGMxWzBdLnl9LFxuICAgICAgICB7eDogYzFbMV0ueCAtIGMxWzNdLngsIHk6IGMxWzFdLnkgLSBjMVszXS55fSxcbiAgICAgICAge3g6IGMyWzBdLnggLSBjMlsyXS54LCB5OiBjMlswXS55IC0gYzJbMl0ueX0sXG4gICAgICAgIHt4OiBjMlswXS54IC0gYzJbMV0ueCwgeTogYzJbMF0ueSAtIGMyWzFdLnl9XG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0IGEgcmVjdGFuZ2xlJ3MgY29ybmVyIG9uIGFuIGF4aXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIGEgY29ybmVyICh4LCB5KS5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIGFuIGF4aXMgKHgsIHkpLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHByb2plY3Rpb24gZGVmaW5lZCBieSBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICovXG4gICAgcHJvamVjdGlvbjogZnVuY3Rpb24oYywgYSkge1xuICAgICAgdmFyIGwgPSAoXG4gICAgICAgIChjLnggKiBhLnggKyBjLnkgKiBhLnkpIC9cbiAgICAgICAgKE1hdGgucG93KGEueCwgMikgKyBNYXRoLnBvdyhhLnksIDIpKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogbCAqIGEueCxcbiAgICAgICAgeTogbCAqIGEueVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0d28gcmVjdGFuZ2xlcyBjb2xsaWRlIG9uIG9uZSBwYXJ0aWN1bGFyIGF4aXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgQW4gYXhpcycgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQSdzIGNvcm5lcnMuXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBCJ3MgY29ybmVycy5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlcyBjb2xsaWRlIG9uIHRoZSBheGlzLlxuICAgICAqL1xuICAgIGF4aXNDb2xsaXNpb246IGZ1bmN0aW9uKGEsIGMxLCBjMikge1xuICAgICAgdmFyIHNjMSA9IFtdLFxuICAgICAgICAgIHNjMiA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgNDsgY2krKykge1xuICAgICAgICB2YXIgcDEgPSB0aGlzLnByb2plY3Rpb24oYzFbY2ldLCBhKSxcbiAgICAgICAgICAgIHAyID0gdGhpcy5wcm9qZWN0aW9uKGMyW2NpXSwgYSk7XG5cbiAgICAgICAgc2MxLnB1c2gocDEueCAqIGEueCArIHAxLnkgKiBhLnkpO1xuICAgICAgICBzYzIucHVzaChwMi54ICogYS54ICsgcDIueSAqIGEueSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXhjMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjMSksXG4gICAgICAgICAgbWF4YzIgPSBNYXRoLm1heC5hcHBseShNYXRoLCBzYzIpLFxuICAgICAgICAgIG1pbmMxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgc2MxKSxcbiAgICAgICAgICBtaW5jMiA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHNjMik7XG5cbiAgICAgIHJldHVybiAobWluYzIgPD0gbWF4YzEgJiYgbWF4YzIgPj0gbWluYzEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHR3byByZWN0YW5nbGVzIGNvbGxpZGUgb24gZWFjaCBvbmUgb2YgdGhlaXIgZm91ciBheGlzLiBJZlxuICAgICAqIGFsbCBheGlzIGNvbGxpZGUsIHRoZW4gdGhlIHR3byByZWN0YW5nbGVzIGRvIGNvbGxpZGUgb24gdGhlIHBsYW5lLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBBJ3MgY29ybmVycy5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEIncyBjb3JuZXJzLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIHRoZSByZWN0YW5nbGVzIGNvbGxpZGUuXG4gICAgICovXG4gICAgY29sbGlzaW9uOiBmdW5jdGlvbihjMSwgYzIpIHtcbiAgICAgIHZhciBheGlzID0gdGhpcy5heGlzKGMxLCBjMiksXG4gICAgICAgICAgY29sID0gdHJ1ZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICAgIGNvbCA9IGNvbCAmJiB0aGlzLmF4aXNDb2xsaXNpb24oYXhpc1tpXSwgYzEsIGMyKTtcblxuICAgICAgcmV0dXJuIGNvbDtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogUXVhZCBGdW5jdGlvbnNcbiAgICogLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIFRoZSBRdWFkdHJlZSBmdW5jdGlvbnMgdGhlbXNlbHZlcy5cbiAgICogRm9yIGVhY2ggb2YgdGhvc2UgZnVuY3Rpb25zLCB3ZSBjb25zaWRlciB0aGF0IGluIGEgc3BsaXR0ZWQgcXVhZCwgdGhlXG4gICAqIGluZGV4IG9mIGVhY2ggbm9kZSBpcyB0aGUgZm9sbG93aW5nOlxuICAgKiAwOiB0b3AgbGVmdFxuICAgKiAxOiB0b3AgcmlnaHRcbiAgICogMjogYm90dG9tIGxlZnRcbiAgICogMzogYm90dG9tIHJpZ2h0XG4gICAqXG4gICAqIE1vcmVvdmVyLCB0aGUgaGVyZWFmdGVyIHF1YWQncyBwaGlsb3NvcGh5IGlzIHRvIGNvbnNpZGVyIHRoYXQgaWYgYW4gZWxlbWVudFxuICAgKiBjb2xsaWRlcyB3aXRoIG1vcmUgdGhhbiBvbmUgbm9kZXMsIHRoaXMgZWxlbWVudCBiZWxvbmdzIHRvIGVhY2ggb2YgdGhlXG4gICAqIG5vZGVzIGl0IGNvbGxpZGVzIHdpdGggd2hlcmUgb3RoZXIgd291bGQgbGV0IGl0IGxpZSBvbiBhIGhpZ2hlciBub2RlLlxuICAgKi9cblxuICAvKipcbiAgICogR2V0IHRoZSBpbmRleCBvZiB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBwb2ludCBpbiB0aGUgcXVhZFxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBwb2ludCAgICAgIEEgcG9pbnQgZGVmaW5lZCBieSBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHF1YWRCb3VuZHMgQm91bmRhcmllcyBvZiB0aGUgcXVhZCAoeCwgeSwgd2lkdGgsIGhlaWd0aCkuXG4gICAqIEByZXR1cm4ge2ludGVnZXJ9ICAgICAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIHBvaW50LlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRJbmRleChwb2ludCwgcXVhZEJvdW5kcykge1xuICAgIHZhciB4bXAgPSBxdWFkQm91bmRzLnggKyBxdWFkQm91bmRzLndpZHRoIC8gMixcbiAgICAgICAgeW1wID0gcXVhZEJvdW5kcy55ICsgcXVhZEJvdW5kcy5oZWlnaHQgLyAyLFxuICAgICAgICB0b3AgPSAocG9pbnQueSA8IHltcCksXG4gICAgICAgIGxlZnQgPSAocG9pbnQueCA8IHhtcCk7XG5cbiAgICBpZiAodG9wKSB7XG4gICAgICBpZiAobGVmdClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChsZWZ0KVxuICAgICAgICByZXR1cm4gMjtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgaW5kZXhlcyBvZiBub2RlcyBjb250YWluaW5nIGFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGVcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcmVjdGFuZ2xlICAgQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gIHthcnJheX0gICBxdWFkQ29ybmVycyBBbiBhcnJheSBvZiB0aGUgcXVhZCBub2RlcycgY29ybmVycy5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgaW5kZXhlcyBjb250YWluaW5nIG9uZSB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VyIGludGVnZXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRJbmRleGVzKHJlY3RhbmdsZSwgcXVhZENvcm5lcnMpIHtcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xuXG4gICAgLy8gSXRlcmF0aW5nIHRocm91Z2ggcXVhZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICAgIGlmICgocmVjdGFuZ2xlLngyID49IHF1YWRDb3JuZXJzW2ldWzBdLngpICYmXG4gICAgICAgICAgKHJlY3RhbmdsZS54MSA8PSBxdWFkQ29ybmVyc1tpXVsxXS54KSAmJlxuICAgICAgICAgIChyZWN0YW5nbGUueTEgKyByZWN0YW5nbGUuaGVpZ2h0ID49IHF1YWRDb3JuZXJzW2ldWzBdLnkpICYmXG4gICAgICAgICAgKHJlY3RhbmdsZS55MSA8PSBxdWFkQ29ybmVyc1tpXVsyXS55KSlcbiAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuXG4gICAgcmV0dXJuIGluZGV4ZXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBpbmRleGVzIG9mIG5vZGVzIGNvbnRhaW5pbmcgYSBub24tYXhpcy1hbGlnbmVkIHJlY3RhbmdsZVxuICAgKlxuICAgKiBAcGFyYW0gIHthcnJheX0gIGNvcm5lcnMgICAgICBBbiBhcnJheSBjb250YWluaW5nIGVhY2ggY29ybmVyIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgZGVmaW5lZCBieSBpdHMgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgKiBAcGFyYW0gIHthcnJheX0gIHF1YWRDb3JuZXJzICBBbiBhcnJheSBvZiB0aGUgcXVhZCBub2RlcycgY29ybmVycy5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgaW5kZXhlcyBjb250YWluaW5nIG9uZSB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VyIGludGVnZXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRDb2xsaXNpb24oY29ybmVycywgcXVhZENvcm5lcnMpIHtcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xuXG4gICAgLy8gSXRlcmF0aW5nIHRocm91Z2ggcXVhZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICAgIGlmIChfZ2VvbS5jb2xsaXNpb24oY29ybmVycywgcXVhZENvcm5lcnNbaV0pKVxuICAgICAgICBpbmRleGVzLnB1c2goaSk7XG5cbiAgICByZXR1cm4gaW5kZXhlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJkaXZpZGUgYSBxdWFkIGJ5IGNyZWF0aW5nIGEgbm9kZSBhdCBhIHByZWNpc2UgaW5kZXguIFRoZSBmdW5jdGlvbiBkb2VzXG4gICAqIG5vdCBnZW5lcmF0ZSBhbGwgZm91ciBub2RlcyBub3QgdG8gcG90ZW50aWFsbHkgY3JlYXRlIHVudXNlZCBub2Rlcy5cbiAgICpcbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBjcmVhdGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICBxdWFkICBUaGUgcXVhZCBvYmplY3QgdG8gc3ViZGl2aWRlLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgQSBuZXcgcXVhZCByZXByZXNlbnRpbmcgdGhlIG5vZGUgY3JlYXRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkU3ViZGl2aWRlKGluZGV4LCBxdWFkKSB7XG4gICAgdmFyIG5leHQgPSBxdWFkLmxldmVsICsgMSxcbiAgICAgICAgc3VidyA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMud2lkdGggLyAyKSxcbiAgICAgICAgc3ViaCA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMuaGVpZ2h0IC8gMiksXG4gICAgICAgIHF4ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy54KSxcbiAgICAgICAgcXkgPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLnkpLFxuICAgICAgICB4LFxuICAgICAgICB5O1xuXG4gICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB4ID0gcXg7XG4gICAgICAgIHkgPSBxeTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHggPSBxeCArIHN1Ync7XG4gICAgICAgIHkgPSBxeTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHggPSBxeDtcbiAgICAgICAgeSA9IHF5ICsgc3ViaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHggPSBxeCArIHN1Ync7XG4gICAgICAgIHkgPSBxeSArIHN1Ymg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBfcXVhZFRyZWUoXG4gICAgICB7eDogeCwgeTogeSwgd2lkdGg6IHN1YncsIGhlaWdodDogc3ViaH0sXG4gICAgICBuZXh0LFxuICAgICAgcXVhZC5tYXhFbGVtZW50cyxcbiAgICAgIHF1YWQubWF4TGV2ZWxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGluc2VydCBhbiBlbGVtZW50IGludG8gdGhlIHF1YWR0cmVlLiBPbmx5IHBvaW50c1xuICAgKiB3aXRoIHNpemUsIGkuZS4gYXhpcy1hbGlnbmVkIHNxdWFyZXMsIG1heSBiZSBpbnNlcnRlZCB3aXRoIHRoaXNcbiAgICogbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBlbCAgICAgICAgIFRoZSBlbGVtZW50IHRvIGluc2VydCBpbiB0aGUgcXVhZHRyZWUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHNpemVkUG9pbnQgQSBzaXplZCBwb2ludCBkZWZpbmVkIGJ5IHR3byB0b3AgcG9pbnRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHF1YWQgICAgICAgVGhlIHF1YWQgaW4gd2hpY2ggdG8gaW5zZXJ0IHRoZSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9ICAgICAgICAgIFRoZSBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZEluc2VydChlbCwgc2l6ZWRQb2ludCwgcXVhZCkge1xuICAgIGlmIChxdWFkLmxldmVsIDwgcXVhZC5tYXhMZXZlbCkge1xuXG4gICAgICAvLyBTZWFyY2hpbmcgYXBwcm9wcmlhdGUgcXVhZHNcbiAgICAgIHZhciBpbmRleGVzID0gX3F1YWRJbmRleGVzKHNpemVkUG9pbnQsIHF1YWQuY29ybmVycyk7XG5cbiAgICAgIC8vIEl0ZXJhdGluZ1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbmRleGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXG4gICAgICAgIC8vIFN1YmRpdmlkaW5nIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAocXVhZC5ub2Rlc1tpbmRleGVzW2ldXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHF1YWQubm9kZXNbaW5kZXhlc1tpXV0gPSBfcXVhZFN1YmRpdmlkZShpbmRleGVzW2ldLCBxdWFkKTtcblxuICAgICAgICAvLyBSZWN1cnNpb25cbiAgICAgICAgX3F1YWRJbnNlcnQoZWwsIHNpemVkUG9pbnQsIHF1YWQubm9kZXNbaW5kZXhlc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgLy8gUHVzaGluZyB0aGUgZWxlbWVudCBpbiBhIGxlYWYgbm9kZVxuICAgICAgcXVhZC5lbGVtZW50cy5wdXNoKGVsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgcmV0cmlldmUgZXZlcnkgZWxlbWVudHMgaGVsZCBieSB0aGUgbm9kZSBjb250YWluaW5nIHRoZVxuICAgKiBzZWFyY2hlZCBwb2ludC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcG9pbnQgVGhlIHNlYXJjaGVkIHBvaW50ICh4LCB5KS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcXVhZCAgVGhlIHNlYXJjaGVkIHF1YWQuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgIEFuIGFycmF5IG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgcmVsZXZhbnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkUmV0cmlldmVQb2ludChwb2ludCwgcXVhZCkge1xuICAgIGlmIChxdWFkLmxldmVsIDwgcXVhZC5tYXhMZXZlbCkge1xuICAgICAgdmFyIGluZGV4ID0gX3F1YWRJbmRleChwb2ludCwgcXVhZC5ib3VuZHMpO1xuXG4gICAgICAvLyBJZiBub2RlIGRvZXMgbm90IGV4aXN0IHdlIHJldHVybiBhbiBlbXB0eSBsaXN0XG4gICAgICBpZiAocXVhZC5ub2Rlc1tpbmRleF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gX3F1YWRSZXRyaWV2ZVBvaW50KHBvaW50LCBxdWFkLm5vZGVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBxdWFkLmVsZW1lbnRzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSByZXRyaWV2ZSBldmVyeSBlbGVtZW50cyBjb250YWluZWQgd2l0aGluIGFuIHJlY3Rhbmd1bGFyIGFyZWFcbiAgICogdGhhdCBtYXkgb3IgbWF5IG5vdCBiZSBheGlzLWFsaWduZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdHxhcnJheX0gcmVjdERhdGEgICAgICAgVGhlIHNlYXJjaGVkIGFyZWEgZGVmaW5lZCBlaXRoZXIgYnlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbiBhcnJheSBvZiBmb3VyIGNvcm5lcnMgKHgsIHkpIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGNhc2Ugb2YgYSBub24tYXhpcy1hbGlnbmVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIG9yIGFuIG9iamVjdCB3aXRoIHR3byB0b3BcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgcXVhZCAgICAgICAgICAgVGhlIHNlYXJjaGVkIHF1YWQuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgICAgY29sbGlzaW9uRnVuYyAgVGhlIGNvbGxpc2lvbiBmdW5jdGlvbiB1c2VkIHRvIHNlYXJjaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBub2RlIGluZGV4ZXMuXG4gICAqIEBwYXJhbSAge2FycmF5P30gICAgICAgZWxzICAgICAgICAgICAgVGhlIHJldHJpZXZlZCBlbGVtZW50cy5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgICAgICAgICAgICAgICBBbiBhcnJheSBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlYS5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkUmV0cmlldmVBcmVhKHJlY3REYXRhLCBxdWFkLCBjb2xsaXNpb25GdW5jLCBlbHMpIHtcbiAgICBlbHMgPSBlbHMgfHwge307XG5cbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcbiAgICAgIHZhciBpbmRleGVzID0gY29sbGlzaW9uRnVuYyhyZWN0RGF0YSwgcXVhZC5jb3JuZXJzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbmRleGVzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhlc1tpXV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICBfcXVhZFJldHJpZXZlQXJlYShcbiAgICAgICAgICAgIHJlY3REYXRhLFxuICAgICAgICAgICAgcXVhZC5ub2Rlc1tpbmRleGVzW2ldXSxcbiAgICAgICAgICAgIGNvbGxpc2lvbkZ1bmMsXG4gICAgICAgICAgICBlbHNcbiAgICAgICAgICApO1xuICAgIH0gZWxzZVxuICAgICAgZm9yICh2YXIgaiA9IDAsIG0gPSBxdWFkLmVsZW1lbnRzLmxlbmd0aDsgaiA8IG07IGorKylcbiAgICAgICAgaWYgKGVsc1txdWFkLmVsZW1lbnRzW2pdLmlkXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGVsc1txdWFkLmVsZW1lbnRzW2pdLmlkXSA9IHF1YWQuZWxlbWVudHNbal07XG5cbiAgICByZXR1cm4gZWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIHF1YWR0cmVlIG9iamVjdCBpdHNlbGYuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICBib3VuZHMgICAgICAgVGhlIGJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgZGVmaW5lZCBieSBhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbiAoeCwgeSksIHdpZHRoIGFuZCBoZWlndGguXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBsZXZlbCAgICAgICAgVGhlIGxldmVsIG9mIHRoZSBxdWFkIGluIHRoZSB0cmVlLlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbWF4RWxlbWVudHMgIFRoZSBtYXggbnVtYmVyIG9mIGVsZW1lbnQgaW4gYSBsZWFmIG5vZGUuXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBtYXhMZXZlbCAgICAgVGhlIG1heCByZWN1cnNpb24gbGV2ZWwgb2YgdGhlIHRyZWUuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgVGhlIHF1YWR0cmVlIG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkVHJlZShib3VuZHMsIGxldmVsLCBtYXhFbGVtZW50cywgbWF4TGV2ZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWw6IGxldmVsIHx8IDAsXG4gICAgICBib3VuZHM6IGJvdW5kcyxcbiAgICAgIGNvcm5lcnM6IF9nZW9tLnNwbGl0U3F1YXJlKGJvdW5kcyksXG4gICAgICBtYXhFbGVtZW50czogbWF4RWxlbWVudHMgfHwgMjAsXG4gICAgICBtYXhMZXZlbDogbWF4TGV2ZWwgfHwgNCxcbiAgICAgIGVsZW1lbnRzOiBbXSxcbiAgICAgIG5vZGVzOiBbXVxuICAgIH07XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTaWdtYSBRdWFkIENvbnN0cnVjdG9yXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICpcbiAgICogVGhlIHF1YWQgQVBJIGFzIGV4cG9zZWQgdG8gc2lnbWEuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgcXVhZCBjb3JlIHRoYXQgd2lsbCBiZWNvbWUgdGhlIHNpZ21hIGludGVyZmFjZSB3aXRoIHRoZSBxdWFkdHJlZS5cbiAgICpcbiAgICogcHJvcGVydHkge29iamVjdH0gX3RyZWUgIFByb3BlcnR5IGhvbGRpbmcgdGhlIHF1YWR0cmVlIG9iamVjdC5cbiAgICogcHJvcGVydHkge29iamVjdH0gX2dlb20gIEV4cG9zaXRpb24gb2YgdGhlIF9nZW9tIG5hbWVzcGFjZSBmb3IgdGVzdGluZy5cbiAgICogcHJvcGVydHkge29iamVjdH0gX2NhY2hlIENhY2hlIGZvciB0aGUgYXJlYSBtZXRob2QuXG4gICAqL1xuICB2YXIgcXVhZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2dlb20gPSBfZ2VvbTtcbiAgICB0aGlzLl90cmVlID0gbnVsbDtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIHF1ZXJ5OiBmYWxzZSxcbiAgICAgIHJlc3VsdDogZmFsc2VcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbmRleCBhIGdyYXBoIGJ5IGluc2VydGluZyBpdHMgbm9kZXMgaW50byB0aGUgcXVhZHRyZWUuXG4gICAqXG4gICAqIEBwYXJhbSAge2FycmF5fSAgbm9kZXMgICBBbiBhcnJheSBvZiBub2RlcyB0byBpbmRleC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbXMgIEFuIG9iamVjdCBvZiBwYXJhbWV0ZXJzIHdpdGggYXQgbGVhc3QgdGhlIHF1YWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcy5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFRoZSBxdWFkdHJlZSBvYmplY3QuXG4gICAqXG4gICAqIFBhcmFtZXRlcnM6XG4gICAqIC0tLS0tLS0tLS1cbiAgICogYm91bmRzOiAgICAgIHtvYmplY3R9ICAgYm91bmRhcmllcyBvZiB0aGUgcXVhZCBkZWZpbmVkIGJ5IGl0cyBvcmlnaW4gKHgsIHkpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoIGFuZCBoZWlndGguXG4gICAqIHByZWZpeDogICAgICB7c3RyaW5nP30gIGEgcHJlZml4IGZvciBub2RlIGdlb21ldHJpYyBhdHRyaWJ1dGVzLlxuICAgKiBtYXhFbGVtZW50czoge2ludGVnZXI/fSB0aGUgbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiBhIGxlYWYgbm9kZS5cbiAgICogbWF4TGV2ZWw6ICAgIHtpbnRlZ2VyP30gdGhlIG1heCByZWN1cnNpb24gbGV2ZWwgb2YgdGhlIHRyZWUuXG4gICAqL1xuICBxdWFkLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uKG5vZGVzLCBwYXJhbXMpIHtcblxuICAgIC8vIEVuZm9yY2luZyBwcmVzZW5jZSBvZiBib3VuZGFyaWVzXG4gICAgaWYgKCFwYXJhbXMuYm91bmRzKVxuICAgICAgdGhyb3cgJ3NpZ21hLmNsYXNzZXMucXVhZC5pbmRleDogYm91bmRzIGluZm9ybWF0aW9uIG5vdCBnaXZlbi4nO1xuXG4gICAgLy8gUHJlZml4XG4gICAgdmFyIHByZWZpeCA9IHBhcmFtcy5wcmVmaXggfHwgJyc7XG5cbiAgICAvLyBCdWlsZGluZyB0aGUgdHJlZVxuICAgIHRoaXMuX3RyZWUgPSBfcXVhZFRyZWUoXG4gICAgICBwYXJhbXMuYm91bmRzLFxuICAgICAgMCxcbiAgICAgIHBhcmFtcy5tYXhFbGVtZW50cyxcbiAgICAgIHBhcmFtcy5tYXhMZXZlbFxuICAgICk7XG5cbiAgICAvLyBJbnNlcnRpbmcgZ3JhcGggbm9kZXMgaW50byB0aGUgdHJlZVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgIC8vIEluc2VydGluZyBub2RlXG4gICAgICBfcXVhZEluc2VydChcbiAgICAgICAgbm9kZXNbaV0sXG4gICAgICAgIF9nZW9tLnBvaW50VG9TcXVhcmUoe1xuICAgICAgICAgIHg6IG5vZGVzW2ldW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgeTogbm9kZXNbaV1bcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICBzaXplOiBub2Rlc1tpXVtwcmVmaXggKyAnc2l6ZSddXG4gICAgICAgIH0pLFxuICAgICAgICB0aGlzLl90cmVlXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IGNhY2hlOlxuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgcXVlcnk6IGZhbHNlLFxuICAgICAgcmVzdWx0OiBmYWxzZVxuICAgIH07XG5cbiAgICAvLyByZW1vdmU/XG4gICAgcmV0dXJuIHRoaXMuX3RyZWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGV2ZXJ5IGdyYXBoIG5vZGVzIGhlbGQgYnkgdGhlIHF1YWR0cmVlIG5vZGUgY29udGFpbmluZyB0aGVcbiAgICogc2VhcmNoZWQgcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geCBvZiB0aGUgcG9pbnQuXG4gICAqIEBwYXJhbSAge251bWJlcn0geSBvZiB0aGUgcG9pbnQuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgb2Ygbm9kZXMgcmV0cmlldmVkLlxuICAgKi9cbiAgcXVhZC5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyZWUgP1xuICAgICAgX3F1YWRSZXRyaWV2ZVBvaW50KHt4OiB4LCB5OiB5fSwgdGhpcy5fdHJlZSkgfHwgW10gOlxuICAgICAgW107XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGV2ZXJ5IGdyYXBoIG5vZGVzIHdpdGhpbiBhIHJlY3Rhbmd1bGFyIGFyZWEuIFRoZSBtZXRob2RzIGtlZXAgdGhlXG4gICAqIGxhc3QgYXJlYSBxdWVyaWVkIGluIGNhY2hlIGZvciBvcHRpbWl6YXRpb24gcmVhc29uIGFuZCB3aWxsIGFjdCBkaWZmZXJlbnRseVxuICAgKiBmb3IgdGhlIHNhbWUgcmVhc29uIGlmIHRoZSBhcmVhIGlzIGF4aXMtYWxpZ25lZCBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gdG9wIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MilcbiAgICogICAgICAgICAgICAgICAgICBhbmQgaGVpZ2h0LlxuICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIG5vZGVzIHJldHJpZXZlZC5cbiAgICovXG4gIHF1YWQucHJvdG90eXBlLmFyZWEgPSBmdW5jdGlvbihyZWN0KSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeShyZWN0KSxcbiAgICAgICAgY29sbGlzaW9uRnVuYyxcbiAgICAgICAgcmVjdERhdGE7XG5cbiAgICAvLyBSZXR1cm5pbmcgY2FjaGU/XG4gICAgaWYgKHRoaXMuX2NhY2hlLnF1ZXJ5ID09PSBzZXJpYWxpemVkKVxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLnJlc3VsdDtcblxuICAgIC8vIEF4aXMgYWxpZ25lZCA/XG4gICAgaWYgKF9nZW9tLmlzQXhpc0FsaWduZWQocmVjdCkpIHtcbiAgICAgIGNvbGxpc2lvbkZ1bmMgPSBfcXVhZEluZGV4ZXM7XG4gICAgICByZWN0RGF0YSA9IF9nZW9tLmF4aXNBbGlnbmVkVG9wUG9pbnRzKHJlY3QpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbGxpc2lvbkZ1bmMgPSBfcXVhZENvbGxpc2lvbjtcbiAgICAgIHJlY3REYXRhID0gX2dlb20ucmVjdGFuZ2xlQ29ybmVycyhyZWN0KTtcbiAgICB9XG5cbiAgICAvLyBSZXRyaWV2aW5nIG5vZGVzXG4gICAgdmFyIG5vZGVzID0gdGhpcy5fdHJlZSA/XG4gICAgICBfcXVhZFJldHJpZXZlQXJlYShcbiAgICAgICAgcmVjdERhdGEsXG4gICAgICAgIHRoaXMuX3RyZWUsXG4gICAgICAgIGNvbGxpc2lvbkZ1bmNcbiAgICAgICkgOlxuICAgICAgW107XG5cbiAgICAvLyBPYmplY3QgdG8gYXJyYXlcbiAgICB2YXIgbm9kZXNBcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgaW4gbm9kZXMpXG4gICAgICBub2Rlc0FycmF5LnB1c2gobm9kZXNbaV0pO1xuXG4gICAgLy8gQ2FjaGluZ1xuICAgIHRoaXMuX2NhY2hlLnF1ZXJ5ID0gc2VyaWFsaXplZDtcbiAgICB0aGlzLl9jYWNoZS5yZXN1bHQgPSBub2Rlc0FycmF5O1xuXG4gICAgcmV0dXJuIG5vZGVzQXJyYXk7XG4gIH07XG5cblxuICAvKipcbiAgICogRVhQT1JUOlxuICAgKiAqKioqKioqXG4gICAqL1xuICBpZiAodHlwZW9mIHRoaXMuc2lnbWEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzID0gdGhpcy5zaWdtYS5jbGFzc2VzIHx8IHt9O1xuICAgIHRoaXMuc2lnbWEuY2xhc3Nlcy5xdWFkID0gcXVhZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBxdWFkO1xuICAgIGV4cG9ydHMucXVhZCA9IHF1YWQ7XG4gIH0gZWxzZVxuICAgIHRoaXMucXVhZCA9IHF1YWQ7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFNpZ21hIFF1YWR0cmVlIE1vZHVsZSBmb3IgZWRnZXNcbiAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgKlxuICAgKiBBdXRob3I6IFPDqWJhc3RpZW4gSGV5bWFubixcbiAgICogICBmcm9tIHRoZSBxdWFkIG9mIEd1aWxsYXVtZSBQbGlxdWUgKFlvbWd1aXRoZXJlYWwpXG4gICAqIFZlcnNpb246IDAuMlxuICAgKi9cblxuXG5cbiAgLyoqXG4gICAqIFF1YWQgR2VvbWV0cmljIE9wZXJhdGlvbnNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBBIHVzZWZ1bCBiYXRjaCBvZiBnZW9tZXRyaWMgb3BlcmF0aW9ucyB1c2VkIGJ5IHRoZSBxdWFkdHJlZS5cbiAgICovXG5cbiAgdmFyIF9nZW9tID0ge1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhIGdyYXBoIG5vZGUgd2l0aCB4LCB5IGFuZCBzaXplIGludG8gYW5cbiAgICAgKiBheGlzLWFsaWduZWQgc3F1YXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIGdyYXBoIG5vZGUgd2l0aCBhdCBsZWFzdCBhIHBvaW50ICh4LCB5KSBhbmQgYSBzaXplLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQSBzcXVhcmU6IHR3byBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICovXG4gICAgcG9pbnRUb1NxdWFyZTogZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IG4ueCAtIG4uc2l6ZSxcbiAgICAgICAgeTE6IG4ueSAtIG4uc2l6ZSxcbiAgICAgICAgeDI6IG4ueCArIG4uc2l6ZSxcbiAgICAgICAgeTI6IG4ueSAtIG4uc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBuLnNpemUgKiAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgZ3JhcGggZWRnZSB3aXRoIHgxLCB5MSwgeDIsIHkyIGFuZCBzaXplIGludG8gYW5cbiAgICAgKiBheGlzLWFsaWduZWQgc3F1YXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIGdyYXBoIGVkZ2Ugd2l0aCBhdCBsZWFzdCB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGEgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgc3F1YXJlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIGxpbmVUb1NxdWFyZTogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUueTEgPCBlLnkyKSB7XG4gICAgICAgIC8vIChlLngxLCBlLnkxKSBvbiB0b3BcbiAgICAgICAgaWYgKGUueDEgPCBlLngyKSB7XG4gICAgICAgICAgLy8gKGUueDEsIGUueTEpIG9uIGxlZnRcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDE6IGUueDEgLSBlLnNpemUsXG4gICAgICAgICAgICB5MTogZS55MSAtIGUuc2l6ZSxcbiAgICAgICAgICAgIHgyOiBlLngyICsgZS5zaXplLFxuICAgICAgICAgICAgeTI6IGUueTEgLSBlLnNpemUsXG4gICAgICAgICAgICBoZWlnaHQ6IGUueTIgLSBlLnkxICsgZS5zaXplICogMlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gKGUueDEsIGUueTEpIG9uIHJpZ2h0XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDE6IGUueDIgLSBlLnNpemUsXG4gICAgICAgICAgeTE6IGUueTEgLSBlLnNpemUsXG4gICAgICAgICAgeDI6IGUueDEgKyBlLnNpemUsXG4gICAgICAgICAgeTI6IGUueTEgLSBlLnNpemUsXG4gICAgICAgICAgaGVpZ2h0OiBlLnkyIC0gZS55MSArIGUuc2l6ZSAqIDJcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gKGUueDIsIGUueTIpIG9uIHRvcFxuICAgICAgaWYgKGUueDEgPCBlLngyKSB7XG4gICAgICAgIC8vIChlLngxLCBlLnkxKSBvbiBsZWZ0XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDE6IGUueDEgLSBlLnNpemUsXG4gICAgICAgICAgeTE6IGUueTIgLSBlLnNpemUsXG4gICAgICAgICAgeDI6IGUueDIgKyBlLnNpemUsXG4gICAgICAgICAgeTI6IGUueTIgLSBlLnNpemUsXG4gICAgICAgICAgaGVpZ2h0OiBlLnkxIC0gZS55MiArIGUuc2l6ZSAqIDJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIChlLngyLCBlLnkyKSBvbiByaWdodFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IGUueDIgLSBlLnNpemUsXG4gICAgICAgIHkxOiBlLnkyIC0gZS5zaXplLFxuICAgICAgICB4MjogZS54MSArIGUuc2l6ZSxcbiAgICAgICAgeTI6IGUueTIgLSBlLnNpemUsXG4gICAgICAgIGhlaWdodDogZS55MSAtIGUueTIgKyBlLnNpemUgKiAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgZ3JhcGggZWRnZSBvZiB0eXBlICdjdXJ2ZScgd2l0aCB4MSwgeTEsIHgyLCB5MixcbiAgICAgKiBjb250cm9sIHBvaW50IGFuZCBzaXplIGludG8gYW4gYXhpcy1hbGlnbmVkIHNxdWFyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gZSAgQSBncmFwaCBlZGdlIHdpdGggYXQgbGVhc3QgdHdvIHBvaW50c1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBhIHNpemUuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBjcCBBIGNvbnRyb2wgcG9pbnQgKHgseSkuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgICBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBxdWFkcmF0aWNDdXJ2ZVRvU3F1YXJlOiBmdW5jdGlvbihlLCBjcCkge1xuICAgICAgdmFyIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPblF1YWRyYXRpY0N1cnZlKFxuICAgICAgICAwLjUsXG4gICAgICAgIGUueDEsXG4gICAgICAgIGUueTEsXG4gICAgICAgIGUueDIsXG4gICAgICAgIGUueTIsXG4gICAgICAgIGNwLngsXG4gICAgICAgIGNwLnlcbiAgICAgICk7XG5cbiAgICAgIC8vIEJvdW5kaW5nIGJveCBvZiB0aGUgdHdvIHBvaW50cyBhbmQgdGhlIHBvaW50IGF0IHRoZSBtaWRkbGUgb2YgdGhlXG4gICAgICAvLyBjdXJ2ZTpcbiAgICAgIHZhciBtaW5YID0gTWF0aC5taW4oZS54MSwgZS54MiwgcHQueCksXG4gICAgICAgICAgbWF4WCA9IE1hdGgubWF4KGUueDEsIGUueDIsIHB0LngpLFxuICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihlLnkxLCBlLnkyLCBwdC55KSxcbiAgICAgICAgICBtYXhZID0gTWF0aC5tYXgoZS55MSwgZS55MiwgcHQueSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBtaW5YIC0gZS5zaXplLFxuICAgICAgICB5MTogbWluWSAtIGUuc2l6ZSxcbiAgICAgICAgeDI6IG1heFggKyBlLnNpemUsXG4gICAgICAgIHkyOiBtaW5ZIC0gZS5zaXplLFxuICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZICsgZS5zaXplICogMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhIGdyYXBoIHNlbGYgbG9vcCBpbnRvIGFuIGF4aXMtYWxpZ25lZCBzcXVhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IG4gQSBncmFwaCBub2RlIHdpdGggYSBwb2ludCAoeCwgeSkgYW5kIGEgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgQSBzcXVhcmU6IHR3byBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICovXG4gICAgc2VsZkxvb3BUb1NxdWFyZTogZnVuY3Rpb24obikge1xuICAgICAgLy8gRml0dGluZyB0byB0aGUgY3VydmUgaXMgdG9vIGNvc3RseSwgd2UgY29tcHV0ZSBhIGxhcmdlciBib3VuZGluZyBib3hcbiAgICAgIC8vIHVzaW5nIHRoZSBjb250cm9sIHBvaW50czpcbiAgICAgIHZhciBjcCA9IHNpZ21hLnV0aWxzLmdldFNlbGZMb29wQ29udHJvbFBvaW50cyhuLngsIG4ueSwgbi5zaXplKTtcblxuICAgICAgLy8gQm91bmRpbmcgYm94IG9mIHRoZSBwb2ludCBhbmQgdGhlIHR3byBjb250cm9sIHBvaW50czpcbiAgICAgIHZhciBtaW5YID0gTWF0aC5taW4obi54LCBjcC54MSwgY3AueDIpLFxuICAgICAgICAgIG1heFggPSBNYXRoLm1heChuLngsIGNwLngxLCBjcC54MiksXG4gICAgICAgICAgbWluWSA9IE1hdGgubWluKG4ueSwgY3AueTEsIGNwLnkyKSxcbiAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobi55LCBjcC55MSwgY3AueTIpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogbWluWCAtIG4uc2l6ZSxcbiAgICAgICAgeTE6IG1pblkgLSBuLnNpemUsXG4gICAgICAgIHgyOiBtYXhYICsgbi5zaXplLFxuICAgICAgICB5MjogbWluWSAtIG4uc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBtYXhZIC0gbWluWSArIG4uc2l6ZSAqIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgcmVjdGFuZ2xlIGlzIGF4aXMtYWxpZ25lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gIEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50c1xuICAgICAqICAgICAgICAgICAgICAgICAgICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSByZWN0YW5nbGUgaXMgYXhpcy1hbGlnbmVkLlxuICAgICAqL1xuICAgIGlzQXhpc0FsaWduZWQ6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiByLngxID09PSByLngyIHx8IHIueTEgPT09IHIueTI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdG9wIHBvaW50cyBvZiBhbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlLiBUaGlzIGlzIHVzZWZ1bCBpblxuICAgICAqIGNhc2VzIHdoZW4gdGhlIHJlY3RhbmdsZSBoYXMgYmVlbiByb3RhdGVkIChsZWZ0LCByaWdodCBvciBib3R0b20gdXApIGFuZFxuICAgICAqIGxhdGVyIG9wZXJhdGlvbnMgbmVlZCB0byBrbm93IHRoZSB0b3AgcG9pbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50c1xuICAgICAqICAgICAgICAgICAgICAgICAgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHJlY3RhbmdsZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBheGlzQWxpZ25lZFRvcFBvaW50czogZnVuY3Rpb24ocikge1xuXG4gICAgICAvLyBCYXNpY1xuICAgICAgaWYgKHIueTEgPT09IHIueTIgJiYgci54MSA8IHIueDIpXG4gICAgICAgIHJldHVybiByO1xuXG4gICAgICAvLyBSb3RhdGVkIHRvIHJpZ2h0XG4gICAgICBpZiAoci54MSA9PT0gci54MiAmJiByLnkyID4gci55MSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogci54MSAtIHIuaGVpZ2h0LCB5MTogci55MSxcbiAgICAgICAgICB4Mjogci54MSwgeTI6IHIueTEsXG4gICAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAvLyBSb3RhdGVkIHRvIGxlZnRcbiAgICAgIGlmIChyLngxID09PSByLngyICYmIHIueTIgPCByLnkxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiByLngxLCB5MTogci55MixcbiAgICAgICAgICB4Mjogci54MiArIHIuaGVpZ2h0LCB5Mjogci55MixcbiAgICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgIC8vIEJvdHRvbSdzIHVwXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogci54MiwgeTE6IHIueTEgLSByLmhlaWdodCxcbiAgICAgICAgeDI6IHIueDEsIHkyOiByLnkxIC0gci5oZWlnaHQsXG4gICAgICAgIGhlaWdodDogci5oZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjb29yZGluYXRlcyBvZiBhIHJlY3RhbmdsZSdzIGxvd2VyIGxlZnQgY29ybmVyIGZyb20gaXRzIHRvcCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgY29ybmVyICh4LCB5KS5cbiAgICAgKi9cbiAgICBsb3dlckxlZnRDb29yOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgd2lkdGggPSAoXG4gICAgICAgIE1hdGguc3FydChcbiAgICAgICAgICBNYXRoLnBvdyhyLngyIC0gci54MSwgMikgK1xuICAgICAgICAgIE1hdGgucG93KHIueTIgLSByLnkxLCAyKVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByLngxIC0gKHIueTIgLSByLnkxKSAqIHIuaGVpZ2h0IC8gd2lkdGgsXG4gICAgICAgIHk6IHIueTEgKyAoci54MiAtIHIueDEpICogci5oZWlnaHQgLyB3aWR0aFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvb3JkaW5hdGVzIG9mIGEgcmVjdGFuZ2xlJ3MgbG93ZXIgcmlnaHQgY29ybmVyIGZyb20gaXRzIHRvcCBwb2ludHNcbiAgICAgKiBhbmQgaXRzIGxvd2VyIGxlZnQgY29ybmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSBjb3JuZXIncyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgY29ybmVyICh4LCB5KS5cbiAgICAgKi9cbiAgICBsb3dlclJpZ2h0Q29vcjogZnVuY3Rpb24ociwgbGxjKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBsbGMueCAtIHIueDEgKyByLngyLFxuICAgICAgICB5OiBsbGMueSAtIHIueTEgKyByLnkyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvb3JkaW5hdGVzIG9mIGFsbCB0aGUgY29ybmVycyBvZiBhIHJlY3RhbmdsZSBmcm9tIGl0cyB0b3AgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiB0aGUgZm91ciBjb3JuZXJzJyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICovXG4gICAgcmVjdGFuZ2xlQ29ybmVyczogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIGxsYyA9IHRoaXMubG93ZXJMZWZ0Q29vcihyKSxcbiAgICAgICAgICBscmMgPSB0aGlzLmxvd2VyUmlnaHRDb29yKHIsIGxsYyk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt4OiByLngxLCB5OiByLnkxfSxcbiAgICAgICAge3g6IHIueDIsIHk6IHIueTJ9LFxuICAgICAgICB7eDogbGxjLngsIHk6IGxsYy55fSxcbiAgICAgICAge3g6IGxyYy54LCB5OiBscmMueX1cbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNwbGl0IGEgc3F1YXJlIGRlZmluZWQgYnkgaXRzIGJvdW5kYXJpZXMgaW50byBmb3VyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBCb3VuZGFyaWVzIG9mIHRoZSBzcXVhcmUgKHgsIHksIHdpZHRoLCBoZWlnaHQpLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZm91ciBuZXcgc3F1YXJlcywgdGhlbXNlbHZlc1xuICAgICAqICAgICAgICAgICAgICAgICAgZGVmaW5lZCBieSBhbiBhcnJheSBvZiB0aGVpciBmb3VyIGNvcm5lcnMgKHgsIHkpLlxuICAgICAqL1xuICAgIHNwbGl0U3F1YXJlOiBmdW5jdGlvbihiKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueX0sXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHt4OiBiLngsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLngsIHk6IGIueSArIGIuaGVpZ2h0fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0fVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHR9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnkgKyBiLmhlaWdodH1cbiAgICAgICAgXVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgZm91ciBheGlzIGJldHdlZW4gY29ybmVycyBvZiByZWN0YW5nbGUgQSBhbmQgY29ybmVycyBvZlxuICAgICAqIHJlY3RhbmdsZSBCLiBUaGlzIGlzIG5lZWRlZCBsYXRlciB0byBjaGVjayBhbiBldmVudHVhbCBjb2xsaXNpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gQW4gYXJyYXkgb2YgcmVjdGFuZ2xlIEEncyBmb3VyIGNvcm5lcnMgKHgsIHkpLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSBBbiBhcnJheSBvZiByZWN0YW5nbGUgQidzIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIGZvdXIgYXhpcyBkZWZpbmVkIGJ5IHRoZWlyIGNvb3JkaW5hdGVzICh4LHkpLlxuICAgICAqL1xuICAgIGF4aXM6IGZ1bmN0aW9uKGMxLCBjMikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3g6IGMxWzFdLnggLSBjMVswXS54LCB5OiBjMVsxXS55IC0gYzFbMF0ueX0sXG4gICAgICAgIHt4OiBjMVsxXS54IC0gYzFbM10ueCwgeTogYzFbMV0ueSAtIGMxWzNdLnl9LFxuICAgICAgICB7eDogYzJbMF0ueCAtIGMyWzJdLngsIHk6IGMyWzBdLnkgLSBjMlsyXS55fSxcbiAgICAgICAge3g6IGMyWzBdLnggLSBjMlsxXS54LCB5OiBjMlswXS55IC0gYzJbMV0ueX1cbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2plY3QgYSByZWN0YW5nbGUncyBjb3JuZXIgb24gYW4gYXhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgYSBjb3JuZXIgKHgsIHkpLlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgYW4gYXhpcyAoeCwgeSkuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcHJvamVjdGlvbiBkZWZpbmVkIGJ5IGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKi9cbiAgICBwcm9qZWN0aW9uOiBmdW5jdGlvbihjLCBhKSB7XG4gICAgICB2YXIgbCA9IChcbiAgICAgICAgKGMueCAqIGEueCArIGMueSAqIGEueSkgL1xuICAgICAgICAoTWF0aC5wb3coYS54LCAyKSArIE1hdGgucG93KGEueSwgMikpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBsICogYS54LFxuICAgICAgICB5OiBsICogYS55XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHR3byByZWN0YW5nbGVzIGNvbGxpZGUgb24gb25lIHBhcnRpY3VsYXIgYXhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICBBbiBheGlzJyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBBJ3MgY29ybmVycy5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEIncyBjb3JuZXJzLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIHRoZSByZWN0YW5nbGVzIGNvbGxpZGUgb24gdGhlIGF4aXMuXG4gICAgICovXG4gICAgYXhpc0NvbGxpc2lvbjogZnVuY3Rpb24oYSwgYzEsIGMyKSB7XG4gICAgICB2YXIgc2MxID0gW10sXG4gICAgICAgICAgc2MyID0gW107XG5cbiAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCA0OyBjaSsrKSB7XG4gICAgICAgIHZhciBwMSA9IHRoaXMucHJvamVjdGlvbihjMVtjaV0sIGEpLFxuICAgICAgICAgICAgcDIgPSB0aGlzLnByb2plY3Rpb24oYzJbY2ldLCBhKTtcblxuICAgICAgICBzYzEucHVzaChwMS54ICogYS54ICsgcDEueSAqIGEueSk7XG4gICAgICAgIHNjMi5wdXNoKHAyLnggKiBhLnggKyBwMi55ICogYS55KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heGMxID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgc2MxKSxcbiAgICAgICAgICBtYXhjMiA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjMiksXG4gICAgICAgICAgbWluYzEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBzYzEpLFxuICAgICAgICAgIG1pbmMyID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgc2MyKTtcblxuICAgICAgcmV0dXJuIChtaW5jMiA8PSBtYXhjMSAmJiBtYXhjMiA+PSBtaW5jMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdHdvIHJlY3RhbmdsZXMgY29sbGlkZSBvbiBlYWNoIG9uZSBvZiB0aGVpciBmb3VyIGF4aXMuIElmXG4gICAgICogYWxsIGF4aXMgY29sbGlkZSwgdGhlbiB0aGUgdHdvIHJlY3RhbmdsZXMgZG8gY29sbGlkZSBvbiB0aGUgcGxhbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEEncyBjb3JuZXJzLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQidzIGNvcm5lcnMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgdGhlIHJlY3RhbmdsZXMgY29sbGlkZS5cbiAgICAgKi9cbiAgICBjb2xsaXNpb246IGZ1bmN0aW9uKGMxLCBjMikge1xuICAgICAgdmFyIGF4aXMgPSB0aGlzLmF4aXMoYzEsIGMyKSxcbiAgICAgICAgICBjb2wgPSB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICAgICAgY29sID0gY29sICYmIHRoaXMuYXhpc0NvbGxpc2lvbihheGlzW2ldLCBjMSwgYzIpO1xuXG4gICAgICByZXR1cm4gY29sO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBRdWFkIEZ1bmN0aW9uc1xuICAgKiAtLS0tLS0tLS0tLS1cbiAgICpcbiAgICogVGhlIFF1YWR0cmVlIGZ1bmN0aW9ucyB0aGVtc2VsdmVzLlxuICAgKiBGb3IgZWFjaCBvZiB0aG9zZSBmdW5jdGlvbnMsIHdlIGNvbnNpZGVyIHRoYXQgaW4gYSBzcGxpdHRlZCBxdWFkLCB0aGVcbiAgICogaW5kZXggb2YgZWFjaCBub2RlIGlzIHRoZSBmb2xsb3dpbmc6XG4gICAqIDA6IHRvcCBsZWZ0XG4gICAqIDE6IHRvcCByaWdodFxuICAgKiAyOiBib3R0b20gbGVmdFxuICAgKiAzOiBib3R0b20gcmlnaHRcbiAgICpcbiAgICogTW9yZW92ZXIsIHRoZSBoZXJlYWZ0ZXIgcXVhZCdzIHBoaWxvc29waHkgaXMgdG8gY29uc2lkZXIgdGhhdCBpZiBhbiBlbGVtZW50XG4gICAqIGNvbGxpZGVzIHdpdGggbW9yZSB0aGFuIG9uZSBub2RlcywgdGhpcyBlbGVtZW50IGJlbG9uZ3MgdG8gZWFjaCBvZiB0aGVcbiAgICogbm9kZXMgaXQgY29sbGlkZXMgd2l0aCB3aGVyZSBvdGhlciB3b3VsZCBsZXQgaXQgbGllIG9uIGEgaGlnaGVyIG5vZGUuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGluZGV4IG9mIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIHBvaW50IGluIHRoZSBxdWFkXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHBvaW50ICAgICAgQSBwb2ludCBkZWZpbmVkIGJ5IGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcXVhZEJvdW5kcyBCb3VuZGFyaWVzIG9mIHRoZSBxdWFkICh4LCB5LCB3aWR0aCwgaGVpZ3RoKS5cbiAgICogQHJldHVybiB7aW50ZWdlcn0gICAgICAgICAgICBUaGUgaW5kZXggb2YgdGhlIG5vZGUgY29udGFpbmluZyB0aGUgcG9pbnQuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZEluZGV4KHBvaW50LCBxdWFkQm91bmRzKSB7XG4gICAgdmFyIHhtcCA9IHF1YWRCb3VuZHMueCArIHF1YWRCb3VuZHMud2lkdGggLyAyLFxuICAgICAgICB5bXAgPSBxdWFkQm91bmRzLnkgKyBxdWFkQm91bmRzLmhlaWdodCAvIDIsXG4gICAgICAgIHRvcCA9IChwb2ludC55IDwgeW1wKSxcbiAgICAgICAgbGVmdCA9IChwb2ludC54IDwgeG1wKTtcblxuICAgIGlmICh0b3ApIHtcbiAgICAgIGlmIChsZWZ0KVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGxlZnQpXG4gICAgICAgIHJldHVybiAyO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBpbmRleGVzIG9mIG5vZGVzIGNvbnRhaW5pbmcgYW4gYXhpcy1hbGlnbmVkIHJlY3RhbmdsZVxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICByZWN0YW5nbGUgICBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSAge2FycmF5fSAgIHF1YWRDb3JuZXJzIEFuIGFycmF5IG9mIHRoZSBxdWFkIG5vZGVzJyBjb3JuZXJzLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICBBbiBhcnJheSBvZiBpbmRleGVzIGNvbnRhaW5pbmcgb25lIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXIgaW50ZWdlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZEluZGV4ZXMocmVjdGFuZ2xlLCBxdWFkQ29ybmVycykge1xuICAgIHZhciBpbmRleGVzID0gW107XG5cbiAgICAvLyBJdGVyYXRpbmcgdGhyb3VnaCBxdWFkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgaWYgKChyZWN0YW5nbGUueDIgPj0gcXVhZENvcm5lcnNbaV1bMF0ueCkgJiZcbiAgICAgICAgICAocmVjdGFuZ2xlLngxIDw9IHF1YWRDb3JuZXJzW2ldWzFdLngpICYmXG4gICAgICAgICAgKHJlY3RhbmdsZS55MSArIHJlY3RhbmdsZS5oZWlnaHQgPj0gcXVhZENvcm5lcnNbaV1bMF0ueSkgJiZcbiAgICAgICAgICAocmVjdGFuZ2xlLnkxIDw9IHF1YWRDb3JuZXJzW2ldWzJdLnkpKVxuICAgICAgICBpbmRleGVzLnB1c2goaSk7XG5cbiAgICByZXR1cm4gaW5kZXhlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGluZGV4ZXMgb2Ygbm9kZXMgY29udGFpbmluZyBhIG5vbi1heGlzLWFsaWduZWQgcmVjdGFuZ2xlXG4gICAqXG4gICAqIEBwYXJhbSAge2FycmF5fSAgY29ybmVycyAgICAgIEFuIGFycmF5IGNvbnRhaW5pbmcgZWFjaCBjb3JuZXIgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IGl0cyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAqIEBwYXJhbSAge2FycmF5fSAgcXVhZENvcm5lcnMgIEFuIGFycmF5IG9mIHRoZSBxdWFkIG5vZGVzJyBjb3JuZXJzLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICBBbiBhcnJheSBvZiBpbmRleGVzIGNvbnRhaW5pbmcgb25lIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXIgaW50ZWdlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZENvbGxpc2lvbihjb3JuZXJzLCBxdWFkQ29ybmVycykge1xuICAgIHZhciBpbmRleGVzID0gW107XG5cbiAgICAvLyBJdGVyYXRpbmcgdGhyb3VnaCBxdWFkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgaWYgKF9nZW9tLmNvbGxpc2lvbihjb3JuZXJzLCBxdWFkQ29ybmVyc1tpXSkpXG4gICAgICAgIGluZGV4ZXMucHVzaChpKTtcblxuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YmRpdmlkZSBhIHF1YWQgYnkgY3JlYXRpbmcgYSBub2RlIGF0IGEgcHJlY2lzZSBpbmRleC4gVGhlIGZ1bmN0aW9uIGRvZXNcbiAgICogbm90IGdlbmVyYXRlIGFsbCBmb3VyIG5vZGVzIG5vdCB0byBwb3RlbnRpYWxseSBjcmVhdGUgdW51c2VkIG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGNyZWF0ZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgIHF1YWQgIFRoZSBxdWFkIG9iamVjdCB0byBzdWJkaXZpZGUuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBBIG5ldyBxdWFkIHJlcHJlc2VudGluZyB0aGUgbm9kZSBjcmVhdGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRTdWJkaXZpZGUoaW5kZXgsIHF1YWQpIHtcbiAgICB2YXIgbmV4dCA9IHF1YWQubGV2ZWwgKyAxLFxuICAgICAgICBzdWJ3ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy53aWR0aCAvIDIpLFxuICAgICAgICBzdWJoID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy5oZWlnaHQgLyAyKSxcbiAgICAgICAgcXggPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLngpLFxuICAgICAgICBxeSA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMueSksXG4gICAgICAgIHgsXG4gICAgICAgIHk7XG5cbiAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHggPSBxeDtcbiAgICAgICAgeSA9IHF5O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgeCA9IHF4ICsgc3VidztcbiAgICAgICAgeSA9IHF5O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgeCA9IHF4O1xuICAgICAgICB5ID0gcXkgKyBzdWJoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgeCA9IHF4ICsgc3VidztcbiAgICAgICAgeSA9IHF5ICsgc3ViaDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9xdWFkVHJlZShcbiAgICAgIHt4OiB4LCB5OiB5LCB3aWR0aDogc3VidywgaGVpZ2h0OiBzdWJofSxcbiAgICAgIG5leHQsXG4gICAgICBxdWFkLm1heEVsZW1lbnRzLFxuICAgICAgcXVhZC5tYXhMZXZlbFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgaW5zZXJ0IGFuIGVsZW1lbnQgaW50byB0aGUgcXVhZHRyZWUuIE9ubHkgcG9pbnRzXG4gICAqIHdpdGggc2l6ZSwgaS5lLiBheGlzLWFsaWduZWQgc3F1YXJlcywgbWF5IGJlIGluc2VydGVkIHdpdGggdGhpc1xuICAgKiBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIGVsICAgICAgICAgVGhlIGVsZW1lbnQgdG8gaW5zZXJ0IGluIHRoZSBxdWFkdHJlZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgc2l6ZWRQb2ludCBBIHNpemVkIHBvaW50IGRlZmluZWQgYnkgdHdvIHRvcCBwb2ludHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcXVhZCAgICAgICBUaGUgcXVhZCBpbiB3aGljaCB0byBpbnNlcnQgdGhlIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH0gICAgICAgICAgVGhlIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhbnl0aGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5zZXJ0KGVsLCBzaXplZFBvaW50LCBxdWFkKSB7XG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XG5cbiAgICAgIC8vIFNlYXJjaGluZyBhcHByb3ByaWF0ZSBxdWFkc1xuICAgICAgdmFyIGluZGV4ZXMgPSBfcXVhZEluZGV4ZXMoc2l6ZWRQb2ludCwgcXVhZC5jb3JuZXJzKTtcblxuICAgICAgLy8gSXRlcmF0aW5nXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluZGV4ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgLy8gU3ViZGl2aWRpbmcgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4ZXNbaV1dID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcXVhZC5ub2Rlc1tpbmRleGVzW2ldXSA9IF9xdWFkU3ViZGl2aWRlKGluZGV4ZXNbaV0sIHF1YWQpO1xuXG4gICAgICAgIC8vIFJlY3Vyc2lvblxuICAgICAgICBfcXVhZEluc2VydChlbCwgc2l6ZWRQb2ludCwgcXVhZC5ub2Rlc1tpbmRleGVzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAvLyBQdXNoaW5nIHRoZSBlbGVtZW50IGluIGEgbGVhZiBub2RlXG4gICAgICBxdWFkLmVsZW1lbnRzLnB1c2goZWwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSByZXRyaWV2ZSBldmVyeSBlbGVtZW50cyBoZWxkIGJ5IHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlXG4gICAqIHNlYXJjaGVkIHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBwb2ludCBUaGUgc2VhcmNoZWQgcG9pbnQgKHgsIHkpLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkICBUaGUgc2VhcmNoZWQgcXVhZC5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgQW4gYXJyYXkgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSByZWxldmFudFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRSZXRyaWV2ZVBvaW50KHBvaW50LCBxdWFkKSB7XG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XG4gICAgICB2YXIgaW5kZXggPSBfcXVhZEluZGV4KHBvaW50LCBxdWFkLmJvdW5kcyk7XG5cbiAgICAgIC8vIElmIG5vZGUgZG9lcyBub3QgZXhpc3Qgd2UgcmV0dXJuIGFuIGVtcHR5IGxpc3RcbiAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBfcXVhZFJldHJpZXZlUG9pbnQocG9pbnQsIHF1YWQubm9kZXNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHF1YWQuZWxlbWVudHM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHJldHJpZXZlIGV2ZXJ5IGVsZW1lbnRzIGNvbnRhaW5lZCB3aXRoaW4gYW4gcmVjdGFuZ3VsYXIgYXJlYVxuICAgKiB0aGF0IG1heSBvciBtYXkgbm90IGJlIGF4aXMtYWxpZ25lZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fGFycmF5fSByZWN0RGF0YSAgICAgICBUaGUgc2VhcmNoZWQgYXJlYSBkZWZpbmVkIGVpdGhlciBieVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGFycmF5IG9mIGZvdXIgY29ybmVycyAoeCwgeSkgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY2FzZSBvZiBhIG5vbi1heGlzLWFsaWduZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgb3IgYW4gb2JqZWN0IHdpdGggdHdvIHRvcFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICBxdWFkICAgICAgICAgICBUaGUgc2VhcmNoZWQgcXVhZC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICAgICBjb2xsaXNpb25GdW5jICBUaGUgY29sbGlzaW9uIGZ1bmN0aW9uIHVzZWQgdG8gc2VhcmNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG5vZGUgaW5kZXhlcy5cbiAgICogQHBhcmFtICB7YXJyYXk/fSAgICAgICBlbHMgICAgICAgICAgICBUaGUgcmV0cmlldmVkIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRSZXRyaWV2ZUFyZWEocmVjdERhdGEsIHF1YWQsIGNvbGxpc2lvbkZ1bmMsIGVscykge1xuICAgIGVscyA9IGVscyB8fCB7fTtcblxuICAgIGlmIChxdWFkLmxldmVsIDwgcXVhZC5tYXhMZXZlbCkge1xuICAgICAgdmFyIGluZGV4ZXMgPSBjb2xsaXNpb25GdW5jKHJlY3REYXRhLCBxdWFkLmNvcm5lcnMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluZGV4ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAocXVhZC5ub2Rlc1tpbmRleGVzW2ldXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIF9xdWFkUmV0cmlldmVBcmVhKFxuICAgICAgICAgICAgcmVjdERhdGEsXG4gICAgICAgICAgICBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dLFxuICAgICAgICAgICAgY29sbGlzaW9uRnVuYyxcbiAgICAgICAgICAgIGVsc1xuICAgICAgICAgICk7XG4gICAgfSBlbHNlXG4gICAgICBmb3IgKHZhciBqID0gMCwgbSA9IHF1YWQuZWxlbWVudHMubGVuZ3RoOyBqIDwgbTsgaisrKVxuICAgICAgICBpZiAoZWxzW3F1YWQuZWxlbWVudHNbal0uaWRdID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgZWxzW3F1YWQuZWxlbWVudHNbal0uaWRdID0gcXVhZC5lbGVtZW50c1tqXTtcblxuICAgIHJldHVybiBlbHM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgcXVhZHRyZWUgb2JqZWN0IGl0c2VsZi5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgIGJvdW5kcyAgICAgICBUaGUgYm91bmRhcmllcyBvZiB0aGUgcXVhZCBkZWZpbmVkIGJ5IGFuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luICh4LCB5KSwgd2lkdGggYW5kIGhlaWd0aC5cbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIGxldmVsICAgICAgICBUaGUgbGV2ZWwgb2YgdGhlIHF1YWQgaW4gdGhlIHRyZWUuXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBtYXhFbGVtZW50cyAgVGhlIG1heCBudW1iZXIgb2YgZWxlbWVudCBpbiBhIGxlYWYgbm9kZS5cbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIG1heExldmVsICAgICBUaGUgbWF4IHJlY3Vyc2lvbiBsZXZlbCBvZiB0aGUgdHJlZS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICBUaGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRUcmVlKGJvdW5kcywgbGV2ZWwsIG1heEVsZW1lbnRzLCBtYXhMZXZlbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbDogbGV2ZWwgfHwgMCxcbiAgICAgIGJvdW5kczogYm91bmRzLFxuICAgICAgY29ybmVyczogX2dlb20uc3BsaXRTcXVhcmUoYm91bmRzKSxcbiAgICAgIG1heEVsZW1lbnRzOiBtYXhFbGVtZW50cyB8fCA0MCxcbiAgICAgIG1heExldmVsOiBtYXhMZXZlbCB8fCA4LFxuICAgICAgZWxlbWVudHM6IFtdLFxuICAgICAgbm9kZXM6IFtdXG4gICAgfTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNpZ21hIFF1YWQgQ29uc3RydWN0b3JcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBUaGUgZWRnZXF1YWQgQVBJIGFzIGV4cG9zZWQgdG8gc2lnbWEuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgZWRnZXF1YWQgY29yZSB0aGF0IHdpbGwgYmVjb21lIHRoZSBzaWdtYSBpbnRlcmZhY2Ugd2l0aCB0aGUgcXVhZHRyZWUuXG4gICAqXG4gICAqIHByb3BlcnR5IHtvYmplY3R9IF90cmVlICAgICBQcm9wZXJ0eSBob2xkaW5nIHRoZSBxdWFkdHJlZSBvYmplY3QuXG4gICAqIHByb3BlcnR5IHtvYmplY3R9IF9nZW9tICAgICBFeHBvc2l0aW9uIG9mIHRoZSBfZ2VvbSBuYW1lc3BhY2UgZm9yIHRlc3RpbmcuXG4gICAqIHByb3BlcnR5IHtvYmplY3R9IF9jYWNoZSAgICBDYWNoZSBmb3IgdGhlIGFyZWEgbWV0aG9kLlxuICAgKiBwcm9wZXJ0eSB7Ym9vbGVhbn0gX2VuYWJsZWQgQ2FuIGluZGV4IGFuZCByZXRyZWl2ZSBlbGVtZW50cy5cbiAgICovXG4gIHZhciBlZGdlcXVhZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2dlb20gPSBfZ2VvbTtcbiAgICB0aGlzLl90cmVlID0gbnVsbDtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIHF1ZXJ5OiBmYWxzZSxcbiAgICAgIHJlc3VsdDogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbmRleCBhIGdyYXBoIGJ5IGluc2VydGluZyBpdHMgZWRnZXMgaW50byB0aGUgcXVhZHRyZWUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gZ3JhcGggICBBIGdyYXBoIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtcyAgQW4gb2JqZWN0IG9mIHBhcmFtZXRlcnMgd2l0aCBhdCBsZWFzdCB0aGUgcXVhZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgVGhlIHF1YWR0cmVlIG9iamVjdC5cbiAgICpcbiAgICogUGFyYW1ldGVyczpcbiAgICogLS0tLS0tLS0tLVxuICAgKiBib3VuZHM6ICAgICAge29iamVjdH0gICBib3VuZGFyaWVzIG9mIHRoZSBxdWFkIGRlZmluZWQgYnkgaXRzIG9yaWdpbiAoeCwgeSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggYW5kIGhlaWd0aC5cbiAgICogcHJlZml4OiAgICAgIHtzdHJpbmc/fSAgYSBwcmVmaXggZm9yIGVkZ2UgZ2VvbWV0cmljIGF0dHJpYnV0ZXMuXG4gICAqIG1heEVsZW1lbnRzOiB7aW50ZWdlcj99IHRoZSBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIGEgbGVhZiBub2RlLlxuICAgKiBtYXhMZXZlbDogICAge2ludGVnZXI/fSB0aGUgbWF4IHJlY3Vyc2lvbiBsZXZlbCBvZiB0aGUgdHJlZS5cbiAgICovXG4gIGVkZ2VxdWFkLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uKGdyYXBoLCBwYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMuX2VuYWJsZWQpXG4gICAgICByZXR1cm4gdGhpcy5fdHJlZTtcblxuICAgIC8vIEVuZm9yY2luZyBwcmVzZW5jZSBvZiBib3VuZGFyaWVzXG4gICAgaWYgKCFwYXJhbXMuYm91bmRzKVxuICAgICAgdGhyb3cgJ3NpZ21hLmNsYXNzZXMuZWRnZXF1YWQuaW5kZXg6IGJvdW5kcyBpbmZvcm1hdGlvbiBub3QgZ2l2ZW4uJztcblxuICAgIC8vIFByZWZpeFxuICAgIHZhciBwcmVmaXggPSBwYXJhbXMucHJlZml4IHx8ICcnLFxuICAgICAgICBjcCxcbiAgICAgICAgc291cmNlLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIG4sXG4gICAgICAgIGU7XG5cbiAgICAvLyBCdWlsZGluZyB0aGUgdHJlZVxuICAgIHRoaXMuX3RyZWUgPSBfcXVhZFRyZWUoXG4gICAgICBwYXJhbXMuYm91bmRzLFxuICAgICAgMCxcbiAgICAgIHBhcmFtcy5tYXhFbGVtZW50cyxcbiAgICAgIHBhcmFtcy5tYXhMZXZlbFxuICAgICk7XG5cbiAgICB2YXIgZWRnZXMgPSBncmFwaC5lZGdlcygpO1xuXG4gICAgLy8gSW5zZXJ0aW5nIGdyYXBoIGVkZ2VzIGludG8gdGhlIHRyZWVcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVkZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc291cmNlID0gZ3JhcGgubm9kZXMoZWRnZXNbaV0uc291cmNlKTtcbiAgICAgIHRhcmdldCA9IGdyYXBoLm5vZGVzKGVkZ2VzW2ldLnRhcmdldCk7XG4gICAgICBlID0ge1xuICAgICAgICB4MTogc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgIHkxOiBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgeDI6IHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICB5MjogdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgIHNpemU6IGVkZ2VzW2ldW3ByZWZpeCArICdzaXplJ10gfHwgMFxuICAgICAgfTtcblxuICAgICAgLy8gSW5zZXJ0aW5nIGVkZ2VcbiAgICAgIGlmIChlZGdlc1tpXS50eXBlID09PSAnY3VydmUnIHx8IGVkZ2VzW2ldLnR5cGUgPT09ICdjdXJ2ZWRBcnJvdycpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSB7XG4gICAgICAgICAgbiA9IHtcbiAgICAgICAgICAgIHg6IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgeTogc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICBzaXplOiBzb3VyY2VbcHJlZml4ICsgJ3NpemUnXSB8fCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBfcXVhZEluc2VydChcbiAgICAgICAgICAgIGVkZ2VzW2ldLFxuICAgICAgICAgICAgX2dlb20uc2VsZkxvb3BUb1NxdWFyZShuKSxcbiAgICAgICAgICAgIHRoaXMuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNwID0gc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50KGUueDEsIGUueTEsIGUueDIsIGUueTIpO1xuICAgICAgICAgIF9xdWFkSW5zZXJ0KFxuICAgICAgICAgICAgZWRnZXNbaV0sXG4gICAgICAgICAgICBfZ2VvbS5xdWFkcmF0aWNDdXJ2ZVRvU3F1YXJlKGUsIGNwKSxcbiAgICAgICAgICAgIHRoaXMuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgX3F1YWRJbnNlcnQoXG4gICAgICAgICAgZWRnZXNbaV0sXG4gICAgICAgICAgX2dlb20ubGluZVRvU3F1YXJlKGUpLFxuICAgICAgICAgIHRoaXMuX3RyZWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc2V0IGNhY2hlOlxuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgcXVlcnk6IGZhbHNlLFxuICAgICAgcmVzdWx0OiBmYWxzZVxuICAgIH07XG5cbiAgICAvLyByZW1vdmU/XG4gICAgcmV0dXJuIHRoaXMuX3RyZWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGV2ZXJ5IGdyYXBoIGVkZ2VzIGhlbGQgYnkgdGhlIHF1YWR0cmVlIG5vZGUgY29udGFpbmluZyB0aGVcbiAgICogc2VhcmNoZWQgcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geCBvZiB0aGUgcG9pbnQuXG4gICAqIEBwYXJhbSAge251bWJlcn0geSBvZiB0aGUgcG9pbnQuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgb2YgZWRnZXMgcmV0cmlldmVkLlxuICAgKi9cbiAgZWRnZXF1YWQucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICghdGhpcy5fZW5hYmxlZClcbiAgICAgIHJldHVybiBbXTtcblxuICAgIHJldHVybiB0aGlzLl90cmVlID9cbiAgICAgIF9xdWFkUmV0cmlldmVQb2ludCh7eDogeCwgeTogeX0sIHRoaXMuX3RyZWUpIHx8IFtdIDpcbiAgICAgIFtdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBldmVyeSBncmFwaCBlZGdlcyB3aXRoaW4gYSByZWN0YW5ndWxhciBhcmVhLiBUaGUgbWV0aG9kcyBrZWVwIHRoZVxuICAgKiBsYXN0IGFyZWEgcXVlcmllZCBpbiBjYWNoZSBmb3Igb3B0aW1pemF0aW9uIHJlYXNvbiBhbmQgd2lsbCBhY3QgZGlmZmVyZW50bHlcbiAgICogZm9yIHRoZSBzYW1lIHJlYXNvbiBpZiB0aGUgYXJlYSBpcyBheGlzLWFsaWduZWQgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHRvcCBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpXG4gICAqICAgICAgICAgICAgICAgICAgYW5kIGhlaWdodC5cbiAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiBlZGdlcyByZXRyaWV2ZWQuXG4gICAqL1xuICBlZGdlcXVhZC5wcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICBpZiAoIXRoaXMuX2VuYWJsZWQpXG4gICAgICByZXR1cm4gW107XG5cbiAgICB2YXIgc2VyaWFsaXplZCA9IEpTT04uc3RyaW5naWZ5KHJlY3QpLFxuICAgICAgICBjb2xsaXNpb25GdW5jLFxuICAgICAgICByZWN0RGF0YTtcblxuICAgIC8vIFJldHVybmluZyBjYWNoZT9cbiAgICBpZiAodGhpcy5fY2FjaGUucXVlcnkgPT09IHNlcmlhbGl6ZWQpXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGUucmVzdWx0O1xuXG4gICAgLy8gQXhpcyBhbGlnbmVkID9cbiAgICBpZiAoX2dlb20uaXNBeGlzQWxpZ25lZChyZWN0KSkge1xuICAgICAgY29sbGlzaW9uRnVuYyA9IF9xdWFkSW5kZXhlcztcbiAgICAgIHJlY3REYXRhID0gX2dlb20uYXhpc0FsaWduZWRUb3BQb2ludHMocmVjdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29sbGlzaW9uRnVuYyA9IF9xdWFkQ29sbGlzaW9uO1xuICAgICAgcmVjdERhdGEgPSBfZ2VvbS5yZWN0YW5nbGVDb3JuZXJzKHJlY3QpO1xuICAgIH1cblxuICAgIC8vIFJldHJpZXZpbmcgZWRnZXNcbiAgICB2YXIgZWRnZXMgPSB0aGlzLl90cmVlID9cbiAgICAgIF9xdWFkUmV0cmlldmVBcmVhKFxuICAgICAgICByZWN0RGF0YSxcbiAgICAgICAgdGhpcy5fdHJlZSxcbiAgICAgICAgY29sbGlzaW9uRnVuY1xuICAgICAgKSA6XG4gICAgICBbXTtcblxuICAgIC8vIE9iamVjdCB0byBhcnJheVxuICAgIHZhciBlZGdlc0FycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBlZGdlcylcbiAgICAgIGVkZ2VzQXJyYXkucHVzaChlZGdlc1tpXSk7XG5cbiAgICAvLyBDYWNoaW5nXG4gICAgdGhpcy5fY2FjaGUucXVlcnkgPSBzZXJpYWxpemVkO1xuICAgIHRoaXMuX2NhY2hlLnJlc3VsdCA9IGVkZ2VzQXJyYXk7XG5cbiAgICByZXR1cm4gZWRnZXNBcnJheTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBFWFBPUlQ6XG4gICAqICoqKioqKipcbiAgICovXG4gIGlmICh0eXBlb2YgdGhpcy5zaWdtYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMgPSB0aGlzLnNpZ21hLmNsYXNzZXMgfHwge307XG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzLmVkZ2VxdWFkID0gZWRnZXF1YWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZWRnZXF1YWQ7XG4gICAgZXhwb3J0cy5lZGdlcXVhZCA9IGVkZ2VxdWFkO1xuICB9IGVsc2VcbiAgICB0aGlzLmVkZ2VxdWFkID0gZWRnZXF1YWQ7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYXB0b3JzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSB1c2VyIGlucHV0cyBkZWZhdWx0IGNhcHRvci4gSXQgZGVhbHMgd2l0aCBtb3VzZSBldmVudHMsIGtleWJvYXJkc1xuICAgKiBldmVudHMgYW5kIHRvdWNoIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICB0YXJnZXQgICBUaGUgRE9NIGVsZW1lbnQgd2hlcmUgdGhlIGxpc3RlbmVycyB3aWxsIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmQuXG4gICAqIEBwYXJhbSAge2NhbWVyYX0gICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYSByZWxhdGVkIHRvIHRoZSB0YXJnZXQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5jYXB0b3J9ICAgICAgICAgIFRoZSBmcmVzaCBuZXcgY2FwdG9yIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEuY2FwdG9ycy5tb3VzZSA9IGZ1bmN0aW9uKHRhcmdldCwgY2FtZXJhLCBzZXR0aW5ncykge1xuICAgIHZhciBfc2VsZiA9IHRoaXMsXG4gICAgICAgIF90YXJnZXQgPSB0YXJnZXQsXG4gICAgICAgIF9jYW1lcmEgPSBjYW1lcmEsXG4gICAgICAgIF9zZXR0aW5ncyA9IHNldHRpbmdzLFxuXG4gICAgICAgIC8vIENBTUVSQSBNQU5BR0VNRU5UOlxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKipcbiAgICAgICAgLy8gVGhlIGNhbWVyYSBwb3NpdGlvbiB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZzpcbiAgICAgICAgX3N0YXJ0Q2FtZXJhWCxcbiAgICAgICAgX3N0YXJ0Q2FtZXJhWSxcbiAgICAgICAgX3N0YXJ0Q2FtZXJhQW5nbGUsXG5cbiAgICAgICAgLy8gVGhlIGxhdGVzdCBzdGFnZSBwb3NpdGlvbjpcbiAgICAgICAgX2xhc3RDYW1lcmFYLFxuICAgICAgICBfbGFzdENhbWVyYVksXG4gICAgICAgIF9sYXN0Q2FtZXJhQW5nbGUsXG4gICAgICAgIF9sYXN0Q2FtZXJhUmF0aW8sXG5cbiAgICAgICAgLy8gTU9VU0UgTUFOQUdFTUVOVDpcbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKipcbiAgICAgICAgLy8gVGhlIG1vdXNlIHBvc2l0aW9uIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nOlxuICAgICAgICBfc3RhcnRNb3VzZVgsXG4gICAgICAgIF9zdGFydE1vdXNlWSxcblxuICAgICAgICBfaXNNb3VzZURvd24sXG4gICAgICAgIF9pc01vdmluZyxcbiAgICAgICAgX2hhc0RyYWdnZWQsXG4gICAgICAgIF9kb3duU3RhcnRUaW1lLFxuICAgICAgICBfbW92aW5nVGltZW91dElkO1xuXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIHNpZ21hLnV0aWxzLmRvdWJsZUNsaWNrKF90YXJnZXQsICdjbGljaycsIF9kb3VibGVDbGlja0hhbmRsZXIpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBfd2hlZWxIYW5kbGVyLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgX3doZWVsSGFuZGxlciwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX21vdmVIYW5kbGVyLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBfZG93bkhhbmRsZXIsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX2NsaWNrSGFuZGxlciwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBfb3V0SGFuZGxlciwgZmFsc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfdXBIYW5kbGVyLCBmYWxzZSk7XG5cblxuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1bmJpbmRzIGV2ZXJ5IGhhbmRsZXJzIHRoYXQgbWFrZXMgdGhlIGNhcHRvciB3b3JrLlxuICAgICAqL1xuICAgIHRoaXMua2lsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2lnbWEudXRpbHMudW5iaW5kRG91YmxlQ2xpY2soX3RhcmdldCwgJ2NsaWNrJyk7XG4gICAgICBfdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgX3doZWVsSGFuZGxlcik7XG4gICAgICBfdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBfd2hlZWxIYW5kbGVyKTtcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX21vdmVIYW5kbGVyKTtcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgX2Rvd25IYW5kbGVyKTtcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfY2xpY2tIYW5kbGVyKTtcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBfb3V0SGFuZGxlcik7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX3VwSGFuZGxlcik7XG4gICAgfTtcblxuXG5cblxuICAgIC8vIE1PVVNFIEVWRU5UUzpcbiAgICAvLyAqKioqKioqKioqKioqXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICdtb3ZlJyBtb3VzZSBldmVudC4gSXQgd2lsbCBlZmZlY3RpdmVseVxuICAgICAqIGRyYWcgdGhlIGdyYXBoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9tb3ZlSGFuZGxlcihlKSB7XG4gICAgICB2YXIgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIHBvcztcblxuICAgICAgLy8gRGlzcGF0Y2ggZXZlbnQ6XG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSkge1xuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdtb3VzZW1vdmUnLFxuICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUpKTtcblxuICAgICAgICBpZiAoX2lzTW91c2VEb3duKSB7XG4gICAgICAgICAgX2lzTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICBfaGFzRHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoX21vdmluZ1RpbWVvdXRJZClcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfbW92aW5nVGltZW91dElkKTtcblxuICAgICAgICAgIF9tb3ZpbmdUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX2lzTW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgfSwgX3NldHRpbmdzKCdkcmFnVGltZW91dCcpKTtcblxuICAgICAgICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmtpbGxBbGwoX2NhbWVyYSk7XG5cbiAgICAgICAgICBfY2FtZXJhLmlzTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICBwb3MgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WChlKSAtIF9zdGFydE1vdXNlWCxcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldFkoZSkgLSBfc3RhcnRNb3VzZVksXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHggPSBfc3RhcnRDYW1lcmFYIC0gcG9zLng7XG4gICAgICAgICAgeSA9IF9zdGFydENhbWVyYVkgLSBwb3MueTtcblxuICAgICAgICAgIGlmICh4ICE9PSBfY2FtZXJhLnggfHwgeSAhPT0gX2NhbWVyYS55KSB7XG4gICAgICAgICAgICBfbGFzdENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICBfbGFzdENhbWVyYVkgPSBfY2FtZXJhLnk7XG5cbiAgICAgICAgICAgIF9jYW1lcmEuZ29Ubyh7XG4gICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KVxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblxuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAndXAnIG1vdXNlIGV2ZW50LiBJdCB3aWxsIHN0b3AgZHJhZ2dpbmcgdGhlXG4gICAgICogZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3VwSGFuZGxlcihlKSB7XG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSAmJiBfaXNNb3VzZURvd24pIHtcbiAgICAgICAgX2lzTW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIGlmIChfbW92aW5nVGltZW91dElkKVxuICAgICAgICAgIGNsZWFyVGltZW91dChfbW92aW5nVGltZW91dElkKTtcblxuICAgICAgICBfY2FtZXJhLmlzTW92aW5nID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIHggPSBzaWdtYS51dGlscy5nZXRYKGUpLFxuICAgICAgICAgICAgeSA9IHNpZ21hLnV0aWxzLmdldFkoZSk7XG5cbiAgICAgICAgaWYgKF9pc01vdmluZykge1xuICAgICAgICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmtpbGxBbGwoX2NhbWVyYSk7XG4gICAgICAgICAgc2lnbWEubWlzYy5hbmltYXRpb24uY2FtZXJhKFxuICAgICAgICAgICAgX2NhbWVyYSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogX2NhbWVyYS54ICtcbiAgICAgICAgICAgICAgICBfc2V0dGluZ3MoJ21vdXNlSW5lcnRpYVJhdGlvJykgKiAoX2NhbWVyYS54IC0gX2xhc3RDYW1lcmFYKSxcbiAgICAgICAgICAgICAgeTogX2NhbWVyYS55ICtcbiAgICAgICAgICAgICAgICBfc2V0dGluZ3MoJ21vdXNlSW5lcnRpYVJhdGlvJykgKiAoX2NhbWVyYS55IC0gX2xhc3RDYW1lcmFZKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZWFzaW5nOiAncXVhZHJhdGljT3V0JyxcbiAgICAgICAgICAgICAgZHVyYXRpb246IF9zZXR0aW5ncygnbW91c2VJbmVydGlhRHVyYXRpb24nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgX3N0YXJ0TW91c2VYICE9PSB4IHx8XG4gICAgICAgICAgX3N0YXJ0TW91c2VZICE9PSB5XG4gICAgICAgIClcbiAgICAgICAgICBfY2FtZXJhLmdvVG8oe1xuICAgICAgICAgICAgeDogX2NhbWVyYS54LFxuICAgICAgICAgICAgeTogX2NhbWVyYS55XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnbW91c2V1cCcsXG4gICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSkpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBfaXNNb3ZpbmcgZmxhZzpcbiAgICAgICAgX2lzTW92aW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAnZG93bicgbW91c2UgZXZlbnQuIEl0IHdpbGwgc3RhcnQgb2JzZXJ2aW5nXG4gICAgICogdGhlIG1vdXNlIHBvc2l0aW9uIGZvciBkcmFnZ2luZyB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2Rvd25IYW5kbGVyKGUpIHtcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpKSB7XG4gICAgICAgIF9zdGFydENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgIF9zdGFydENhbWVyYVkgPSBfY2FtZXJhLnk7XG5cbiAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xuICAgICAgICBfbGFzdENhbWVyYVkgPSBfY2FtZXJhLnk7XG5cbiAgICAgICAgX3N0YXJ0TW91c2VYID0gc2lnbWEudXRpbHMuZ2V0WChlKTtcbiAgICAgICAgX3N0YXJ0TW91c2VZID0gc2lnbWEudXRpbHMuZ2V0WShlKTtcblxuICAgICAgICBfaGFzRHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICBfZG93blN0YXJ0VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgc3dpdGNoIChlLndoaWNoKSB7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgLy8gTWlkZGxlIG1vdXNlIGJ1dHRvbiBwcmVzc2VkXG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgLy8gUmlnaHQgbW91c2UgYnV0dG9uIHByZXNzZWRcbiAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ3JpZ2h0Y2xpY2snLFxuICAgICAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlLCBfc3RhcnRNb3VzZVgsIF9zdGFydE1vdXNlWSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gY2FzZSAxOlxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBMZWZ0IG1vdXNlIGJ1dHRvbiBwcmVzc2VkXG4gICAgICAgICAgICBfaXNNb3VzZURvd24gPSB0cnVlO1xuXG4gICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdtb3VzZWRvd24nLFxuICAgICAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlLCBfc3RhcnRNb3VzZVgsIF9zdGFydE1vdXNlWSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAnb3V0JyBtb3VzZSBldmVudC4gSXQgd2lsbCBqdXN0IHJlZGlzcGF0Y2hcbiAgICAgKiB0aGUgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX291dEhhbmRsZXIoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpXG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNlb3V0Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAnY2xpY2snIG1vdXNlIGV2ZW50LiBJdCB3aWxsIHJlZGlzcGF0Y2ggdGhlXG4gICAgICogY2xpY2sgZXZlbnQsIGJ1dCB3aXRoIG5vcm1hbGl6ZWQgWCBhbmQgWSBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfY2xpY2tIYW5kbGVyKGUpIHtcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpKSB7XG4gICAgICAgIHZhciBldmVudCA9IHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUpO1xuICAgICAgICBldmVudC5pc0RyYWdnaW5nID1cbiAgICAgICAgICAoKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBfZG93blN0YXJ0VGltZSkgPiAxMDApICYmIF9oYXNEcmFnZ2VkO1xuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGljaycsIGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgZG91YmxlIGNsaWNrIGN1c3RvbSBldmVudC4gSXQgd2lsbFxuICAgICAqIGJhc2ljYWxseSB6b29tIGludG8gdGhlIGdyYXBoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9kb3VibGVDbGlja0hhbmRsZXIoZSkge1xuICAgICAgdmFyIHBvcyxcbiAgICAgICAgICByYXRpbyxcbiAgICAgICAgICBhbmltYXRpb247XG5cbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpKSB7XG4gICAgICAgIHJhdGlvID0gMSAvIF9zZXR0aW5ncygnZG91YmxlQ2xpY2tab29taW5nUmF0aW8nKTtcblxuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVjbGljaycsXG4gICAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlLCBfc3RhcnRNb3VzZVgsIF9zdGFydE1vdXNlWSkpO1xuXG4gICAgICAgIGlmIChfc2V0dGluZ3MoJ2RvdWJsZUNsaWNrRW5hYmxlZCcpKSB7XG4gICAgICAgICAgcG9zID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldFgoZSkgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldFkoZSkgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgYW5pbWF0aW9uID0ge1xuICAgICAgICAgICAgZHVyYXRpb246IF9zZXR0aW5ncygnZG91YmxlQ2xpY2tab29tRHVyYXRpb24nKVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBzaWdtYS51dGlscy56b29tVG8oX2NhbWVyYSwgcG9zLngsIHBvcy55LCByYXRpbywgYW5pbWF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KVxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAnd2hlZWwnIG1vdXNlIGV2ZW50LiBJdCB3aWxsIGJhc2ljYWxseSB6b29tXG4gICAgICogaW4gb3Igbm90IGludG8gdGhlIGdyYXBoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF93aGVlbEhhbmRsZXIoZSkge1xuICAgICAgdmFyIHBvcyxcbiAgICAgICAgICByYXRpbyxcbiAgICAgICAgICBhbmltYXRpb24sXG4gICAgICAgICAgd2hlZWxEZWx0YSA9IHNpZ21hLnV0aWxzLmdldERlbHRhKGUpO1xuXG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSAmJiBfc2V0dGluZ3MoJ21vdXNlV2hlZWxFbmFibGVkJykgJiYgd2hlZWxEZWx0YSAhPT0gMCkge1xuICAgICAgICByYXRpbyA9IHdoZWVsRGVsdGEgPiAwID9cbiAgICAgICAgICAxIC8gX3NldHRpbmdzKCd6b29taW5nUmF0aW8nKSA6XG4gICAgICAgICAgX3NldHRpbmdzKCd6b29taW5nUmF0aW8nKTtcblxuICAgICAgICBwb3MgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgIHNpZ21hLnV0aWxzLmdldFgoZSkgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcbiAgICAgICAgICBzaWdtYS51dGlscy5nZXRZKGUpIC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuXG4gICAgICAgIGFuaW1hdGlvbiA9IHtcbiAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCdtb3VzZVpvb21EdXJhdGlvbicpXG4gICAgICAgIH07XG5cbiAgICAgICAgc2lnbWEudXRpbHMuem9vbVRvKF9jYW1lcmEsIHBvcy54LCBwb3MueSwgcmF0aW8sIGFuaW1hdGlvbik7XG5cbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYXB0b3JzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSB1c2VyIGlucHV0cyBkZWZhdWx0IGNhcHRvci4gSXQgZGVhbHMgd2l0aCBtb3VzZSBldmVudHMsIGtleWJvYXJkc1xuICAgKiBldmVudHMgYW5kIHRvdWNoIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICB0YXJnZXQgICBUaGUgRE9NIGVsZW1lbnQgd2hlcmUgdGhlIGxpc3RlbmVycyB3aWxsIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmQuXG4gICAqIEBwYXJhbSAge2NhbWVyYX0gICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYSByZWxhdGVkIHRvIHRoZSB0YXJnZXQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5jYXB0b3J9ICAgICAgICAgIFRoZSBmcmVzaCBuZXcgY2FwdG9yIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEuY2FwdG9ycy50b3VjaCA9IGZ1bmN0aW9uKHRhcmdldCwgY2FtZXJhLCBzZXR0aW5ncykge1xuICAgIHZhciBfc2VsZiA9IHRoaXMsXG4gICAgICAgIF90YXJnZXQgPSB0YXJnZXQsXG4gICAgICAgIF9jYW1lcmEgPSBjYW1lcmEsXG4gICAgICAgIF9zZXR0aW5ncyA9IHNldHRpbmdzLFxuXG4gICAgICAgIC8vIENBTUVSQSBNQU5BR0VNRU5UOlxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKipcbiAgICAgICAgLy8gVGhlIGNhbWVyYSBwb3NpdGlvbiB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZzpcbiAgICAgICAgX3N0YXJ0Q2FtZXJhWCxcbiAgICAgICAgX3N0YXJ0Q2FtZXJhWSxcbiAgICAgICAgX3N0YXJ0Q2FtZXJhQW5nbGUsXG4gICAgICAgIF9zdGFydENhbWVyYVJhdGlvLFxuXG4gICAgICAgIC8vIFRoZSBsYXRlc3Qgc3RhZ2UgcG9zaXRpb246XG4gICAgICAgIF9sYXN0Q2FtZXJhWCxcbiAgICAgICAgX2xhc3RDYW1lcmFZLFxuICAgICAgICBfbGFzdENhbWVyYUFuZ2xlLFxuICAgICAgICBfbGFzdENhbWVyYVJhdGlvLFxuXG4gICAgICAgIC8vIFRPVUNIIE1BTkFHRU1FTlQ6XG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqXG4gICAgICAgIC8vIFRvdWNoZXMgdGhhdCBhcmUgZG93bjpcbiAgICAgICAgX2Rvd25Ub3VjaGVzID0gW10sXG5cbiAgICAgICAgX3N0YXJ0VG91Y2hYMCxcbiAgICAgICAgX3N0YXJ0VG91Y2hZMCxcbiAgICAgICAgX3N0YXJ0VG91Y2hYMSxcbiAgICAgICAgX3N0YXJ0VG91Y2hZMSxcbiAgICAgICAgX3N0YXJ0VG91Y2hBbmdsZSxcbiAgICAgICAgX3N0YXJ0VG91Y2hEaXN0YW5jZSxcblxuICAgICAgICBfdG91Y2hNb2RlLFxuXG4gICAgICAgIF9pc01vdmluZyxcbiAgICAgICAgX2RvdWJsZVRhcCxcbiAgICAgICAgX21vdmluZ1RpbWVvdXRJZDtcblxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XG5cbiAgICBzaWdtYS51dGlscy5kb3VibGVDbGljayhfdGFyZ2V0LCAndG91Y2hzdGFydCcsIF9kb3VibGVUYXBIYW5kbGVyKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBfaGFuZGxlU3RhcnQsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX2hhbmRsZUxlYXZlLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIF9oYW5kbGVMZWF2ZSwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hsZWF2ZScsIF9oYW5kbGVMZWF2ZSwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX2hhbmRsZU1vdmUsIGZhbHNlKTtcblxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uKGUpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBzaWdtYS51dGlscy5nZXRPZmZzZXQoX3RhcmdldCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGUucGFnZVggLSBvZmZzZXQubGVmdCxcbiAgICAgICAgeTogZS5wYWdlWSAtIG9mZnNldC50b3BcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdW5iaW5kcyBldmVyeSBoYW5kbGVycyB0aGF0IG1ha2VzIHRoZSBjYXB0b3Igd29yay5cbiAgICAgKi9cbiAgICB0aGlzLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNpZ21hLnV0aWxzLnVuYmluZERvdWJsZUNsaWNrKF90YXJnZXQsICd0b3VjaHN0YXJ0Jyk7XG4gICAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBfaGFuZGxlU3RhcnQpO1xuICAgICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF9oYW5kbGVMZWF2ZSk7XG4gICAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgX2hhbmRsZUxlYXZlKTtcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hsZWF2ZScsIF9oYW5kbGVMZWF2ZSk7XG4gICAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF9oYW5kbGVNb3ZlKTtcbiAgICB9O1xuXG4gICAgLy8gVE9VQ0ggRVZFTlRTOlxuICAgIC8vICoqKioqKioqKioqKipcbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd0b3VjaHN0YXJ0JyBldmVudC4gSXQgd2lsbCBzZXQgdGhlIHRvdWNoXG4gICAgICogbW9kZSAoXCJfdG91Y2hNb2RlXCIpIGFuZCBzdGFydCBvYnNlcnZpbmcgdGhlIHVzZXIgdG91Y2ggbW92ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgdG91Y2ggZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2hhbmRsZVN0YXJ0KGUpIHtcbiAgICAgIGlmIChfc2V0dGluZ3MoJ3RvdWNoRW5hYmxlZCcpKSB7XG4gICAgICAgIHZhciB4MCxcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTAsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIHBvczAsXG4gICAgICAgICAgICBwb3MxO1xuXG4gICAgICAgIF9kb3duVG91Y2hlcyA9IGUudG91Y2hlcztcblxuICAgICAgICBzd2l0Y2ggKF9kb3duVG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBfY2FtZXJhLmlzTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIF90b3VjaE1vZGUgPSAxO1xuXG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFYID0gX2NhbWVyYS54O1xuICAgICAgICAgICAgX3N0YXJ0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xuICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICBwb3MwID0gcG9zaXRpb24oX2Rvd25Ub3VjaGVzWzBdKTtcbiAgICAgICAgICAgIF9zdGFydFRvdWNoWDAgPSBwb3MwLng7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaFkwID0gcG9zMC55O1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfY2FtZXJhLmlzTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIF90b3VjaE1vZGUgPSAyO1xuXG4gICAgICAgICAgICBwb3MwID0gcG9zaXRpb24oX2Rvd25Ub3VjaGVzWzBdKTtcbiAgICAgICAgICAgIHBvczEgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMV0pO1xuICAgICAgICAgICAgeDAgPSBwb3MwLng7XG4gICAgICAgICAgICB5MCA9IHBvczAueTtcbiAgICAgICAgICAgIHgxID0gcG9zMS54O1xuICAgICAgICAgICAgeTEgPSBwb3MxLnk7XG5cbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICAgICAgX3N0YXJ0Q2FtZXJhQW5nbGUgPSBfY2FtZXJhLmFuZ2xlO1xuICAgICAgICAgICAgX3N0YXJ0Q2FtZXJhUmF0aW8gPSBfY2FtZXJhLnJhdGlvO1xuXG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFYID0gX2NhbWVyYS54O1xuICAgICAgICAgICAgX3N0YXJ0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICAgICAgX3N0YXJ0VG91Y2hYMCA9IHgwO1xuICAgICAgICAgICAgX3N0YXJ0VG91Y2hZMCA9IHkwO1xuICAgICAgICAgICAgX3N0YXJ0VG91Y2hYMSA9IHgxO1xuICAgICAgICAgICAgX3N0YXJ0VG91Y2hZMSA9IHkxO1xuXG4gICAgICAgICAgICBfc3RhcnRUb3VjaEFuZ2xlID0gTWF0aC5hdGFuMihcbiAgICAgICAgICAgICAgX3N0YXJ0VG91Y2hZMSAtIF9zdGFydFRvdWNoWTAsXG4gICAgICAgICAgICAgIF9zdGFydFRvdWNoWDEgLSBfc3RhcnRUb3VjaFgwXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgX3N0YXJ0VG91Y2hEaXN0YW5jZSA9IE1hdGguc3FydChcbiAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWTEgLSBfc3RhcnRUb3VjaFkwKSAqXG4gICAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWTEgLSBfc3RhcnRUb3VjaFkwKSArXG4gICAgICAgICAgICAgIChfc3RhcnRUb3VjaFgxIC0gX3N0YXJ0VG91Y2hYMCkgKlxuICAgICAgICAgICAgICAgIChfc3RhcnRUb3VjaFgxIC0gX3N0YXJ0VG91Y2hYMClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJyBhbmQgJ3RvdWNobGVhdmUnXG4gICAgICogZXZlbnQuIEl0IHdpbGwgdXBkYXRlIHRoZSB0b3VjaCBtb2RlIGlmIHRoZXJlIGFyZSBzdGlsbCBhdCBsZWFzdCBvbmVcbiAgICAgKiBmaW5nZXIsIGFuZCBzdG9wIGRyYWdnaW5nIGVsc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgdG91Y2ggZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2hhbmRsZUxlYXZlKGUpIHtcbiAgICAgIGlmIChfc2V0dGluZ3MoJ3RvdWNoRW5hYmxlZCcpKSB7XG4gICAgICAgIF9kb3duVG91Y2hlcyA9IGUudG91Y2hlcztcbiAgICAgICAgdmFyIGluZXJ0aWFSYXRpbyA9IF9zZXR0aW5ncygndG91Y2hJbmVydGlhUmF0aW8nKTtcblxuICAgICAgICBpZiAoX21vdmluZ1RpbWVvdXRJZCkge1xuICAgICAgICAgIF9pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICAgIGNsZWFyVGltZW91dChfbW92aW5nVGltZW91dElkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoX3RvdWNoTW9kZSkge1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIF9oYW5kbGVTdGFydChlKTtcblxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ3N0b3BEcmFnJyk7XG5cbiAgICAgICAgICAgIGlmIChfaXNNb3ZpbmcpIHtcbiAgICAgICAgICAgICAgX2RvdWJsZVRhcCA9IGZhbHNlO1xuICAgICAgICAgICAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5jYW1lcmEoXG4gICAgICAgICAgICAgICAgX2NhbWVyYSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB4OiBfY2FtZXJhLnggK1xuICAgICAgICAgICAgICAgICAgICBpbmVydGlhUmF0aW8gKiAoX2NhbWVyYS54IC0gX2xhc3RDYW1lcmFYKSxcbiAgICAgICAgICAgICAgICAgIHk6IF9jYW1lcmEueSArXG4gICAgICAgICAgICAgICAgICAgIGluZXJ0aWFSYXRpbyAqIChfY2FtZXJhLnkgLSBfbGFzdENhbWVyYVkpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlYXNpbmc6ICdxdWFkcmF0aWNPdXQnLFxuICAgICAgICAgICAgICAgICAgZHVyYXRpb246IF9zZXR0aW5ncygndG91Y2hJbmVydGlhRHVyYXRpb24nKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2lzTW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBfdG91Y2hNb2RlID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAndG91Y2htb3ZlJyBldmVudC4gSXQgd2lsbCBlZmZlY3RpdmVseSBkcmFnXG4gICAgICogdGhlIGdyYXBoLCBhbmQgZXZlbnR1YWxseSB6b29tcyBhbmQgdHVybiBpdCBpZiB0aGUgdXNlciBpcyB1c2luZyB0d29cbiAgICAgKiBmaW5nZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIHRvdWNoIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9oYW5kbGVNb3ZlKGUpIHtcbiAgICAgIGlmICghX2RvdWJsZVRhcCAmJiBfc2V0dGluZ3MoJ3RvdWNoRW5hYmxlZCcpKSB7XG4gICAgICAgIHZhciB4MCxcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTAsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIGNvcyxcbiAgICAgICAgICAgIHNpbixcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIHBvczAsXG4gICAgICAgICAgICBwb3MxLFxuICAgICAgICAgICAgZGlmZixcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZEFuZ2xlLFxuICAgICAgICAgICAgZFJhdGlvLFxuICAgICAgICAgICAgbmV3U3RhZ2VYLFxuICAgICAgICAgICAgbmV3U3RhZ2VZLFxuICAgICAgICAgICAgbmV3U3RhZ2VSYXRpbyxcbiAgICAgICAgICAgIG5ld1N0YWdlQW5nbGU7XG5cbiAgICAgICAgX2Rvd25Ub3VjaGVzID0gZS50b3VjaGVzO1xuICAgICAgICBfaXNNb3ZpbmcgPSB0cnVlO1xuXG4gICAgICAgIGlmIChfbW92aW5nVGltZW91dElkKVxuICAgICAgICAgIGNsZWFyVGltZW91dChfbW92aW5nVGltZW91dElkKTtcblxuICAgICAgICBfbW92aW5nVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgfSwgX3NldHRpbmdzKCdkcmFnVGltZW91dCcpKTtcblxuICAgICAgICBzd2l0Y2ggKF90b3VjaE1vZGUpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBwb3MwID0gcG9zaXRpb24oX2Rvd25Ub3VjaGVzWzBdKTtcbiAgICAgICAgICAgIHgwID0gcG9zMC54O1xuICAgICAgICAgICAgeTAgPSBwb3MwLnk7XG5cbiAgICAgICAgICAgIGRpZmYgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgICB4MCAtIF9zdGFydFRvdWNoWDAsXG4gICAgICAgICAgICAgIHkwIC0gX3N0YXJ0VG91Y2hZMCxcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbmV3U3RhZ2VYID0gX3N0YXJ0Q2FtZXJhWCAtIGRpZmYueDtcbiAgICAgICAgICAgIG5ld1N0YWdlWSA9IF9zdGFydENhbWVyYVkgLSBkaWZmLnk7XG5cbiAgICAgICAgICAgIGlmIChuZXdTdGFnZVggIT09IF9jYW1lcmEueCB8fCBuZXdTdGFnZVkgIT09IF9jYW1lcmEueSkge1xuICAgICAgICAgICAgICBfbGFzdENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICAgICAgICBfY2FtZXJhLmdvVG8oe1xuICAgICAgICAgICAgICAgIHg6IG5ld1N0YWdlWCxcbiAgICAgICAgICAgICAgICB5OiBuZXdTdGFnZVlcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnbW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlLCBwb3MwLngsIHBvczAueSkpO1xuXG4gICAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2RyYWcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHBvczAgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgcG9zMSA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1sxXSk7XG4gICAgICAgICAgICB4MCA9IHBvczAueDtcbiAgICAgICAgICAgIHkwID0gcG9zMC55O1xuICAgICAgICAgICAgeDEgPSBwb3MxLng7XG4gICAgICAgICAgICB5MSA9IHBvczEueTtcblxuICAgICAgICAgICAgc3RhcnQgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hYMCArIF9zdGFydFRvdWNoWDEpIC8gMiAtXG4gICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLngsXG4gICAgICAgICAgICAgIChfc3RhcnRUb3VjaFkwICsgX3N0YXJ0VG91Y2hZMSkgLyAyIC1cbiAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueSxcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVuZCA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICAgICh4MCArIHgxKSAvIDIgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcbiAgICAgICAgICAgICAgKHkwICsgeTEpIC8gMiAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBkQW5nbGUgPSBNYXRoLmF0YW4yKHkxIC0geTAsIHgxIC0geDApIC0gX3N0YXJ0VG91Y2hBbmdsZTtcbiAgICAgICAgICAgIGRSYXRpbyA9IE1hdGguc3FydChcbiAgICAgICAgICAgICAgKHkxIC0geTApICogKHkxIC0geTApICsgKHgxIC0geDApICogKHgxIC0geDApXG4gICAgICAgICAgICApIC8gX3N0YXJ0VG91Y2hEaXN0YW5jZTtcblxuICAgICAgICAgICAgLy8gVHJhbnNsYXRpb246XG4gICAgICAgICAgICB4MCA9IHN0YXJ0Lng7XG4gICAgICAgICAgICB5MCA9IHN0YXJ0Lnk7XG5cbiAgICAgICAgICAgIC8vIEhvbW90aGV0aWMgdHJhbnNmb3JtYXRpb246XG4gICAgICAgICAgICBuZXdTdGFnZVJhdGlvID0gX3N0YXJ0Q2FtZXJhUmF0aW8gLyBkUmF0aW87XG4gICAgICAgICAgICB4MCA9IHgwICogZFJhdGlvO1xuICAgICAgICAgICAgeTAgPSB5MCAqIGRSYXRpbztcblxuICAgICAgICAgICAgLy8gUm90YXRpb246XG4gICAgICAgICAgICBuZXdTdGFnZUFuZ2xlID0gX3N0YXJ0Q2FtZXJhQW5nbGUgLSBkQW5nbGU7XG4gICAgICAgICAgICBjb3MgPSBNYXRoLmNvcygtZEFuZ2xlKTtcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKC1kQW5nbGUpO1xuICAgICAgICAgICAgeDEgPSB4MCAqIGNvcyArIHkwICogc2luO1xuICAgICAgICAgICAgeTEgPSB5MCAqIGNvcyAtIHgwICogc2luO1xuICAgICAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgICAgIHkwID0geTE7XG5cbiAgICAgICAgICAgIC8vIEZpbmFsaXplOlxuICAgICAgICAgICAgbmV3U3RhZ2VYID0geDAgLSBlbmQueCArIF9zdGFydENhbWVyYVg7XG4gICAgICAgICAgICBuZXdTdGFnZVkgPSB5MCAtIGVuZC55ICsgX3N0YXJ0Q2FtZXJhWTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBuZXdTdGFnZVJhdGlvICE9PSBfY2FtZXJhLnJhdGlvIHx8XG4gICAgICAgICAgICAgIG5ld1N0YWdlQW5nbGUgIT09IF9jYW1lcmEuYW5nbGUgfHxcbiAgICAgICAgICAgICAgbmV3U3RhZ2VYICE9PSBfY2FtZXJhLnggfHxcbiAgICAgICAgICAgICAgbmV3U3RhZ2VZICE9PSBfY2FtZXJhLnlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBfbGFzdENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhWSA9IF9jYW1lcmEueTtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFBbmdsZSA9IF9jYW1lcmEuYW5nbGU7XG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhUmF0aW8gPSBfY2FtZXJhLnJhdGlvO1xuXG4gICAgICAgICAgICAgIF9jYW1lcmEuZ29Ubyh7XG4gICAgICAgICAgICAgICAgeDogbmV3U3RhZ2VYLFxuICAgICAgICAgICAgICAgIHk6IG5ld1N0YWdlWSxcbiAgICAgICAgICAgICAgICBhbmdsZTogbmV3U3RhZ2VBbmdsZSxcbiAgICAgICAgICAgICAgICByYXRpbzogbmV3U3RhZ2VSYXRpb1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkcmFnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSBkb3VibGUgdGFwIGN1c3RvbSBldmVudC4gSXQgd2lsbFxuICAgICAqIGJhc2ljYWxseSB6b29tIGludG8gdGhlIGdyYXBoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIHRvdWNoIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9kb3VibGVUYXBIYW5kbGVyKGUpIHtcbiAgICAgIHZhciBwb3MsXG4gICAgICAgICAgcmF0aW8sXG4gICAgICAgICAgYW5pbWF0aW9uO1xuXG4gICAgICBpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDEgJiYgX3NldHRpbmdzKCd0b3VjaEVuYWJsZWQnKSkge1xuICAgICAgICBfZG91YmxlVGFwID0gdHJ1ZTtcblxuICAgICAgICByYXRpbyA9IDEgLyBfc2V0dGluZ3MoJ2RvdWJsZUNsaWNrWm9vbWluZ1JhdGlvJyk7XG5cbiAgICAgICAgcG9zID0gcG9zaXRpb24oZS50b3VjaGVzWzBdKTtcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlY2xpY2snLFxuICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIHBvcy54LCBwb3MueSkpO1xuXG4gICAgICAgIGlmIChfc2V0dGluZ3MoJ2RvdWJsZUNsaWNrRW5hYmxlZCcpKSB7XG4gICAgICAgICAgcG9zID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgIHBvcy54IC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLngsXG4gICAgICAgICAgICBwb3MueSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBhbmltYXRpb24gPSB7XG4gICAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCdkb3VibGVDbGlja1pvb21EdXJhdGlvbicpLFxuICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIF9kb3VibGVUYXAgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgc2lnbWEudXRpbHMuem9vbVRvKF9jYW1lcmEsIHBvcy54LCBwb3MueSwgcmF0aW8sIGFuaW1hdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICBpZiAodHlwZW9mIGNvbnJhZCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ2NvbnJhZCBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucmVuZGVyZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBjYW52YXMgc2lnbWEncyByZW5kZXJlci5cbiAgICpcbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5ncmFwaH0gICAgICAgICAgICBncmFwaCAgICBUaGUgZ3JhcGggdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmNhbWVyYX0gICAgICAgICAgIGNhbWVyYSAgIFRoZSBjYW1lcmEuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgIHNldHRpbmdzIFRoZSBzaWdtYSBpbnN0YW5jZSBzZXR0aW5nc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgb2JqZWN0ICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuY2FudmFzfSAgICAgICAgICBUaGUgcmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzID0gZnVuY3Rpb24oZ3JhcGgsIGNhbWVyYSwgc2V0dGluZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKVxuICAgICAgdGhyb3cgJ3NpZ21hLnJlbmRlcmVycy5jYW52YXM6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKCEob3B0aW9ucy5jb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpXG4gICAgICB0aHJvdyAnQ29udGFpbmVyIG5vdCBmb3VuZC4nO1xuXG4gICAgdmFyIGssXG4gICAgICAgIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIGZuLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XG5cbiAgICAvLyBJbml0aWFsaXplIG1haW4gYXR0cmlidXRlczpcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvbnJhZElkJywge1xuICAgICAgdmFsdWU6IHNpZ21hLnV0aWxzLmlkKClcbiAgICB9KTtcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5jb250ZXh0cyA9IHt9O1xuICAgIHRoaXMuZG9tRWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICB0aGlzLnNldHRpbmdzID0gKFxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5zZXR0aW5ncyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgb3B0aW9ucy5zZXR0aW5nc1xuICAgICAgKSA/XG4gICAgICAgIHNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLnNldHRpbmdzKSA6XG4gICAgICAgIHNldHRpbmdzO1xuXG4gICAgLy8gTm9kZSBpbmRleGVzOlxuICAgIHRoaXMubm9kZXNPblNjcmVlbiA9IFtdO1xuICAgIHRoaXMuZWRnZXNPblNjcmVlbiA9IFtdO1xuXG4gICAgLy8gQ29ucmFkIHJlbGF0ZWQgYXR0cmlidXRlczpcbiAgICB0aGlzLmpvYnMgPSB7fTtcblxuICAgIC8vIEZpbmQgdGhlIHByZWZpeDpcbiAgICB0aGlzLm9wdGlvbnMucHJlZml4ID0gJ3JlbmRlcmVyJyArIHRoaXMuY29ucmFkSWQgKyAnOic7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBET00gZWxlbWVudHM6XG4gICAgaWYgKFxuICAgICAgIXRoaXMuc2V0dGluZ3MoJ2JhdGNoRWRnZXNEcmF3aW5nJylcbiAgICApIHtcbiAgICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ3NjZW5lJyk7XG4gICAgICB0aGlzLmNvbnRleHRzLmVkZ2VzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcbiAgICAgIHRoaXMuY29udGV4dHMubm9kZXMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xuICAgICAgdGhpcy5jb250ZXh0cy5sYWJlbHMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdlZGdlcycpO1xuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnc2NlbmUnKTtcbiAgICAgIHRoaXMuY29udGV4dHMubm9kZXMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xuICAgICAgdGhpcy5jb250ZXh0cy5sYWJlbHMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ21vdXNlJyk7XG4gICAgdGhpcy5jb250ZXh0cy5ob3ZlciA9IHRoaXMuY29udGV4dHMubW91c2U7XG5cbiAgICAvLyBJbml0aWFsaXplIGNhcHRvcnM6XG4gICAgdGhpcy5jYXB0b3JzID0gW107XG4gICAgYSA9IHRoaXMub3B0aW9ucy5jYXB0b3JzIHx8IFtzaWdtYS5jYXB0b3JzLm1vdXNlLCBzaWdtYS5jYXB0b3JzLnRvdWNoXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuID0gdHlwZW9mIGFbaV0gPT09ICdmdW5jdGlvbicgPyBhW2ldIDogc2lnbWEuY2FwdG9yc1thW2ldXTtcbiAgICAgIHRoaXMuY2FwdG9ycy5wdXNoKFxuICAgICAgICBuZXcgZm4oXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5tb3VzZSxcbiAgICAgICAgICB0aGlzLmNhbWVyYSxcbiAgICAgICAgICB0aGlzLnNldHRpbmdzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRGVhbCB3aXRoIHNpZ21hIGV2ZW50czpcbiAgICBzaWdtYS5taXNjLmJpbmRFdmVudHMuY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMucHJlZml4KTtcbiAgICBzaWdtYS5taXNjLmRyYXdIb3ZlcnMuY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMucHJlZml4KTtcblxuICAgIHRoaXMucmVzaXplKGZhbHNlKTtcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVuZGVycyB0aGUgZ3JhcGggb24gdGhlIGNhbnZhc2VzLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSAgICAgICAgICAgICAgICBvcHRpb25zIEV2ZW50dWFsbHkgYW4gb2JqZWN0IG9mIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9ICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGEsXG4gICAgICAgIGksXG4gICAgICAgIGssXG4gICAgICAgIGwsXG4gICAgICAgIG8sXG4gICAgICAgIGlkLFxuICAgICAgICBlbmQsXG4gICAgICAgIGpvYixcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVkZ2VzLFxuICAgICAgICByZW5kZXJlcnMsXG4gICAgICAgIHJlbmRlcmVyVHlwZSxcbiAgICAgICAgYmF0Y2hTaXplLFxuICAgICAgICB0ZW1wR0NPLFxuICAgICAgICBpbmRleCA9IHt9LFxuICAgICAgICBncmFwaCA9IHRoaXMuZ3JhcGgsXG4gICAgICAgIG5vZGVzID0gdGhpcy5ncmFwaC5ub2RlcyxcbiAgICAgICAgcHJlZml4ID0gdGhpcy5vcHRpb25zLnByZWZpeCB8fCAnJyxcbiAgICAgICAgZHJhd0VkZ2VzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0VkZ2VzJyksXG4gICAgICAgIGRyYXdOb2RlcyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdOb2RlcycpLFxuICAgICAgICBkcmF3TGFiZWxzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0xhYmVscycpLFxuICAgICAgICBkcmF3RWRnZUxhYmVscyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdFZGdlTGFiZWxzJyksXG4gICAgICAgIGVtYmVkU2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLCB7XG4gICAgICAgICAgcHJlZml4OiB0aGlzLm9wdGlvbnMucHJlZml4XG4gICAgICAgIH0pO1xuXG4gICAgLy8gQ2FsbCB0aGUgcmVzaXplIGZ1bmN0aW9uOlxuICAgIHRoaXMucmVzaXplKGZhbHNlKTtcblxuICAgIC8vIENoZWNrIHRoZSAnaGlkZUVkZ2VzT25Nb3ZlJyBzZXR0aW5nOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdoaWRlRWRnZXNPbk1vdmUnKSlcbiAgICAgIGlmICh0aGlzLmNhbWVyYS5pc0FuaW1hdGVkIHx8IHRoaXMuY2FtZXJhLmlzTW92aW5nKVxuICAgICAgICBkcmF3RWRnZXMgPSBmYWxzZTtcblxuICAgIC8vIEFwcGx5IHRoZSBjYW1lcmEncyB2aWV3OlxuICAgIHRoaXMuY2FtZXJhLmFwcGx5VmlldyhcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHRoaXMub3B0aW9ucy5wcmVmaXgsXG4gICAgICB7XG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIENsZWFyIGNhbnZhc2VzOlxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIC8vIEtpbGwgcnVubmluZyBqb2JzOlxuICAgIGZvciAoayBpbiB0aGlzLmpvYnMpXG4gICAgICBpZiAoY29ucmFkLmhhc0pvYihrKSlcbiAgICAgICAgY29ucmFkLmtpbGxKb2Ioayk7XG5cbiAgICAvLyBGaW5kIHdoaWNoIG5vZGVzIGFyZSBvbiBzY3JlZW46XG4gICAgdGhpcy5lZGdlc09uU2NyZWVuID0gW107XG4gICAgdGhpcy5ub2Rlc09uU2NyZWVuID0gdGhpcy5jYW1lcmEucXVhZHRyZWUuYXJlYShcbiAgICAgIHRoaXMuY2FtZXJhLmdldFJlY3RhbmdsZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcbiAgICApO1xuXG4gICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaW5kZXhbYVtpXS5pZF0gPSBhW2ldO1xuXG4gICAgLy8gRHJhdyBlZGdlczpcbiAgICAvLyAtIElmIHNldHRpbmdzKCdiYXRjaEVkZ2VzRHJhd2luZycpIGlzIHRydWUsIHRoZSBlZGdlcyBhcmUgZGlzcGxheWVkIHBlclxuICAgIC8vICAgYmF0Y2hlcy4gSWYgbm90LCB0aGV5IGFyZSBkcmF3biBpbiBvbmUgZnJhbWUuXG4gICAgaWYgKGRyYXdFZGdlcykge1xuICAgICAgLy8gRmlyc3QsIGxldCdzIGlkZW50aWZ5IHdoaWNoIGVkZ2VzIHRvIGRyYXcuIFRvIGRvIHRoaXMsIHdlIGp1c3Qga2VlcFxuICAgICAgLy8gZXZlcnkgZWRnZXMgdGhhdCBoYXZlIGF0IGxlYXN0IG9uZSBleHRyZW1pdHkgZGlzcGxheWVkIGFjY29yZGluZyB0b1xuICAgICAgLy8gdGhlIHF1YWR0cmVlIGFuZCB0aGUgXCJoaWRkZW5cIiBhdHRyaWJ1dGUuIFdlIGFsc28gZG8gbm90IGtlZXAgaGlkZGVuXG4gICAgICAvLyBlZGdlcy5cbiAgICAgIGZvciAoYSA9IGdyYXBoLmVkZ2VzKCksIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbyA9IGFbaV07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoaW5kZXhbby5zb3VyY2VdIHx8IGluZGV4W28udGFyZ2V0XSkgJiZcbiAgICAgICAgICAoIW8uaGlkZGVuICYmICFub2RlcyhvLnNvdXJjZSkuaGlkZGVuICYmICFub2RlcyhvLnRhcmdldCkuaGlkZGVuKVxuICAgICAgICApXG4gICAgICAgICAgdGhpcy5lZGdlc09uU2NyZWVuLnB1c2gobyk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBcImJhdGNoRWRnZXNEcmF3aW5nXCIgc2V0dGluZ3MgaXMgdHJ1ZSwgZWRnZXMgYXJlIGJhdGNoZWQ6XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnYmF0Y2hFZGdlc0RyYXdpbmcnKSkge1xuICAgICAgICBpZCA9ICdlZGdlc18nICsgdGhpcy5jb25yYWRJZDtcbiAgICAgICAgYmF0Y2hTaXplID0gZW1iZWRTZXR0aW5ncygnY2FudmFzRWRnZXNCYXRjaFNpemUnKTtcblxuICAgICAgICBlZGdlcyA9IHRoaXMuZWRnZXNPblNjcmVlbjtcbiAgICAgICAgbCA9IGVkZ2VzLmxlbmd0aDtcblxuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKGVkZ2VzLmxlbmd0aCwgc3RhcnQgKyBiYXRjaFNpemUpO1xuXG4gICAgICAgIGpvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRlbXBHQ08gPSB0aGlzLmNvbnRleHRzLmVkZ2VzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgICB0aGlzLmNvbnRleHRzLmVkZ2VzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdmVyJztcblxuICAgICAgICAgIHJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5lZGdlcztcbiAgICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBvID0gZWRnZXNbaV07XG4gICAgICAgICAgICAocmVuZGVyZXJzW1xuICAgICAgICAgICAgICBvLnR5cGUgfHwgdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdEVkZ2VUeXBlJylcbiAgICAgICAgICAgIF0gfHwgcmVuZGVyZXJzLmRlZikoXG4gICAgICAgICAgICAgIG8sXG4gICAgICAgICAgICAgIGdyYXBoLm5vZGVzKG8uc291cmNlKSxcbiAgICAgICAgICAgICAgZ3JhcGgubm9kZXMoby50YXJnZXQpLFxuICAgICAgICAgICAgICB0aGlzLmNvbnRleHRzLmVkZ2VzLFxuICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERyYXcgZWRnZSBsYWJlbHM6XG4gICAgICAgICAgaWYgKGRyYXdFZGdlTGFiZWxzKSB7XG4gICAgICAgICAgICByZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuZWRnZXMubGFiZWxzO1xuICAgICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgICBvID0gZWRnZXNbaV07XG4gICAgICAgICAgICAgIGlmICghby5oaWRkZW4pXG4gICAgICAgICAgICAgICAgKHJlbmRlcmVyc1tcbiAgICAgICAgICAgICAgICAgIG8udHlwZSB8fCB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0RWRnZVR5cGUnKVxuICAgICAgICAgICAgICAgIF0gfHwgcmVuZGVyZXJzLmRlZikoXG4gICAgICAgICAgICAgICAgICBvLFxuICAgICAgICAgICAgICAgICAgZ3JhcGgubm9kZXMoby5zb3VyY2UpLFxuICAgICAgICAgICAgICAgICAgZ3JhcGgubm9kZXMoby50YXJnZXQpLFxuICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5sYWJlbHMsXG4gICAgICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjpcbiAgICAgICAgICB0aGlzLmNvbnRleHRzLmVkZ2VzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRlbXBHQ087XG5cbiAgICAgICAgICAvLyBDYXRjaCBqb2IncyBlbmQ6XG4gICAgICAgICAgaWYgKGVuZCA9PT0gZWRnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5qb2JzW2lkXTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGFydCA9IGVuZCArIDE7XG4gICAgICAgICAgZW5kID0gTWF0aC5taW4oZWRnZXMubGVuZ3RoLCBzdGFydCArIGJhdGNoU2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5qb2JzW2lkXSA9IGpvYjtcbiAgICAgICAgY29ucmFkLmFkZEpvYihpZCwgam9iLmJpbmQodGhpcykpO1xuXG4gICAgICAvLyBJZiBub3QsIHRoZXkgYXJlIGRyYXduIGluIG9uZSBmcmFtZTpcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5lZGdlcztcbiAgICAgICAgZm9yIChhID0gdGhpcy5lZGdlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgbyA9IGFbaV07XG4gICAgICAgICAgKHJlbmRlcmVyc1tcbiAgICAgICAgICAgIG8udHlwZSB8fCB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0RWRnZVR5cGUnKVxuICAgICAgICAgIF0gfHwgcmVuZGVyZXJzLmRlZikoXG4gICAgICAgICAgICBvLFxuICAgICAgICAgICAgZ3JhcGgubm9kZXMoby5zb3VyY2UpLFxuICAgICAgICAgICAgZ3JhcGgubm9kZXMoby50YXJnZXQpLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5lZGdlcyxcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRHJhdyBlZGdlIGxhYmVsczpcbiAgICAgICAgLy8gLSBObyBiYXRjaGluZ1xuICAgICAgICBpZiAoZHJhd0VkZ2VMYWJlbHMpIHtcbiAgICAgICAgICByZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuZWRnZXMubGFiZWxzO1xuICAgICAgICAgIGZvciAoYSA9IHRoaXMuZWRnZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgIGlmICghYVtpXS5oaWRkZW4pXG4gICAgICAgICAgICAgIChyZW5kZXJlcnNbXG4gICAgICAgICAgICAgICAgYVtpXS50eXBlIHx8IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHRFZGdlVHlwZScpXG4gICAgICAgICAgICAgIF0gfHwgcmVuZGVyZXJzLmRlZikoXG4gICAgICAgICAgICAgICAgYVtpXSxcbiAgICAgICAgICAgICAgICBncmFwaC5ub2RlcyhhW2ldLnNvdXJjZSksXG4gICAgICAgICAgICAgICAgZ3JhcGgubm9kZXMoYVtpXS50YXJnZXQpLFxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dHMubGFiZWxzLFxuICAgICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERyYXcgbm9kZXM6XG4gICAgLy8gLSBObyBiYXRjaGluZ1xuICAgIGlmIChkcmF3Tm9kZXMpIHtcbiAgICAgIHJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5ub2RlcztcbiAgICAgIGZvciAoYSA9IHRoaXMubm9kZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKCFhW2ldLmhpZGRlbilcbiAgICAgICAgICAocmVuZGVyZXJzW1xuICAgICAgICAgICAgYVtpXS50eXBlIHx8IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHROb2RlVHlwZScpXG4gICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzLm5vZGVzLFxuICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRHJhdyBsYWJlbHM6XG4gICAgLy8gLSBObyBiYXRjaGluZ1xuICAgIGlmIChkcmF3TGFiZWxzKSB7XG4gICAgICByZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMubGFiZWxzO1xuICAgICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0uaGlkZGVuKVxuICAgICAgICAgIChyZW5kZXJlcnNbXG4gICAgICAgICAgICBhW2ldLnR5cGUgfHwgdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdE5vZGVUeXBlJylcbiAgICAgICAgICBdIHx8IHJlbmRlcmVycy5kZWYpKFxuICAgICAgICAgICAgYVtpXSxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMubGFiZWxzLFxuICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdyZW5kZXInKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgRE9NIGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLCBzd2l0Y2hlcyBpdHNcbiAgICogcG9zaXRpb24gdG8gXCJhYnNvbHV0ZVwiLCByZWZlcmVuY2VzIGl0IHRvIHRoZSBkb21FbGVtZW50cyBhdHRyaWJ1dGUsIGFuZFxuICAgKiBmaW5hbGx5IGFwcGVuZHMgaXQgdG8gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWcgVGhlIGxhYmVsIHRhZy5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZCAgVGhlIGlkIG9mIHRoZSBlbGVtZW50ICh0byBzdG9yZSBpdCBpbiBcImRvbUVsZW1lbnRzXCIpLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5wcm90b3R5cGUuaW5pdERPTSA9IGZ1bmN0aW9uKHRhZywgaWQpIHtcbiAgICB2YXIgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuXG4gICAgZG9tLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsICdzaWdtYS0nICsgaWQpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50c1tpZF0gPSBkb207XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZG9tKTtcblxuICAgIGlmICh0YWcudG9Mb3dlckNhc2UoKSA9PT0gJ2NhbnZhcycpXG4gICAgICB0aGlzLmNvbnRleHRzW2lkXSA9IGRvbS5nZXRDb250ZXh0KCcyZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXNpemVzIGVhY2ggRE9NIGVsZW1lbnRzIGluIHRoZSBjb250YWluZXIgYW5kIHN0b3JlcyB0aGUgbmV3XG4gICAqIGRpbWVuc2lvbnMuIFRoZW4sIGl0IHJlbmRlcnMgdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/bnVtYmVyfSAgICAgICAgICAgICAgICB3aWR0aCAgVGhlIG5ldyB3aWR0aCBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcGFyYW0gIHs/bnVtYmVyfSAgICAgICAgICAgICAgICBoZWlnaHQgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLmNhbnZhc30gICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHcsIGgpIHtcbiAgICB2YXIgayxcbiAgICAgICAgb2xkV2lkdGggPSB0aGlzLndpZHRoLFxuICAgICAgICBvbGRIZWlnaHQgPSB0aGlzLmhlaWdodCxcbiAgICAgICAgcGl4ZWxSYXRpbyA9IHNpZ21hLnV0aWxzLmdldFBpeGVsUmF0aW8oKTtcblxuICAgIGlmICh3ICE9PSB1bmRlZmluZWQgJiYgaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLndpZHRoID0gdztcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIHcgPSB0aGlzLndpZHRoO1xuICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChvbGRXaWR0aCAhPT0gdGhpcy53aWR0aCB8fCBvbGRIZWlnaHQgIT09IHRoaXMuaGVpZ2h0KSB7XG4gICAgICBmb3IgKGsgaW4gdGhpcy5kb21FbGVtZW50cykge1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG5cbiAgICAgICAgaWYgKHRoaXMuZG9tRWxlbWVudHNba10udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJykge1xuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKCd3aWR0aCcsICh3ICogcGl4ZWxSYXRpbykgKyAncHgnKTtcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgKGggKiBwaXhlbFJhdGlvKSArICdweCcpO1xuXG4gICAgICAgICAgaWYgKHBpeGVsUmF0aW8gIT09IDEpXG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzW2tdLnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNsZWFycyBlYWNoIGNhbnZhcy5cbiAgICpcbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLmNhbnZhc30gUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBrIGluIHRoaXMuY29udGV4dHMpIHtcbiAgICAgIHRoaXMuY29udGV4dHNba10uY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qga2lsbHMgY29udGV4dHMgYW5kIG90aGVyIGF0dHJpYnV0ZXMuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGssXG4gICAgICAgIGNhcHRvcjtcblxuICAgIC8vIEtpbGwgY2FwdG9yczpcbiAgICB3aGlsZSAoKGNhcHRvciA9IHRoaXMuY2FwdG9ycy5wb3AoKSkpXG4gICAgICBjYXB0b3Iua2lsbCgpO1xuICAgIGRlbGV0ZSB0aGlzLmNhcHRvcnM7XG5cbiAgICAvLyBLaWxsIGNvbnRleHRzOlxuICAgIGZvciAoayBpbiB0aGlzLmRvbUVsZW1lbnRzKSB7XG4gICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50c1trXSk7XG4gICAgICBkZWxldGUgdGhpcy5kb21FbGVtZW50c1trXTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbnRleHRzW2tdO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5kb21FbGVtZW50cztcbiAgICBkZWxldGUgdGhpcy5jb250ZXh0cztcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhlIGxhYmVscywgbm9kZXMgYW5kIGVkZ2VzIHJlbmRlcmVycyBhcmUgc3RvcmVkIGluIHRoZSB0aHJlZSBmb2xsb3dpbmdcbiAgICogb2JqZWN0cy4gV2hlbiBhbiBlbGVtZW50IGlzIGRyYXduLCBpdHMgdHlwZSB3aWxsIGJlIGNoZWNrZWQgYW5kIGlmIGFcbiAgICogcmVuZGVyZXIgd2l0aCB0aGUgc2FtZSBuYW1lIGV4aXN0cywgaXQgd2lsbCBiZSB1c2VkLiBJZiBub3QgZm91bmQsIHRoZVxuICAgKiBkZWZhdWx0IHJlbmRlcmVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBUaGV5IGFyZSBzdG9yZWQgaW4gZGlmZmVyZW50IGZpbGVzLCBpbiB0aGUgXCIuL2NhbnZhc1wiIGZvbGRlci5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLm5vZGVzJyk7XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2VzJyk7XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmxhYmVscycpO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucmVuZGVyZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBjYW52YXMgc2lnbWEncyByZW5kZXJlci5cbiAgICpcbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5ncmFwaH0gICAgICAgICAgICBncmFwaCAgICBUaGUgZ3JhcGggdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmNhbWVyYX0gICAgICAgICAgIGNhbWVyYSAgIFRoZSBjYW1lcmEuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgIHNldHRpbmdzIFRoZSBzaWdtYSBpbnN0YW5jZSBzZXR0aW5nc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgb2JqZWN0ICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuY2FudmFzfSAgICAgICAgICBUaGUgcmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wgPSBmdW5jdGlvbihncmFwaCwgY2FtZXJhLCBzZXR0aW5ncywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgICB0aHJvdyAnc2lnbWEucmVuZGVyZXJzLndlYmdsOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmICghKG9wdGlvbnMuY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKVxuICAgICAgdGhyb3cgJ0NvbnRhaW5lciBub3QgZm91bmQuJztcblxuICAgIHZhciBrLFxuICAgICAgICBpLFxuICAgICAgICBsLFxuICAgICAgICBhLFxuICAgICAgICBmbixcbiAgICAgICAgX3NlbGYgPSB0aGlzO1xuXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIC8vIENvbnJhZCByZWxhdGVkIGF0dHJpYnV0ZXM6XG4gICAgdGhpcy5qb2JzID0ge307XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvbnJhZElkJywge1xuICAgICAgdmFsdWU6IHNpZ21hLnV0aWxzLmlkKClcbiAgICB9KTtcblxuICAgIC8vIEluaXRpYWxpemUgbWFpbiBhdHRyaWJ1dGVzOlxuICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLmNvbnRleHRzID0ge307XG4gICAgdGhpcy5kb21FbGVtZW50cyA9IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgIHRoaXMuc2V0dGluZ3MgPSAoXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLnNldHRpbmdzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBvcHRpb25zLnNldHRpbmdzXG4gICAgICApID9cbiAgICAgICAgc2V0dGluZ3MuZW1iZWRPYmplY3RzKG9wdGlvbnMuc2V0dGluZ3MpIDpcbiAgICAgICAgc2V0dGluZ3M7XG5cbiAgICAvLyBGaW5kIHRoZSBwcmVmaXg6XG4gICAgdGhpcy5vcHRpb25zLnByZWZpeCA9IHRoaXMuY2FtZXJhLnJlYWRQcmVmaXg7XG5cbiAgICAvLyBJbml0aWFsaXplIHByb2dyYW1zIGhhc2hcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25vZGVQcm9ncmFtcycsIHtcbiAgICAgIHZhbHVlOiB7fVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZWRnZVByb2dyYW1zJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdub2RlRmxvYXRBcnJheXMnLCB7XG4gICAgICB2YWx1ZToge31cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2VkZ2VGbG9hdEFycmF5cycsIHtcbiAgICAgIHZhbHVlOiB7fVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZWRnZUluZGljZXNBcnJheXMnLCB7XG4gICAgICB2YWx1ZToge31cbiAgICB9KTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIERPTSBlbGVtZW50czpcbiAgICBpZiAodGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnYmF0Y2hFZGdlc0RyYXdpbmcnKSkge1xuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnZWRnZXMnLCB0cnVlKTtcbiAgICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ25vZGVzJywgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ3NjZW5lJywgdHJ1ZSk7XG4gICAgICB0aGlzLmNvbnRleHRzLm5vZGVzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcbiAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ2xhYmVscycpO1xuICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ21vdXNlJyk7XG4gICAgdGhpcy5jb250ZXh0cy5ob3ZlciA9IHRoaXMuY29udGV4dHMubW91c2U7XG5cbiAgICAvLyBJbml0aWFsaXplIGNhcHRvcnM6XG4gICAgdGhpcy5jYXB0b3JzID0gW107XG4gICAgYSA9IHRoaXMub3B0aW9ucy5jYXB0b3JzIHx8IFtzaWdtYS5jYXB0b3JzLm1vdXNlLCBzaWdtYS5jYXB0b3JzLnRvdWNoXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuID0gdHlwZW9mIGFbaV0gPT09ICdmdW5jdGlvbicgPyBhW2ldIDogc2lnbWEuY2FwdG9yc1thW2ldXTtcbiAgICAgIHRoaXMuY2FwdG9ycy5wdXNoKFxuICAgICAgICBuZXcgZm4oXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5tb3VzZSxcbiAgICAgICAgICB0aGlzLmNhbWVyYSxcbiAgICAgICAgICB0aGlzLnNldHRpbmdzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRGVhbCB3aXRoIHNpZ21hIGV2ZW50czpcbiAgICBzaWdtYS5taXNjLmJpbmRFdmVudHMuY2FsbCh0aGlzLCB0aGlzLmNhbWVyYS5wcmVmaXgpO1xuICAgIHNpZ21hLm1pc2MuZHJhd0hvdmVycy5jYWxsKHRoaXMsIHRoaXMuY2FtZXJhLnByZWZpeCk7XG5cbiAgICB0aGlzLnJlc2l6ZSgpO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGdlbmVyYXRlIHRoZSBub2RlcyBhbmQgZWRnZXMgZmxvYXQgYXJyYXlzLiBUaGlzIHN0ZXAgaXNcbiAgICogc2VwYXJhdGVkIGZyb20gdGhlIFwicmVuZGVyXCIgbWV0aG9kLCBiZWNhdXNlIHRvIGtlZXAgV2ViR0wgZWZmaWNpZW50LCBzaW5jZVxuICAgKiBhbGwgdGhlIGNhbWVyYSBhbmQgbWlkZGxld2FyZXMgYXJlIG1vZGVsaXNlZCBhcyBtYXRyaWNlcyBhbmQgdGhleSBkbyBub3RcbiAgICogcmVxdWlyZSB0aGUgZmxvYXQgYXJyYXlzIHRvIGJlIHJlZ2VuZXJhdGVkLlxuICAgKlxuICAgKiBCYXNpY2FsbHksIHdoZW4gdGhlIHVzZXIgbW92ZXMgdGhlIGNhbWVyYSBvciBhcHBsaWVzIHNvbWUgc3BlY2lmaWMgbGluZWFyXG4gICAqIHRyYW5zZm9ybWF0aW9ucywgdGhpcyBwcm9jZXNzIHN0ZXAgd2lsbCBiZSBza2lwcGVkLCBhbmQgdGhlIFwicmVuZGVyXCJcbiAgICogbWV0aG9kIHdpbGwgZWZmaWNpZW50bHkgcmVmcmVzaCB0aGUgcmVuZGVyaW5nLlxuICAgKlxuICAgKiBBbmQgd2hlbiB0aGUgdXNlciBtb2RpZmllcyB0aGUgZ3JhcGggY29sb3JzIG9yIHBvc2l0aW9ucyAoYXBwbHlpbmcgYSBuZXdcbiAgICogbGF5b3V0IG9yIGZpbHRlcmluZyB0aGUgY29sb3JzLCBmb3IgaW5zdGFuY2UpLCB0aGlzIFwicHJvY2Vzc1wiIHN0ZXAgd2lsbCBiZVxuICAgKiByZXF1aXJlZCB0byByZWdlbmVyYXRlIHRoZSBmbG9hdCBhcnJheXMuXG4gICAqXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy53ZWJnbH0gUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEsXG4gICAgICAgIGksXG4gICAgICAgIGwsXG4gICAgICAgIGssXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHJlbmRlcmVyLFxuICAgICAgICBncmFwaCA9IHRoaXMuZ3JhcGgsXG4gICAgICAgIG9wdGlvbnMgPSBzaWdtYS51dGlscy5leHRlbmQob3B0aW9ucywgdGhpcy5vcHRpb25zKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VUeXBlID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdEVkZ2VUeXBlJyksXG4gICAgICAgIGRlZmF1bHROb2RlVHlwZSA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHROb2RlVHlwZScpO1xuXG4gICAgLy8gRW1wdHkgZmxvYXQgYXJyYXlzOlxuICAgIGZvciAoayBpbiB0aGlzLm5vZGVGbG9hdEFycmF5cylcbiAgICAgIGRlbGV0ZSB0aGlzLm5vZGVGbG9hdEFycmF5c1trXTtcblxuICAgIGZvciAoayBpbiB0aGlzLmVkZ2VGbG9hdEFycmF5cylcbiAgICAgIGRlbGV0ZSB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXTtcblxuICAgIGZvciAoayBpbiB0aGlzLmVkZ2VJbmRpY2VzQXJyYXlzKVxuICAgICAgZGVsZXRlIHRoaXMuZWRnZUluZGljZXNBcnJheXNba107XG5cbiAgICAvLyBTb3J0IGVkZ2VzIGFuZCBub2RlcyBwZXIgdHlwZXM6XG4gICAgZm9yIChhID0gZ3JhcGguZWRnZXMoKSwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdHlwZSA9IGFbaV0udHlwZSB8fCBkZWZhdWx0RWRnZVR5cGU7XG4gICAgICBrID0gKHR5cGUgJiYgc2lnbWEud2ViZ2wuZWRnZXNbdHlwZV0pID8gdHlwZSA6ICdkZWYnO1xuXG4gICAgICBpZiAoIXRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdKVxuICAgICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXSA9IHtcbiAgICAgICAgICBlZGdlczogW11cbiAgICAgICAgfTtcblxuICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10uZWRnZXMucHVzaChhW2ldKTtcbiAgICB9XG5cbiAgICBmb3IgKGEgPSBncmFwaC5ub2RlcygpLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0eXBlID0gYVtpXS50eXBlIHx8IGRlZmF1bHROb2RlVHlwZTtcbiAgICAgIGsgPSAodHlwZSAmJiBzaWdtYS53ZWJnbC5ub2Rlc1t0eXBlXSkgPyB0eXBlIDogJ2RlZic7XG5cbiAgICAgIGlmICghdGhpcy5ub2RlRmxvYXRBcnJheXNba10pXG4gICAgICAgIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdID0ge1xuICAgICAgICAgIG5vZGVzOiBbXVxuICAgICAgICB9O1xuXG4gICAgICB0aGlzLm5vZGVGbG9hdEFycmF5c1trXS5ub2Rlcy5wdXNoKGFbaV0pO1xuICAgIH1cblxuICAgIC8vIFB1c2ggZWRnZXM6XG4gICAgZm9yIChrIGluIHRoaXMuZWRnZUZsb2F0QXJyYXlzKSB7XG4gICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLmVkZ2VzW2tdO1xuICAgICAgYSA9IHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdLmVkZ2VzO1xuXG4gICAgICAvLyBDcmVhdGluZyB0aGUgbmVjZXNzYXJ5IGFycmF5c1xuICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10uYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFxuICAgICAgICBhLmxlbmd0aCAqIHJlbmRlcmVyLlBPSU5UUyAqIHJlbmRlcmVyLkFUVFJJQlVURVNcbiAgICAgICk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXG4gICAgICAgIC8vIEp1c3QgY2hlY2sgdGhhdCB0aGUgZWRnZSBhbmQgYm90aCBpdHMgZXh0cmVtaXRpZXMgYXJlIHZpc2libGU6XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhYVtpXS5oaWRkZW4gJiZcbiAgICAgICAgICAhZ3JhcGgubm9kZXMoYVtpXS5zb3VyY2UpLmhpZGRlbiAmJlxuICAgICAgICAgICFncmFwaC5ub2RlcyhhW2ldLnRhcmdldCkuaGlkZGVuXG4gICAgICAgIClcbiAgICAgICAgICByZW5kZXJlci5hZGRFZGdlKFxuICAgICAgICAgICAgYVtpXSxcbiAgICAgICAgICAgIGdyYXBoLm5vZGVzKGFbaV0uc291cmNlKSxcbiAgICAgICAgICAgIGdyYXBoLm5vZGVzKGFbaV0udGFyZ2V0KSxcbiAgICAgICAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdLmFycmF5LFxuICAgICAgICAgICAgaSAqIHJlbmRlcmVyLlBPSU5UUyAqIHJlbmRlcmVyLkFUVFJJQlVURVMsXG4gICAgICAgICAgICBvcHRpb25zLnByZWZpeCxcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NcbiAgICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVyLmNvbXB1dGVJbmRpY2VzID09PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aGlzLmVkZ2VJbmRpY2VzQXJyYXlzW2tdID0gcmVuZGVyZXIuY29tcHV0ZUluZGljZXMoXG4gICAgICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10uYXJyYXlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBQdXNoIG5vZGVzOlxuICAgIGZvciAoayBpbiB0aGlzLm5vZGVGbG9hdEFycmF5cykge1xuICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5ub2Rlc1trXTtcbiAgICAgIGEgPSB0aGlzLm5vZGVGbG9hdEFycmF5c1trXS5ub2RlcztcblxuICAgICAgLy8gQ3JlYXRpbmcgdGhlIG5lY2Vzc2FyeSBhcnJheXNcbiAgICAgIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgYS5sZW5ndGggKiByZW5kZXJlci5QT0lOVFMgKiByZW5kZXJlci5BVFRSSUJVVEVTXG4gICAgICApO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKCF0aGlzLm5vZGVGbG9hdEFycmF5c1trXS5hcnJheSlcbiAgICAgICAgICB0aGlzLm5vZGVGbG9hdEFycmF5c1trXS5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgICAgICBhLmxlbmd0aCAqIHJlbmRlcmVyLlBPSU5UUyAqIHJlbmRlcmVyLkFUVFJJQlVURVNcbiAgICAgICAgICApO1xuXG4gICAgICAgIC8vIEp1c3QgY2hlY2sgdGhhdCB0aGUgZWRnZSBhbmQgYm90aCBpdHMgZXh0cmVtaXRpZXMgYXJlIHZpc2libGU6XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhYVtpXS5oaWRkZW5cbiAgICAgICAgKVxuICAgICAgICAgIHJlbmRlcmVyLmFkZE5vZGUoXG4gICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXksXG4gICAgICAgICAgICBpICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFUyxcbiAgICAgICAgICAgIG9wdGlvbnMucHJlZml4LFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlbmRlcnMgdGhlIGdyYXBoLiBJdCBiYXNpY2FsbHkgY2FsbHMgZWFjaCBwcm9ncmFtIChhbmRcbiAgICogZ2VuZXJhdGUgdGhlbSBpZiB0aGV5IGRvIG5vdCBleGlzdCB5ZXQpIHRvIHJlbmRlciBub2RlcyBhbmQgZWRnZXMsIGJhdGNoZWRcbiAgICogcGVyIHJlbmRlcmVyLlxuICAgKlxuICAgKiBBcyBpbiB0aGUgY2FudmFzIHJlbmRlcmVyLCBpdCBpcyBwb3NzaWJsZSB0byBkaXNwbGF5IGVkZ2VzLCBub2RlcyBhbmQgLyBvclxuICAgKiBsYWJlbHMgaW4gYmF0Y2hlcywgdG8gbWFrZSB0aGUgd2hvbGUgdGhpbmcgd2F5IG1vcmUgc2NhbGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgICAgICAgICAgICAgcGFyYW1zIEV2ZW50dWFsbHkgYW4gb2JqZWN0IG9mIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy53ZWJnbH0gICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgdmFyIGEsXG4gICAgICAgIGksXG4gICAgICAgIGwsXG4gICAgICAgIGssXG4gICAgICAgIG8sXG4gICAgICAgIHByb2dyYW0sXG4gICAgICAgIHJlbmRlcmVyLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgZ3JhcGggPSB0aGlzLmdyYXBoLFxuICAgICAgICBub2Rlc0dsID0gdGhpcy5jb250ZXh0cy5ub2RlcyxcbiAgICAgICAgZWRnZXNHbCA9IHRoaXMuY29udGV4dHMuZWRnZXMsXG4gICAgICAgIG1hdHJpeCA9IHRoaXMuY2FtZXJhLmdldE1hdHJpeCgpLFxuICAgICAgICBvcHRpb25zID0gc2lnbWEudXRpbHMuZXh0ZW5kKHBhcmFtcywgdGhpcy5vcHRpb25zKSxcbiAgICAgICAgZHJhd0xhYmVscyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdMYWJlbHMnKSxcbiAgICAgICAgZHJhd0VkZ2VzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0VkZ2VzJyksXG4gICAgICAgIGRyYXdOb2RlcyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdOb2RlcycpO1xuXG4gICAgLy8gQ2FsbCB0aGUgcmVzaXplIGZ1bmN0aW9uOlxuICAgIHRoaXMucmVzaXplKGZhbHNlKTtcblxuICAgIC8vIENoZWNrIHRoZSAnaGlkZUVkZ2VzT25Nb3ZlJyBzZXR0aW5nOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdoaWRlRWRnZXNPbk1vdmUnKSlcbiAgICAgIGlmICh0aGlzLmNhbWVyYS5pc0FuaW1hdGVkIHx8IHRoaXMuY2FtZXJhLmlzTW92aW5nKVxuICAgICAgICBkcmF3RWRnZXMgPSBmYWxzZTtcblxuICAgIC8vIENsZWFyIGNhbnZhc2VzOlxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIC8vIFRyYW5zbGF0ZSBtYXRyaXggdG8gW3dpZHRoLzIsIGhlaWdodC8yXTpcbiAgICBtYXRyaXggPSBzaWdtYS51dGlscy5tYXRyaWNlcy5tdWx0aXBseShcbiAgICAgIG1hdHJpeCxcbiAgICAgIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnRyYW5zbGF0aW9uKHRoaXMud2lkdGggLyAyLCB0aGlzLmhlaWdodCAvIDIpXG4gICAgKTtcblxuICAgIC8vIEtpbGwgcnVubmluZyBqb2JzOlxuICAgIGZvciAoayBpbiB0aGlzLmpvYnMpXG4gICAgICBpZiAoY29ucmFkLmhhc0pvYihrKSlcbiAgICAgICAgY29ucmFkLmtpbGxKb2Ioayk7XG5cbiAgICBpZiAoZHJhd0VkZ2VzKSB7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnYmF0Y2hFZGdlc0RyYXdpbmcnKSlcbiAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhLFxuICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgam9iLFxuICAgICAgICAgICAgICBhcnIsXG4gICAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgIGluZGljZXMsXG4gICAgICAgICAgICAgIHJlbmRlcmVyLFxuICAgICAgICAgICAgICBiYXRjaFNpemUsXG4gICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmFtO1xuXG4gICAgICAgICAgaWQgPSAnZWRnZXNfJyArIHRoaXMuY29ucmFkSWQ7XG4gICAgICAgICAgYmF0Y2hTaXplID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnd2ViZ2xFZGdlc0JhdGNoU2l6ZScpO1xuICAgICAgICAgIGEgPSBPYmplY3Qua2V5cyh0aGlzLmVkZ2VGbG9hdEFycmF5cyk7XG5cbiAgICAgICAgICBpZiAoIWEubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgIHJlbmRlcmVyID0gc2lnbWEud2ViZ2wuZWRnZXNbYVtpXV07XG4gICAgICAgICAgYXJyID0gdGhpcy5lZGdlRmxvYXRBcnJheXNbYVtpXV0uYXJyYXk7XG4gICAgICAgICAgaW5kaWNlcyA9IHRoaXMuZWRnZUluZGljZXNBcnJheXNbYVtpXV07XG4gICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgIGVuZCA9IE1hdGgubWluKFxuICAgICAgICAgICAgc3RhcnQgKyBiYXRjaFNpemUgKiByZW5kZXJlci5QT0lOVFMsXG4gICAgICAgICAgICBhcnIubGVuZ3RoIC8gcmVuZGVyZXIuQVRUUklCVVRFU1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBqb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIHByb2dyYW06XG4gICAgICAgICAgICBpZiAoIXRoaXMuZWRnZVByb2dyYW1zW2FbaV1dKVxuICAgICAgICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtc1thW2ldXSA9IHJlbmRlcmVyLmluaXRQcm9ncmFtKGVkZ2VzR2wpO1xuXG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgICAgICAgZWRnZXNHbC51c2VQcm9ncmFtKHRoaXMuZWRnZVByb2dyYW1zW2FbaV1dKTtcbiAgICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKFxuICAgICAgICAgICAgICAgIGVkZ2VzR2wsXG4gICAgICAgICAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNbYVtpXV0sXG4gICAgICAgICAgICAgICAgYXJyLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLFxuICAgICAgICAgICAgICAgICAgbWF0cml4OiBtYXRyaXgsXG4gICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICByYXRpbzogdGhpcy5jYW1lcmEucmF0aW8sXG4gICAgICAgICAgICAgICAgICBzY2FsaW5nUmF0aW86IHRoaXMuc2V0dGluZ3MoXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJ1xuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgIGNvdW50OiBlbmQgLSBzdGFydCxcbiAgICAgICAgICAgICAgICAgIGluZGljZXNEYXRhOiBpbmRpY2VzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYXRjaCBqb2IncyBlbmQ6XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGVuZCA+PSBhcnIubGVuZ3RoIC8gcmVuZGVyZXIuQVRUUklCVVRFUyAmJlxuICAgICAgICAgICAgICBpID09PSBhLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5qb2JzW2lkXTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW5kID49IGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTKSB7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgYXJyID0gdGhpcy5lZGdlRmxvYXRBcnJheXNbYVtpXV0uYXJyYXk7XG4gICAgICAgICAgICAgIHJlbmRlcmVyID0gc2lnbWEud2ViZ2wuZWRnZXNbYVtpXV07XG4gICAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgc3RhcnQgKyBiYXRjaFNpemUgKiByZW5kZXJlci5QT0lOVFMsXG4gICAgICAgICAgICAgICAgYXJyLmxlbmd0aCAvIHJlbmRlcmVyLkFUVFJJQlVURVNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICBzdGFydCArIGJhdGNoU2l6ZSAqIHJlbmRlcmVyLlBPSU5UUyxcbiAgICAgICAgICAgICAgICBhcnIubGVuZ3RoIC8gcmVuZGVyZXIuQVRUUklCVVRFU1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdGhpcy5qb2JzW2lkXSA9IGpvYjtcbiAgICAgICAgICBjb25yYWQuYWRkSm9iKGlkLCBqb2IuYmluZCh0aGlzKSk7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yIChrIGluIHRoaXMuZWRnZUZsb2F0QXJyYXlzKSB7XG4gICAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5lZGdlc1trXTtcblxuICAgICAgICAgIC8vIENoZWNrIHByb2dyYW06XG4gICAgICAgICAgaWYgKCF0aGlzLmVkZ2VQcm9ncmFtc1trXSlcbiAgICAgICAgICAgIHRoaXMuZWRnZVByb2dyYW1zW2tdID0gcmVuZGVyZXIuaW5pdFByb2dyYW0oZWRnZXNHbCk7XG5cbiAgICAgICAgICAvLyBSZW5kZXJcbiAgICAgICAgICBpZiAodGhpcy5lZGdlRmxvYXRBcnJheXNba10pIHtcbiAgICAgICAgICAgIGVkZ2VzR2wudXNlUHJvZ3JhbSh0aGlzLmVkZ2VQcm9ncmFtc1trXSk7XG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXIoXG4gICAgICAgICAgICAgIGVkZ2VzR2wsXG4gICAgICAgICAgICAgIHRoaXMuZWRnZVByb2dyYW1zW2tdLFxuICAgICAgICAgICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5hcnJheSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLFxuICAgICAgICAgICAgICAgIG1hdHJpeDogbWF0cml4LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgcmF0aW86IHRoaXMuY2FtZXJhLnJhdGlvLFxuICAgICAgICAgICAgICAgIHNjYWxpbmdSYXRpbzogdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpLFxuICAgICAgICAgICAgICAgIGluZGljZXNEYXRhOiB0aGlzLmVkZ2VJbmRpY2VzQXJyYXlzW2tdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRyYXdOb2Rlcykge1xuICAgICAgLy8gRW5hYmxlIGJsZW5kaW5nOlxuICAgICAgbm9kZXNHbC5ibGVuZEZ1bmMobm9kZXNHbC5TUkNfQUxQSEEsIG5vZGVzR2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICBub2Rlc0dsLmVuYWJsZShub2Rlc0dsLkJMRU5EKTtcblxuICAgICAgZm9yIChrIGluIHRoaXMubm9kZUZsb2F0QXJyYXlzKSB7XG4gICAgICAgIHJlbmRlcmVyID0gc2lnbWEud2ViZ2wubm9kZXNba107XG5cbiAgICAgICAgLy8gQ2hlY2sgcHJvZ3JhbTpcbiAgICAgICAgaWYgKCF0aGlzLm5vZGVQcm9ncmFtc1trXSlcbiAgICAgICAgICB0aGlzLm5vZGVQcm9ncmFtc1trXSA9IHJlbmRlcmVyLmluaXRQcm9ncmFtKG5vZGVzR2wpO1xuXG4gICAgICAgIC8vIFJlbmRlclxuICAgICAgICBpZiAodGhpcy5ub2RlRmxvYXRBcnJheXNba10pIHtcbiAgICAgICAgICBub2Rlc0dsLnVzZVByb2dyYW0odGhpcy5ub2RlUHJvZ3JhbXNba10pO1xuICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcihcbiAgICAgICAgICAgIG5vZGVzR2wsXG4gICAgICAgICAgICB0aGlzLm5vZGVQcm9ncmFtc1trXSxcbiAgICAgICAgICAgIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLmFycmF5LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgICAgICAgbWF0cml4OiBtYXRyaXgsXG4gICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgICByYXRpbzogdGhpcy5jYW1lcmEucmF0aW8sXG4gICAgICAgICAgICAgIHNjYWxpbmdSYXRpbzogdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkcmF3TGFiZWxzKSB7XG4gICAgICBhID0gdGhpcy5jYW1lcmEucXVhZHRyZWUuYXJlYShcbiAgICAgICAgdGhpcy5jYW1lcmEuZ2V0UmVjdGFuZ2xlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICAgICAgKTtcblxuICAgICAgLy8gQXBwbHkgY2FtZXJhIHZpZXcgdG8gdGhlc2Ugbm9kZXM6XG4gICAgICB0aGlzLmNhbWVyYS5hcHBseVZpZXcoXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB7XG4gICAgICAgICAgbm9kZXM6IGEsXG4gICAgICAgICAgZWRnZXM6IFtdLFxuICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgbyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gc2VsZi5zZXR0aW5ncyh7XG4gICAgICAgICAgcHJlZml4OiBzZWxmLmNhbWVyYS5wcmVmaXhcbiAgICAgICAgfSwga2V5KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKCFhW2ldLmhpZGRlbilcbiAgICAgICAgICAoXG4gICAgICAgICAgICBzaWdtYS5jYW52YXMubGFiZWxzW1xuICAgICAgICAgICAgICBhW2ldLnR5cGUgfHxcbiAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdE5vZGVUeXBlJylcbiAgICAgICAgICAgIF0gfHwgc2lnbWEuY2FudmFzLmxhYmVscy5kZWZcbiAgICAgICAgICApKGFbaV0sIHRoaXMuY29udGV4dHMubGFiZWxzLCBvKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3JlbmRlcicpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBET00gZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUsIHN3aXRjaGVzIGl0c1xuICAgKiBwb3NpdGlvbiB0byBcImFic29sdXRlXCIsIHJlZmVyZW5jZXMgaXQgdG8gdGhlIGRvbUVsZW1lbnRzIGF0dHJpYnV0ZSwgYW5kXG4gICAqIGZpbmFsbHkgYXBwZW5kcyBpdCB0byB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgdGFnICAgVGhlIGxhYmVsIHRhZy5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIGlkICAgIFRoZSBpZCBvZiB0aGUgZWxlbWVudCAodG8gc3RvcmUgaXQgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFwiZG9tRWxlbWVudHNcIikuXG4gICAqIEBwYXJhbSAgez9ib29sZWFufSB3ZWJnbCBXaWxsIGluaXQgdGhlIFdlYkdMIGNvbnRleHQgaWYgdHJ1ZS5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUuaW5pdERPTSA9IGZ1bmN0aW9uKHRhZywgaWQsIHdlYmdsKSB7XG4gICAgdmFyIGdsLFxuICAgICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyksXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgZG9tLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsICdzaWdtYS0nICsgaWQpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50c1tpZF0gPSBkb207XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZG9tKTtcblxuICAgIGlmICh0YWcudG9Mb3dlckNhc2UoKSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgIHRoaXMuY29udGV4dHNbaWRdID0gZG9tLmdldENvbnRleHQod2ViZ2wgPyAnZXhwZXJpbWVudGFsLXdlYmdsJyA6ICcyZCcsIHtcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkaW5nIHdlYmdsIGNvbnRleHQgbG9zcyBsaXN0ZW5lcnNcbiAgICAgIGlmICh3ZWJnbCkge1xuICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgc2VsZi5yZW5kZXIoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVzaXplcyBlYWNoIERPTSBlbGVtZW50cyBpbiB0aGUgY29udGFpbmVyIGFuZCBzdG9yZXMgdGhlIG5ld1xuICAgKiBkaW1lbnNpb25zLiBUaGVuLCBpdCByZW5kZXJzIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtICB7P251bWJlcn0gICAgICAgICAgICAgICB3aWR0aCAgVGhlIG5ldyB3aWR0aCBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcGFyYW0gIHs/bnVtYmVyfSAgICAgICAgICAgICAgIGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMud2ViZ2x9ICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHcsIGgpIHtcbiAgICB2YXIgayxcbiAgICAgICAgb2xkV2lkdGggPSB0aGlzLndpZHRoLFxuICAgICAgICBvbGRIZWlnaHQgPSB0aGlzLmhlaWdodCxcbiAgICAgICAgcGl4ZWxSYXRpbyA9IHNpZ21hLnV0aWxzLmdldFBpeGVsUmF0aW8oKTtcblxuICAgIGlmICh3ICE9PSB1bmRlZmluZWQgJiYgaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLndpZHRoID0gdztcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIHcgPSB0aGlzLndpZHRoO1xuICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChvbGRXaWR0aCAhPT0gdGhpcy53aWR0aCB8fCBvbGRIZWlnaHQgIT09IHRoaXMuaGVpZ2h0KSB7XG4gICAgICBmb3IgKGsgaW4gdGhpcy5kb21FbGVtZW50cykge1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG5cbiAgICAgICAgaWYgKHRoaXMuZG9tRWxlbWVudHNba10udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJykge1xuICAgICAgICAgIC8vIElmIHNpbXBsZSAyRCBjYW52YXM6XG4gICAgICAgICAgaWYgKHRoaXMuY29udGV4dHNba10gJiYgdGhpcy5jb250ZXh0c1trXS5zY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgKHcgKiBwaXhlbFJhdGlvKSArICdweCcpO1xuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIChoICogcGl4ZWxSYXRpbykgKyAncHgnKTtcblxuICAgICAgICAgICAgaWYgKHBpeGVsUmF0aW8gIT09IDEpXG4gICAgICAgICAgICAgIHRoaXMuY29udGV4dHNba10uc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgICAodyAqIHRoaXMuc2V0dGluZ3MoJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nKSkgKyAncHgnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICAgICAgICAoaCAqIHRoaXMuc2V0dGluZ3MoJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nKSkgKyAncHgnXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNjYWxlOlxuICAgIGZvciAoayBpbiB0aGlzLmNvbnRleHRzKVxuICAgICAgaWYgKHRoaXMuY29udGV4dHNba10gJiYgdGhpcy5jb250ZXh0c1trXS52aWV3cG9ydClcbiAgICAgICAgdGhpcy5jb250ZXh0c1trXS52aWV3cG9ydChcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgdGhpcy53aWR0aCAqIHRoaXMuc2V0dGluZ3MoJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nKSxcbiAgICAgICAgICB0aGlzLmhlaWdodCAqIHRoaXMuc2V0dGluZ3MoJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nKVxuICAgICAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNsZWFycyBlYWNoIGNhbnZhcy5cbiAgICpcbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLndlYmdsfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb250ZXh0cy5sYWJlbHMuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB0aGlzLmNvbnRleHRzLm5vZGVzLmNsZWFyKHRoaXMuY29udGV4dHMubm9kZXMuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgdGhpcy5jb250ZXh0cy5lZGdlcy5jbGVhcih0aGlzLmNvbnRleHRzLmVkZ2VzLkNPTE9SX0JVRkZFUl9CSVQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGtpbGxzIGNvbnRleHRzIGFuZCBvdGhlciBhdHRyaWJ1dGVzLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGssXG4gICAgICAgIGNhcHRvcjtcblxuICAgIC8vIEtpbGwgY2FwdG9yczpcbiAgICB3aGlsZSAoKGNhcHRvciA9IHRoaXMuY2FwdG9ycy5wb3AoKSkpXG4gICAgICBjYXB0b3Iua2lsbCgpO1xuICAgIGRlbGV0ZSB0aGlzLmNhcHRvcnM7XG5cbiAgICAvLyBLaWxsIGNvbnRleHRzOlxuICAgIGZvciAoayBpbiB0aGlzLmRvbUVsZW1lbnRzKSB7XG4gICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50c1trXSk7XG4gICAgICBkZWxldGUgdGhpcy5kb21FbGVtZW50c1trXTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbnRleHRzW2tdO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5kb21FbGVtZW50cztcbiAgICBkZWxldGUgdGhpcy5jb250ZXh0cztcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhlIG9iamVjdCBcInNpZ21hLndlYmdsLm5vZGVzXCIgY29udGFpbnMgdGhlIGRpZmZlcmVudCBXZWJHTCBub2RlXG4gICAqIHJlbmRlcmVycy4gVGhlIGRlZmF1bHQgb25lIGRyYXcgbm9kZXMgYXMgZGlzY3MuIEhlcmUgYXJlIHRoZSBhdHRyaWJ1dGVzXG4gICAqIGFueSBub2RlIHJlbmRlcmVyIG11c3QgaGF2ZTpcbiAgICpcbiAgICoge251bWJlcn0gICBQT0lOVFMgICAgICBUaGUgbnVtYmVyIG9mIHBvaW50cyByZXF1aXJlZCB0byBkcmF3IGEgbm9kZS5cbiAgICoge251bWJlcn0gICBBVFRSSUJVVEVTICBUaGUgbnVtYmVyIG9mIGF0dHJpYnV0ZXMgbmVlZGVkIHRvIGRyYXcgb25lIHBvaW50LlxuICAgKiB7ZnVuY3Rpb259IGFkZE5vZGUgICAgIEEgZnVuY3Rpb24gdGhhdCBhZGRzIGEgbm9kZSB0byB0aGUgZGF0YSBzdGFjayB0aGF0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBnaXZlbiB0byB0aGUgYnVmZmVyLiBIZXJlIGlzIHRoZSBhcmd1bWVudHM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBub2RlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7bnVtYmVyfSAgICAgICBpbmRleCAgIFRoZSBub2RlIGluZGV4IGluIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlcyBhcnJheS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtGbG9hdDMyQXJyYXl9IGRhdGEgICAgVGhlIHN0YWNrLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgb3B0aW9ucyBTb21lIG9wdGlvbnMuXG4gICAqIHtmdW5jdGlvbn0gcmVuZGVyICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBlZmZlY3RpdmVseSByZW5kZXIgdGhlIG5vZGVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgaW50byB0aGUgYnVmZmVyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtXZWJHTFByb2dyYW19ICAgICAgICAgIHByb2dyYW1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtGbG9hdDMyQXJyYXl9IGRhdGEgICAgVGhlIHN0YWNrIHRvIGdpdmUgdG8gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIHBhcmFtcyAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgc29tZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLCBsaWtlIHdpZHRoLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsIHRoZSBjYW1lcmEgcmF0aW8uXG4gICAqIHtmdW5jdGlvbn0gaW5pdFByb2dyYW0gVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBpbml0aWF0ZSB0aGUgcHJvZ3JhbSwgd2l0aFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHRoZSByZWxldmFudCBzaGFkZXJzIGFuZCBwYXJhbWV0ZXJzLiBJdCBtdXN0IHJldHVyblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBuZXdseSBjcmVhdGVkIHByb2dyYW0uXG4gICAqXG4gICAqIENoZWNrIHNpZ21hLndlYmdsLm5vZGVzLmRlZiBvciBzaWdtYS53ZWJnbC5ub2Rlcy5mYXN0IHRvIHNlZSBob3cgaXRcbiAgICogd29ya3MgbW9yZSBwcmVjaXNlbHkuXG4gICAqL1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLm5vZGVzJyk7XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgXCJzaWdtYS53ZWJnbC5lZGdlc1wiIGNvbnRhaW5zIHRoZSBkaWZmZXJlbnQgV2ViR0wgZWRnZVxuICAgKiByZW5kZXJlcnMuIFRoZSBkZWZhdWx0IG9uZSBkcmF3IGVkZ2VzIGFzIGRpcmVjdCBsaW5lcy4gSGVyZSBhcmUgdGhlXG4gICAqIGF0dHJpYnV0ZXMgYW55IGVkZ2UgcmVuZGVyZXIgbXVzdCBoYXZlOlxuICAgKlxuICAgKiB7bnVtYmVyfSAgIFBPSU5UUyAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHJlcXVpcmVkIHRvIGRyYXcgYW4gZWRnZS5cbiAgICoge251bWJlcn0gICBBVFRSSUJVVEVTICBUaGUgbnVtYmVyIG9mIGF0dHJpYnV0ZXMgbmVlZGVkIHRvIGRyYXcgb25lIHBvaW50LlxuICAgKiB7ZnVuY3Rpb259IGFkZEVkZ2UgICAgIEEgZnVuY3Rpb24gdGhhdCBhZGRzIGFuIGVkZ2UgdG8gdGhlIGRhdGEgc3RhY2sgdGhhdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGJ1ZmZlci4gSGVyZSBpcyB0aGUgYXJndW1lbnRzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgZWRnZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgc291cmNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICB0YXJnZXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtGbG9hdDMyQXJyYXl9IGRhdGEgICAgVGhlIHN0YWNrLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgb3B0aW9ucyBTb21lIG9wdGlvbnMuXG4gICAqIHtmdW5jdGlvbn0gcmVuZGVyICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBlZmZlY3RpdmVseSByZW5kZXIgdGhlIGVkZ2VzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgaW50byB0aGUgYnVmZmVyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtXZWJHTFByb2dyYW19ICAgICAgICAgIHByb2dyYW1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtGbG9hdDMyQXJyYXl9IGRhdGEgICAgVGhlIHN0YWNrIHRvIGdpdmUgdG8gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIHBhcmFtcyAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgc29tZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLCBsaWtlIHdpZHRoLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsIHRoZSBjYW1lcmEgcmF0aW8uXG4gICAqIHtmdW5jdGlvbn0gaW5pdFByb2dyYW0gVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBpbml0aWF0ZSB0aGUgcHJvZ3JhbSwgd2l0aFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHRoZSByZWxldmFudCBzaGFkZXJzIGFuZCBwYXJhbWV0ZXJzLiBJdCBtdXN0IHJldHVyblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBuZXdseSBjcmVhdGVkIHByb2dyYW0uXG4gICAqXG4gICAqIENoZWNrIHNpZ21hLndlYmdsLmVkZ2VzLmRlZiBvciBzaWdtYS53ZWJnbC5lZGdlcy5mYXN0IHRvIHNlZSBob3cgaXRcbiAgICogd29ya3MgbW9yZSBwcmVjaXNlbHkuXG4gICAqL1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLmVkZ2VzJyk7XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgXCJzaWdtYS5jYW52YXMubGFiZWxzXCIgY29udGFpbnMgdGhlIGRpZmZlcmVudFxuICAgKiBsYWJlbCByZW5kZXJlcnMgZm9yIHRoZSBXZWJHTCByZW5kZXJlci4gU2luY2UgZGlzcGxheWluZyB0ZXh0cyBpbiBXZWJHTCBpc1xuICAgKiBkZWZpbml0ZWx5IHBhaW5mdWwgYW5kIHNpbmNlIHRoZXJlIGEgd2F5IGxlc3MgbGFiZWxzIHRvIGRpc3BsYXkgdGhhbiBub2Rlc1xuICAgKiBvciBlZGdlcywgdGhlIGRlZmF1bHQgcmVuZGVyZXIgc2ltcGx5IHJlbmRlcnMgdGhlbSBpbiBhIGNhbnZhcy5cbiAgICpcbiAgICogQSBsYWJlbHMgcmVuZGVyZXIgaXMgYSBzaW1wbGUgZnVuY3Rpb24sIHRha2luZyBhcyBhcmd1bWVudHMgdGhlIHJlbGF0ZWRcbiAgICogbm9kZSwgdGhlIHJlbmRlcmVyIGFuZCBhIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubGFiZWxzJyk7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgaWYgKHR5cGVvZiBjb25yYWQgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdjb25yYWQgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnJlbmRlcmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgc3ZnIHNpZ21hJ3MgcmVuZGVyZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuZ3JhcGh9ICAgICAgICAgICAgZ3JhcGggICAgVGhlIGdyYXBoIHRvIHJlbmRlci5cbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5jYW1lcmF9ICAgICAgICAgICBjYW1lcmEgICBUaGUgY2FtZXJhLlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2lnbWEgaW5zdGFuY2Ugc2V0dGluZ3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgIG9iamVjdCAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLnN2Z30gICAgICAgICAgICAgVGhlIHJlbmRlcmVyIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLnN2ZyA9IGZ1bmN0aW9uKGdyYXBoLCBjYW1lcmEsIHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JylcbiAgICAgIHRocm93ICdzaWdtYS5yZW5kZXJlcnMuc3ZnOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmICghKG9wdGlvbnMuY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKVxuICAgICAgdGhyb3cgJ0NvbnRhaW5lciBub3QgZm91bmQuJztcblxuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBhLFxuICAgICAgICBmbixcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBtYWluIGF0dHJpYnV0ZXM6XG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuZG9tRWxlbWVudHMgPSB7XG4gICAgICBncmFwaDogbnVsbCxcbiAgICAgIGdyb3Vwczoge30sXG4gICAgICBub2Rlczoge30sXG4gICAgICBlZGdlczoge30sXG4gICAgICBsYWJlbHM6IHt9LFxuICAgICAgaG92ZXJzOiB7fVxuICAgIH07XG4gICAgdGhpcy5tZWFzdXJlbWVudENhbnZhcyA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgdGhpcy5zZXR0aW5ncyA9IChcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuc2V0dGluZ3MgPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9wdGlvbnMuc2V0dGluZ3NcbiAgICAgICkgP1xuICAgICAgICBzZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucy5zZXR0aW5ncykgOlxuICAgICAgICBzZXR0aW5ncztcblxuICAgIC8vIElzIHRoZSByZW5kZXJlciBtZWFudCB0byBiZSBmcmVlc3R5bGU/XG4gICAgdGhpcy5zZXR0aW5ncygnZnJlZVN0eWxlJywgISF0aGlzLm9wdGlvbnMuZnJlZVN0eWxlKTtcblxuICAgIC8vIFNWRyB4bWxuc1xuICAgIHRoaXMuc2V0dGluZ3MoJ3htbG5zJywgJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyk7XG5cbiAgICAvLyBJbmRleGVzOlxuICAgIHRoaXMubm9kZXNPblNjcmVlbiA9IFtdO1xuICAgIHRoaXMuZWRnZXNPblNjcmVlbiA9IFtdO1xuXG4gICAgLy8gRmluZCB0aGUgcHJlZml4OlxuICAgIHRoaXMub3B0aW9ucy5wcmVmaXggPSAncmVuZGVyZXInICsgc2lnbWEudXRpbHMuaWQoKSArICc6JztcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIERPTSBlbGVtZW50c1xuICAgIHRoaXMuaW5pdERPTSgnc3ZnJyk7XG5cbiAgICAvLyBJbml0aWFsaXplIGNhcHRvcnM6XG4gICAgdGhpcy5jYXB0b3JzID0gW107XG4gICAgYSA9IHRoaXMub3B0aW9ucy5jYXB0b3JzIHx8IFtzaWdtYS5jYXB0b3JzLm1vdXNlLCBzaWdtYS5jYXB0b3JzLnRvdWNoXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuID0gdHlwZW9mIGFbaV0gPT09ICdmdW5jdGlvbicgPyBhW2ldIDogc2lnbWEuY2FwdG9yc1thW2ldXTtcbiAgICAgIHRoaXMuY2FwdG9ycy5wdXNoKFxuICAgICAgICBuZXcgZm4oXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ncmFwaCxcbiAgICAgICAgICB0aGlzLmNhbWVyYSxcbiAgICAgICAgICB0aGlzLnNldHRpbmdzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQmluZCByZXNpemU6XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5yZXNpemUoKTtcbiAgICB9KTtcblxuICAgIC8vIERlYWwgd2l0aCBzaWdtYSBldmVudHM6XG4gICAgLy8gVE9ETzoga2VlcCBhbiBvcHRpb24gdG8gb3ZlcnJpZGUgdGhlIERPTSBldmVudHM/XG4gICAgc2lnbWEubWlzYy5iaW5kRE9NRXZlbnRzLmNhbGwodGhpcywgdGhpcy5kb21FbGVtZW50cy5ncmFwaCk7XG4gICAgdGhpcy5iaW5kSG92ZXJzKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xuXG4gICAgLy8gUmVzaXplXG4gICAgdGhpcy5yZXNpemUoZmFsc2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZW5kZXJzIHRoZSBncmFwaCBvbiB0aGUgc3ZnIHNjZW5lLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSAgICAgICAgICAgICAgICBvcHRpb25zIEV2ZW50dWFsbHkgYW4gb2JqZWN0IG9mIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5zdmd9ICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGEsXG4gICAgICAgIGksXG4gICAgICAgIGssXG4gICAgICAgIGUsXG4gICAgICAgIGwsXG4gICAgICAgIG8sXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZWRnZXMsXG4gICAgICAgIHJlbmRlcmVycyxcbiAgICAgICAgc3VicmVuZGVyZXJzLFxuICAgICAgICBpbmRleCA9IHt9LFxuICAgICAgICBncmFwaCA9IHRoaXMuZ3JhcGgsXG4gICAgICAgIG5vZGVzID0gdGhpcy5ncmFwaC5ub2RlcyxcbiAgICAgICAgcHJlZml4ID0gdGhpcy5vcHRpb25zLnByZWZpeCB8fCAnJyxcbiAgICAgICAgZHJhd0VkZ2VzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0VkZ2VzJyksXG4gICAgICAgIGRyYXdOb2RlcyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdOb2RlcycpLFxuICAgICAgICBkcmF3TGFiZWxzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0xhYmVscycpLFxuICAgICAgICBlbWJlZFNldHRpbmdzID0gdGhpcy5zZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucywge1xuICAgICAgICAgIHByZWZpeDogdGhpcy5vcHRpb25zLnByZWZpeCxcbiAgICAgICAgICBmb3JjZUxhYmVsczogdGhpcy5vcHRpb25zLmZvcmNlTGFiZWxzXG4gICAgICAgIH0pO1xuXG4gICAgLy8gQ2hlY2sgdGhlICdoaWRlRWRnZXNPbk1vdmUnIHNldHRpbmc6XG4gICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2hpZGVFZGdlc09uTW92ZScpKVxuICAgICAgaWYgKHRoaXMuY2FtZXJhLmlzQW5pbWF0ZWQgfHwgdGhpcy5jYW1lcmEuaXNNb3ZpbmcpXG4gICAgICAgIGRyYXdFZGdlcyA9IGZhbHNlO1xuXG4gICAgLy8gQXBwbHkgdGhlIGNhbWVyYSdzIHZpZXc6XG4gICAgdGhpcy5jYW1lcmEuYXBwbHlWaWV3KFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpcy5vcHRpb25zLnByZWZpeCxcbiAgICAgIHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gSGlkaW5nIGV2ZXJ5dGhpbmdcbiAgICAvLyBUT0RPOiBmaW5kIGEgbW9yZSBzZW5zaWJsZSB3YXkgdG8gcGVyZm9ybSB0aGlzIG9wZXJhdGlvblxuICAgIHRoaXMuaGlkZURPTUVsZW1lbnRzKHRoaXMuZG9tRWxlbWVudHMubm9kZXMpO1xuICAgIHRoaXMuaGlkZURPTUVsZW1lbnRzKHRoaXMuZG9tRWxlbWVudHMuZWRnZXMpO1xuICAgIHRoaXMuaGlkZURPTUVsZW1lbnRzKHRoaXMuZG9tRWxlbWVudHMubGFiZWxzKTtcblxuICAgIC8vIEZpbmQgd2hpY2ggbm9kZXMgYXJlIG9uIHNjcmVlblxuICAgIHRoaXMuZWRnZXNPblNjcmVlbiA9IFtdO1xuICAgIHRoaXMubm9kZXNPblNjcmVlbiA9IHRoaXMuY2FtZXJhLnF1YWR0cmVlLmFyZWEoXG4gICAgICB0aGlzLmNhbWVyYS5nZXRSZWN0YW5nbGUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gICAgKTtcblxuICAgIC8vIE5vZGUgaW5kZXhcbiAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpbmRleFthW2ldLmlkXSA9IGFbaV07XG5cbiAgICAvLyBGaW5kIHdoaWNoIGVkZ2VzIGFyZSBvbiBzY3JlZW5cbiAgICBmb3IgKGEgPSBncmFwaC5lZGdlcygpLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBvID0gYVtpXTtcbiAgICAgIGlmIChcbiAgICAgICAgKGluZGV4W28uc291cmNlXSB8fCBpbmRleFtvLnRhcmdldF0pICYmXG4gICAgICAgICghby5oaWRkZW4gJiYgIW5vZGVzKG8uc291cmNlKS5oaWRkZW4gJiYgIW5vZGVzKG8udGFyZ2V0KS5oaWRkZW4pXG4gICAgICApXG4gICAgICAgIHRoaXMuZWRnZXNPblNjcmVlbi5wdXNoKG8pO1xuICAgIH1cblxuICAgIC8vIERpc3BsYXkgbm9kZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLVxuICAgIHJlbmRlcmVycyA9IHNpZ21hLnN2Zy5ub2RlcztcbiAgICBzdWJyZW5kZXJlcnMgPSBzaWdtYS5zdmcubGFiZWxzO1xuXG4gICAgLy8tLSBGaXJzdCB3ZSBjcmVhdGUgdGhlIG5vZGVzIHdoaWNoIGFyZSBub3QgYWxyZWFkeSBjcmVhdGVkXG4gICAgaWYgKGRyYXdOb2RlcylcbiAgICAgIGZvciAoYSA9IHRoaXMubm9kZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoIWFbaV0uaGlkZGVuICYmICF0aGlzLmRvbUVsZW1lbnRzLm5vZGVzW2FbaV0uaWRdKSB7XG5cbiAgICAgICAgICAvLyBOb2RlXG4gICAgICAgICAgZSA9IChyZW5kZXJlcnNbYVtpXS50eXBlXSB8fCByZW5kZXJlcnMuZGVmKS5jcmVhdGUoXG4gICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLm5vZGVzW2FbaV0uaWRdID0gZTtcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyb3Vwcy5ub2Rlcy5hcHBlbmRDaGlsZChlKTtcblxuICAgICAgICAgIC8vIExhYmVsXG4gICAgICAgICAgZSA9IChzdWJyZW5kZXJlcnNbYVtpXS50eXBlXSB8fCBzdWJyZW5kZXJlcnMuZGVmKS5jcmVhdGUoXG4gICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmxhYmVsc1thW2ldLmlkXSA9IGU7XG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ncm91cHMubGFiZWxzLmFwcGVuZENoaWxkKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAvLy0tIFNlY29uZCB3ZSB1cGRhdGUgdGhlIG5vZGVzXG4gICAgaWYgKGRyYXdOb2RlcylcbiAgICAgIGZvciAoYSA9IHRoaXMubm9kZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXG4gICAgICAgIGlmIChhW2ldLmhpZGRlbilcbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAvLyBOb2RlXG4gICAgICAgIChyZW5kZXJlcnNbYVtpXS50eXBlXSB8fCByZW5kZXJlcnMuZGVmKS51cGRhdGUoXG4gICAgICAgICAgYVtpXSxcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLm5vZGVzW2FbaV0uaWRdLFxuICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBMYWJlbFxuICAgICAgICAoc3VicmVuZGVyZXJzW2FbaV0udHlwZV0gfHwgc3VicmVuZGVyZXJzLmRlZikudXBkYXRlKFxuICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5sYWJlbHNbYVtpXS5pZF0sXG4gICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgLy8gRGlzcGxheSBlZGdlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tXG4gICAgcmVuZGVyZXJzID0gc2lnbWEuc3ZnLmVkZ2VzO1xuXG4gICAgLy8tLSBGaXJzdCB3ZSBjcmVhdGUgdGhlIGVkZ2VzIHdoaWNoIGFyZSBub3QgYWxyZWFkeSBjcmVhdGVkXG4gICAgaWYgKGRyYXdFZGdlcylcbiAgICAgIGZvciAoYSA9IHRoaXMuZWRnZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tRWxlbWVudHMuZWRnZXNbYVtpXS5pZF0pIHtcbiAgICAgICAgICBzb3VyY2UgPSBub2RlcyhhW2ldLnNvdXJjZSk7XG4gICAgICAgICAgdGFyZ2V0ID0gbm9kZXMoYVtpXS50YXJnZXQpO1xuXG4gICAgICAgICAgZSA9IChyZW5kZXJlcnNbYVtpXS50eXBlXSB8fCByZW5kZXJlcnMuZGVmKS5jcmVhdGUoXG4gICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmVkZ2VzW2FbaV0uaWRdID0gZTtcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyb3Vwcy5lZGdlcy5hcHBlbmRDaGlsZChlKTtcbiAgICAgICAgfVxuICAgICAgIH1cblxuICAgIC8vLS0gU2Vjb25kIHdlIHVwZGF0ZSB0aGUgZWRnZXNcbiAgICBpZiAoZHJhd0VkZ2VzKVxuICAgICAgZm9yIChhID0gdGhpcy5lZGdlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHNvdXJjZSA9IG5vZGVzKGFbaV0uc291cmNlKTtcbiAgICAgICAgdGFyZ2V0ID0gbm9kZXMoYVtpXS50YXJnZXQpO1xuXG4gICAgICAgIChyZW5kZXJlcnNbYVtpXS50eXBlXSB8fCByZW5kZXJlcnMuZGVmKS51cGRhdGUoXG4gICAgICAgICAgYVtpXSxcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmVkZ2VzW2FbaV0uaWRdLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICApO1xuICAgICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgncmVuZGVyJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIERPTSBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSwgc3dpdGNoZXMgaXRzXG4gICAqIHBvc2l0aW9uIHRvIFwiYWJzb2x1dGVcIiwgcmVmZXJlbmNlcyBpdCB0byB0aGUgZG9tRWxlbWVudHMgYXR0cmlidXRlLCBhbmRcbiAgICogZmluYWxseSBhcHBlbmRzIGl0IHRvIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdGFnIFRoZSBsYWJlbCB0YWcuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgIFRoZSBpZCBvZiB0aGUgZWxlbWVudCAodG8gc3RvcmUgaXQgaW4gXCJkb21FbGVtZW50c1wiKS5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5zdmcucHJvdG90eXBlLmluaXRET00gPSBmdW5jdGlvbih0YWcpIHtcbiAgICB2YXIgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMuc2V0dGluZ3MoJ3htbG5zJyksIHRhZyksXG4gICAgICAgIGMgPSB0aGlzLnNldHRpbmdzKCdjbGFzc1ByZWZpeCcpLFxuICAgICAgICBnLFxuICAgICAgICBsLFxuICAgICAgICBpO1xuXG4gICAgZG9tLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsIGMgKyAnLXN2ZycpO1xuXG4gICAgLy8gU2V0dGluZyBTVkcgbmFtZXNwYWNlXG4gICAgZG9tLnNldEF0dHJpYnV0ZSgneG1sbnMnLCB0aGlzLnNldHRpbmdzKCd4bWxucycpKTtcbiAgICBkb20uc2V0QXR0cmlidXRlKCd4bWxuczp4bGluaycsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyk7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgndmVyc2lvbicsICcxLjEnKTtcblxuICAgIC8vIENyZWF0aW5nIHRoZSBtZWFzdXJlbWVudCBjYW52YXNcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjICsgJy1tZWFzdXJlbWVudC1jYW52YXMnKTtcblxuICAgIC8vIEFwcGVuZGluZyBlbGVtZW50c1xuICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGggPSB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkb20pO1xuXG4gICAgLy8gQ3JlYXRpbmcgZ3JvdXBzXG4gICAgdmFyIGdyb3VwcyA9IFsnZWRnZXMnLCAnbm9kZXMnLCAnbGFiZWxzJywgJ2hvdmVycyddO1xuICAgIGZvciAoaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMuc2V0dGluZ3MoJ3htbG5zJyksICdnJyk7XG5cbiAgICAgIGcuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2lkJywgYyArICctZ3JvdXAtJyArIGdyb3Vwc1tpXSk7XG4gICAgICBnLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIGMgKyAnLWdyb3VwJyk7XG5cbiAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JvdXBzW2dyb3Vwc1tpXV0gPVxuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLmFwcGVuZENoaWxkKGcpO1xuICAgIH1cblxuICAgIC8vIEFwcGVuZGluZyBtZWFzdXJlbWVudCBjYW52YXNcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIHRoaXMubWVhc3VyZW1lbnRDYW52YXMgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaGlkZXMgYSBiYXRjaCBvZiBTVkcgRE9NIGVsZW1lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthcnJheX0gICAgICAgICAgICAgICAgICBlbGVtZW50cyAgQW4gYXJyYXkgb2YgZWxlbWVudHMgdG8gaGlkZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgcmVuZGVyZXIgIFRoZSByZW5kZXJlciB0byB1c2UuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5zdmd9ICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuc3ZnLnByb3RvdHlwZS5oaWRlRE9NRWxlbWVudHMgPSBmdW5jdGlvbihlbGVtZW50cykge1xuICAgIHZhciBvLFxuICAgICAgICBpO1xuXG4gICAgZm9yIChpIGluIGVsZW1lbnRzKSB7XG4gICAgICBvID0gZWxlbWVudHNbaV07XG4gICAgICBzaWdtYS5zdmcudXRpbHMuaGlkZShvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgYmluZHMgdGhlIGhvdmVyIGV2ZW50cyB0byB0aGUgcmVuZGVyZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcHJlZml4IFRoZSByZW5kZXJlciBwcmVmaXguXG4gICAqL1xuICAvLyBUT0RPOiBhZGQgb3B0aW9uIGFib3V0IHdoZXRoZXIgdG8gZGlzcGxheSBob3ZlcnMgb3Igbm90XG4gIHNpZ21hLnJlbmRlcmVycy5zdmcucHJvdG90eXBlLmJpbmRIb3ZlcnMgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgcmVuZGVyZXJzID0gc2lnbWEuc3ZnLmhvdmVycyxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGhvdmVyZWROb2RlO1xuXG4gICAgZnVuY3Rpb24gb3Zlck5vZGUoZSkge1xuICAgICAgdmFyIG5vZGUgPSBlLmRhdGEubm9kZSxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzID0gc2VsZi5zZXR0aW5ncy5lbWJlZE9iamVjdHMoe1xuICAgICAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgICAgICB9KTtcblxuICAgICAgaWYgKCFlbWJlZFNldHRpbmdzKCdlbmFibGVIb3ZlcmluZycpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHZhciBob3ZlciA9IChyZW5kZXJlcnNbbm9kZS50eXBlXSB8fCByZW5kZXJlcnMuZGVmKS5jcmVhdGUoXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHNlbGYuZG9tRWxlbWVudHMubm9kZXNbbm9kZS5pZF0sXG4gICAgICAgIHNlbGYubWVhc3VyZW1lbnRDYW52YXMsXG4gICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICk7XG5cbiAgICAgIHNlbGYuZG9tRWxlbWVudHMuaG92ZXJzW25vZGUuaWRdID0gaG92ZXI7XG5cbiAgICAgIC8vIEluc2VydGluZyB0aGUgaG92ZXIgaW4gdGhlIGRvbVxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ncm91cHMuaG92ZXJzLmFwcGVuZENoaWxkKGhvdmVyKTtcbiAgICAgIGhvdmVyZWROb2RlID0gbm9kZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvdXROb2RlKGUpIHtcbiAgICAgIHZhciBub2RlID0gZS5kYXRhLm5vZGUsXG4gICAgICAgICAgZW1iZWRTZXR0aW5ncyA9IHNlbGYuc2V0dGluZ3MuZW1iZWRPYmplY3RzKHtcbiAgICAgICAgICAgIHByZWZpeDogcHJlZml4XG4gICAgICAgICAgfSk7XG5cbiAgICAgIGlmICghZW1iZWRTZXR0aW5ncygnZW5hYmxlSG92ZXJpbmcnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAvLyBEZWxldGluZyBlbGVtZW50XG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmdyb3Vwcy5ob3ZlcnMucmVtb3ZlQ2hpbGQoXG4gICAgICAgIHNlbGYuZG9tRWxlbWVudHMuaG92ZXJzW25vZGUuaWRdXG4gICAgICApO1xuICAgICAgaG92ZXJlZE5vZGUgPSBudWxsO1xuICAgICAgZGVsZXRlIHNlbGYuZG9tRWxlbWVudHMuaG92ZXJzW25vZGUuaWRdO1xuXG4gICAgICAvLyBSZWluc3RhdGVcbiAgICAgIHNlbGYuZG9tRWxlbWVudHMuZ3JvdXBzLm5vZGVzLmFwcGVuZENoaWxkKFxuICAgICAgICBzZWxmLmRvbUVsZW1lbnRzLm5vZGVzW25vZGUuaWRdXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIE9QVElNSVpFOiBwZXJmb3JtIGEgcmVhbCB1cGRhdGUgcmF0aGVyIHRoYW4gYSBkZWxldGlvblxuICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIGlmICghaG92ZXJlZE5vZGUpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgdmFyIGVtYmVkU2V0dGluZ3MgPSBzZWxmLnNldHRpbmdzLmVtYmVkT2JqZWN0cyh7XG4gICAgICAgICAgICBwcmVmaXg6IHByZWZpeFxuICAgICAgICAgIH0pO1xuXG4gICAgICAvLyBEZWxldGluZyBlbGVtZW50IGJlZm9yZSB1cGRhdGVcbiAgICAgIHNlbGYuZG9tRWxlbWVudHMuZ3JvdXBzLmhvdmVycy5yZW1vdmVDaGlsZChcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbaG92ZXJlZE5vZGUuaWRdXG4gICAgICApO1xuICAgICAgZGVsZXRlIHNlbGYuZG9tRWxlbWVudHMuaG92ZXJzW2hvdmVyZWROb2RlLmlkXTtcblxuICAgICAgdmFyIGhvdmVyID0gKHJlbmRlcmVyc1tob3ZlcmVkTm9kZS50eXBlXSB8fCByZW5kZXJlcnMuZGVmKS5jcmVhdGUoXG4gICAgICAgIGhvdmVyZWROb2RlLFxuICAgICAgICBzZWxmLmRvbUVsZW1lbnRzLm5vZGVzW2hvdmVyZWROb2RlLmlkXSxcbiAgICAgICAgc2VsZi5tZWFzdXJlbWVudENhbnZhcyxcbiAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgKTtcblxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbaG92ZXJlZE5vZGUuaWRdID0gaG92ZXI7XG5cbiAgICAgIC8vIEluc2VydGluZyB0aGUgaG92ZXIgaW4gdGhlIGRvbVxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ncm91cHMuaG92ZXJzLmFwcGVuZENoaWxkKGhvdmVyKTtcbiAgICB9XG5cbiAgICAvLyBCaW5kaW5nIGV2ZW50c1xuICAgIHRoaXMuYmluZCgnb3Zlck5vZGUnLCBvdmVyTm9kZSk7XG4gICAgdGhpcy5iaW5kKCdvdXROb2RlJywgb3V0Tm9kZSk7XG5cbiAgICAvLyBVcGRhdGUgb24gcmVuZGVyXG4gICAgdGhpcy5iaW5kKCdyZW5kZXInLCB1cGRhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXNpemVzIGVhY2ggRE9NIGVsZW1lbnRzIGluIHRoZSBjb250YWluZXIgYW5kIHN0b3JlcyB0aGUgbmV3XG4gICAqIGRpbWVuc2lvbnMuIFRoZW4sIGl0IHJlbmRlcnMgdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/bnVtYmVyfSAgICAgICAgICAgICAgICB3aWR0aCAgVGhlIG5ldyB3aWR0aCBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcGFyYW0gIHs/bnVtYmVyfSAgICAgICAgICAgICAgICBoZWlnaHQgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLnN2Z30gICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5zdmcucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHcsIGgpIHtcbiAgICB2YXIgb2xkV2lkdGggPSB0aGlzLndpZHRoLFxuICAgICAgICBvbGRIZWlnaHQgPSB0aGlzLmhlaWdodCxcbiAgICAgICAgcGl4ZWxSYXRpbyA9IDE7XG5cbiAgICBpZiAodyAhPT0gdW5kZWZpbmVkICYmIGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy53aWR0aCA9IHc7XG4gICAgICB0aGlzLmhlaWdodCA9IGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICB3ID0gdGhpcy53aWR0aDtcbiAgICAgIGggPSB0aGlzLmhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAob2xkV2lkdGggIT09IHRoaXMud2lkdGggfHwgb2xkSGVpZ2h0ICE9PSB0aGlzLmhlaWdodCkge1xuICAgICAgdGhpcy5kb21FbGVtZW50cy5ncmFwaC5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgICAgdGhpcy5kb21FbGVtZW50cy5ncmFwaC5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcblxuICAgICAgaWYgKHRoaXMuZG9tRWxlbWVudHMuZ3JhcGgudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJykge1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAodyAqIHBpeGVsUmF0aW8pKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ncmFwaC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIChoICogcGl4ZWxSYXRpbykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFRoZSBsYWJlbHMsIG5vZGVzIGFuZCBlZGdlcyByZW5kZXJlcnMgYXJlIHN0b3JlZCBpbiB0aGUgdGhyZWUgZm9sbG93aW5nXG4gICAqIG9iamVjdHMuIFdoZW4gYW4gZWxlbWVudCBpcyBkcmF3biwgaXRzIHR5cGUgd2lsbCBiZSBjaGVja2VkIGFuZCBpZiBhXG4gICAqIHJlbmRlcmVyIHdpdGggdGhlIHNhbWUgbmFtZSBleGlzdHMsIGl0IHdpbGwgYmUgdXNlZC4gSWYgbm90IGZvdW5kLCB0aGVcbiAgICogZGVmYXVsdCByZW5kZXJlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cbiAgICpcbiAgICogVGhleSBhcmUgc3RvcmVkIGluIGRpZmZlcmVudCBmaWxlcywgaW4gdGhlIFwiLi9zdmdcIiBmb2xkZXIuXG4gICAqL1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5ub2RlcycpO1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5lZGdlcycpO1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5sYWJlbHMnKTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnJlbmRlcmVycycpO1xuXG4gIC8vIENoZWNrIGlmIFdlYkdMIGlzIGVuYWJsZWQ6XG4gIHZhciBjYW52YXMsXG4gICAgICB3ZWJnbCA9ICEhZ2xvYmFsLldlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgaWYgKHdlYmdsKSB7XG4gICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdHJ5IHtcbiAgICAgIHdlYmdsID0gISEoXG4gICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8XG4gICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3ZWJnbCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvcHkgdGhlIGdvb2QgcmVuZGVyZXI6XG4gIHNpZ21hLnJlbmRlcmVycy5kZWYgPSB3ZWJnbCA/XG4gICAgc2lnbWEucmVuZGVyZXJzLndlYmdsIDpcbiAgICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzO1xufSkodGhpcyk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLm5vZGVzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbm9kZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgbm9kZXMgYXMgZGlzY3MsIHNoYXBlZCBpbiB0cmlhbmdsZXMgd2l0aFxuICAgKiB0aGUgZ2wuVFJJQU5HTEVTIGRpc3BsYXkgbW9kZS4gU28sIHRvIGJlIG1vcmUgcHJlY2lzZSwgdG8gZHJhdyBvbmUgbm9kZSxcbiAgICogaXQgd2lsbCBzdG9yZSB0aHJlZSB0aW1lcyB0aGUgY2VudGVyIG9mIG5vZGUsIHdpdGggdGhlIGNvbG9yIGFuZCB0aGUgc2l6ZSxcbiAgICogYW5kIGFuIGFuZ2xlIGluZGljYXRpbmcgd2hpY2ggXCJjb3JuZXJcIiBvZiB0aGUgdHJpYW5nbGUgdG8gZHJhdy5cbiAgICpcbiAgICogVGhlIGZyYWdtZW50IHNoYWRlciBkb2VzIG5vdCBkZWFsIHdpdGggYW50aS1hbGlhc2luZywgc28gbWFrZSBzdXJlIHRoYXRcbiAgICogeW91IGRlYWwgd2l0aCBpdCBzb21ld2hlcmUgZWxzZSBpbiB0aGUgY29kZSAoYnkgZGVmYXVsdCwgdGhlIFdlYkdMXG4gICAqIHJlbmRlcmVyIHdpbGwgb3ZlcnNhbXBsZSB0aGUgcmVuZGVyaW5nIHRocm91Z2ggdGhlIHdlYmdsT3ZlcnNhbXBsaW5nUmF0aW9cbiAgICogdmFsdWUpLlxuICAgKi9cbiAgc2lnbWEud2ViZ2wubm9kZXMuZGVmID0ge1xuICAgIFBPSU5UUzogMyxcbiAgICBBVFRSSUJVVEVTOiA1LFxuICAgIGFkZE5vZGU6IGZ1bmN0aW9uKG5vZGUsIGRhdGEsIGksIHByZWZpeCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBjb2xvciA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoXG4gICAgICAgIG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKVxuICAgICAgKTtcblxuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAneCddO1xuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAneSddO1xuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG4gICAgICBkYXRhW2krK10gPSAwO1xuXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd4J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd5J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICdzaXplJ107XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICAgIGRhdGFbaSsrXSA9IDIgKiBNYXRoLlBJIC8gMztcblxuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAneCddO1xuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAneSddO1xuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG4gICAgICBkYXRhW2krK10gPSA0ICogTWF0aC5QSSAvIDM7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBkYXRhLCBwYXJhbXMpIHtcbiAgICAgIHZhciBidWZmZXI7XG5cbiAgICAgIC8vIERlZmluZSBhdHRyaWJ1dGVzOlxuICAgICAgdmFyIHBvc2l0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zaXRpb24nKSxcbiAgICAgICAgICBzaXplTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2Ffc2l6ZScpLFxuICAgICAgICAgIGNvbG9yTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfY29sb3InKSxcbiAgICAgICAgICBhbmdsZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2FuZ2xlJyksXG4gICAgICAgICAgcmVzb2x1dGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yZXNvbHV0aW9uJyksXG4gICAgICAgICAgbWF0cml4TG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeCcpLFxuICAgICAgICAgIHJhdGlvTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3JhdGlvJyksXG4gICAgICAgICAgc2NhbGVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfc2NhbGUnKTtcblxuICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5EWU5BTUlDX0RSQVcpO1xuXG4gICAgICBnbC51bmlmb3JtMmYocmVzb2x1dGlvbkxvY2F0aW9uLCBwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQpO1xuICAgICAgZ2wudW5pZm9ybTFmKFxuICAgICAgICByYXRpb0xvY2F0aW9uLFxuICAgICAgICAxIC8gTWF0aC5wb3cocGFyYW1zLnJhdGlvLCBwYXJhbXMuc2V0dGluZ3MoJ25vZGVzUG93UmF0aW8nKSlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWYoc2NhbGVMb2NhdGlvbiwgcGFyYW1zLnNjYWxpbmdSYXRpbyk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KG1hdHJpeExvY2F0aW9uLCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG5cbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoc2l6ZUxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGNvbG9yTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYW5nbGVMb2NhdGlvbik7XG5cbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgIHBvc2l0aW9uTG9jYXRpb24sXG4gICAgICAgIDIsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgc2l6ZUxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgOFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgIGNvbG9yTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAxMlxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgIGFuZ2xlTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAxNlxuICAgICAgKTtcblxuICAgICAgZ2wuZHJhd0FycmF5cyhcbiAgICAgICAgZ2wuVFJJQU5HTEVTLFxuICAgICAgICBwYXJhbXMuc3RhcnQgfHwgMCxcbiAgICAgICAgcGFyYW1zLmNvdW50IHx8IChkYXRhLmxlbmd0aCAvIHRoaXMuQVRUUklCVVRFUylcbiAgICAgICk7XG4gICAgfSxcbiAgICBpbml0UHJvZ3JhbTogZnVuY3Rpb24oZ2wpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgcHJvZ3JhbTtcblxuICAgICAgdmVydGV4U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9zaXplOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2NvbG9yOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2FuZ2xlOycsXG5cbiAgICAgICAgICAndW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfcmF0aW87JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3NjYWxlOycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MyB1X21hdHJpeDsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuICAgICAgICAgICd2YXJ5aW5nIHZlYzIgY2VudGVyOycsXG4gICAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgcmFkaXVzOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgICAvLyBNdWx0aXBseSB0aGUgcG9pbnQgc2l6ZSB0d2ljZTpcbiAgICAgICAgICAgICdyYWRpdXMgPSBhX3NpemUgKiB1X3JhdGlvOycsXG5cbiAgICAgICAgICAgIC8vIFNjYWxlIGZyb20gW1stMSAxXSBbLTEgMV1dIHRvIHRoZSBjb250YWluZXI6XG4gICAgICAgICAgICAndmVjMiBwb3NpdGlvbiA9ICh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSkpLnh5OycsXG4gICAgICAgICAgICAvLyAnY2VudGVyID0gKHBvc2l0aW9uIC8gdV9yZXNvbHV0aW9uICogMi4wIC0gMS4wKSAqIHZlYzIoMSwgLTEpOycsXG4gICAgICAgICAgICAnY2VudGVyID0gcG9zaXRpb24gKiB1X3NjYWxlOycsXG4gICAgICAgICAgICAnY2VudGVyID0gdmVjMihjZW50ZXIueCwgdV9zY2FsZSAqIHVfcmVzb2x1dGlvbi55IC0gY2VudGVyLnkpOycsXG5cbiAgICAgICAgICAgICdwb3NpdGlvbiA9IHBvc2l0aW9uICsnLFxuICAgICAgICAgICAgICAnMi4wICogcmFkaXVzICogdmVjMihjb3MoYV9hbmdsZSksIHNpbihhX2FuZ2xlKSk7JyxcbiAgICAgICAgICAgICdwb3NpdGlvbiA9IChwb3NpdGlvbiAvIHVfcmVzb2x1dGlvbiAqIDIuMCAtIDEuMCkgKiB2ZWMyKDEsIC0xKTsnLFxuXG4gICAgICAgICAgICAncmFkaXVzID0gcmFkaXVzICogdV9zY2FsZTsnLFxuXG4gICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAwLCAxKTsnLFxuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBjb2xvcjpcbiAgICAgICAgICAgICdmbG9hdCBjID0gYV9jb2xvcjsnLFxuICAgICAgICAgICAgJ2NvbG9yLmIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxuICAgICAgICAgICAgJ2NvbG9yLmcgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxuICAgICAgICAgICAgJ2NvbG9yLnIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsgY29sb3IgLz0gMjU1LjA7JyxcbiAgICAgICAgICAgICdjb2xvci5hID0gMS4wOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLlZFUlRFWF9TSEFERVJcbiAgICAgICk7XG5cbiAgICAgIGZyYWdtZW50U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcbiAgICAgICAgICAndmFyeWluZyB2ZWMyIGNlbnRlcjsnLFxuICAgICAgICAgICd2YXJ5aW5nIGZsb2F0IHJhZGl1czsnLFxuXG4gICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgICAgICd2ZWM0IGNvbG9yMCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTsnLFxuXG4gICAgICAgICAgICAndmVjMiBtID0gZ2xfRnJhZ0Nvb3JkLnh5IC0gY2VudGVyOycsXG4gICAgICAgICAgICAnZmxvYXQgZGlmZiA9IHJhZGl1cyAtIHNxcnQobS54ICogbS54ICsgbS55ICogbS55KTsnLFxuXG4gICAgICAgICAgICAvLyBIZXJlIGlzIGhvdyB3ZSBkcmF3IGEgZGlzYyBpbnN0ZWFkIG9mIGEgc3F1YXJlOlxuICAgICAgICAgICAgJ2lmIChkaWZmID4gMC4wKScsXG4gICAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjsnLFxuICAgICAgICAgICAgJ2Vsc2UnLFxuICAgICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3IwOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5ub2RlcycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIG5vZGUgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IG5vZGVzIGluIHRoZSBmYXN0ZXN0IHdheTogTm9kZXMgYXJlIGJhc2ljXG4gICAqIHNxdWFyZXMsIGRyYXduIHRocm91Z2ggdGhlIGdsLlBPSU5UUyBkcmF3aW5nIG1ldGhvZC4gVGhlIHNpemUgb2YgdGhlIG5vZGVzXG4gICAqIGFyZSByZXByZXNlbnRlZCB3aXRoIHRoZSBcImdsX1BvaW50U2l6ZVwiIHZhbHVlIGluIHRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgKlxuICAgKiBJdCBpcyB0aGUgZmFzdGVzdCBub2RlIHJlbmRlcmVyIGhlcmUgc2luY2UgdGhlIGJ1ZmZlciBqdXN0IHRha2VzIG9uZSBsaW5lXG4gICAqIHRvIGRyYXcgZWFjaCBub2RlICh3aXRoIGF0dHJpYnV0ZXMgXCJ4XCIsIFwieVwiLCBcInNpemVcIiBhbmQgXCJjb2xvclwiKS5cbiAgICpcbiAgICogTmV2ZXJ0aGVsZXNzLCB0aGlzIG1ldGhvZCBoYXMgc29tZSBwcm9ibGVtcywgZXNwZWNpYWxseSBkdWUgdG8gc29tZSBpc3N1ZXNcbiAgICogd2l0aCB0aGUgZ2wuUE9JTlRTOlxuICAgKiAgLSBGaXJzdCwgaWYgdGhlIGNlbnRlciBvZiBhIG5vZGUgaXMgb3V0c2lkZSB0aGUgc2NlbmUsIHRoZSBwb2ludCB3aWxsIG5vdFxuICAgKiAgICBiZSBkcmF3biwgZXZlbiBpZiBpdCBzaG91bGQgYmUgcGFydGx5IG9uIHNjcmVlbi5cbiAgICogIC0gSSB0cmllZCBhcHBseWluZyBhIGZyYWdtZW50IHNoYWRlciBzaW1pbGFyIHRvIHRoZSBvbmUgaW4gdGhlIGRlZmF1bHRcbiAgICogICAgbm9kZSByZW5kZXJlciB0byBkaXNwbGF5IHRoZW0gYXMgZGlzY3MsIGJ1dCBpdCBkaWQgbm90IHdvcmsgZmluZSBvblxuICAgKiAgICBzb21lIGNvbXB1dGVycyBzZXR0aW5ncywgZmlsbGluZyB0aGUgZGlzY3Mgd2l0aCB3ZWlyZCBncmFkaWVudHMgbm90XG4gICAqICAgIGRlcGVuZGluZyBvbiB0aGUgYWN0dWFsIGNvbG9yLlxuICAgKi9cbiAgc2lnbWEud2ViZ2wubm9kZXMuZmFzdCA9IHtcbiAgICBQT0lOVFM6IDEsXG4gICAgQVRUUklCVVRFUzogNCxcbiAgICBhZGROb2RlOiBmdW5jdGlvbihub2RlLCBkYXRhLCBpLCBwcmVmaXgsIHNldHRpbmdzKSB7XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd4J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd5J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICdzaXplJ107XG4gICAgICBkYXRhW2krK10gPSBzaWdtYS51dGlscy5mbG9hdENvbG9yKFxuICAgICAgICBub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJylcbiAgICAgICk7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBkYXRhLCBwYXJhbXMpIHtcbiAgICAgIHZhciBidWZmZXI7XG5cbiAgICAgIC8vIERlZmluZSBhdHRyaWJ1dGVzOlxuICAgICAgdmFyIHBvc2l0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zaXRpb24nKSxcbiAgICAgICAgICBzaXplTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2Ffc2l6ZScpLFxuICAgICAgICAgIGNvbG9yTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfY29sb3InKSxcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4JyksXG4gICAgICAgICAgcmF0aW9Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmF0aW8nKSxcbiAgICAgICAgICBzY2FsZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zY2FsZScpO1xuXG4gICAgICBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLkRZTkFNSUNfRFJBVyk7XG5cbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XG4gICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgIHJhdGlvTG9jYXRpb24sXG4gICAgICAgIDEgLyBNYXRoLnBvdyhwYXJhbXMucmF0aW8sIHBhcmFtcy5zZXR0aW5ncygnbm9kZXNQb3dSYXRpbycpKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xZihzY2FsZUxvY2F0aW9uLCBwYXJhbXMuc2NhbGluZ1JhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzaXplTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XG5cbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgIHBvc2l0aW9uTG9jYXRpb24sXG4gICAgICAgIDIsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgc2l6ZUxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgOFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgIGNvbG9yTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAxMlxuICAgICAgKTtcblxuICAgICAgZ2wuZHJhd0FycmF5cyhcbiAgICAgICAgZ2wuUE9JTlRTLFxuICAgICAgICBwYXJhbXMuc3RhcnQgfHwgMCxcbiAgICAgICAgcGFyYW1zLmNvdW50IHx8IChkYXRhLmxlbmd0aCAvIHRoaXMuQVRUUklCVVRFUylcbiAgICAgICk7XG4gICAgfSxcbiAgICBpbml0UHJvZ3JhbTogZnVuY3Rpb24oZ2wpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgcHJvZ3JhbTtcblxuICAgICAgdmVydGV4U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9zaXplOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2NvbG9yOycsXG5cbiAgICAgICAgICAndW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfcmF0aW87JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3NjYWxlOycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MyB1X21hdHJpeDsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuXG4gICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoJyxcbiAgICAgICAgICAgICAgJygodV9tYXRyaXggKiB2ZWMzKGFfcG9zaXRpb24sIDEpKS54eSAvJyxcbiAgICAgICAgICAgICAgICAndV9yZXNvbHV0aW9uICogMi4wIC0gMS4wKSAqIHZlYzIoMSwgLTEpLCcsXG4gICAgICAgICAgICAgICcwLCcsXG4gICAgICAgICAgICAgICcxJyxcbiAgICAgICAgICAgICcpOycsXG5cbiAgICAgICAgICAgIC8vIE11bHRpcGx5IHRoZSBwb2ludCBzaXplIHR3aWNlOlxuICAgICAgICAgICAgLy8gIC0geCBTQ0FMSU5HX1JBVElPIHRvIGNvcnJlY3QgdGhlIGNhbnZhcyBzY2FsaW5nXG4gICAgICAgICAgICAvLyAgLSB4IDIgdG8gY29ycmVjdCB0aGUgZm9ybXVsYWVcbiAgICAgICAgICAgICdnbF9Qb2ludFNpemUgPSBhX3NpemUgKiB1X3JhdGlvICogdV9zY2FsZSAqIDIuMDsnLFxuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBjb2xvcjpcbiAgICAgICAgICAgICdmbG9hdCBjID0gYV9jb2xvcjsnLFxuICAgICAgICAgICAgJ2NvbG9yLmIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxuICAgICAgICAgICAgJ2NvbG9yLmcgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxuICAgICAgICAgICAgJ2NvbG9yLnIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsgY29sb3IgLz0gMjU1LjA7JyxcbiAgICAgICAgICAgICdjb2xvci5hID0gMS4wOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLlZFUlRFWF9TSEFERVJcbiAgICAgICk7XG5cbiAgICAgIGZyYWdtZW50U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICAgICAnZmxvYXQgYm9yZGVyID0gMC4wMTsnLFxuICAgICAgICAgICAgJ2Zsb2F0IHJhZGl1cyA9IDAuNTsnLFxuXG4gICAgICAgICAgICAndmVjNCBjb2xvcjAgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7JyxcbiAgICAgICAgICAgICd2ZWMyIG0gPSBnbF9Qb2ludENvb3JkIC0gdmVjMigwLjUsIDAuNSk7JyxcbiAgICAgICAgICAgICdmbG9hdCBkaXN0ID0gcmFkaXVzIC0gc3FydChtLnggKiBtLnggKyBtLnkgKiBtLnkpOycsXG5cbiAgICAgICAgICAgICdmbG9hdCB0ID0gMC4wOycsXG4gICAgICAgICAgICAnaWYgKGRpc3QgPiBib3JkZXIpJyxcbiAgICAgICAgICAgICAgJ3QgPSAxLjA7JyxcbiAgICAgICAgICAgICdlbHNlIGlmIChkaXN0ID4gMC4wKScsXG4gICAgICAgICAgICAgICd0ID0gZGlzdCAvIGJvcmRlcjsnLFxuXG4gICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gbWl4KGNvbG9yMCwgY29sb3IsIHQpOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGVkZ2UgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IGVkZ2VzIGFzIGxpbmVzIGdvaW5nIGZyb20gdGhlIHNvdXJjZSBub2RlXG4gICAqIHRvIHRoZSB0YXJnZXQgbm9kZS4gVG8gZGVhbCB3aXRoIGVkZ2UgdGhpY2tuZXNzZXMsIHRoZSBsaW5lcyBhcmUgbWFkZSBvZlxuICAgKiB0d28gdHJpYW5nbGVzIGZvcm1pbmcgcmVjdGFuZ2xlcywgd2l0aCB0aGUgZ2wuVFJJQU5HTEVTIGRyYXdpbmcgbW9kZS5cbiAgICpcbiAgICogSXQgaXMgZXhwZW5zaXZlLCBzaW5jZSBkcmF3aW5nIGEgc2luZ2xlIGVkZ2UgcmVxdWlyZXMgNiBwb2ludHMsIGVhY2hcbiAgICogaGF2aW5nIDcgYXR0cmlidXRlcyAoc291cmNlIHBvc2l0aW9uLCB0YXJnZXQgcG9zaXRpb24sIHRoaWNrbmVzcywgY29sb3JcbiAgICogYW5kIGEgZmxhZyBpbmRpY2F0aW5nIHdoaWNoIHZlcnRpY2Ugb2YgdGhlIHJlY3RhbmdsZSBpdCBpcykuXG4gICAqL1xuICBzaWdtYS53ZWJnbC5lZGdlcy5kZWYgPSB7XG4gICAgUE9JTlRTOiA2LFxuICAgIEFUVFJJQlVURVM6IDcsXG4gICAgYWRkRWRnZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGRhdGEsIGksIHByZWZpeCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciB3ID0gKGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKSAvIDIsXG4gICAgICAgICAgeDEgPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5MSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgIHgyID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgICAgeTIgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICBjb2xvciA9IGVkZ2UuY29sb3I7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MoJ2VkZ2VDb2xvcicpKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWxpemUgY29sb3I6XG4gICAgICBjb2xvciA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoY29sb3IpO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSwgZGF0YSwgcGFyYW1zKSB7XG4gICAgICB2YXIgYnVmZmVyO1xuXG4gICAgICAvLyBEZWZpbmUgYXR0cmlidXRlczpcbiAgICAgIHZhciBjb2xvckxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2NvbG9yJyksXG4gICAgICAgICAgcG9zaXRpb25Mb2NhdGlvbjEgPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zaXRpb24xJyksXG4gICAgICAgICAgcG9zaXRpb25Mb2NhdGlvbjIgPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zaXRpb24yJyksXG4gICAgICAgICAgdGhpY2tuZXNzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfdGhpY2tuZXNzJyksXG4gICAgICAgICAgbWludXNMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9taW51cycpLFxuICAgICAgICAgIHJlc29sdXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpLFxuICAgICAgICAgIG1hdHJpeExvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXgnKSxcbiAgICAgICAgICBtYXRyaXhIYWxmUGlMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4SGFsZlBpJyksXG4gICAgICAgICAgbWF0cml4SGFsZlBpTWludXNMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4SGFsZlBpTWludXMnKSxcbiAgICAgICAgICByYXRpb0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yYXRpbycpLFxuICAgICAgICAgIHNjYWxlTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NjYWxlJyk7XG5cbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgICBnbC51bmlmb3JtMmYocmVzb2x1dGlvbkxvY2F0aW9uLCBwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQpO1xuICAgICAgZ2wudW5pZm9ybTFmKFxuICAgICAgICByYXRpb0xvY2F0aW9uLFxuICAgICAgICBwYXJhbXMucmF0aW8gLyBNYXRoLnBvdyhwYXJhbXMucmF0aW8sIHBhcmFtcy5zZXR0aW5ncygnZWRnZXNQb3dSYXRpbycpKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xZihzY2FsZUxvY2F0aW9uLCBwYXJhbXMuc2NhbGluZ1JhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYoXG4gICAgICAgIG1hdHJpeEhhbGZQaUxvY2F0aW9uLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24oTWF0aC5QSSAvIDIsIHRydWUpXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDJmdihcbiAgICAgICAgbWF0cml4SGFsZlBpTWludXNMb2NhdGlvbixcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnJvdGF0aW9uKC1NYXRoLlBJIC8gMiwgdHJ1ZSlcbiAgICAgICk7XG5cbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGNvbG9yTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbjEpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbjIpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpY2tuZXNzTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobWludXNMb2NhdGlvbik7XG5cbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbjEsXG4gICAgICAgIDIsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uMixcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDhcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaWNrbmVzc0xvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMTZcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKG1pbnVzTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAyMFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY29sb3JMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDI0XG4gICAgICApO1xuXG4gICAgICBnbC5kcmF3QXJyYXlzKFxuICAgICAgICBnbC5UUklBTkdMRVMsXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxuICAgICAgICBwYXJhbXMuY291bnQgfHwgKGRhdGEubGVuZ3RoIC8gdGhpcy5BVFRSSUJVVEVTKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGluaXRQcm9ncmFtOiBmdW5jdGlvbihnbCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlcixcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICBwcm9ncmFtO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uMTsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uMjsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV90aGlja25lc3M7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfbWludXM7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfY29sb3I7JyxcblxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9yYXRpbzsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfc2NhbGU7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MiB1X21hdHJpeEhhbGZQaTsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDIgdV9tYXRyaXhIYWxmUGlNaW51czsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuXG4gICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxuICAgICAgICAgICAgLy8gRmluZCB0aGUgZ29vZCBwb2ludDpcbiAgICAgICAgICAgICd2ZWMyIHBvc2l0aW9uID0gYV90aGlja25lc3MgKiB1X3JhdGlvIConLFxuICAgICAgICAgICAgICAnbm9ybWFsaXplKGFfcG9zaXRpb24yIC0gYV9wb3NpdGlvbjEpOycsXG5cbiAgICAgICAgICAgICdtYXQyIG1hdHJpeCA9IGFfbWludXMgKiB1X21hdHJpeEhhbGZQaU1pbnVzICsnLFxuICAgICAgICAgICAgICAnKDEuMCAtIGFfbWludXMpICogdV9tYXRyaXhIYWxmUGk7JyxcblxuICAgICAgICAgICAgJ3Bvc2l0aW9uID0gbWF0cml4ICogcG9zaXRpb24gKyBhX3Bvc2l0aW9uMTsnLFxuXG4gICAgICAgICAgICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNCgnLFxuICAgICAgICAgICAgICAnKCh1X21hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEpKS54eSAvJyxcbiAgICAgICAgICAgICAgICAndV9yZXNvbHV0aW9uICogMi4wIC0gMS4wKSAqIHZlYzIoMSwgLTEpLCcsXG4gICAgICAgICAgICAgICcwLCcsXG4gICAgICAgICAgICAgICcxJyxcbiAgICAgICAgICAgICcpOycsXG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbG9yOlxuICAgICAgICAgICAgJ2Zsb2F0IGMgPSBhX2NvbG9yOycsXG4gICAgICAgICAgICAnY29sb3IuYiA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuZyA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuciA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOyBjb2xvciAvPSAyNTUuMDsnLFxuICAgICAgICAgICAgJ2NvbG9yLmEgPSAxLjA7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuVkVSVEVYX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuXG4gICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5GUkFHTUVOVF9TSEFERVJcbiAgICAgICk7XG5cbiAgICAgIHByb2dyYW0gPSBzaWdtYS51dGlscy5sb2FkUHJvZ3JhbShnbCwgW3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdKTtcblxuICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wuZWRnZXMnKTtcblxuICAvKipcbiAgICogVGhpcyBlZGdlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBlZGdlcyBhcyBsaW5lcyB3aXRoIHRoZSBnbC5MSU5FUyBkaXNwbGF5XG4gICAqIG1vZGUuIFNpbmNlIHRoaXMgbW9kZSBkb2VzIG5vdCBzdXBwb3J0IHdlbGwgdGhpY2tuZXNzLCBlZGdlcyBhcmUgYWxsIGRyYXduXG4gICAqIHdpdGggdGhlIHNhbWUgdGhpY2tuZXNzICgzcHgpLCBpbmRlcGVuZGFudGx5IG9mIHRoZSBlZGdlIGF0dHJpYnV0ZXMgb3IgdGhlXG4gICAqIHpvb21pbmcgcmF0aW8uXG4gICAqL1xuICBzaWdtYS53ZWJnbC5lZGdlcy5mYXN0ID0ge1xuICAgIFBPSU5UUzogMixcbiAgICBBVFRSSUJVVEVTOiAzLFxuICAgIGFkZEVkZ2U6IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBkYXRhLCBpLCBwcmVmaXgsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgdyA9IChlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSkgLyAyLFxuICAgICAgICAgIHgxID0gc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgeTEgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICB4MiA9IHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHkyID0gdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgY29sb3IgPSBlZGdlLmNvbG9yO1xuXG4gICAgICBpZiAoIWNvbG9yKVxuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzKCdlZGdlQ29sb3InKSkge1xuICAgICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgLy8gTm9ybWFsaXplIGNvbG9yOlxuICAgICAgY29sb3IgPSBzaWdtYS51dGlscy5mbG9hdENvbG9yKGNvbG9yKTtcblxuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBkYXRhLCBwYXJhbXMpIHtcbiAgICAgIHZhciBidWZmZXI7XG5cbiAgICAgIC8vIERlZmluZSBhdHRyaWJ1dGVzOlxuICAgICAgdmFyIGNvbG9yTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfY29sb3InKSxcbiAgICAgICAgICBwb3NpdGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3Bvc2l0aW9uJyksXG4gICAgICAgICAgcmVzb2x1dGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yZXNvbHV0aW9uJyksXG4gICAgICAgICAgbWF0cml4TG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeCcpO1xuXG4gICAgICBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLkRZTkFNSUNfRFJBVyk7XG5cbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KG1hdHJpeExvY2F0aW9uLCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG5cbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XG5cbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbixcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGNvbG9yTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICA4XG4gICAgICApO1xuXG4gICAgICBnbC5saW5lV2lkdGgoMyk7XG4gICAgICBnbC5kcmF3QXJyYXlzKFxuICAgICAgICBnbC5MSU5FUyxcbiAgICAgICAgcGFyYW1zLnN0YXJ0IHx8IDAsXG4gICAgICAgIHBhcmFtcy5jb3VudCB8fCAoZGF0YS5sZW5ndGggLyB0aGlzLkFUVFJJQlVURVMpXG4gICAgICApO1xuICAgIH0sXG4gICAgaW5pdFByb2dyYW06IGZ1bmN0aW9uKGdsKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyLFxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyLFxuICAgICAgICAgIHByb2dyYW07XG5cbiAgICAgIHZlcnRleFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfY29sb3I7JyxcblxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MyB1X21hdHJpeDsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuXG4gICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoJyxcbiAgICAgICAgICAgICAgJygodV9tYXRyaXggKiB2ZWMzKGFfcG9zaXRpb24sIDEpKS54eSAvJyxcbiAgICAgICAgICAgICAgICAndV9yZXNvbHV0aW9uICogMi4wIC0gMS4wKSAqIHZlYzIoMSwgLTEpLCcsXG4gICAgICAgICAgICAgICcwLCcsXG4gICAgICAgICAgICAgICcxJyxcbiAgICAgICAgICAgICcpOycsXG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbG9yOlxuICAgICAgICAgICAgJ2Zsb2F0IGMgPSBhX2NvbG9yOycsXG4gICAgICAgICAgICAnY29sb3IuYiA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuZyA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuciA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOyBjb2xvciAvPSAyNTUuMDsnLFxuICAgICAgICAgICAgJ2NvbG9yLmEgPSAxLjA7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuVkVSVEVYX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuXG4gICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5GUkFHTUVOVF9TSEFERVJcbiAgICAgICk7XG5cbiAgICAgIHByb2dyYW0gPSBzaWdtYS51dGlscy5sb2FkUHJvZ3JhbShnbCwgW3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdKTtcblxuICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wuZWRnZXMnKTtcblxuICAvKipcbiAgICogVGhpcyBlZGdlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBlZGdlcyBhcyBhcnJvd3MgZ29pbmcgZnJvbSB0aGUgc291cmNlIG5vZGVcbiAgICogdG8gdGhlIHRhcmdldCBub2RlLiBUbyBkZWFsIHdpdGggZWRnZSB0aGlja25lc3NlcywgdGhlIGxpbmVzIGFyZSBtYWRlIG9mXG4gICAqIHRocmVlIHRyaWFuZ2xlczogdHdvIGZvcm1pbmcgcmVjdGFuZ2xlcywgd2l0aCB0aGUgZ2wuVFJJQU5HTEVTIGRyYXdpbmdcbiAgICogbW9kZS5cbiAgICpcbiAgICogSXQgaXMgZXhwZW5zaXZlLCBzaW5jZSBkcmF3aW5nIGEgc2luZ2xlIGVkZ2UgcmVxdWlyZXMgOSBwb2ludHMsIGVhY2hcbiAgICogaGF2aW5nIGEgbG90IG9mIGF0dHJpYnV0ZXMuXG4gICAqL1xuICBzaWdtYS53ZWJnbC5lZGdlcy5hcnJvdyA9IHtcbiAgICBQT0lOVFM6IDksXG4gICAgQVRUUklCVVRFUzogMTEsXG4gICAgYWRkRWRnZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGRhdGEsIGksIHByZWZpeCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciB3ID0gKGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKSAvIDIsXG4gICAgICAgICAgeDEgPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5MSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgIHgyID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgICAgeTIgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICB0YXJnZXRTaXplID0gdGFyZ2V0W3ByZWZpeCArICdzaXplJ10sXG4gICAgICAgICAgY29sb3IgPSBlZGdlLmNvbG9yO1xuXG4gICAgICBpZiAoIWNvbG9yKVxuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzKCdlZGdlQ29sb3InKSkge1xuICAgICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgLy8gTm9ybWFsaXplIGNvbG9yOlxuICAgICAgY29sb3IgPSBzaWdtYS51dGlscy5mbG9hdENvbG9yKGNvbG9yKTtcblxuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgLy8gQXJyb3cgaGVhZDpcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAtMS4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSwgZGF0YSwgcGFyYW1zKSB7XG4gICAgICB2YXIgYnVmZmVyO1xuXG4gICAgICAvLyBEZWZpbmUgYXR0cmlidXRlczpcbiAgICAgIHZhciBwb3NpdGlvbkxvY2F0aW9uMSA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3MxJyksXG4gICAgICAgICAgcG9zaXRpb25Mb2NhdGlvbjIgPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zMicpLFxuICAgICAgICAgIHRoaWNrbmVzc0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3RoaWNrbmVzcycpLFxuICAgICAgICAgIHRhcmdldFNpemVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV90U2l6ZScpLFxuICAgICAgICAgIGRlbGF5TG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfZGVsYXknKSxcbiAgICAgICAgICBtaW51c0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX21pbnVzJyksXG4gICAgICAgICAgaGVhZExvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2hlYWQnKSxcbiAgICAgICAgICBoZWFkUG9zaXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9oZWFkUG9zaXRpb24nKSxcbiAgICAgICAgICBjb2xvckxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2NvbG9yJyksXG4gICAgICAgICAgcmVzb2x1dGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yZXNvbHV0aW9uJyksXG4gICAgICAgICAgbWF0cml4TG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeCcpLFxuICAgICAgICAgIG1hdHJpeEhhbGZQaUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXhIYWxmUGknKSxcbiAgICAgICAgICBtYXRyaXhIYWxmUGlNaW51c0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXhIYWxmUGlNaW51cycpLFxuICAgICAgICAgIHJhdGlvTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3JhdGlvJyksXG4gICAgICAgICAgbm9kZVJhdGlvTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X25vZGVSYXRpbycpLFxuICAgICAgICAgIGFycm93SGVhZExvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9hcnJvd0hlYWQnKSxcbiAgICAgICAgICBzY2FsZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zY2FsZScpO1xuXG4gICAgICBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgcmF0aW9Mb2NhdGlvbixcbiAgICAgICAgcGFyYW1zLnJhdGlvIC8gTWF0aC5wb3cocGFyYW1zLnJhdGlvLCBwYXJhbXMuc2V0dGluZ3MoJ2VkZ2VzUG93UmF0aW8nKSlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgIG5vZGVSYXRpb0xvY2F0aW9uLFxuICAgICAgICBNYXRoLnBvdyhwYXJhbXMucmF0aW8sIHBhcmFtcy5zZXR0aW5ncygnbm9kZXNQb3dSYXRpbycpKSAvXG4gICAgICAgIHBhcmFtcy5yYXRpb1xuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xZihhcnJvd0hlYWRMb2NhdGlvbiwgNS4wKTtcbiAgICAgIGdsLnVuaWZvcm0xZihzY2FsZUxvY2F0aW9uLCBwYXJhbXMuc2NhbGluZ1JhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYoXG4gICAgICAgIG1hdHJpeEhhbGZQaUxvY2F0aW9uLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24oTWF0aC5QSSAvIDIsIHRydWUpXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDJmdihcbiAgICAgICAgbWF0cml4SGFsZlBpTWludXNMb2NhdGlvbixcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnJvdGF0aW9uKC1NYXRoLlBJIC8gMiwgdHJ1ZSlcbiAgICAgICk7XG5cbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24xKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24yKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaWNrbmVzc0xvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRhcmdldFNpemVMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShkZWxheUxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KG1pbnVzTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaGVhZExvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGhlYWRQb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGNvbG9yTG9jYXRpb24pO1xuXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24xLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbjIsXG4gICAgICAgIDIsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICA4XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlja25lc3NMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDE2XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0YXJnZXRTaXplTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAyMFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoZGVsYXlMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDI0XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihtaW51c0xvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMjhcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGhlYWRMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDMyXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihoZWFkUG9zaXRpb25Mb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDM2XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihjb2xvckxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgNDBcbiAgICAgICk7XG5cbiAgICAgIGdsLmRyYXdBcnJheXMoXG4gICAgICAgIGdsLlRSSUFOR0xFUyxcbiAgICAgICAgcGFyYW1zLnN0YXJ0IHx8IDAsXG4gICAgICAgIHBhcmFtcy5jb3VudCB8fCAoZGF0YS5sZW5ndGggLyB0aGlzLkFUVFJJQlVURVMpXG4gICAgICApO1xuICAgIH0sXG4gICAgaW5pdFByb2dyYW06IGZ1bmN0aW9uKGdsKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyLFxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyLFxuICAgICAgICAgIHByb2dyYW07XG5cbiAgICAgIHZlcnRleFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zMTsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3BvczI7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfdGhpY2tuZXNzOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3RTaXplOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2RlbGF5OycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX21pbnVzOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2hlYWQ7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfaGVhZFBvc2l0aW9uOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2NvbG9yOycsXG5cbiAgICAgICAgICAndW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfcmF0aW87JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X25vZGVSYXRpbzsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfYXJyb3dIZWFkOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9zY2FsZTsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDMgdV9tYXRyaXg7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQyIHVfbWF0cml4SGFsZlBpOycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MiB1X21hdHJpeEhhbGZQaU1pbnVzOycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBnb29kIHBvaW50OlxuICAgICAgICAgICAgJ3ZlYzIgcG9zID0gbm9ybWFsaXplKGFfcG9zMiAtIGFfcG9zMSk7JyxcblxuICAgICAgICAgICAgJ21hdDIgbWF0cml4ID0gKDEuMCAtIGFfaGVhZCkgKicsXG4gICAgICAgICAgICAgICcoJyxcbiAgICAgICAgICAgICAgICAnYV9taW51cyAqIHVfbWF0cml4SGFsZlBpTWludXMgKycsXG4gICAgICAgICAgICAgICAgJygxLjAgLSBhX21pbnVzKSAqIHVfbWF0cml4SGFsZlBpJyxcbiAgICAgICAgICAgICAgJykgKyBhX2hlYWQgKiAoJyxcbiAgICAgICAgICAgICAgICAnYV9oZWFkUG9zaXRpb24gKiB1X21hdHJpeEhhbGZQaU1pbnVzICogMC42ICsnLFxuICAgICAgICAgICAgICAgICcoYV9oZWFkUG9zaXRpb24gKiBhX2hlYWRQb3NpdGlvbiAtIDEuMCkgKiBtYXQyKDEuMCknLFxuICAgICAgICAgICAgICAnKTsnLFxuXG4gICAgICAgICAgICAncG9zID0gYV9wb3MxICsgKCcsXG4gICAgICAgICAgICAgIC8vIERlYWwgd2l0aCBib2R5OlxuICAgICAgICAgICAgICAnKDEuMCAtIGFfaGVhZCkgKiBhX3RoaWNrbmVzcyAqIHVfcmF0aW8gKiBtYXRyaXggKiBwb3MgKycsXG4gICAgICAgICAgICAgIC8vIERlYWwgd2l0aCBoZWFkOlxuICAgICAgICAgICAgICAnYV9oZWFkICogdV9hcnJvd0hlYWQgKiBhX3RoaWNrbmVzcyAqIHVfcmF0aW8gKiBtYXRyaXggKiBwb3MgKycsXG4gICAgICAgICAgICAgIC8vIERlYWwgd2l0aCBkZWxheTpcbiAgICAgICAgICAgICAgJ2FfZGVsYXkgKiBwb3MgKiAoJyxcbiAgICAgICAgICAgICAgICAnYV90U2l6ZSAvIHVfbm9kZVJhdGlvICsnLFxuICAgICAgICAgICAgICAgICd1X2Fycm93SGVhZCAqIGFfdGhpY2tuZXNzICogdV9yYXRpbycsXG4gICAgICAgICAgICAgICcpJyxcbiAgICAgICAgICAgICcpOycsXG5cbiAgICAgICAgICAgIC8vIFNjYWxlIGZyb20gW1stMSAxXSBbLTEgMV1dIHRvIHRoZSBjb250YWluZXI6XG4gICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KCcsXG4gICAgICAgICAgICAgICcoKHVfbWF0cml4ICogdmVjMyhwb3MsIDEpKS54eSAvJyxcbiAgICAgICAgICAgICAgICAndV9yZXNvbHV0aW9uICogMi4wIC0gMS4wKSAqIHZlYzIoMSwgLTEpLCcsXG4gICAgICAgICAgICAgICcwLCcsXG4gICAgICAgICAgICAgICcxJyxcbiAgICAgICAgICAgICcpOycsXG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbG9yOlxuICAgICAgICAgICAgJ2Zsb2F0IGMgPSBhX2NvbG9yOycsXG4gICAgICAgICAgICAnY29sb3IuYiA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuZyA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuciA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOyBjb2xvciAvPSAyNTUuMDsnLFxuICAgICAgICAgICAgJ2NvbG9yLmEgPSAxLjA7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuVkVSVEVYX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuXG4gICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5GUkFHTUVOVF9TSEFERVJcbiAgICAgICk7XG5cbiAgICAgIHByb2dyYW0gPSBzaWdtYS51dGlscy5sb2FkUHJvZ3JhbShnbCwgW3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdKTtcblxuICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmxhYmVscycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGxhYmVsIHJlbmRlcmVyIHdpbGwganVzdCBkaXNwbGF5IHRoZSBsYWJlbCBvbiB0aGUgcmlnaHQgb2YgdGhlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMubGFiZWxzLmRlZiA9IGZ1bmN0aW9uKG5vZGUsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgdmFyIGZvbnRTaXplLFxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgIHNpemUgPSBub2RlW3ByZWZpeCArICdzaXplJ107XG5cbiAgICBpZiAoc2l6ZSA8IHNldHRpbmdzKCdsYWJlbFRocmVzaG9sZCcpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKCFub2RlLmxhYmVsIHx8IHR5cGVvZiBub2RlLmxhYmVsICE9PSAnc3RyaW5nJylcbiAgICAgIHJldHVybjtcblxuICAgIGZvbnRTaXplID0gKHNldHRpbmdzKCdsYWJlbFNpemUnKSA9PT0gJ2ZpeGVkJykgP1xuICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbFNpemUnKSA6XG4gICAgICBzZXR0aW5ncygnbGFiZWxTaXplUmF0aW8nKSAqIHNpemU7XG5cbiAgICBjb250ZXh0LmZvbnQgPSAoc2V0dGluZ3MoJ2ZvbnRTdHlsZScpID8gc2V0dGluZ3MoJ2ZvbnRTdHlsZScpICsgJyAnIDogJycpICtcbiAgICAgIGZvbnRTaXplICsgJ3B4ICcgKyBzZXR0aW5ncygnZm9udCcpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gKHNldHRpbmdzKCdsYWJlbENvbG9yJykgPT09ICdub2RlJykgP1xuICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbENvbG9yJyk7XG5cbiAgICBjb250ZXh0LmZpbGxUZXh0KFxuICAgICAgbm9kZS5sYWJlbCxcbiAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddICsgc2l6ZSArIDMpLFxuICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gKyBmb250U2l6ZSAvIDMpXG4gICAgKTtcbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5ob3ZlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBob3ZlciByZW5kZXJlciB3aWxsIGJhc2ljYWxseSBkaXNwbGF5IHRoZSBsYWJlbCB3aXRoIGEgYmFja2dyb3VuZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5ob3ZlcnMuZGVmID0gZnVuY3Rpb24obm9kZSwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgeCxcbiAgICAgICAgeSxcbiAgICAgICAgdyxcbiAgICAgICAgaCxcbiAgICAgICAgZSxcbiAgICAgICAgZm9udFN0eWxlID0gc2V0dGluZ3MoJ2hvdmVyRm9udFN0eWxlJykgfHwgc2V0dGluZ3MoJ2ZvbnRTdHlsZScpLFxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgIHNpemUgPSBub2RlW3ByZWZpeCArICdzaXplJ10sXG4gICAgICAgIGZvbnRTaXplID0gKHNldHRpbmdzKCdsYWJlbFNpemUnKSA9PT0gJ2ZpeGVkJykgP1xuICAgICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxTaXplJykgOlxuICAgICAgICAgIHNldHRpbmdzKCdsYWJlbFNpemVSYXRpbycpICogc2l6ZTtcblxuICAgIC8vIExhYmVsIGJhY2tncm91bmQ6XG4gICAgY29udGV4dC5mb250ID0gKGZvbnRTdHlsZSA/IGZvbnRTdHlsZSArICcgJyA6ICcnKSArXG4gICAgICBmb250U2l6ZSArICdweCAnICsgKHNldHRpbmdzKCdob3ZlckZvbnQnKSB8fCBzZXR0aW5ncygnZm9udCcpKTtcblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncygnbGFiZWxIb3ZlckJHQ29sb3InKSA9PT0gJ25vZGUnID9cbiAgICAgIChub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpIDpcbiAgICAgIHNldHRpbmdzKCdkZWZhdWx0SG92ZXJMYWJlbEJHQ29sb3InKTtcblxuICAgIGlmIChub2RlLmxhYmVsICYmIHNldHRpbmdzKCdsYWJlbEhvdmVyU2hhZG93JykpIHtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSAwO1xuICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gODtcbiAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBzZXR0aW5ncygnbGFiZWxIb3ZlclNoYWRvd0NvbG9yJyk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUubGFiZWwgJiYgdHlwZW9mIG5vZGUubGFiZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB4ID0gTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd4J10gLSBmb250U2l6ZSAvIDIgLSAyKTtcbiAgICAgIHkgPSBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSAtIGZvbnRTaXplIC8gMiAtIDIpO1xuICAgICAgdyA9IE1hdGgucm91bmQoXG4gICAgICAgIGNvbnRleHQubWVhc3VyZVRleHQobm9kZS5sYWJlbCkud2lkdGggKyBmb250U2l6ZSAvIDIgKyBzaXplICsgN1xuICAgICAgKTtcbiAgICAgIGggPSBNYXRoLnJvdW5kKGZvbnRTaXplICsgNCk7XG4gICAgICBlID0gTWF0aC5yb3VuZChmb250U2l6ZSAvIDIgKyAyKTtcblxuICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeSArIGUpO1xuICAgICAgY29udGV4dC5hcmNUbyh4LCB5LCB4ICsgZSwgeSwgZSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4ICsgdywgeSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4ICsgdywgeSArIGgpO1xuICAgICAgY29udGV4dC5saW5lVG8oeCArIGUsIHkgKyBoKTtcbiAgICAgIGNvbnRleHQuYXJjVG8oeCwgeSArIGgsIHgsIHkgKyBoIC0gZSwgZSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4LCB5ICsgZSk7XG5cbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcblxuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xuICAgIH1cblxuICAgIC8vIE5vZGUgYm9yZGVyOlxuICAgIGlmIChzZXR0aW5ncygnYm9yZGVyU2l6ZScpID4gMCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc2V0dGluZ3MoJ25vZGVCb3JkZXJDb2xvcicpID09PSAnbm9kZScgP1xuICAgICAgICAobm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKSA6XG4gICAgICAgIHNldHRpbmdzKCdkZWZhdWx0Tm9kZUJvcmRlckNvbG9yJyk7XG4gICAgICBjb250ZXh0LmFyYyhcbiAgICAgICAgbm9kZVtwcmVmaXggKyAneCddLFxuICAgICAgICBub2RlW3ByZWZpeCArICd5J10sXG4gICAgICAgIHNpemUgKyBzZXR0aW5ncygnYm9yZGVyU2l6ZScpLFxuICAgICAgICAwLFxuICAgICAgICBNYXRoLlBJICogMixcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG5cbiAgICAvLyBOb2RlOlxuICAgIHZhciBub2RlUmVuZGVyZXIgPSBzaWdtYS5jYW52YXMubm9kZXNbbm9kZS50eXBlXSB8fCBzaWdtYS5jYW52YXMubm9kZXMuZGVmO1xuICAgIG5vZGVSZW5kZXJlcihub2RlLCBjb250ZXh0LCBzZXR0aW5ncyk7XG5cbiAgICAvLyBEaXNwbGF5IHRoZSBsYWJlbDpcbiAgICBpZiAobm9kZS5sYWJlbCAmJiB0eXBlb2Ygbm9kZS5sYWJlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gKHNldHRpbmdzKCdsYWJlbEhvdmVyQ29sb3InKSA9PT0gJ25vZGUnKSA/XG4gICAgICAgIChub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpIDpcbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbEhvdmVyQ29sb3InKTtcblxuICAgICAgY29udGV4dC5maWxsVGV4dChcbiAgICAgICAgbm9kZS5sYWJlbCxcbiAgICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd4J10gKyBzaXplICsgMyksXG4gICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddICsgZm9udFNpemUgLyAzKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubm9kZXMnKTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgbm9kZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIHNpbXBsZSBkaXNjLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLm5vZGVzLmRlZiA9IGZ1bmN0aW9uKG5vZGUsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJztcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gbm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5hcmMoXG4gICAgICBub2RlW3ByZWZpeCArICd4J10sXG4gICAgICBub2RlW3ByZWZpeCArICd5J10sXG4gICAgICBub2RlW3ByZWZpeCArICdzaXplJ10sXG4gICAgICAwLFxuICAgICAgTWF0aC5QSSAqIDIsXG4gICAgICB0cnVlXG4gICAgKTtcblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZXMnKTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgZWRnZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgZWRnZSBhcyBhIHNpbXBsZSBsaW5lLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMuZWRnZXMuZGVmID0gZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBzaXplID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEsXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xuXG4gICAgaWYgKCFjb2xvcilcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhcbiAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgc291cmNlW3ByZWZpeCArICd5J11cbiAgICApO1xuICAgIGNvbnRleHQubGluZVRvKFxuICAgICAgdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICB0YXJnZXRbcHJlZml4ICsgJ3knXVxuICAgICk7XG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGVkZ2UgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IGVkZ2VzIGFzIGFycm93cyBnb2luZyBmcm9tIHRoZSBzb3VyY2Ugbm9kZVxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMuZWRnZXMuYXJyb3cgPSBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpLFxuICAgICAgICBzaXplID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEsXG4gICAgICAgIHRTaXplID0gdGFyZ2V0W3ByZWZpeCArICdzaXplJ10sXG4gICAgICAgIHNYID0gc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgIHNZID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgIHRZID0gdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgIGFTaXplID0gTWF0aC5tYXgoc2l6ZSAqIDIuNSwgc2V0dGluZ3MoJ21pbkFycm93U2l6ZScpKSxcbiAgICAgICAgZCA9IE1hdGguc3FydChNYXRoLnBvdyh0WCAtIHNYLCAyKSArIE1hdGgucG93KHRZIC0gc1ksIDIpKSxcbiAgICAgICAgYVggPSBzWCArICh0WCAtIHNYKSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkLFxuICAgICAgICBhWSA9IHNZICsgKHRZIC0gc1kpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQsXG4gICAgICAgIHZYID0gKHRYIC0gc1gpICogYVNpemUgLyBkLFxuICAgICAgICB2WSA9ICh0WSAtIHNZKSAqIGFTaXplIC8gZDtcblxuICAgIGlmICghY29sb3IpXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xuICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcbiAgICBjb250ZXh0LmxpbmVUbyhcbiAgICAgIGFYLFxuICAgICAgYVlcbiAgICApO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WSAqIDAuNiwgYVkgLSB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggLSB2WSAqIDAuNiwgYVkgKyB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlaG92ZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaG92ZXIgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IHRoZSBlZGdlIHdpdGggYSBkaWZmZXJlbnQgY29sb3Igb3Igc2l6ZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMuZGVmID1cbiAgICBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgc2l6ZSA9IGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxLFxuICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcblxuICAgIGlmICghY29sb3IpXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xuICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MoJ2VkZ2VIb3ZlckNvbG9yJykgPT09ICdlZGdlJykge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IGNvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHRFZGdlSG92ZXJDb2xvcicpIHx8IGNvbG9yO1xuICAgIH1cbiAgICBzaXplICo9IHNldHRpbmdzKCdlZGdlSG92ZXJTaXplUmF0aW8nKTtcblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhcbiAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgc291cmNlW3ByZWZpeCArICd5J11cbiAgICApO1xuICAgIGNvbnRleHQubGluZVRvKFxuICAgICAgdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICB0YXJnZXRbcHJlZml4ICsgJ3knXVxuICAgICk7XG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlaG92ZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaG92ZXIgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IHRoZSBlZGdlIHdpdGggYSBkaWZmZXJlbnQgY29sb3Igb3Igc2l6ZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMuY3VydmUgPVxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgc2l6ZSA9IHNldHRpbmdzKCdlZGdlSG92ZXJTaXplUmF0aW8nKSAqIChlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSksXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpLFxuICAgICAgICBjcCA9IHt9LFxuICAgICAgICBzU2l6ZSA9IHNvdXJjZVtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgICBzWCA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICBzWSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICB0WCA9IHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICB0WSA9IHRhcmdldFtwcmVmaXggKyAneSddO1xuXG4gICAgY3AgPSAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpID9cbiAgICAgIHNpZ21hLnV0aWxzLmdldFNlbGZMb29wQ29udHJvbFBvaW50cyhzWCwgc1ksIHNTaXplKSA6XG4gICAgICBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQoc1gsIHNZLCB0WCwgdFkpO1xuXG4gICAgaWYgKCFjb2xvcilcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGlmIChzZXR0aW5ncygnZWRnZUhvdmVyQ29sb3InKSA9PT0gJ2VkZ2UnKSB7XG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdEVkZ2VIb3ZlckNvbG9yJykgfHwgY29sb3I7XG4gICAgfVxuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKHNYLCBzWSk7XG4gICAgaWYgKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSB7XG4gICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oY3AueDEsIGNwLnkxLCBjcC54MiwgY3AueTIsIHRYLCB0WSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjcC54LCBjcC55LCB0WCwgdFkpO1xuICAgIH1cbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBob3ZlciByZW5kZXJlciB3aWxsIGRpc3BsYXkgdGhlIGVkZ2Ugd2l0aCBhIGRpZmZlcmVudCBjb2xvciBvciBzaXplLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMuZWRnZWhvdmVycy5hcnJvdyA9XG4gICAgZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKSxcbiAgICAgICAgc2l6ZSA9IGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxLFxuICAgICAgICB0U2l6ZSA9IHRhcmdldFtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgICBzWCA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICBzWSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICB0WCA9IHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICB0WSA9IHRhcmdldFtwcmVmaXggKyAneSddO1xuXG4gICAgc2l6ZSA9IChlZGdlLmhvdmVyKSA/XG4gICAgICBzZXR0aW5ncygnZWRnZUhvdmVyU2l6ZVJhdGlvJykgKiBzaXplIDogc2l6ZTtcbiAgICB2YXIgYVNpemUgPSBzaXplICogMi41LFxuICAgICAgICBkID0gTWF0aC5zcXJ0KE1hdGgucG93KHRYIC0gc1gsIDIpICsgTWF0aC5wb3codFkgLSBzWSwgMikpLFxuICAgICAgICBhWCA9IHNYICsgKHRYIC0gc1gpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQsXG4gICAgICAgIGFZID0gc1kgKyAodFkgLSBzWSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZCxcbiAgICAgICAgdlggPSAodFggLSBzWCkgKiBhU2l6ZSAvIGQsXG4gICAgICAgIHZZID0gKHRZIC0gc1kpICogYVNpemUgLyBkO1xuXG4gICAgaWYgKCFjb2xvcilcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGlmIChzZXR0aW5ncygnZWRnZUhvdmVyQ29sb3InKSA9PT0gJ2VkZ2UnKSB7XG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdEVkZ2VIb3ZlckNvbG9yJykgfHwgY29sb3I7XG4gICAgfVxuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKHNYLCBzWSk7XG4gICAgY29udGV4dC5saW5lVG8oXG4gICAgICBhWCxcbiAgICAgIGFZXG4gICAgKTtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKGFYICsgdlgsIGFZICsgdlkpO1xuICAgIGNvbnRleHQubGluZVRvKGFYICsgdlkgKiAwLjYsIGFZIC0gdlggKiAwLjYpO1xuICAgIGNvbnRleHQubGluZVRvKGFYIC0gdlkgKiAwLjYsIGFZICsgdlggKiAwLjYpO1xuICAgIGNvbnRleHQubGluZVRvKGFYICsgdlgsIGFZICsgdlkpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZWhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGhvdmVyIHJlbmRlcmVyIHdpbGwgZGlzcGxheSB0aGUgZWRnZSB3aXRoIGEgZGlmZmVyZW50IGNvbG9yIG9yIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlaG92ZXJzLmN1cnZlZEFycm93ID1cbiAgICBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpLFxuICAgICAgICBjcCA9IHt9LFxuICAgICAgICBzaXplID0gc2V0dGluZ3MoJ2VkZ2VIb3ZlclNpemVSYXRpbycpICogKGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKSxcbiAgICAgICAgdFNpemUgPSB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgc1ggPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgc1kgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgdFggPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgdFkgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgZCxcbiAgICAgICAgYVNpemUsXG4gICAgICAgIGFYLFxuICAgICAgICBhWSxcbiAgICAgICAgdlgsXG4gICAgICAgIHZZO1xuXG4gICAgY3AgPSAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpID9cbiAgICAgIHNpZ21hLnV0aWxzLmdldFNlbGZMb29wQ29udHJvbFBvaW50cyhzWCwgc1ksIHRTaXplKSA6XG4gICAgICBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQoc1gsIHNZLCB0WCwgdFkpO1xuXG4gICAgaWYgKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSB7XG4gICAgICBkID0gTWF0aC5zcXJ0KE1hdGgucG93KHRYIC0gY3AueDEsIDIpICsgTWF0aC5wb3codFkgLSBjcC55MSwgMikpO1xuICAgICAgYVNpemUgPSBzaXplICogMi41O1xuICAgICAgYVggPSBjcC54MSArICh0WCAtIGNwLngxKSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkO1xuICAgICAgYVkgPSBjcC55MSArICh0WSAtIGNwLnkxKSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkO1xuICAgICAgdlggPSAodFggLSBjcC54MSkgKiBhU2l6ZSAvIGQ7XG4gICAgICB2WSA9ICh0WSAtIGNwLnkxKSAqIGFTaXplIC8gZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBkID0gTWF0aC5zcXJ0KE1hdGgucG93KHRYIC0gY3AueCwgMikgKyBNYXRoLnBvdyh0WSAtIGNwLnksIDIpKTtcbiAgICAgIGFTaXplID0gc2l6ZSAqIDIuNTtcbiAgICAgIGFYID0gY3AueCArICh0WCAtIGNwLngpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XG4gICAgICBhWSA9IGNwLnkgKyAodFkgLSBjcC55KSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkO1xuICAgICAgdlggPSAodFggLSBjcC54KSAqIGFTaXplIC8gZDtcbiAgICAgIHZZID0gKHRZIC0gY3AueSkgKiBhU2l6ZSAvIGQ7XG4gICAgfVxuXG4gICAgaWYgKCFjb2xvcilcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGlmIChzZXR0aW5ncygnZWRnZUhvdmVyQ29sb3InKSA9PT0gJ2VkZ2UnKSB7XG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdEVkZ2VIb3ZlckNvbG9yJykgfHwgY29sb3I7XG4gICAgfVxuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKHNYLCBzWSk7XG4gICAgaWYgKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSB7XG4gICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oY3AueDIsIGNwLnkyLCBjcC54MSwgY3AueTEsIGFYLCBhWSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjcC54LCBjcC55LCBhWCwgYVkpO1xuICAgIH1cbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKGFYICsgdlgsIGFZICsgdlkpO1xuICAgIGNvbnRleHQubGluZVRvKGFYICsgdlkgKiAwLjYsIGFZIC0gdlggKiAwLjYpO1xuICAgIGNvbnRleHQubGluZVRvKGFYIC0gdlkgKiAwLjYsIGFZICsgdlggKiAwLjYpO1xuICAgIGNvbnRleHQubGluZVRvKGFYICsgdlgsIGFZICsgdlkpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZXh0cmVtaXRpZXMnKTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgcmVuZGVyZXIgZm9yIGhvdmVyZWQgZWRnZSBleHRyZW1pdGllcy4gSXQgcmVuZGVycyB0aGUgZWRnZVxuICAgKiBleHRyZW1pdGllcyBhcyBob3ZlcmVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMuZXh0cmVtaXRpZXMuZGVmID1cbiAgICBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICAvLyBTb3VyY2UgTm9kZTpcbiAgICAoXG4gICAgICBzaWdtYS5jYW52YXMuaG92ZXJzW3NvdXJjZS50eXBlXSB8fFxuICAgICAgc2lnbWEuY2FudmFzLmhvdmVycy5kZWZcbiAgICApIChcbiAgICAgIHNvdXJjZSwgY29udGV4dCwgc2V0dGluZ3NcbiAgICApO1xuXG4gICAgLy8gVGFyZ2V0IE5vZGU6XG4gICAgKFxuICAgICAgc2lnbWEuY2FudmFzLmhvdmVyc1t0YXJnZXQudHlwZV0gfHxcbiAgICAgIHNpZ21hLmNhbnZhcy5ob3ZlcnMuZGVmXG4gICAgKSAoXG4gICAgICB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzXG4gICAgKTtcbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy51dGlscycpO1xuXG4gIC8qKlxuICAgKiBTb21lIHVzZWZ1bCBmdW5jdGlvbnMgdXNlZCBieSBzaWdtYSdzIFNWRyByZW5kZXJlci5cbiAgICovXG4gIHNpZ21hLnN2Zy51dGlscyA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IHNob3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICAgICAgICAgIGVsZW1lbnQgICBUaGUgRE9NIGVsZW1lbnQgdG8gc2hvdy5cbiAgICAgKi9cbiAgICBzaG93OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCBoaWRlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICAgICAgICAgICAgICBlbGVtZW50ICAgVGhlIERPTSBlbGVtZW50IHRvIGhpZGUuXG4gICAgICovXG4gICAgaGlkZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLm5vZGVzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IG5vZGUgcmVuZGVyZXIuIEl0IHJlbmRlcnMgdGhlIG5vZGUgYXMgYSBzaW1wbGUgZGlzYy5cbiAgICovXG4gIHNpZ21hLnN2Zy5ub2Rlcy5kZWYgPSB7XG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24obm9kZSwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgICAgY2lyY2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAnY2lyY2xlJyk7XG5cbiAgICAgIC8vIERlZmluaW5nIHRoZSBub2RlJ3MgY2lyY2xlXG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtbm9kZS1pZCcsIG5vZGUuaWQpO1xuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ub2RlJyk7XG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgIG51bGwsICdmaWxsJywgbm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKTtcblxuICAgICAgLy8gUmV0dXJuaW5nIHRoZSBET00gRWxlbWVudFxuICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgdXBkYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICAgICAgICAgICAgICBjaXJjbGUgICBUaGUgbm9kZSBET00gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKG5vZGUsIGNpcmNsZSwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJyc7XG5cbiAgICAgIC8vIEFwcGx5aW5nIGNoYW5nZXNcbiAgICAgIC8vIFRPRE86IG9wdGltaXplIC0gY2hlY2sgaWYgbmVjZXNzYXJ5XG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N4Jywgbm9kZVtwcmVmaXggKyAneCddKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY3knLCBub2RlW3ByZWZpeCArICd5J10pO1xuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdyJywgbm9kZVtwcmVmaXggKyAnc2l6ZSddKTtcblxuICAgICAgLy8gVXBkYXRpbmcgb25seSBpZiBub3QgZnJlZXN0eWxlXG4gICAgICBpZiAoIXNldHRpbmdzKCdmcmVlU3R5bGUnKSlcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKFxuICAgICAgICAgIG51bGwsICdmaWxsJywgbm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKTtcblxuICAgICAgLy8gU2hvd2luZ1xuICAgICAgY2lyY2xlLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGVkZ2UgcmVuZGVyZXIuIEl0IHJlbmRlcnMgdGhlIG5vZGUgYXMgYSBzaW1wbGUgbGluZS5cbiAgICovXG4gIHNpZ21hLnN2Zy5lZGdlcy5kZWYgPSB7XG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2UgICAgIFRoZSBzb3VyY2Ugbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgICAgIFRoZSB0YXJnZXQgbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBzZXR0aW5ncykge1xuICAgICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcbiAgICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxuICAgICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xuXG4gICAgICBpZiAoIWNvbG9yKVxuICAgICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xuICAgICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgdmFyIGxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdsaW5lJyk7XG5cbiAgICAgIC8vIEF0dHJpYnV0ZXNcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtZWRnZS1pZCcsIGVkZ2UuaWQpO1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctZWRnZScpO1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnc3Ryb2tlJywgY29sb3IpO1xuXG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgdXBkYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICAgICAgICAgIGxpbmUgICAgICAgVGhlIGxpbmUgRE9NIEVsZW1lbnQuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2UgICAgIFRoZSBzb3VyY2Ugbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgICAgIFRoZSB0YXJnZXQgbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGVkZ2UsIGxpbmUsIHNvdXJjZSwgdGFyZ2V0LCBzZXR0aW5ncykge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJztcblxuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnc3Ryb2tlLXdpZHRoJywgZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpO1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneDEnLCBzb3VyY2VbcHJlZml4ICsgJ3gnXSk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5MScsIHNvdXJjZVtwcmVmaXggKyAneSddKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gyJywgdGFyZ2V0W3ByZWZpeCArICd4J10pO1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneTInLCB0YXJnZXRbcHJlZml4ICsgJ3knXSk7XG5cbiAgICAgIC8vIFNob3dpbmdcbiAgICAgIGxpbmUuc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcuZWRnZXMnKTtcblxuICAvKipcbiAgICogVGhlIGN1cnZlIGVkZ2UgcmVuZGVyZXIuIEl0IHJlbmRlcnMgdGhlIG5vZGUgYXMgYSBiZXppZXIgY3VydmUuXG4gICAqL1xuICBzaWdtYS5zdmcuZWRnZXMuY3VydmUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2UgICAgIFRoZSBzb3VyY2Ugbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgICAgIFRoZSB0YXJnZXQgbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBzZXR0aW5ncykge1xuICAgICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcbiAgICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxuICAgICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xuXG4gICAgICBpZiAoIWNvbG9yKVxuICAgICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xuICAgICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgdmFyIHBhdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdwYXRoJyk7XG5cbiAgICAgIC8vIEF0dHJpYnV0ZXNcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtZWRnZS1pZCcsIGVkZ2UuaWQpO1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctZWRnZScpO1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnc3Ryb2tlJywgY29sb3IpO1xuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgdXBkYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICAgICAgICAgIGxpbmUgICAgICAgVGhlIGxpbmUgRE9NIEVsZW1lbnQuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2UgICAgIFRoZSBzb3VyY2Ugbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgICAgIFRoZSB0YXJnZXQgbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGVkZ2UsIHBhdGgsIHNvdXJjZSwgdGFyZ2V0LCBzZXR0aW5ncykge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJztcblxuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnc3Ryb2tlLXdpZHRoJywgZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpO1xuXG4gICAgICAvLyBDb250cm9sIHBvaW50XG4gICAgICB2YXIgY3ggPSAoc291cmNlW3ByZWZpeCArICd4J10gKyB0YXJnZXRbcHJlZml4ICsgJ3gnXSkgLyAyICtcbiAgICAgICAgKHRhcmdldFtwcmVmaXggKyAneSddIC0gc291cmNlW3ByZWZpeCArICd5J10pIC8gNCxcbiAgICAgICAgICBjeSA9IChzb3VyY2VbcHJlZml4ICsgJ3knXSArIHRhcmdldFtwcmVmaXggKyAneSddKSAvIDIgK1xuICAgICAgICAoc291cmNlW3ByZWZpeCArICd4J10gLSB0YXJnZXRbcHJlZml4ICsgJ3gnXSkgLyA0O1xuXG4gICAgICAvLyBQYXRoXG4gICAgICB2YXIgcCA9ICdNJyArIHNvdXJjZVtwcmVmaXggKyAneCddICsgJywnICsgc291cmNlW3ByZWZpeCArICd5J10gKyAnICcgK1xuICAgICAgICAgICAgICAnUScgKyBjeCArICcsJyArIGN5ICsgJyAnICtcbiAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd4J10gKyAnLCcgKyB0YXJnZXRbcHJlZml4ICsgJ3knXTtcblxuICAgICAgLy8gVXBkYXRpbmcgYXR0cmlidXRlc1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsIHApO1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICdub25lJyk7XG5cbiAgICAgIC8vIFNob3dpbmdcbiAgICAgIHBhdGguc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcubGFiZWxzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGxhYmVsIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBsYWJlbCBhcyBhIHNpbXBsZSB0ZXh0LlxuICAgKi9cbiAgc2lnbWEuc3ZnLmxhYmVscy5kZWYgPSB7XG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG5vZGUsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICAgIHNpemUgPSBub2RlW3ByZWZpeCArICdzaXplJ10sXG4gICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ3RleHQnKTtcblxuICAgICAgdmFyIGZvbnRTaXplID0gKHNldHRpbmdzKCdsYWJlbFNpemUnKSA9PT0gJ2ZpeGVkJykgP1xuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsU2l6ZScpIDpcbiAgICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplO1xuXG4gICAgICB2YXIgZm9udENvbG9yID0gKHNldHRpbmdzKCdsYWJlbENvbG9yJykgPT09ICdub2RlJykgP1xuICAgICAgICAobm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKSA6XG4gICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxDb2xvcicpO1xuXG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLWxhYmVsLXRhcmdldCcsIG5vZGUuaWQpO1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctbGFiZWwnKTtcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZvbnQtc2l6ZScsIGZvbnRTaXplKTtcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZvbnQtZmFtaWx5Jywgc2V0dGluZ3MoJ2ZvbnQnKSk7XG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgZm9udENvbG9yKTtcblxuICAgICAgdGV4dC5pbm5lckhUTUwgPSBub2RlLmxhYmVsO1xuICAgICAgdGV4dC50ZXh0Q29udGVudCA9IG5vZGUubGFiZWw7XG5cbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICAgICAgICAgIHRleHQgICAgIFRoZSBsYWJlbCBET00gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKG5vZGUsIHRleHQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICAgIHNpemUgPSBub2RlW3ByZWZpeCArICdzaXplJ107XG5cbiAgICAgIHZhciBmb250U2l6ZSA9IChzZXR0aW5ncygnbGFiZWxTaXplJykgPT09ICdmaXhlZCcpID9cbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbFNpemUnKSA6XG4gICAgICAgIHNldHRpbmdzKCdsYWJlbFNpemVSYXRpbycpICogc2l6ZTtcblxuICAgICAgLy8gQ2FzZSB3aGVuIHdlIGRvbid0IHdhbnQgdG8gZGlzcGxheSB0aGUgbGFiZWxcbiAgICAgIGlmICghc2V0dGluZ3MoJ2ZvcmNlTGFiZWxzJykgJiYgc2l6ZSA8IHNldHRpbmdzKCdsYWJlbFRocmVzaG9sZCcpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGlmICh0eXBlb2Ygbm9kZS5sYWJlbCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgLy8gVXBkYXRpbmdcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gnLFxuICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSArIHNpemUgKyAzKSk7XG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd5JyxcbiAgICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gKyBmb250U2l6ZSAvIDMpKTtcblxuICAgICAgLy8gU2hvd2luZ1xuICAgICAgdGV4dC5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5ob3ZlcnMnKTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgaG92ZXIgcmVuZGVyZXIuXG4gICAqL1xuICBzaWdtYS5zdmcuaG92ZXJzLmRlZiA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgbm9kZSAgICAgICAgICAgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtDYW52YXNFbGVtZW50fSAgICBtZWFzdXJlbWVudENhbnZhcyAgQSBmYWtlIGNhbnZhcyBoYW5kbGVkIGJ5XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHN2ZyB0byBwZXJmb3JtIHNvbWUgbWVhc3VyZW1lbnRzIGFuZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3NlZCBieSB0aGUgcmVuZGVyZXIuXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICAgICAgbm9kZUNpcmNsZSAgICAgICAgIFRoZSBub2RlIERPTSBFbGVtZW50LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgIHNldHRpbmdzICAgICAgICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbihub2RlLCBub2RlQ2lyY2xlLCBtZWFzdXJlbWVudENhbnZhcywgc2V0dGluZ3MpIHtcblxuICAgICAgLy8gRGVmaW5pbmcgdmlzdWFsIHByb3BlcnRpZXNcbiAgICAgIHZhciB4LFxuICAgICAgICAgIHksXG4gICAgICAgICAgdyxcbiAgICAgICAgICBoLFxuICAgICAgICAgIGUsXG4gICAgICAgICAgZCxcbiAgICAgICAgICBmb250U3R5bGUgPSBzZXR0aW5ncygnaG92ZXJGb250U3R5bGUnKSB8fCBzZXR0aW5ncygnZm9udFN0eWxlJyksXG4gICAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICAgIHNpemUgPSBub2RlW3ByZWZpeCArICdzaXplJ10sXG4gICAgICAgICAgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XG4gICAgICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsU2l6ZScpIDpcbiAgICAgICAgICAgIHNldHRpbmdzKCdsYWJlbFNpemVSYXRpbycpICogc2l6ZSxcbiAgICAgICAgICBmb250Q29sb3IgPSAoc2V0dGluZ3MoJ2xhYmVsSG92ZXJDb2xvcicpID09PSAnbm9kZScpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIChub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxIb3ZlckNvbG9yJyk7XG5cbiAgICAgIC8vIENyZWF0aW5nIGVsZW1lbnRzXG4gICAgICB2YXIgZ3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdnJyksXG4gICAgICAgICAgcmVjdGFuZ2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAncmVjdCcpLFxuICAgICAgICAgIGNpcmNsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ2NpcmNsZScpLFxuICAgICAgICAgIHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICd0ZXh0Jyk7XG5cbiAgICAgIC8vIERlZmluaW5nIHByb3BlcnRpZXNcbiAgICAgIGdyb3VwLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3ZlcicpO1xuICAgICAgZ3JvdXAuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtbm9kZS1pZCcsIG5vZGUuaWQpO1xuXG4gICAgICBpZiAodHlwZW9mIG5vZGUubGFiZWwgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgLy8gVGV4dFxuICAgICAgICB0ZXh0LmlubmVySFRNTCA9IG5vZGUubGFiZWw7XG4gICAgICAgIHRleHQudGV4dENvbnRlbnQgPSBub2RlLmxhYmVsO1xuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICdjbGFzcycsXG4gICAgICAgICAgICBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctaG92ZXItbGFiZWwnKTtcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZm9udC1zaXplJywgZm9udFNpemUpO1xuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmb250LWZhbWlseScsIHNldHRpbmdzKCdmb250JykpO1xuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgZm9udENvbG9yKTtcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsXG4gICAgICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd4J10gKyBzaXplICsgMykpO1xuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd5JyxcbiAgICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSArIGZvbnRTaXplIC8gMykpO1xuXG4gICAgICAgIC8vIE1lYXN1cmVzXG4gICAgICAgIC8vIE9QVElNSVpFOiBGaW5kIGEgYmV0dGVyIHdheSB0aGFuIGEgbWVhc3VyZW1lbnQgY2FudmFzXG4gICAgICAgIHggPSBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSAtIGZvbnRTaXplIC8gMiAtIDIpO1xuICAgICAgICB5ID0gTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gLSBmb250U2l6ZSAvIDIgLSAyKTtcbiAgICAgICAgdyA9IE1hdGgucm91bmQoXG4gICAgICAgICAgbWVhc3VyZW1lbnRDYW52YXMubWVhc3VyZVRleHQobm9kZS5sYWJlbCkud2lkdGggK1xuICAgICAgICAgICAgZm9udFNpemUgLyAyICsgc2l6ZSArIDlcbiAgICAgICAgKTtcbiAgICAgICAgaCA9IE1hdGgucm91bmQoZm9udFNpemUgKyA0KTtcbiAgICAgICAgZSA9IE1hdGgucm91bmQoZm9udFNpemUgLyAyICsgMik7XG5cbiAgICAgICAgLy8gQ2lyY2xlXG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAnY2xhc3MnLFxuICAgICAgICAgICAgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWhvdmVyLWFyZWEnKTtcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJyNmZmYnKTtcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeCcsIG5vZGVbcHJlZml4ICsgJ3gnXSk7XG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY3knLCBub2RlW3ByZWZpeCArICd5J10pO1xuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3InLCBlKTtcblxuICAgICAgICAvLyBSZWN0YW5nbGVcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICdjbGFzcycsXG4gICAgICAgICAgICBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctaG92ZXItYXJlYScpO1xuICAgICAgICByZWN0YW5nbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAnI2ZmZicpO1xuICAgICAgICByZWN0YW5nbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gnLCBub2RlW3ByZWZpeCArICd4J10gKyBlIC8gNCk7XG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneScsIG5vZGVbcHJlZml4ICsgJ3knXSAtIGUpO1xuICAgICAgICByZWN0YW5nbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgdyk7XG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0JywgaCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFwcGVuZGluZyBjaGlsZHNcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKGNpcmNsZSk7XG4gICAgICBncm91cC5hcHBlbmRDaGlsZChyZWN0YW5nbGUpO1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQodGV4dCk7XG4gICAgICBncm91cC5hcHBlbmRDaGlsZChub2RlQ2lyY2xlKTtcblxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH1cbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLm1pZGRsZXdhcmVzJyk7XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEudXRpbHMnKTtcblxuICAvKipcbiAgICogVGhpcyBtaWRkbGV3YXJlIHdpbGwgcmVzY2FsZSB0aGUgZ3JhcGggc3VjaCB0aGF0IGl0IHRha2VzIGFuIG9wdGltYWwgc3BhY2VcbiAgICogb24gdGhlIHJlbmRlcmVyLlxuICAgKlxuICAgKiBBcyBlYWNoIG1pZGRsZXdhcmUsIHRoaXMgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSBzaWdtYVxuICAgKiBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHs/c3RyaW5nfSByZWFkUHJlZml4ICBUaGUgcmVhZCBwcmVmaXguXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gd3JpdGVQcmVmaXggVGhlIHdyaXRlIHByZWZpeC5cbiAgICogQHBhcmFtIHtvYmplY3R9ICBvcHRpb25zICAgICBUaGUgcGFyYW1ldGVycy5cbiAgICovXG4gIHNpZ21hLm1pZGRsZXdhcmVzLnJlc2NhbGUgPSBmdW5jdGlvbihyZWFkUHJlZml4LCB3cml0ZVByZWZpeCwgb3B0aW9ucykge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBhLFxuICAgICAgICBiLFxuICAgICAgICBjLFxuICAgICAgICBkLFxuICAgICAgICBzY2FsZSxcbiAgICAgICAgbWFyZ2luLFxuICAgICAgICBuID0gdGhpcy5ncmFwaC5ub2RlcygpLFxuICAgICAgICBlID0gdGhpcy5ncmFwaC5lZGdlcygpLFxuICAgICAgICBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MuZW1iZWRPYmplY3RzKG9wdGlvbnMgfHwge30pLFxuICAgICAgICBib3VuZHMgPSBzZXR0aW5ncygnYm91bmRzJykgfHwgc2lnbWEudXRpbHMuZ2V0Qm91bmRhcmllcyhcbiAgICAgICAgICB0aGlzLmdyYXBoLFxuICAgICAgICAgIHJlYWRQcmVmaXgsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApLFxuICAgICAgICBtaW5YID0gYm91bmRzLm1pblgsXG4gICAgICAgIG1pblkgPSBib3VuZHMubWluWSxcbiAgICAgICAgbWF4WCA9IGJvdW5kcy5tYXhYLFxuICAgICAgICBtYXhZID0gYm91bmRzLm1heFksXG4gICAgICAgIHNpemVNYXggPSBib3VuZHMuc2l6ZU1heCxcbiAgICAgICAgd2VpZ2h0TWF4ID0gYm91bmRzLndlaWdodE1heCxcbiAgICAgICAgdyA9IHNldHRpbmdzKCd3aWR0aCcpIHx8IDEsXG4gICAgICAgIGggPSBzZXR0aW5ncygnaGVpZ2h0JykgfHwgMSxcbiAgICAgICAgcmVzY2FsZVNldHRpbmdzID0gc2V0dGluZ3MoJ2F1dG9SZXNjYWxlJyksXG4gICAgICAgIHZhbGlkU2V0dGluZ3MgPSB7XG4gICAgICAgICAgbm9kZVBvc2l0aW9uOiAxLFxuICAgICAgICAgIG5vZGVTaXplOiAxLFxuICAgICAgICAgIGVkZ2VTaXplOiAxXG4gICAgICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXaGF0IGVsZW1lbnRzIHNob3VsZCB3ZSByZXNjYWxlP1xuICAgICAqL1xuICAgIGlmICghKHJlc2NhbGVTZXR0aW5ncyBpbnN0YW5jZW9mIEFycmF5KSlcbiAgICAgIHJlc2NhbGVTZXR0aW5ncyA9IFsnbm9kZVBvc2l0aW9uJywgJ25vZGVTaXplJywgJ2VkZ2VTaXplJ107XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gcmVzY2FsZVNldHRpbmdzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmICghdmFsaWRTZXR0aW5nc1tyZXNjYWxlU2V0dGluZ3NbaV1dKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1RoZSByZXNjYWxlIHNldHRpbmcgXCInICsgcmVzY2FsZVNldHRpbmdzW2ldICsgJ1wiIGlzIG5vdCByZWNvZ25pemVkLidcbiAgICAgICAgKTtcblxuICAgIHZhciBucCA9IH5yZXNjYWxlU2V0dGluZ3MuaW5kZXhPZignbm9kZVBvc2l0aW9uJyksXG4gICAgICAgIG5zID0gfnJlc2NhbGVTZXR0aW5ncy5pbmRleE9mKCdub2RlU2l6ZScpLFxuICAgICAgICBlcyA9IH5yZXNjYWxlU2V0dGluZ3MuaW5kZXhPZignZWRnZVNpemUnKTtcblxuICAgIC8qKlxuICAgICAqIEZpcnN0LCB3ZSBjb21wdXRlIHRoZSBzY2FsaW5nIHJhdGlvLCB3aXRob3V0IGNvbnNpZGVyaW5nIHRoZSBzaXplc1xuICAgICAqIG9mIHRoZSBub2RlcyA6IEVhY2ggbm9kZSB3aWxsIGhhdmUgaXRzIGNlbnRlciBpbiB0aGUgY2FudmFzLCBidXQgbWlnaHRcbiAgICAgKiBiZSBwYXJ0aWFsbHkgb3V0IG9mIGl0LlxuICAgICAqL1xuICAgIHNjYWxlID0gc2V0dGluZ3MoJ3NjYWxpbmdNb2RlJykgPT09ICdvdXRzaWRlJyA/XG4gICAgICBNYXRoLm1heChcbiAgICAgICAgdyAvIE1hdGgubWF4KG1heFggLSBtaW5YLCAxKSxcbiAgICAgICAgaCAvIE1hdGgubWF4KG1heFkgLSBtaW5ZLCAxKVxuICAgICAgKSA6XG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgdyAvIE1hdGgubWF4KG1heFggLSBtaW5YLCAxKSxcbiAgICAgICAgaCAvIE1hdGgubWF4KG1heFkgLSBtaW5ZLCAxKVxuICAgICAgKTtcblxuICAgIC8qKlxuICAgICAqIFRoZW4sIHdlIGNvcnJlY3QgdGhhdCBzY2FsaW5nIHJhdGlvIGNvbnNpZGVyaW5nIGEgbWFyZ2luLCB3aGljaCBpc1xuICAgICAqIGJhc2ljYWxseSB0aGUgc2l6ZSBvZiB0aGUgYmlnZ2VzdCBub2RlLlxuICAgICAqIFRoaXMgaGFzIHRvIGJlIGRvbmUgYXMgYSBjb3JyZWN0aW9uIHNpbmNlIHRvIGNvbXBhcmUgdGhlIHNpemUgb2YgdGhlXG4gICAgICogYmlnZ2VzdCBub2RlIHRvIHRoZSBYIGFuZCBZIHZhbHVlcywgd2UgaGF2ZSB0byBmaXJzdCBnZXQgYW5cbiAgICAgKiBhcHByb3hpbWF0aW9uIG9mIHRoZSBzY2FsaW5nIHJhdGlvLlxuICAgICAqKi9cbiAgICBtYXJnaW4gPVxuICAgICAgKFxuICAgICAgICBzZXR0aW5ncygncmVzY2FsZUlnbm9yZVNpemUnKSA/XG4gICAgICAgICAgMCA6XG4gICAgICAgICAgKHNldHRpbmdzKCdtYXhOb2RlU2l6ZScpIHx8IHNpemVNYXgpIC8gc2NhbGVcbiAgICAgICkgK1xuICAgICAgKHNldHRpbmdzKCdzaWRlTWFyZ2luJykgfHwgMCk7XG4gICAgbWF4WCArPSBtYXJnaW47XG4gICAgbWluWCAtPSBtYXJnaW47XG4gICAgbWF4WSArPSBtYXJnaW47XG4gICAgbWluWSAtPSBtYXJnaW47XG5cbiAgICAvLyBGaXggdGhlIHNjYWxpbmcgd2l0aCB0aGUgbmV3IGV4dHJlbWE6XG4gICAgc2NhbGUgPSBzZXR0aW5ncygnc2NhbGluZ01vZGUnKSA9PT0gJ291dHNpZGUnID9cbiAgICAgIE1hdGgubWF4KFxuICAgICAgICB3IC8gTWF0aC5tYXgobWF4WCAtIG1pblgsIDEpLFxuICAgICAgICBoIC8gTWF0aC5tYXgobWF4WSAtIG1pblksIDEpXG4gICAgICApIDpcbiAgICAgIE1hdGgubWluKFxuICAgICAgICB3IC8gTWF0aC5tYXgobWF4WCAtIG1pblgsIDEpLFxuICAgICAgICBoIC8gTWF0aC5tYXgobWF4WSAtIG1pblksIDEpXG4gICAgICApO1xuXG4gICAgLy8gU2l6ZSBob21vdGhldGljIHBhcmFtZXRlcnM6XG4gICAgaWYgKCFzZXR0aW5ncygnbWF4Tm9kZVNpemUnKSAmJiAhc2V0dGluZ3MoJ21pbk5vZGVTaXplJykpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgYiA9IDA7XG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncygnbWF4Tm9kZVNpemUnKSA9PT0gc2V0dGluZ3MoJ21pbk5vZGVTaXplJykpIHtcbiAgICAgIGEgPSAwO1xuICAgICAgYiA9ICtzZXR0aW5ncygnbWF4Tm9kZVNpemUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IChzZXR0aW5ncygnbWF4Tm9kZVNpemUnKSAtIHNldHRpbmdzKCdtaW5Ob2RlU2l6ZScpKSAvIHNpemVNYXg7XG4gICAgICBiID0gK3NldHRpbmdzKCdtaW5Ob2RlU2l6ZScpO1xuICAgIH1cblxuICAgIGlmICghc2V0dGluZ3MoJ21heEVkZ2VTaXplJykgJiYgIXNldHRpbmdzKCdtaW5FZGdlU2l6ZScpKSB7XG4gICAgICBjID0gMTtcbiAgICAgIGQgPSAwO1xuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MoJ21heEVkZ2VTaXplJykgPT09IHNldHRpbmdzKCdtaW5FZGdlU2l6ZScpKSB7XG4gICAgICBjID0gMDtcbiAgICAgIGQgPSArc2V0dGluZ3MoJ21pbkVkZ2VTaXplJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgPSAoc2V0dGluZ3MoJ21heEVkZ2VTaXplJykgLSBzZXR0aW5ncygnbWluRWRnZVNpemUnKSkgLyB3ZWlnaHRNYXg7XG4gICAgICBkID0gK3NldHRpbmdzKCdtaW5FZGdlU2l6ZScpO1xuICAgIH1cblxuICAgIC8vIFJlc2NhbGUgdGhlIG5vZGVzIGFuZCBlZGdlczpcbiAgICBmb3IgKGkgPSAwLCBsID0gZS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBlW2ldW3dyaXRlUHJlZml4ICsgJ3NpemUnXSA9XG4gICAgICAgIGVbaV1bcmVhZFByZWZpeCArICdzaXplJ10gKiAoZXMgPyBjIDogMSkgKyAoZXMgPyBkIDogMCk7XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG5baV1bd3JpdGVQcmVmaXggKyAnc2l6ZSddID1cbiAgICAgICAgbltpXVtyZWFkUHJlZml4ICsgJ3NpemUnXSAqIChucyA/IGEgOiAxKSArIChucyA/IGIgOiAwKTtcbiAgICAgIG5baV1bd3JpdGVQcmVmaXggKyAneCddID1cbiAgICAgICAgKG5baV1bcmVhZFByZWZpeCArICd4J10gLSAobWF4WCArIG1pblgpIC8gMikgKiAobnAgPyBzY2FsZSA6IDEpO1xuICAgICAgbltpXVt3cml0ZVByZWZpeCArICd5J10gPVxuICAgICAgICAobltpXVtyZWFkUHJlZml4ICsgJ3knXSAtIChtYXhZICsgbWluWSkgLyAyKSAqIChucCA/IHNjYWxlIDogMSk7XG4gICAgfVxuICB9O1xuXG4gIHNpZ21hLnV0aWxzLmdldEJvdW5kYXJpZXMgPSBmdW5jdGlvbihncmFwaCwgcHJlZml4LCBkb0VkZ2VzKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGUgPSBncmFwaC5lZGdlcygpLFxuICAgICAgICBuID0gZ3JhcGgubm9kZXMoKSxcbiAgICAgICAgd2VpZ2h0TWF4ID0gLUluZmluaXR5LFxuICAgICAgICBzaXplTWF4ID0gLUluZmluaXR5LFxuICAgICAgICBtaW5YID0gSW5maW5pdHksXG4gICAgICAgIG1pblkgPSBJbmZpbml0eSxcbiAgICAgICAgbWF4WCA9IC1JbmZpbml0eSxcbiAgICAgICAgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGlmIChkb0VkZ2VzKVxuICAgICAgZm9yIChpID0gMCwgbCA9IGUubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICB3ZWlnaHRNYXggPSBNYXRoLm1heChlW2ldW3ByZWZpeCArICdzaXplJ10sIHdlaWdodE1heCk7XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHNpemVNYXggPSBNYXRoLm1heChuW2ldW3ByZWZpeCArICdzaXplJ10sIHNpemVNYXgpO1xuICAgICAgbWF4WCA9IE1hdGgubWF4KG5baV1bcHJlZml4ICsgJ3gnXSwgbWF4WCk7XG4gICAgICBtaW5YID0gTWF0aC5taW4obltpXVtwcmVmaXggKyAneCddLCBtaW5YKTtcbiAgICAgIG1heFkgPSBNYXRoLm1heChuW2ldW3ByZWZpeCArICd5J10sIG1heFkpO1xuICAgICAgbWluWSA9IE1hdGgubWluKG5baV1bcHJlZml4ICsgJ3knXSwgbWluWSk7XG4gICAgfVxuXG4gICAgd2VpZ2h0TWF4ID0gd2VpZ2h0TWF4IHx8IDE7XG4gICAgc2l6ZU1heCA9IHNpemVNYXggfHwgMTtcblxuICAgIHJldHVybiB7XG4gICAgICB3ZWlnaHRNYXg6IHdlaWdodE1heCxcbiAgICAgIHNpemVNYXg6IHNpemVNYXgsXG4gICAgICBtaW5YOiBtaW5YLFxuICAgICAgbWluWTogbWluWSxcbiAgICAgIG1heFg6IG1heFgsXG4gICAgICBtYXhZOiBtYXhZXG4gICAgfTtcbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLm1pZGRsZXdhcmVzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWlkZGxld2FyZSB3aWxsIGp1c3QgY29weSB0aGUgZ3JhcGhpYyBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHJlYWRQcmVmaXggIFRoZSByZWFkIHByZWZpeC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSB3cml0ZVByZWZpeCBUaGUgd3JpdGUgcHJlZml4LlxuICAgKi9cbiAgc2lnbWEubWlkZGxld2FyZXMuY29weSA9IGZ1bmN0aW9uKHJlYWRQcmVmaXgsIHdyaXRlUHJlZml4KSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGE7XG5cbiAgICBpZiAod3JpdGVQcmVmaXggKyAnJyA9PT0gcmVhZFByZWZpeCArICcnKVxuICAgICAgcmV0dXJuO1xuXG4gICAgYSA9IHRoaXMuZ3JhcGgubm9kZXMoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGFbaV1bd3JpdGVQcmVmaXggKyAneCddID0gYVtpXVtyZWFkUHJlZml4ICsgJ3gnXTtcbiAgICAgIGFbaV1bd3JpdGVQcmVmaXggKyAneSddID0gYVtpXVtyZWFkUHJlZml4ICsgJ3knXTtcbiAgICAgIGFbaV1bd3JpdGVQcmVmaXggKyAnc2l6ZSddID0gYVtpXVtyZWFkUHJlZml4ICsgJ3NpemUnXTtcbiAgICB9XG5cbiAgICBhID0gdGhpcy5ncmFwaC5lZGdlcygpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGFbaV1bd3JpdGVQcmVmaXggKyAnc2l6ZSddID0gYVtpXVtyZWFkUHJlZml4ICsgJ3NpemUnXTtcbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmcnKTtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElEIGZvciB0aGUgYW5pbWF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgdGhlIG5ldyBJRC5cbiAgICovXG4gIHZhciBfZ2V0SUQgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJycgKyAoKytpZCk7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhbmltYXRlcyBhIGNhbWVyYS4gSXQgaGFzIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBjYW1lcmEgdG9cbiAgICogYW5pbWF0ZSwgdGhlIHZhbHVlcyBvZiB0aGUgY29vcmRpbmF0ZXMgdG8gcmVhY2ggYW5kIGV2ZW50dWFsbHkgc29tZVxuICAgKiBvcHRpb25zLiBJdCByZXR1cm5zIGEgbnVtYmVyIGlkLCB0aGF0IHlvdSBjYW4gdXNlIHRvIGtpbGwgdGhlIGFuaW1hdGlvbixcbiAgICogd2l0aCB0aGUgbWV0aG9kIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmtpbGwoaWQpLlxuICAgKlxuICAgKiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlOlxuICAgKlxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIGR1cmF0aW9uICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXG4gICAqICAgez9mdW5jdGlvbn0gICAgICAgICAgb25OZXdGcmFtZSBBIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgYW5pbWF0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRlciBhIG5ldyBmcmFtZS5cbiAgICogICB7P2Z1bmN0aW9ufSAgICAgICAgICBvbkNvbXBsZXRlIEEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBhbmltYXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGNvbXBsZXRlZCBvciBraWxsZWQuXG4gICAqICAgez8oc3RyaW5nfGZ1bmN0aW9uKX0gZWFzaW5nICAgICBUaGUgbmFtZSBvZiBhIGZ1bmN0aW9uIGZyb20gdGhlIHBhY2thZ2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmVhc2luZ3MsIG9yIGEgY3VzdG9tIGVhc2luZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge2NhbWVyYX0gIGNhbWVyYSAgVGhlIGNhbWVyYSB0byBhbmltYXRlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICB0YXJnZXQgIFRoZSBjb29yZGluYXRlcyB0byByZWFjaC5cbiAgICogQHBhcmFtICB7P29iamVjdH0gb3B0aW9ucyBFdmVudHVhbGx5IGFuIG9iamVjdCB0byBzcGVjaWZ5IHNvbWUgb3B0aW9ucyB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBmdW5jdGlvbi4gVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnRlZCBpbiB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgIFRoZSBhbmltYXRpb24gaWQsIHRvIG1ha2UgaXQgZWFzeSB0byBraWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3VnaCB0aGUgbWV0aG9kIFwic2lnbWEubWlzYy5hbmltYXRpb24ua2lsbFwiLlxuICAgKi9cbiAgc2lnbWEubWlzYy5hbmltYXRpb24uY2FtZXJhID0gZnVuY3Rpb24oY2FtZXJhLCB2YWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoXG4gICAgICAhKGNhbWVyYSBpbnN0YW5jZW9mIHNpZ21hLmNsYXNzZXMuY2FtZXJhKSB8fFxuICAgICAgdHlwZW9mIHZhbCAhPT0gJ29iamVjdCcgfHxcbiAgICAgICF2YWxcbiAgICApXG4gICAgICB0aHJvdyAnYW5pbWF0aW9uLmNhbWVyYTogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgdmFsLnggIT09ICdudW1iZXInICYmXG4gICAgICB0eXBlb2YgdmFsLnkgIT09ICdudW1iZXInICYmXG4gICAgICB0eXBlb2YgdmFsLnJhdGlvICE9PSAnbnVtYmVyJyAmJlxuICAgICAgdHlwZW9mIHZhbC5hbmdsZSAhPT0gJ251bWJlcidcbiAgICApXG4gICAgICB0aHJvdyAnVGhlcmUgbXVzdCBiZSBhdCBsZWFzdCBvbmUgdmFsaWQgY29vcmRpbmF0ZSBpbiB0aGUgZ2l2ZW4gdmFsLic7XG5cbiAgICB2YXIgZm4sXG4gICAgICAgIGlkLFxuICAgICAgICBhbmltLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBpbml0aWFsVmFsLFxuICAgICAgICBvID0gb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgc3RhcnQgPSBzaWdtYS51dGlscy5kYXRlTm93KCk7XG5cbiAgICAvLyBTdG9yZSBpbml0aWFsIHZhbHVlczpcbiAgICBpbml0aWFsVmFsID0ge1xuICAgICAgeDogY2FtZXJhLngsXG4gICAgICB5OiBjYW1lcmEueSxcbiAgICAgIHJhdGlvOiBjYW1lcmEucmF0aW8sXG4gICAgICBhbmdsZTogY2FtZXJhLmFuZ2xlXG4gICAgfTtcblxuICAgIGR1cmF0aW9uID0gby5kdXJhdGlvbjtcbiAgICBlYXNpbmcgPSB0eXBlb2Ygby5lYXNpbmcgIT09ICdmdW5jdGlvbicgP1xuICAgICAgc2lnbWEudXRpbHMuZWFzaW5nc1tvLmVhc2luZyB8fCAncXVhZHJhdGljSW5PdXQnXSA6XG4gICAgICBvLmVhc2luZztcblxuICAgIGZuID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29lZixcbiAgICAgICAgICB0ID0gby5kdXJhdGlvbiA/IChzaWdtYS51dGlscy5kYXRlTm93KCkgLSBzdGFydCkgLyBvLmR1cmF0aW9uIDogMTtcblxuICAgICAgLy8gSWYgdGhlIGFuaW1hdGlvbiBpcyBvdmVyOlxuICAgICAgaWYgKHQgPj0gMSkge1xuICAgICAgICBjYW1lcmEuaXNBbmltYXRlZCA9IGZhbHNlO1xuICAgICAgICBjYW1lcmEuZ29Ubyh7XG4gICAgICAgICAgeDogdmFsLnggIT09IHVuZGVmaW5lZCA/IHZhbC54IDogaW5pdGlhbFZhbC54LFxuICAgICAgICAgIHk6IHZhbC55ICE9PSB1bmRlZmluZWQgPyB2YWwueSA6IGluaXRpYWxWYWwueSxcbiAgICAgICAgICByYXRpbzogdmFsLnJhdGlvICE9PSB1bmRlZmluZWQgPyB2YWwucmF0aW8gOiBpbml0aWFsVmFsLnJhdGlvLFxuICAgICAgICAgIGFuZ2xlOiB2YWwuYW5nbGUgIT09IHVuZGVmaW5lZCA/IHZhbC5hbmdsZSA6IGluaXRpYWxWYWwuYW5nbGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICAgICAgICBkZWxldGUgc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tpZF07XG5cbiAgICAgICAgLy8gQ2hlY2sgY2FsbGJhY2tzOlxuICAgICAgICBpZiAodHlwZW9mIG8ub25Db21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBvLm9uQ29tcGxldGUoKTtcblxuICAgICAgLy8gRWxzZSwgbGV0J3Mga2VlcCBnb2luZzpcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZWYgPSBlYXNpbmcodCk7XG4gICAgICAgIGNhbWVyYS5pc0FuaW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgY2FtZXJhLmdvVG8oe1xuICAgICAgICAgIHg6IHZhbC54ICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgaW5pdGlhbFZhbC54ICsgKHZhbC54IC0gaW5pdGlhbFZhbC54KSAqIGNvZWYgOlxuICAgICAgICAgICAgaW5pdGlhbFZhbC54LFxuICAgICAgICAgIHk6IHZhbC55ICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgaW5pdGlhbFZhbC55ICsgKHZhbC55IC0gaW5pdGlhbFZhbC55KSAqIGNvZWYgOlxuICAgICAgICAgICAgaW5pdGlhbFZhbC55LFxuICAgICAgICAgIHJhdGlvOiB2YWwucmF0aW8gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBpbml0aWFsVmFsLnJhdGlvICsgKHZhbC5yYXRpbyAtIGluaXRpYWxWYWwucmF0aW8pICogY29lZiA6XG4gICAgICAgICAgICBpbml0aWFsVmFsLnJhdGlvLFxuICAgICAgICAgIGFuZ2xlOiB2YWwuYW5nbGUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBpbml0aWFsVmFsLmFuZ2xlICsgKHZhbC5hbmdsZSAtIGluaXRpYWxWYWwuYW5nbGUpICogY29lZiA6XG4gICAgICAgICAgICBpbml0aWFsVmFsLmFuZ2xlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENoZWNrIGNhbGxiYWNrczpcbiAgICAgICAgaWYgKHR5cGVvZiBvLm9uTmV3RnJhbWUgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgby5vbk5ld0ZyYW1lKCk7XG5cbiAgICAgICAgYW5pbS5mcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWQgPSBfZ2V0SUQoKTtcbiAgICBhbmltID0ge1xuICAgICAgZnJhbWVJZDogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKSxcbiAgICAgIHRhcmdldDogY2FtZXJhLFxuICAgICAgdHlwZTogJ2NhbWVyYScsXG4gICAgICBvcHRpb25zOiBvLFxuICAgICAgZm46IGZuXG4gICAgfTtcbiAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nW2lkXSA9IGFuaW07XG5cbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEtpbGxzIGEgcnVubmluZyBhbmltYXRpb24uIEl0IHRyaWdnZXJzIHRoZSBldmVudHVhbCBvbkNvbXBsZXRlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlkICBUaGUgaWQgb2YgdGhlIGFuaW1hdGlvbiB0byBraWxsLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICBSZXR1cm5zIHRoZSBzaWdtYS5taXNjLmFuaW1hdGlvbiBwYWNrYWdlLlxuICAgKi9cbiAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEgfHwgdHlwZW9mIGlkICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93ICdhbmltYXRpb24ua2lsbDogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICB2YXIgbyA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdO1xuXG4gICAgaWYgKG8pIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgICAgIGRlbGV0ZSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nW28uZnJhbWVJZF07XG5cbiAgICAgIGlmIChvLnR5cGUgPT09ICdjYW1lcmEnKVxuICAgICAgICBvLnRhcmdldC5pc0FuaW1hdGVkID0gZmFsc2U7XG5cbiAgICAgIC8vIENoZWNrIGNhbGxiYWNrczpcbiAgICAgIGlmICh0eXBlb2YgKG8ub3B0aW9ucyB8fCB7fSkub25Db21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgby5vcHRpb25zLm9uQ29tcGxldGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogS2lsbHMgZXZlcnkgcnVubmluZyBhbmltYXRpb25zLCBvciBvbmx5IHRoZSBvbmUgd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGUsXG4gICAqIGlmIGEgc3RyaW5nIHBhcmFtZXRlciBpcyBnaXZlbi5cbiAgICpcbiAgICogQHBhcmFtICB7PyhzdHJpbmd8b2JqZWN0KX0gZmlsdGVyIEEgc3RyaW5nIHRvIGZpbHRlciB0aGUgYW5pbWF0aW9ucyB0byBraWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbiB0aGVpciB0eXBlIChleGFtcGxlOiBcImNhbWVyYVwiKSwgb3IgYW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCB0byBmaWx0ZXIgb24gdGhlaXIgdGFyZ2V0LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgbnVtYmVyIG9mIGFuaW1hdGlvbnMga2lsbGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0IHdheS5cbiAgICovXG4gIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmtpbGxBbGwgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIgbyxcbiAgICAgICAgaWQsXG4gICAgICAgIGNvdW50ID0gMCxcbiAgICAgICAgdHlwZSA9IHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnID8gZmlsdGVyIDogbnVsbCxcbiAgICAgICAgdGFyZ2V0ID0gdHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcgPyBmaWx0ZXIgOiBudWxsLFxuICAgICAgICBydW5uaW5nID0gc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZztcblxuICAgIGZvciAoaWQgaW4gcnVubmluZylcbiAgICAgIGlmIChcbiAgICAgICAgKCF0eXBlIHx8IHJ1bm5pbmdbaWRdLnR5cGUgPT09IHR5cGUpICYmXG4gICAgICAgICghdGFyZ2V0IHx8IHJ1bm5pbmdbaWRdLnRhcmdldCA9PT0gdGFyZ2V0KVxuICAgICAgKSB7XG4gICAgICAgIG8gPSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nW2lkXTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoby5mcmFtZUlkKTtcbiAgICAgICAgZGVsZXRlIHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdO1xuXG4gICAgICAgIGlmIChvLnR5cGUgPT09ICdjYW1lcmEnKVxuICAgICAgICAgIG8udGFyZ2V0LmlzQW5pbWF0ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBJbmNyZW1lbnQgY291bnRlcjpcbiAgICAgICAgY291bnQrKztcblxuICAgICAgICAvLyBDaGVjayBjYWxsYmFja3M6XG4gICAgICAgIGlmICh0eXBlb2YgKG8ub3B0aW9ucyB8fCB7fSkub25Db21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBvLm9wdGlvbnMub25Db21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgcmV0dXJuIGNvdW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIFwidHJ1ZVwiIGlmIGFueSBhbmltYXRpb24gdGhhdCBpcyBjdXJyZW50bHkgc3RpbGwgcnVubmluZyBtYXRjaGVzXG4gICAqIHRoZSBmaWx0ZXIgZ2l2ZW4gdG8gdGhlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8b2JqZWN0fSBmaWx0ZXIgQSBzdHJpbmcgdG8gZmlsdGVyIHRoZSBhbmltYXRpb25zIHRvIGtpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIHRoZWlyIHR5cGUgKGV4YW1wbGU6IFwiY2FtZXJhXCIpLCBvciBhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHRvIGZpbHRlciBvbiB0aGVpciB0YXJnZXQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICAgICAgICBSZXR1cm5zIHRydWUgaWYgYW55IHJ1bm5pbmcgYW5pbWF0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLlxuICAgKi9cbiAgc2lnbWEubWlzYy5hbmltYXRpb24uaGFzID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgdmFyIGlkLFxuICAgICAgICB0eXBlID0gdHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycgPyBmaWx0ZXIgOiBudWxsLFxuICAgICAgICB0YXJnZXQgPSB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyA/IGZpbHRlciA6IG51bGwsXG4gICAgICAgIHJ1bm5pbmcgPSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nO1xuXG4gICAgZm9yIChpZCBpbiBydW5uaW5nKVxuICAgICAgaWYgKFxuICAgICAgICAoIXR5cGUgfHwgcnVubmluZ1tpZF0udHlwZSA9PT0gdHlwZSkgJiZcbiAgICAgICAgKCF0YXJnZXQgfHwgcnVubmluZ1tpZF0udGFyZ2V0ID09PSB0YXJnZXQpXG4gICAgICApXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlzYycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGhlbHBlciB3aWxsIGJpbmQgYW55IG5vLURPTSByZW5kZXJlciAoZm9yIGluc3RhbmNlIGNhbnZhcyBvciBXZWJHTClcbiAgICogdG8gaXRzIGNhcHRvcnMsIHRvIHByb3Blcmx5IGRpc3BhdGNoIHRoZSBnb29kIGV2ZW50cyB0byB0aGUgc2lnbWEgaW5zdGFuY2VcbiAgICogdG8gbWFuYWdlIGNsaWNraW5nLCBob3ZlcmluZyBldGMuLi5cbiAgICpcbiAgICogSXQgaGFzIHRvIGJlIGNhbGxlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIHJlbGF0ZWQgcmVuZGVyZXIuXG4gICAqL1xuICBzaWdtYS5taXNjLmJpbmRFdmVudHMgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgbVgsXG4gICAgICAgIG1ZLFxuICAgICAgICBjYXB0b3IsXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZ2V0Tm9kZXMoZSkge1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgbVggPSAneCcgaW4gZS5kYXRhID8gZS5kYXRhLnggOiBtWDtcbiAgICAgICAgbVkgPSAneScgaW4gZS5kYXRhID8gZS5kYXRhLnkgOiBtWTtcbiAgICAgIH1cblxuICAgICAgdmFyIGksXG4gICAgICAgICAgaixcbiAgICAgICAgICBsLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIHMsXG4gICAgICAgICAgaW5zZXJ0ZWQsXG4gICAgICAgICAgc2VsZWN0ZWQgPSBbXSxcbiAgICAgICAgICBtb2RpZmllZFggPSBtWCArIHNlbGYud2lkdGggLyAyLFxuICAgICAgICAgIG1vZGlmaWVkWSA9IG1ZICsgc2VsZi5oZWlnaHQgLyAyLFxuICAgICAgICAgIHBvaW50ID0gc2VsZi5jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICBtWCxcbiAgICAgICAgICAgIG1ZXG4gICAgICAgICAgKSxcbiAgICAgICAgICBub2RlcyA9IHNlbGYuY2FtZXJhLnF1YWR0cmVlLnBvaW50KFxuICAgICAgICAgICAgcG9pbnQueCxcbiAgICAgICAgICAgIHBvaW50LnlcbiAgICAgICAgICApO1xuXG4gICAgICBpZiAobm9kZXMubGVuZ3RoKVxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgbiA9IG5vZGVzW2ldO1xuICAgICAgICAgIHggPSBuW3ByZWZpeCArICd4J107XG4gICAgICAgICAgeSA9IG5bcHJlZml4ICsgJ3knXTtcbiAgICAgICAgICBzID0gbltwcmVmaXggKyAnc2l6ZSddO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW4uaGlkZGVuICYmXG4gICAgICAgICAgICBtb2RpZmllZFggPiB4IC0gcyAmJlxuICAgICAgICAgICAgbW9kaWZpZWRYIDwgeCArIHMgJiZcbiAgICAgICAgICAgIG1vZGlmaWVkWSA+IHkgLSBzICYmXG4gICAgICAgICAgICBtb2RpZmllZFkgPCB5ICsgcyAmJlxuICAgICAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICBNYXRoLnBvdyhtb2RpZmllZFggLSB4LCAyKSArXG4gICAgICAgICAgICAgIE1hdGgucG93KG1vZGlmaWVkWSAtIHksIDIpXG4gICAgICAgICAgICApIDwgc1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBub2RlOlxuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHNlbGVjdGVkLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICBpZiAobi5zaXplID4gc2VsZWN0ZWRbal0uc2l6ZSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkLnNwbGljZShqLCAwLCBuKTtcbiAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpbnNlcnRlZClcbiAgICAgICAgICAgICAgc2VsZWN0ZWQucHVzaChuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gZ2V0RWRnZXMoZSkge1xuICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdlbmFibGVFZGdlSG92ZXJpbmcnKSkge1xuICAgICAgICAvLyBObyBldmVudCBpZiB0aGUgc2V0dGluZyBpcyBvZmY6XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzQ2FudmFzID0gKFxuICAgICAgICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzICYmIHNlbGYgaW5zdGFuY2VvZiBzaWdtYS5yZW5kZXJlcnMuY2FudmFzKTtcblxuICAgICAgaWYgKCFpc0NhbnZhcykge1xuICAgICAgICAvLyBBIHF1aWNrIGhhcmRjb2RlZCBydWxlIHRvIHByZXZlbnQgcGVvcGxlIGZyb20gdXNpbmcgdGhpcyBmZWF0dXJlXG4gICAgICAgIC8vIHdpdGggdGhlIFdlYkdMIHJlbmRlcmVyICh3aGljaCBpcyBub3QgZ29vZCBlbm91Z2ggYXQgdGhlIG1vbWVudCk6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIGVkZ2UgZXZlbnRzIGZlYXR1cmUgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgV2ViR0wgcmVuZGVyZXInXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIG1YID0gJ3gnIGluIGUuZGF0YSA/IGUuZGF0YS54IDogbVg7XG4gICAgICAgIG1ZID0gJ3knIGluIGUuZGF0YSA/IGUuZGF0YS55IDogbVk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpLFxuICAgICAgICAgIGosXG4gICAgICAgICAgbCxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGVkZ2UsXG4gICAgICAgICAgcyxcbiAgICAgICAgICBtYXhFcHNpbG9uID0gc2VsZi5zZXR0aW5ncygnZWRnZUhvdmVyUHJlY2lzaW9uJyksXG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBjcCxcbiAgICAgICAgICBub2RlSW5kZXggPSB7fSxcbiAgICAgICAgICBpbnNlcnRlZCxcbiAgICAgICAgICBzZWxlY3RlZCA9IFtdLFxuICAgICAgICAgIG1vZGlmaWVkWCA9IG1YICsgc2VsZi53aWR0aCAvIDIsXG4gICAgICAgICAgbW9kaWZpZWRZID0gbVkgKyBzZWxmLmhlaWdodCAvIDIsXG4gICAgICAgICAgcG9pbnQgPSBzZWxmLmNhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgIG1YLFxuICAgICAgICAgICAgbVlcbiAgICAgICAgICApLFxuICAgICAgICAgIGVkZ2VzID0gW107XG5cbiAgICAgIGlmIChpc0NhbnZhcykge1xuICAgICAgICB2YXIgbm9kZXNPblNjcmVlbiA9IHNlbGYuY2FtZXJhLnF1YWR0cmVlLmFyZWEoXG4gICAgICAgICAgc2VsZi5jYW1lcmEuZ2V0UmVjdGFuZ2xlKHNlbGYud2lkdGgsIHNlbGYuaGVpZ2h0KVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGEgPSBub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIG5vZGVJbmRleFthW2ldLmlkXSA9IGFbaV07XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmNhbWVyYS5lZGdlcXVhZHRyZWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlZGdlcyA9IHNlbGYuY2FtZXJhLmVkZ2VxdWFkdHJlZS5wb2ludChcbiAgICAgICAgICBwb2ludC54LFxuICAgICAgICAgIHBvaW50LnlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW5zZXJ0RWRnZShzZWxlY3RlZCwgZWRnZSkge1xuICAgICAgICBpbnNlcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBzZWxlY3RlZC5sZW5ndGg7IGorKylcbiAgICAgICAgICBpZiAoZWRnZS5zaXplID4gc2VsZWN0ZWRbal0uc2l6ZSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQuc3BsaWNlKGosIDAsIGVkZ2UpO1xuICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW5zZXJ0ZWQpXG4gICAgICAgICAgc2VsZWN0ZWQucHVzaChlZGdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVkZ2VzLmxlbmd0aClcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVkZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgICAgICBzb3VyY2UgPSBzZWxmLmdyYXBoLm5vZGVzKGVkZ2Uuc291cmNlKTtcbiAgICAgICAgICB0YXJnZXQgPSBzZWxmLmdyYXBoLm5vZGVzKGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgICAvLyAoSEFDSykgd2UgY2FuJ3QgZ2V0IGVkZ2VbcHJlZml4ICsgJ3NpemUnXSBvbiBXZWJHTCByZW5kZXJlcjpcbiAgICAgICAgICBzID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8XG4gICAgICAgICAgICAgIGVkZ2VbJ3JlYWRfJyArIHByZWZpeCArICdzaXplJ107XG5cbiAgICAgICAgICAvLyBGaXJzdCwgbGV0J3MgaWRlbnRpZnkgd2hpY2ggZWRnZXMgYXJlIGRyYXduLiBUbyBkbyB0aGlzLCB3ZSBrZWVwXG4gICAgICAgICAgLy8gZXZlcnkgZWRnZXMgdGhhdCBoYXZlIGF0IGxlYXN0IG9uZSBleHRyZW1pdHkgZGlzcGxheWVkIGFjY29yZGluZyB0b1xuICAgICAgICAgIC8vIHRoZSBxdWFkdHJlZSBhbmQgdGhlIFwiaGlkZGVuXCIgYXR0cmlidXRlLiBXZSBhbHNvIGRvIG5vdCBrZWVwIGhpZGRlblxuICAgICAgICAgIC8vIGVkZ2VzLlxuICAgICAgICAgIC8vIFRoZW4sIGxldCdzIGNoZWNrIGlmIHRoZSBtb3VzZSBpcyBvbiB0aGUgZWRnZSAod2Ugc3VwcG9zZSB0aGF0IGl0XG4gICAgICAgICAgLy8gaXMgYSBsaW5lIHNlZ21lbnQpLlxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWVkZ2UuaGlkZGVuICYmXG4gICAgICAgICAgICAhc291cmNlLmhpZGRlbiAmJiAhdGFyZ2V0LmhpZGRlbiAmJlxuICAgICAgICAgICAgKCFpc0NhbnZhcyB8fFxuICAgICAgICAgICAgICAobm9kZUluZGV4W2VkZ2Uuc291cmNlXSB8fCBub2RlSW5kZXhbZWRnZS50YXJnZXRdKSkgJiZcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKFxuICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgIG1vZGlmaWVkWCxcbiAgICAgICAgICAgICAgbW9kaWZpZWRZKSA+IHNvdXJjZVtwcmVmaXggKyAnc2l6ZSddICYmXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXREaXN0YW5jZShcbiAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICBtb2RpZmllZFgsXG4gICAgICAgICAgICAgIG1vZGlmaWVkWSkgPiB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGVkZ2UudHlwZSA9PSAnY3VydmUnIHx8IGVkZ2UudHlwZSA9PSAnY3VydmVkQXJyb3cnKSB7XG4gICAgICAgICAgICAgIGlmIChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkge1xuICAgICAgICAgICAgICAgIGNwID0gc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAnc2l6ZSddXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5pc1BvaW50T25CZXppZXJDdXJ2ZShcbiAgICAgICAgICAgICAgICAgIG1vZGlmaWVkWCxcbiAgICAgICAgICAgICAgICAgIG1vZGlmaWVkWSxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICAgICAgY3AueDEsXG4gICAgICAgICAgICAgICAgICBjcC55MSxcbiAgICAgICAgICAgICAgICAgIGNwLngyLFxuICAgICAgICAgICAgICAgICAgY3AueTIsXG4gICAgICAgICAgICAgICAgICBNYXRoLm1heChzLCBtYXhFcHNpbG9uKVxuICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydEVkZ2Uoc2VsZWN0ZWQsIGVkZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjcCA9IHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludChcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneSddKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5pc1BvaW50T25RdWFkcmF0aWNDdXJ2ZShcbiAgICAgICAgICAgICAgICAgIG1vZGlmaWVkWCxcbiAgICAgICAgICAgICAgICAgIG1vZGlmaWVkWSxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICAgICAgY3AueCxcbiAgICAgICAgICAgICAgICAgIGNwLnksXG4gICAgICAgICAgICAgICAgICBNYXRoLm1heChzLCBtYXhFcHNpbG9uKVxuICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydEVkZ2Uoc2VsZWN0ZWQsIGVkZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5pc1BvaW50T25TZWdtZW50KFxuICAgICAgICAgICAgICAgIG1vZGlmaWVkWCxcbiAgICAgICAgICAgICAgICBtb2RpZmllZFksXG4gICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgocywgbWF4RXBzaWxvbilcbiAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICBpbnNlcnRFZGdlKHNlbGVjdGVkLCBlZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYmluZENhcHRvcihjYXB0b3IpIHtcbiAgICAgIHZhciBub2RlcyxcbiAgICAgICAgICBlZGdlcyxcbiAgICAgICAgICBvdmVyTm9kZXMgPSB7fSxcbiAgICAgICAgICBvdmVyRWRnZXMgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrJywgZS5kYXRhKTtcblxuICAgICAgICBub2RlcyA9IGdldE5vZGVzKGUpO1xuICAgICAgICBlZGdlcyA9IGdldEVkZ2VzKGUpO1xuXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrTm9kZScsIHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGVzWzBdLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrTm9kZXMnLCB7XG4gICAgICAgICAgICBub2RlOiBub2RlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGlja0VkZ2UnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlc1swXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGlja0VkZ2VzJywge1xuICAgICAgICAgICAgZWRnZTogZWRnZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrU3RhZ2UnLCB7Y2FwdG9yOiBlLmRhdGF9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25Eb3VibGVDbGljayhlKSB7XG4gICAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrJywgZS5kYXRhKTtcblxuICAgICAgICBub2RlcyA9IGdldE5vZGVzKGUpO1xuICAgICAgICBlZGdlcyA9IGdldEVkZ2VzKGUpO1xuXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrTm9kZScsIHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGVzWzBdLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrTm9kZXMnLCB7XG4gICAgICAgICAgICBub2RlOiBub2RlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja0VkZ2UnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlc1swXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja0VkZ2VzJywge1xuICAgICAgICAgICAgZWRnZTogZWRnZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrU3RhZ2UnLCB7Y2FwdG9yOiBlLmRhdGF9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25SaWdodENsaWNrKGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGljaycsIGUuZGF0YSk7XG5cbiAgICAgICAgbm9kZXMgPSBnZXROb2RlcyhlKTtcbiAgICAgICAgZWRnZXMgPSBnZXRFZGdlcyhlKTtcblxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrTm9kZScsIHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGVzWzBdLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3JpZ2h0Q2xpY2tOb2RlcycsIHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3JpZ2h0Q2xpY2tFZGdlJywge1xuICAgICAgICAgICAgZWRnZTogZWRnZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja0VkZ2VzJywge1xuICAgICAgICAgICAgZWRnZTogZWRnZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3JpZ2h0Q2xpY2tTdGFnZScsIHtjYXB0b3I6IGUuZGF0YX0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbk91dChlKSB7XG4gICAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgayxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgbGUsXG4gICAgICAgICAgICBvdXROb2RlcyA9IFtdLFxuICAgICAgICAgICAgb3V0RWRnZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGsgaW4gb3Zlck5vZGVzKVxuICAgICAgICAgIG91dE5vZGVzLnB1c2gob3Zlck5vZGVzW2tdKTtcblxuICAgICAgICBvdmVyTm9kZXMgPSB7fTtcbiAgICAgICAgLy8gRGlzcGF0Y2ggYm90aCBzaW5nbGUgYW5kIG11bHRpIGV2ZW50czpcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG91dE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dE5vZGUnLCB7XG4gICAgICAgICAgICBub2RlOiBvdXROb2Rlc1tpXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChvdXROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXROb2RlcycsIHtcbiAgICAgICAgICAgIG5vZGVzOiBvdXROb2RlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgb3ZlckVkZ2VzID0ge307XG4gICAgICAgIC8vIERpc3BhdGNoIGJvdGggc2luZ2xlIGFuZCBtdWx0aSBldmVudHM6XG4gICAgICAgIGZvciAoaSA9IDAsIGxlID0gb3V0RWRnZXMubGVuZ3RoOyBpIDwgbGU7IGkrKylcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dEVkZ2UnLCB7XG4gICAgICAgICAgICBlZGdlOiBvdXRFZGdlc1tpXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChvdXRFZGdlcy5sZW5ndGgpXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXRFZGdlcycsIHtcbiAgICAgICAgICAgIGVkZ2VzOiBvdXRFZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uTW92ZShlKSB7XG4gICAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBub2RlcyA9IGdldE5vZGVzKGUpO1xuICAgICAgICBlZGdlcyA9IGdldEVkZ2VzKGUpO1xuXG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBlZGdlLFxuICAgICAgICAgICAgbmV3T3V0Tm9kZXMgPSBbXSxcbiAgICAgICAgICAgIG5ld092ZXJOb2RlcyA9IFtdLFxuICAgICAgICAgICAgY3VycmVudE92ZXJOb2RlcyA9IHt9LFxuICAgICAgICAgICAgbCA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgICAgIG5ld091dEVkZ2VzID0gW10sXG4gICAgICAgICAgICBuZXdPdmVyRWRnZXMgPSBbXSxcbiAgICAgICAgICAgIGN1cnJlbnRPdmVyRWRnZXMgPSB7fSxcbiAgICAgICAgICAgIGxlID0gZWRnZXMubGVuZ3RoO1xuXG4gICAgICAgIC8vIENoZWNrIG5ld2x5IG92ZXJyZWQgbm9kZXM6XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgY3VycmVudE92ZXJOb2Rlc1tub2RlLmlkXSA9IG5vZGU7XG4gICAgICAgICAgaWYgKCFvdmVyTm9kZXNbbm9kZS5pZF0pIHtcbiAgICAgICAgICAgIG5ld092ZXJOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgb3Zlck5vZGVzW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBubyBtb3JlIG92ZXJyZWQgbm9kZXM6XG4gICAgICAgIGZvciAoayBpbiBvdmVyTm9kZXMpXG4gICAgICAgICAgaWYgKCFjdXJyZW50T3Zlck5vZGVzW2tdKSB7XG4gICAgICAgICAgICBuZXdPdXROb2Rlcy5wdXNoKG92ZXJOb2Rlc1trXSk7XG4gICAgICAgICAgICBkZWxldGUgb3Zlck5vZGVzW2tdO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyBEaXNwYXRjaCBib3RoIHNpbmdsZSBhbmQgbXVsdGkgZXZlbnRzOlxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmV3T3Zlck5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ292ZXJOb2RlJywge1xuICAgICAgICAgICAgbm9kZTogbmV3T3Zlck5vZGVzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5ld091dE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dE5vZGUnLCB7XG4gICAgICAgICAgICBub2RlOiBuZXdPdXROb2Rlc1tpXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdPdmVyTm9kZXMubGVuZ3RoKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3Zlck5vZGVzJywge1xuICAgICAgICAgICAgbm9kZXM6IG5ld092ZXJOb2RlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdPdXROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXROb2RlcycsIHtcbiAgICAgICAgICAgIG5vZGVzOiBuZXdPdXROb2RlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgbmV3bHkgb3ZlcnJlZCBlZGdlczpcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlOyBpKyspIHtcbiAgICAgICAgICBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgICAgY3VycmVudE92ZXJFZGdlc1tlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgaWYgKCFvdmVyRWRnZXNbZWRnZS5pZF0pIHtcbiAgICAgICAgICAgIG5ld092ZXJFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgICAgb3ZlckVkZ2VzW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBubyBtb3JlIG92ZXJyZWQgZWRnZXM6XG4gICAgICAgIGZvciAoayBpbiBvdmVyRWRnZXMpXG4gICAgICAgICAgaWYgKCFjdXJyZW50T3ZlckVkZ2VzW2tdKSB7XG4gICAgICAgICAgICBuZXdPdXRFZGdlcy5wdXNoKG92ZXJFZGdlc1trXSk7XG4gICAgICAgICAgICBkZWxldGUgb3ZlckVkZ2VzW2tdO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyBEaXNwYXRjaCBib3RoIHNpbmdsZSBhbmQgbXVsdGkgZXZlbnRzOlxuICAgICAgICBmb3IgKGkgPSAwLCBsZSA9IG5ld092ZXJFZGdlcy5sZW5ndGg7IGkgPCBsZTsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3ZlckVkZ2UnLCB7XG4gICAgICAgICAgICBlZGdlOiBuZXdPdmVyRWRnZXNbaV0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZSA9IG5ld091dEVkZ2VzLmxlbmd0aDsgaSA8IGxlOyBpKyspXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXRFZGdlJywge1xuICAgICAgICAgICAgZWRnZTogbmV3T3V0RWRnZXNbaV0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICBpZiAobmV3T3ZlckVkZ2VzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ292ZXJFZGdlcycsIHtcbiAgICAgICAgICAgIGVkZ2VzOiBuZXdPdmVyRWRnZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICBpZiAobmV3T3V0RWRnZXMubGVuZ3RoKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0RWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlczogbmV3T3V0RWRnZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBCaW5kIGV2ZW50czpcbiAgICAgIGNhcHRvci5iaW5kKCdjbGljaycsIG9uQ2xpY2spO1xuICAgICAgY2FwdG9yLmJpbmQoJ21vdXNlZG93bicsIG9uTW92ZSk7XG4gICAgICBjYXB0b3IuYmluZCgnbW91c2V1cCcsIG9uTW92ZSk7XG4gICAgICBjYXB0b3IuYmluZCgnbW91c2Vtb3ZlJywgb25Nb3ZlKTtcbiAgICAgIGNhcHRvci5iaW5kKCdtb3VzZW91dCcsIG9uT3V0KTtcbiAgICAgIGNhcHRvci5iaW5kKCdkb3VibGVjbGljaycsIG9uRG91YmxlQ2xpY2spO1xuICAgICAgY2FwdG9yLmJpbmQoJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spO1xuICAgICAgc2VsZi5iaW5kKCdyZW5kZXInLCBvbk1vdmUpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNhcHRvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgYmluZENhcHRvcih0aGlzLmNhcHRvcnNbaV0pO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlzYycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGhlbHBlciB3aWxsIGJpbmQgYW55IERPTSByZW5kZXJlciAoZm9yIGluc3RhbmNlIHN2ZylcbiAgICogdG8gaXRzIGNhcHRvcnMsIHRvIHByb3Blcmx5IGRpc3BhdGNoIHRoZSBnb29kIGV2ZW50cyB0byB0aGUgc2lnbWEgaW5zdGFuY2VcbiAgICogdG8gbWFuYWdlIGNsaWNraW5nLCBob3ZlcmluZyBldGMuLi5cbiAgICpcbiAgICogSXQgaGFzIHRvIGJlIGNhbGxlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIHJlbGF0ZWQgcmVuZGVyZXIuXG4gICAqL1xuICBzaWdtYS5taXNjLmJpbmRET01FdmVudHMgPSBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaDtcblxuICAgIC8vIERPTUVsZW1lbnQgYWJzdHJhY3Rpb25cbiAgICBmdW5jdGlvbiBFbGVtZW50KGRvbUVsZW1lbnQpIHtcblxuICAgICAgLy8gSGVscGVyc1xuICAgICAgdGhpcy5hdHRyID0gZnVuY3Rpb24oYXR0ck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlTlMobnVsbCwgYXR0ck5hbWUpO1xuICAgICAgfTtcblxuICAgICAgLy8gUHJvcGVydGllc1xuICAgICAgdGhpcy50YWcgPSBkb21FbGVtZW50LnRhZ05hbWU7XG4gICAgICB0aGlzLmNsYXNzID0gdGhpcy5hdHRyKCdjbGFzcycpO1xuICAgICAgdGhpcy5pZCA9IHRoaXMuYXR0cignaWQnKTtcblxuICAgICAgLy8gTWV0aG9kc1xuICAgICAgdGhpcy5pc05vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhfnRoaXMuY2xhc3MuaW5kZXhPZihzZWxmLnNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ub2RlJyk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmlzRWRnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF+dGhpcy5jbGFzcy5pbmRleE9mKHNlbGYuc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWVkZ2UnKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuaXNIb3ZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF+dGhpcy5jbGFzcy5pbmRleE9mKHNlbGYuc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWhvdmVyJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENsaWNrXG4gICAgZnVuY3Rpb24gY2xpY2soZSkge1xuICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgLy8gR2VuZXJpYyBldmVudFxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGljaycsIGUpO1xuXG4gICAgICAvLyBBcmUgd2Ugb24gYSBub2RlP1xuICAgICAgdmFyIGVsZW1lbnQgPSBuZXcgRWxlbWVudChlLnRhcmdldCk7XG5cbiAgICAgIGlmIChlbGVtZW50LmlzTm9kZSgpKVxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrTm9kZScsIHtcbiAgICAgICAgICBub2RlOiBncmFwaC5ub2RlcyhlbGVtZW50LmF0dHIoJ2RhdGEtbm9kZS1pZCcpKVxuICAgICAgICB9KTtcbiAgICAgIGVsc2VcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGlja1N0YWdlJyk7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgLy8gRG91YmxlIGNsaWNrXG4gICAgZnVuY3Rpb24gZG91YmxlQ2xpY2soZSkge1xuICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgLy8gR2VuZXJpYyBldmVudFxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGljaycsIGUpO1xuXG4gICAgICAvLyBBcmUgd2Ugb24gYSBub2RlP1xuICAgICAgdmFyIGVsZW1lbnQgPSBuZXcgRWxlbWVudChlLnRhcmdldCk7XG5cbiAgICAgIGlmIChlbGVtZW50LmlzTm9kZSgpKVxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrTm9kZScsIHtcbiAgICAgICAgICBub2RlOiBncmFwaC5ub2RlcyhlbGVtZW50LmF0dHIoJ2RhdGEtbm9kZS1pZCcpKVxuICAgICAgICB9KTtcbiAgICAgIGVsc2VcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja1N0YWdlJyk7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgLy8gT24gb3ZlclxuICAgIGZ1bmN0aW9uIG9uT3ZlcihlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gZS50b0VsZW1lbnQgfHwgZS50YXJnZXQ7XG5cbiAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpIHx8ICF0YXJnZXQpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgdmFyIGVsID0gbmV3IEVsZW1lbnQodGFyZ2V0KTtcblxuICAgICAgaWYgKGVsLmlzTm9kZSgpKSB7XG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3Zlck5vZGUnLCB7XG4gICAgICAgICAgbm9kZTogZ3JhcGgubm9kZXMoZWwuYXR0cignZGF0YS1ub2RlLWlkJykpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuaXNFZGdlKCkpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBncmFwaC5lZGdlcyhlbC5hdHRyKCdkYXRhLWVkZ2UtaWQnKSk7XG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3ZlckVkZ2UnLCB7XG4gICAgICAgICAgZWRnZTogZWRnZSxcbiAgICAgICAgICBzb3VyY2U6IGdyYXBoLm5vZGVzKGVkZ2Uuc291cmNlKSxcbiAgICAgICAgICB0YXJnZXQ6IGdyYXBoLm5vZGVzKGVkZ2UudGFyZ2V0KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPbiBvdXRcbiAgICBmdW5jdGlvbiBvbk91dChlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gZS5mcm9tRWxlbWVudCB8fCBlLm9yaWdpbmFsVGFyZ2V0O1xuXG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB2YXIgZWwgPSBuZXcgRWxlbWVudCh0YXJnZXQpO1xuXG4gICAgICBpZiAoZWwuaXNOb2RlKCkpIHtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXROb2RlJywge1xuICAgICAgICAgIG5vZGU6IGdyYXBoLm5vZGVzKGVsLmF0dHIoJ2RhdGEtbm9kZS1pZCcpKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVsLmlzRWRnZSgpKSB7XG4gICAgICAgIHZhciBlZGdlID0gZ3JhcGguZWRnZXMoZWwuYXR0cignZGF0YS1lZGdlLWlkJykpO1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dEVkZ2UnLCB7XG4gICAgICAgICAgZWRnZTogZWRnZSxcbiAgICAgICAgICBzb3VyY2U6IGdyYXBoLm5vZGVzKGVkZ2Uuc291cmNlKSxcbiAgICAgICAgICB0YXJnZXQ6IGdyYXBoLm5vZGVzKGVkZ2UudGFyZ2V0KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlcmluZyBFdmVudHM6XG5cbiAgICAvLyBDbGlja1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrLCBmYWxzZSk7XG4gICAgc2lnbWEudXRpbHMuZG91YmxlQ2xpY2soY29udGFpbmVyLCAnY2xpY2snLCBkb3VibGVDbGljayk7XG5cbiAgICAvLyBUb3VjaCBjb3VudGVycGFydHNcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGNsaWNrLCBmYWxzZSk7XG4gICAgc2lnbWEudXRpbHMuZG91YmxlQ2xpY2soY29udGFpbmVyLCAndG91Y2hzdGFydCcsIGRvdWJsZUNsaWNrKTtcblxuICAgIC8vIE1vdXNlb3ZlclxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBvbk92ZXIsIHRydWUpO1xuXG4gICAgLy8gTW91c2VvdXRcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBvbk91dCwgdHJ1ZSk7XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taXNjJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGxpc3RlbnMgdG8gXCJvdmVyTm9kZVwiLCBcIm91dE5vZGVcIiwgXCJvdmVyRWRnZVwiIGFuZCBcIm91dEVkZ2VcIlxuICAgKiBldmVudHMgZnJvbSBhIHJlbmRlcmVyIGFuZCByZW5kZXJzIHRoZSBub2RlcyBkaWZmZXJlbnRseSBvbiB0aGUgdG9wIGxheWVyLlxuICAgKiBUaGUgZ29hbCBpcyB0byBtYWtlIGFueSBub2RlIGxhYmVsIHJlYWRhYmxlIHdpdGggdGhlIG1vdXNlLCBhbmQgdG9cbiAgICogaGlnaGxpZ2h0IGhvdmVyZWQgbm9kZXMgYW5kIGVkZ2VzLlxuICAgKlxuICAgKiBJdCBoYXMgdG8gYmUgY2FsbGVkIGluIHRoZSBzY29wZSBvZiB0aGUgcmVsYXRlZCByZW5kZXJlci5cbiAgICovXG4gIHNpZ21hLm1pc2MuZHJhd0hvdmVycyA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgaG92ZXJlZE5vZGVzID0ge30sXG4gICAgICAgIGhvdmVyZWRFZGdlcyA9IHt9O1xuXG4gICAgdGhpcy5iaW5kKCdvdmVyTm9kZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgbm9kZSA9IGV2ZW50LmRhdGEubm9kZTtcbiAgICAgIGlmICghbm9kZS5oaWRkZW4pIHtcbiAgICAgICAgaG92ZXJlZE5vZGVzW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgZHJhdygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5iaW5kKCdvdXROb2RlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGRlbGV0ZSBob3ZlcmVkTm9kZXNbZXZlbnQuZGF0YS5ub2RlLmlkXTtcbiAgICAgIGRyYXcoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuYmluZCgnb3ZlckVkZ2UnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIGVkZ2UgPSBldmVudC5kYXRhLmVkZ2U7XG4gICAgICBpZiAoIWVkZ2UuaGlkZGVuKSB7XG4gICAgICAgIGhvdmVyZWRFZGdlc1tlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgIGRyYXcoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuYmluZCgnb3V0RWRnZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBkZWxldGUgaG92ZXJlZEVkZ2VzW2V2ZW50LmRhdGEuZWRnZS5pZF07XG4gICAgICBkcmF3KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmJpbmQoJ3JlbmRlcicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBkcmF3KCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBkcmF3KCkge1xuXG4gICAgICB2YXIgayxcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGhvdmVyZWROb2RlLFxuICAgICAgICAgIGhvdmVyZWRFZGdlLFxuICAgICAgICAgIGMgPSBzZWxmLmNvbnRleHRzLmhvdmVyLmNhbnZhcyxcbiAgICAgICAgICBkZWZhdWx0Tm9kZVR5cGUgPSBzZWxmLnNldHRpbmdzKCdkZWZhdWx0Tm9kZVR5cGUnKSxcbiAgICAgICAgICBkZWZhdWx0RWRnZVR5cGUgPSBzZWxmLnNldHRpbmdzKCdkZWZhdWx0RWRnZVR5cGUnKSxcbiAgICAgICAgICBub2RlUmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmhvdmVycyxcbiAgICAgICAgICBlZGdlUmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMsXG4gICAgICAgICAgZXh0cmVtaXRpZXNSZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuZXh0cmVtaXRpZXMsXG4gICAgICAgICAgZW1iZWRTZXR0aW5ncyA9IHNlbGYuc2V0dGluZ3MuZW1iZWRPYmplY3RzKHtcbiAgICAgICAgICAgIHByZWZpeDogcHJlZml4XG4gICAgICAgICAgfSk7XG5cbiAgICAgIC8vIENsZWFyIHNlbGYuY29udGV4dHMuaG92ZXI6XG4gICAgICBzZWxmLmNvbnRleHRzLmhvdmVyLmNsZWFyUmVjdCgwLCAwLCBjLndpZHRoLCBjLmhlaWdodCk7XG5cbiAgICAgIC8vIE5vZGUgcmVuZGVyOiBzaW5nbGUgaG92ZXJcbiAgICAgIGlmIChcbiAgICAgICAgZW1iZWRTZXR0aW5ncygnZW5hYmxlSG92ZXJpbmcnKSAmJlxuICAgICAgICBlbWJlZFNldHRpbmdzKCdzaW5nbGVIb3ZlcicpICYmXG4gICAgICAgIE9iamVjdC5rZXlzKGhvdmVyZWROb2RlcykubGVuZ3RoXG4gICAgICApIHtcbiAgICAgICAgaG92ZXJlZE5vZGUgPSBob3ZlcmVkTm9kZXNbT2JqZWN0LmtleXMoaG92ZXJlZE5vZGVzKVswXV07XG4gICAgICAgIChcbiAgICAgICAgICBub2RlUmVuZGVyZXJzW2hvdmVyZWROb2RlLnR5cGVdIHx8XG4gICAgICAgICAgbm9kZVJlbmRlcmVyc1tkZWZhdWx0Tm9kZVR5cGVdIHx8XG4gICAgICAgICAgbm9kZVJlbmRlcmVycy5kZWZcbiAgICAgICAgKShcbiAgICAgICAgICBob3ZlcmVkTm9kZSxcbiAgICAgICAgICBzZWxmLmNvbnRleHRzLmhvdmVyLFxuICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm9kZSByZW5kZXI6IG11bHRpcGxlIGhvdmVyXG4gICAgICBpZiAoXG4gICAgICAgIGVtYmVkU2V0dGluZ3MoJ2VuYWJsZUhvdmVyaW5nJykgJiZcbiAgICAgICAgIWVtYmVkU2V0dGluZ3MoJ3NpbmdsZUhvdmVyJylcbiAgICAgIClcbiAgICAgICAgZm9yIChrIGluIGhvdmVyZWROb2RlcylcbiAgICAgICAgICAoXG4gICAgICAgICAgICBub2RlUmVuZGVyZXJzW2hvdmVyZWROb2Rlc1trXS50eXBlXSB8fFxuICAgICAgICAgICAgbm9kZVJlbmRlcmVyc1tkZWZhdWx0Tm9kZVR5cGVdIHx8XG4gICAgICAgICAgICBub2RlUmVuZGVyZXJzLmRlZlxuICAgICAgICAgICkoXG4gICAgICAgICAgICBob3ZlcmVkTm9kZXNba10sXG4gICAgICAgICAgICBzZWxmLmNvbnRleHRzLmhvdmVyLFxuICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICk7XG5cbiAgICAgIC8vIEVkZ2UgcmVuZGVyOiBzaW5nbGUgaG92ZXJcbiAgICAgIGlmIChcbiAgICAgICAgZW1iZWRTZXR0aW5ncygnZW5hYmxlRWRnZUhvdmVyaW5nJykgJiZcbiAgICAgICAgZW1iZWRTZXR0aW5ncygnc2luZ2xlSG92ZXInKSAmJlxuICAgICAgICBPYmplY3Qua2V5cyhob3ZlcmVkRWRnZXMpLmxlbmd0aFxuICAgICAgKSB7XG4gICAgICAgIGhvdmVyZWRFZGdlID0gaG92ZXJlZEVkZ2VzW09iamVjdC5rZXlzKGhvdmVyZWRFZGdlcylbMF1dO1xuICAgICAgICBzb3VyY2UgPSBzZWxmLmdyYXBoLm5vZGVzKGhvdmVyZWRFZGdlLnNvdXJjZSk7XG4gICAgICAgIHRhcmdldCA9IHNlbGYuZ3JhcGgubm9kZXMoaG92ZXJlZEVkZ2UudGFyZ2V0KTtcblxuICAgICAgICBpZiAoISBob3ZlcmVkRWRnZS5oaWRkZW4pIHtcbiAgICAgICAgICAoXG4gICAgICAgICAgICBlZGdlUmVuZGVyZXJzW2hvdmVyZWRFZGdlLnR5cGVdIHx8XG4gICAgICAgICAgICBlZGdlUmVuZGVyZXJzW2RlZmF1bHRFZGdlVHlwZV0gfHxcbiAgICAgICAgICAgIGVkZ2VSZW5kZXJlcnMuZGVmXG4gICAgICAgICAgKSAoXG4gICAgICAgICAgICBob3ZlcmVkRWRnZSxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChlbWJlZFNldHRpbmdzKCdlZGdlSG92ZXJFeHRyZW1pdGllcycpKSB7XG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIGV4dHJlbWl0aWVzUmVuZGVyZXJzW2hvdmVyZWRFZGdlLnR5cGVdIHx8XG4gICAgICAgICAgICAgIGV4dHJlbWl0aWVzUmVuZGVyZXJzLmRlZlxuICAgICAgICAgICAgKShcbiAgICAgICAgICAgICAgaG92ZXJlZEVkZ2UsXG4gICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICBzZWxmLmNvbnRleHRzLmhvdmVyLFxuICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEF2b2lkIGVkZ2VzIHJlbmRlcmVkIG92ZXIgbm9kZXM6XG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlc1tzb3VyY2UudHlwZV0gfHxcbiAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzLmRlZlxuICAgICAgICAgICAgKSAoXG4gICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzW3RhcmdldC50eXBlXSB8fFxuICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXMuZGVmXG4gICAgICAgICAgICApIChcbiAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICBzZWxmLmNvbnRleHRzLmhvdmVyLFxuICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBFZGdlIHJlbmRlcjogbXVsdGlwbGUgaG92ZXJcbiAgICAgIGlmIChcbiAgICAgICAgZW1iZWRTZXR0aW5ncygnZW5hYmxlRWRnZUhvdmVyaW5nJykgJiZcbiAgICAgICAgIWVtYmVkU2V0dGluZ3MoJ3NpbmdsZUhvdmVyJylcbiAgICAgICkge1xuICAgICAgICBmb3IgKGsgaW4gaG92ZXJlZEVkZ2VzKSB7XG4gICAgICAgICAgaG92ZXJlZEVkZ2UgPSBob3ZlcmVkRWRnZXNba107XG4gICAgICAgICAgc291cmNlID0gc2VsZi5ncmFwaC5ub2Rlcyhob3ZlcmVkRWRnZS5zb3VyY2UpO1xuICAgICAgICAgIHRhcmdldCA9IHNlbGYuZ3JhcGgubm9kZXMoaG92ZXJlZEVkZ2UudGFyZ2V0KTtcblxuICAgICAgICAgIGlmICghaG92ZXJlZEVkZ2UuaGlkZGVuKSB7XG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIGVkZ2VSZW5kZXJlcnNbaG92ZXJlZEVkZ2UudHlwZV0gfHxcbiAgICAgICAgICAgICAgZWRnZVJlbmRlcmVyc1tkZWZhdWx0RWRnZVR5cGVdIHx8XG4gICAgICAgICAgICAgIGVkZ2VSZW5kZXJlcnMuZGVmXG4gICAgICAgICAgICApIChcbiAgICAgICAgICAgICAgaG92ZXJlZEVkZ2UsXG4gICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICBzZWxmLmNvbnRleHRzLmhvdmVyLFxuICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoZW1iZWRTZXR0aW5ncygnZWRnZUhvdmVyRXh0cmVtaXRpZXMnKSkge1xuICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgZXh0cmVtaXRpZXNSZW5kZXJlcnNbaG92ZXJlZEVkZ2UudHlwZV0gfHxcbiAgICAgICAgICAgICAgICBleHRyZW1pdGllc1JlbmRlcmVycy5kZWZcbiAgICAgICAgICAgICAgKShcbiAgICAgICAgICAgICAgICBob3ZlcmVkRWRnZSxcbiAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gQXZvaWQgZWRnZXMgcmVuZGVyZWQgb3ZlciBub2RlczpcbiAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlc1tzb3VyY2UudHlwZV0gfHxcbiAgICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXMuZGVmXG4gICAgICAgICAgICAgICkgKFxuICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICBzZWxmLmNvbnRleHRzLmhvdmVyLFxuICAgICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlc1t0YXJnZXQudHlwZV0gfHxcbiAgICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXMuZGVmXG4gICAgICAgICAgICAgICkgKFxuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBzZWxmLmNvbnRleHRzLmhvdmVyLFxuICAgICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuIiwiIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgdDt0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcyx0LlRRR3JhbVVJPWUoKX19KGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4sbyl7ZnVuY3Rpb24gaShsLGEpe2lmKCFuW2xdKXtpZighdFtsXSl7dmFyIHM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighYSYmcylyZXR1cm4gcyhsLCEwKTtpZihyKXJldHVybiByKGwsITApO3ZhciB1PW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbCtcIidcIik7dGhyb3cgdS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLHV9dmFyIGQ9bltsXT17ZXhwb3J0czp7fX07dFtsXVswXS5jYWxsKGQuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W2xdWzFdW2VdO3JldHVybiBpKG4/bjplKX0sZCxkLmV4cG9ydHMsZSx0LG4sbyl9cmV0dXJuIG5bbF0uZXhwb3J0c31mb3IodmFyIHI9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxsPTA7bDxvLmxlbmd0aDtsKyspaShvW2xdKTtyZXR1cm4gaX1yZXR1cm4gZX0oKSh7MTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7ZnVuY3Rpb24gdCgpe3Iucm9vdEh0bWwuaW5uZXJIVE1MPVwiXCIsci5yb290SHRtbC5zdHlsZS5ib3JkZXJUb3A9MCE9PXIuYnV0dG9ucy5sZW5ndGg/XCIxcHggc29saWQgI2NjY2NjY1wiOm51bGwsci5yb290SHRtbC5zdHlsZS5ib3JkZXJCb3R0b209MCE9PXIuYnV0dG9ucy5sZW5ndGg/XCIxcHggc29saWQgI2NjY2NjY1wiOm51bGwsci5idXR0b25zLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkJVVFRPTlwiKTt0LnRpdGxlPWUubGFiZWwsdC5jbGFzc05hbWU9XCJ0cS11aS10b29sYmFyX19idXR0b24gdHEtdWktY29sb3JlZC1idXR0b25cIix0LmlubmVySFRNTD0nPHNwYW4gc3R5bGU9XCJjb2xvcjogJytlLmJvcmRlckNvbG9yKydcIj4nK24oZS5sYWJlbCkrXCI8L3NwYW4+XCIsdC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9ZS5iYWNrZ3JvdW5kQ29sb3J8fFwid2hpdGVcIix0LnN0eWxlLmJvcmRlckNvbG9yPWUuYm9yZGVyQ29sb3J8fFwiYmxhY2tcIix0Lm9uY2xpY2s9ZnVuY3Rpb24odCl7ZS5jYWxsYmFjayhlLHQpfSxyLnJvb3RIdG1sLmFwcGVuZENoaWxkKHQpfSl9ZnVuY3Rpb24gbihlKXtpZihlKXt2YXIgdD1lLm1hdGNoKC9bYS16J1xcLV0rL2dpKTtyZXR1cm4gdC5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuXCJhbmRcIiE9PWUudG9Mb3dlckNhc2UoKSYmXCImXCIhPT1lfSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlWzBdfSkuam9pbihcIlwiKX19ZnVuY3Rpb24gbygpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7cmV0dXJuIGUuY2xhc3NOYW1lPVwidHEtdWktY29sb3JlZC1idXR0b25zLWxpc3RcIixlLmlubmVySFRNTD1cIlwiLGV9dmFyIHI9dGhpcztlfHwoZT17fSksci5yb290SHRtbD1vKCksci5pZD1lLmlkfHxcImNvbG9yZWRCdXR0b25zLVwiK2krKyxyLnJvb3RIdG1sLmlkPXIuaWQsci5idXR0b25zPWUuYnV0dG9uc3x8W10sdCgpLHIucmVtb3ZlQWxsPWZ1bmN0aW9uKCl7ci5idXR0b25zPVtdLHQoKX0sci5hZGRCdXR0b249ZnVuY3Rpb24oZSl7ci5idXR0b25zLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZH0pLmluZGV4T2YoZS5pZCk9PT0tMSYmKHIuYnV0dG9ucy5wdXNoKGUpLHQoKSl9LHIucmVtb3ZlQnV0dG9uPWZ1bmN0aW9uKGUpe3IuYnV0dG9ucy5zcGxpY2Uoci5idXR0b25zLmluZGV4T2YoZSksMSksdCgpfX1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLkNvbG9yZWRCdXR0b25zTGlzdD1vO3ZhciBpPTA7bltcImRlZmF1bHRcIl09b30se31dLDI6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gaShlKXtmdW5jdGlvbiB0KCl7aWYoZS5ib2R5IGluc3RhbmNlb2YgT2JqZWN0KXt2YXIgdD1pLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIudHEtdWktYm9keV9jb250YWluZXJcIik7dC5hcHBlbmRDaGlsZChlLmJvZHkucm9vdEh0bWwpfXZhciBhPWkucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIi50cS11aS1mbHlpbmctcGFuZWxfaGVhZGVyXCIpO2EuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLG8pO3ZhciBzPWkucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIi50cS11aS13aW5kb3dzLWNvbGxhcHNlLWJ1dHRvblwiKTtpZihzLm9uY2xpY2s9aS5oaWRlLGUucmVzaXphYmxlKXt2YXIgdT1pLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIudHEtdWktZmx5aW5nLXBhbmVsX19ib3JkZXIudHEtdWktdG9wLWJvcmRlclwiKTt1LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixmdW5jdGlvbihlKXtvKGUsXCJuXCIpfSk7dmFyIGQ9aS5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiLnRxLXVpLWZseWluZy1wYW5lbF9fYm9yZGVyLnRxLXVpLXJpZ2h0LWJvcmRlclwiKTtkLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixmdW5jdGlvbihlKXtvKGUsXCJlXCIpfSk7dmFyIGM9aS5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiLnRxLXVpLWZseWluZy1wYW5lbF9fYm9yZGVyLnRxLXVpLWJvdHRvbS1ib3JkZXJcIik7Yy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsZnVuY3Rpb24oZSl7byhlLFwic1wiKX0pO3ZhciBmPWkucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIi50cS11aS1mbHlpbmctcGFuZWxfX2JvcmRlci50cS11aS1sZWZ0LWJvcmRlclwiKTtmLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixmdW5jdGlvbihlKXtvKGUsXCJ3XCIpfSk7dmFyIHA9aS5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiLnRxLXVpLWZseWluZy1wYW5lbF9fYm9yZGVyLnRxLXVpLXRvcC1yaWdodC1ib3JkZXJcIik7cC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsZnVuY3Rpb24oZSl7byhlLFwibmVcIil9KTt2YXIgYj1pLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIudHEtdWktZmx5aW5nLXBhbmVsX19ib3JkZXIudHEtdWktdG9wLWxlZnQtYm9yZGVyXCIpO2IuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGZ1bmN0aW9uKGUpe28oZSxcIm53XCIpfSk7dmFyIG09aS5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiLnRxLXVpLWZseWluZy1wYW5lbF9fYm9yZGVyLnRxLXVpLWJvdHRvbS1yaWdodC1ib3JkZXJcIik7bS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsZnVuY3Rpb24oZSl7byhlLFwic2VcIil9KTt2YXIgeT1pLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIudHEtdWktZmx5aW5nLXBhbmVsX19ib3JkZXIudHEtdWktYm90dG9tLWxlZnQtYm9yZGVyXCIpO3kuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGZ1bmN0aW9uKGUpe28oZSxcInN3XCIpfSl9aS5fdHJpZ2dlckJ1dHRvbj1yKGUudHJpZ2dlckJ1dHRvbiksbigpLGkuX3RyaWdnZXJCdXR0b24mJihpLl90cmlnZ2VyQnV0dG9uLm9uY2xpY2s9ZnVuY3Rpb24oKXtsP2kuc2hvdygpOmkuaGlkZSgpfSl9ZnVuY3Rpb24gbigpe2w/KGkuX3RyaWdnZXJCdXR0b24mJihpLl90cmlnZ2VyQnV0dG9uLmNsYXNzTmFtZT1pLl90cmlnZ2VyQnV0dG9uLmNsYXNzTmFtZS5yZXBsYWNlKC8gdHEtdWktc2VsZWN0ZWQvZ2ksXCJcIikpLGkucm9vdEh0bWwuY2xhc3NOYW1lPWkucm9vdEh0bWwuY2xhc3NOYW1lK1wiIHRxLXVpLWNvbGxhcHNlZFwiKTooaS5fdHJpZ2dlckJ1dHRvbiYmKGkuX3RyaWdnZXJCdXR0b24uY2xhc3NOYW1lPWkuX3RyaWdnZXJCdXR0b24uY2xhc3NOYW1lK1wiIHRxLXVpLXNlbGVjdGVkXCIpLGkucm9vdEh0bWwuY2xhc3NOYW1lPWkucm9vdEh0bWwuY2xhc3NOYW1lLnJlcGxhY2UoLyB0cS11aS1jb2xsYXBzZWQvZ2ksXCJcIikpfWZ1bmN0aW9uIG8oZSx0KXtmdW5jdGlvbiBuKGUpe2kuX21vdXNlTW92ZT0hMDt2YXIgbj0wO2UucGFnZVg/bj1lLnBhZ2VYOmUuY2xpZW50WCYmKG49ZS5jbGllbnRYKTt2YXIgbz1uLWw7bD1uLHR8fChpLnJvb3RIdG1sLnN0eWxlLmxlZnQ9aS5yb290SHRtbC5vZmZzZXRMZWZ0K28rXCJweFwiKTt2YXIgcz0wO2UucGFnZVk/cz1lLnBhZ2VZOmUuY2xpZW50WSYmKHM9ZS5jbGllbnRZKTt2YXIgdT1zLWE7YT1zLHR8fChpLnJvb3RIdG1sLnN0eWxlLnRvcD1pLnJvb3RIdG1sLm9mZnNldFRvcCt1K1wicHhcIiksdD8ocihvLHUsdCksaS50cmlnZ2VyKFwic2l6ZS1jaGFuZ2VkXCIse3dpZHRoOmkucm9vdEh0bWwub2Zmc2V0V2lkdGgsaGVpZ2h0Omkucm9vdEh0bWwub2Zmc2V0SGVpZ2h0fSksdC5pbmRleE9mKFwiblwiKT09PS0xJiZ0LmluZGV4T2YoXCJ3XCIpPT09LTF8fGkudHJpZ2dlcihcInBvc2l0aW9uLWNoYW5nZWRcIix7eDppLnJvb3RIdG1sLm9mZnNldExlZnQseTppLnJvb3RIdG1sLm9mZnNldFRvcH0pKTppLnRyaWdnZXIoXCJwb3NpdGlvbi1jaGFuZ2VkXCIse3g6aS5yb290SHRtbC5vZmZzZXRMZWZ0LHk6aS5yb290SHRtbC5vZmZzZXRUb3B9KX1mdW5jdGlvbiBvKGUpe2kuX21vdXNlTW92ZSYmKG4oZSwhMCksaS5fbW91c2VNb3ZlPSExKSxkb2N1bWVudC5ib2R5Lm9ubW91c2Vtb3ZlPWRvY3VtZW50LmJvZHkub25tb3VzZXVwPW51bGwsZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsbiksZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLG8pfWZ1bmN0aW9uIHIoZSx0LG4pe3N3aXRjaChuKXtjYXNlXCJuXCI6aS5yb290SHRtbC5zdHlsZS5oZWlnaHQ9aS5yb290SHRtbC5vZmZzZXRIZWlnaHQtdCtcInB4XCIsaS5yb290SHRtbC5zdHlsZS50b3A9aS5yb290SHRtbC5vZmZzZXRUb3ArdCtcInB4XCI7YnJlYWs7Y2FzZVwiZVwiOmkucm9vdEh0bWwuc3R5bGUud2lkdGg9aS5yb290SHRtbC5vZmZzZXRXaWR0aCtlK1wicHhcIjticmVhaztjYXNlXCJzXCI6aS5yb290SHRtbC5zdHlsZS5oZWlnaHQ9aS5yb290SHRtbC5vZmZzZXRIZWlnaHQrdCtcInB4XCI7YnJlYWs7Y2FzZVwid1wiOmkucm9vdEh0bWwuc3R5bGUud2lkdGg9aS5yb290SHRtbC5vZmZzZXRXaWR0aC1lK1wicHhcIixpLnJvb3RIdG1sLnN0eWxlLmxlZnQ9aS5yb290SHRtbC5vZmZzZXRMZWZ0K2UrXCJweFwiO2JyZWFrO2Nhc2VcIm5lXCI6aS5yb290SHRtbC5zdHlsZS53aWR0aD1pLnJvb3RIdG1sLm9mZnNldFdpZHRoK2UrXCJweFwiLGkucm9vdEh0bWwuc3R5bGUuaGVpZ2h0PWkucm9vdEh0bWwub2Zmc2V0SGVpZ2h0LXQrXCJweFwiLGkucm9vdEh0bWwuc3R5bGUudG9wPWkucm9vdEh0bWwub2Zmc2V0VG9wK3QrXCJweFwiO2JyZWFrO2Nhc2VcIm53XCI6aS5yb290SHRtbC5zdHlsZS5oZWlnaHQ9aS5yb290SHRtbC5vZmZzZXRIZWlnaHQtdCtcInB4XCIsaS5yb290SHRtbC5zdHlsZS50b3A9aS5yb290SHRtbC5vZmZzZXRUb3ArdCtcInB4XCIsaS5yb290SHRtbC5zdHlsZS53aWR0aD1pLnJvb3RIdG1sLm9mZnNldFdpZHRoLWUrXCJweFwiLGkucm9vdEh0bWwuc3R5bGUubGVmdD1pLnJvb3RIdG1sLm9mZnNldExlZnQrZStcInB4XCI7YnJlYWs7Y2FzZVwic2VcIjppLnJvb3RIdG1sLnN0eWxlLndpZHRoPWkucm9vdEh0bWwub2Zmc2V0V2lkdGgrZStcInB4XCIsaS5yb290SHRtbC5zdHlsZS5oZWlnaHQ9aS5yb290SHRtbC5vZmZzZXRIZWlnaHQrdCtcInB4XCI7YnJlYWs7Y2FzZVwic3dcIjppLnJvb3RIdG1sLnN0eWxlLmhlaWdodD1pLnJvb3RIdG1sLm9mZnNldEhlaWdodCt0K1wicHhcIixpLnJvb3RIdG1sLnN0eWxlLndpZHRoPWkucm9vdEh0bWwub2Zmc2V0V2lkdGgtZStcInB4XCIsaS5yb290SHRtbC5zdHlsZS5sZWZ0PWkucm9vdEh0bWwub2Zmc2V0TGVmdCtlK1wicHhcIn19dmFyIGw9MCxhPTA7ZS5wYWdlWD9sPWUucGFnZVg6ZS5jbGllbnRYJiYobD1lLmNsaWVudFgpLGUucGFnZVk/YT1lLnBhZ2VZOmUuY2xpZW50WSYmKGE9ZS5jbGllbnRZKSx3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCksZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsbiksZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLG8pfXNbXCJkZWZhdWx0XCJdLmFwcGx5KHRoaXMpO3ZhciBpPXRoaXM7ZXx8KGU9e30pO3ZhciBsPSFlLmFjdGl2ZTtpLm1hcmt1cD0nXFxuICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktZmx5aW5nLXBhbmVsXCJcXG4gICAgICAgICAgICBzdHlsZT1cIlxcbiAgICAgICAgICAgICAgICB3aWR0aDogJysoZS5zaXplP2Uuc2l6ZS53aWR0aDpcIlwiKStcIjtcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcIisoZS5zaXplP2Uuc2l6ZS5oZWlnaHQ6XCJcIikrXCI7XFxuICAgICAgICAgICAgICAgIGxlZnQ6IFwiKyhlLnBvc2l0aW9uP2UucG9zaXRpb24ueDpcIlwiKStcIjtcXG4gICAgICAgICAgICAgICAgdG9wOiBcIisoZS5wb3NpdGlvbj9lLnBvc2l0aW9uLnk6XCJcIikrJztcXG4gICAgICAgICAgICBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1mbHlpbmctcGFuZWxfaGVhZGVyXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1mbHlpbmctcGFuZWxfaGVhZGVyX19oZWFkZXJcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInRxLXVpLXdpbmRvdy1oZWFkZXItbGFiZWxcIj4nKyhlLmhlYWRlcj9lLmhlYWRlcjpcIlwiKSsnPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XCJ0cS11aS13aW5kb3dzLWNvbGxhcHNlLWJ1dHRvblwiLz5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWJvZHlcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWJvZHlfY29udGFpbmVyICcrKGUucmVtb3ZlQmFja2dyb3VuZD9cInRxLXVpLWJvZHlfZW1wdHktY29udGFpbmVyXCI6XCJ0cS11aS1ib2R5X2RlZmF1bHQtY29udGFpbmVyXCIpKydcIj5cXG4gICAgICAgICAgICAgICAgICAgICcrKGUuYm9keSYmXCJzdHJpbmdcIj09dHlwZW9mIGUuYm9keT9lLmJvZHk6XCJcIikrXCJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgXCIrKGUucmVzaXphYmxlPydcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWZseWluZy1wYW5lbF9fYm9yZGVyIHRxLXVpLXRvcC1ib3JkZXJcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWZseWluZy1wYW5lbF9fYm9yZGVyIHRxLXVpLXJpZ2h0LWJvcmRlclwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktZmx5aW5nLXBhbmVsX19ib3JkZXIgdHEtdWktYm90dG9tLWJvcmRlclwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktZmx5aW5nLXBhbmVsX19ib3JkZXIgdHEtdWktbGVmdC1ib3JkZXJcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWZseWluZy1wYW5lbF9fYm9yZGVyIHRxLXVpLXRvcC1sZWZ0LWJvcmRlclwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktZmx5aW5nLXBhbmVsX19ib3JkZXIgdHEtdWktdG9wLXJpZ2h0LWJvcmRlclwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktZmx5aW5nLXBhbmVsX19ib3JkZXIgdHEtdWktYm90dG9tLWxlZnQtYm9yZGVyXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1mbHlpbmctcGFuZWxfX2JvcmRlciB0cS11aS1ib3R0b20tcmlnaHQtYm9yZGVyXCI+PC9kaXY+XFxuICAgICAgICAgICAgJzpcIlwiKStcIlxcbiAgICAgICAgPC9kaXY+XCI7dmFyIGE9cihlLmJhc2VFbGVtZW50KTthLmlubmVySFRNTD1pLm1hcmt1cCxpLnJvb3RIdG1sPWEucXVlcnlTZWxlY3RvcihcIi50cS11aS1mbHlpbmctcGFuZWxcIiksaS5pZD1lLmlkfHxcImZseWluZ1BhbmVsLVwiK3UrKyxpLnJvb3RIdG1sLmlkPWkuaWQsaS5zaG93PWZ1bmN0aW9uKGUpe2UmJmUuc3RvcFByb3BhZ2F0aW9uKCksbCYmKGw9ITEsbigpKX0saS5oaWRlPWZ1bmN0aW9uKGUpe2UmJmUuc3RvcFByb3BhZ2F0aW9uKCksbHx8KGw9ITAsbigpKX0sdCgpfWZ1bmN0aW9uIHIoZSl7dmFyIHQ9dm9pZCAwO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlP3Q9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZSk6XCJvYmplY3RcIj09PShcInVuZGVmaW5lZFwiPT10eXBlb2YgZT9cInVuZGVmaW5lZFwiOmwoZSkpJiYodD1lKSx0fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBsPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9O24uRmx5aW5nUGFuZWw9aTt2YXIgYT1lKFwiLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZVwiKSxzPW8oYSksdT0wO25bXCJkZWZhdWx0XCJdPWl9LHtcIi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGVcIjo4fV0sMzpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBpKGUpe2Z1bmN0aW9uIHQoZSl7ZnVuY3Rpb24gdChlKXt2YXIgdD1lLmxhYmVsLG49ZS5sYWJlbCtcIiAoXCIrZS5pZCtcIilcIixvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJMSVwiKTtyZXR1cm4gby5jbGFzc05hbWU9XCJ0cS11aS1wcm9wZXJ0eS1idXR0b25cIixvLnRpdGxlPW4sby5pbm5lclRleHQ9dCxvLm9uY2xpY2s9ZnVuY3Rpb24oKXtpLnRyaWdnZXIoXCJzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWRcIixlLmlkKX0sb312YXIgbj1pLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIjcmVsYXRlZEVsZW1lbnRzXCIpO24uaW5uZXJIVE1MPVwiXCI7dmFyIG89ZS5pbmNvbWluZ3N8fFtdO2lmKG8ubGVuZ3RoKXt2YXIgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiTEFCRUxcIik7ci5jbGFzc05hbWU9XCJ0cS1sYWJlbFwiLHIuaW5uZXJUZXh0PVwiSW5jb21pbmcgbm9kZXM6XCIsbi5hcHBlbmRDaGlsZChyKTt2YXIgbD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiVUxcIik7bC5jbGFzc05hbWU9XCJ0cS11aS1pbmZvLXBhbmVsX3JlbGF0ZWQtZWxlbWVudHNfbGlzdFwiLG4uYXBwZW5kQ2hpbGQobCksby5mb3JFYWNoKGZ1bmN0aW9uKGUpe2wuYXBwZW5kQ2hpbGQodChlKSl9KX12YXIgYT1lLm91dGdvaW5nc3x8W107aWYoYS5sZW5ndGgpe3ZhciBzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJMQUJFTFwiKTtzLmNsYXNzTmFtZT1cInRxLWxhYmVsXCIscy5pbm5lclRleHQ9XCJPdXRnb2luZyBub2RlczpcIixuLmFwcGVuZENoaWxkKHMpO3ZhciB1PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJVTFwiKTt1LmNsYXNzTmFtZT1cInRxLXVpLWluZm8tcGFuZWxfcmVsYXRlZC1lbGVtZW50c19saXN0XCIsbi5hcHBlbmRDaGlsZCh1KSxhLmZvckVhY2goZnVuY3Rpb24oZSl7dS5hcHBlbmRDaGlsZCh0KGUpKX0pfX1mdW5jdGlvbiBuKGUpe3ZhciB0PVwiXCI7cmV0dXJuIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24obil7dCs9JzxsYWJlbCBmb3I9XCInK24rJ1wiIGNsYXNzPVwidHEtbGFiZWxcIj4nK24rJzwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGlkPVwiJytuKydcIiB0eXBlPVwidGV4dFwiIGNsYXNzPVwidHEtdWktcHJvcGVydHlcIiB2YWx1ZT1cIicrZVtuXSsnXCIgZGlzYWJsZWQ+PC9pbnB1dD4nfSksdH1mdW5jdGlvbiBvKCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtyZXR1cm4gZS5jbGFzc05hbWU9XCJ0cS11aS1pbmZvLXBhbmVsXCIsZS5pbm5lckhUTUw9aS5tYXJrdXAsZX1sW1wiZGVmYXVsdFwiXS5hcHBseSh0aGlzKSxlfHwoZT17fSk7dmFyIGk9dGhpcyxyPWUucGxhY2Vob2xkZXJ8fFwiU2VsZWN0IGEgZGlhZ3JhbSBlbGVtZW50XCIscz0nPGRpdiBjbGFzcz1cInRxLXVpLWluZm8tcGFuZWxfZW1wdHktc3R1ZmZcIj4nK3IrXCI8L2Rpdj5cIjtpLnJvb3RIdG1sPW8oKSxpLnJvb3RIdG1sLmlubmVySFRNTD1zLGkuaWQ9ZS5pZHx8XCJpbmZvUGFuZWwtXCIrYSsrLGkucm9vdEh0bWwuaWQ9aS5pZCxpLnNldFNlbGVjdGVkRWxlbWVudD1mdW5jdGlvbihvKXtpZihvKXtpZihpLnJvb3RIdG1sLmlubmVySFRNTD1cIlwiKyhlLmxhdW5jaEV4dGVybmFsJiZcIm5vZGVcIj09PW8uZGlhZ3JhbVR5cGU/JzxkaXYgY2xhc3M9XCJ0cS11aS1ncm91cFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGlkPVwidHFMYXVuY2hFeHRlcm5hbEJ0blwiIGNsYXNzPVwidHEtYnV0dG9uXCIgdGl0bGU9XCJWaWV3IG1vcmUgaW4gbmV3IHRhYi5cIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICBNb3JlICZuYnNwO1xcbiAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tbmV3LXdpbmRvd1wiPjwvc3Bhbj48L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICA8L2Rpdj4nOlwiXCIpKyhvLmlkPydcXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInRxLWxhYmVsXCI+SUQ8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHZhbHVlPVwiJytvLmlkKydcIiB0eXBlPVwidGV4dFwiIGNsYXNzPVwidHEtdWktcHJvcGVydHlcIiBkaXNhYmxlZD48L2lucHV0PlxcbiAgICAgICAgICAgICAgICAnOlwiXCIpKyhvLmxhYmVsPydcXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInRxLWxhYmVsXCI+TGFiZWw8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHZhbHVlPVwiJytvLmxhYmVsKydcIiB0eXBlPVwidGV4dFwiIGNsYXNzPVwidHEtdWktcHJvcGVydHlcIiBkaXNhYmxlZD48L2lucHV0PlxcbiAgICAgICAgICAgICAgICAnOlwiXCIpKyhvLnR5cGVzPydcXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInRxLWxhYmVsXCI+VHlwZXM8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHZhbHVlPVwiJytvLnR5cGVzKydcIiB0eXBlPVwidGV4dFwiIGNsYXNzPVwidHEtdWktcHJvcGVydHlcIiBkaXNhYmxlZD48L2lucHV0PlxcbiAgICAgICAgICAgICAgICAnOlwiXCIpKyhvLnNvdXJjZT8nXFxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwibGlua0Zyb21cIiBjbGFzcz1cInRxLWxhYmVsXCI+U291cmNlPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJsaW5rRnJvbVwiIHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJ0cS11aS1wcm9wZXJ0eS1idXR0b25cIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgJzpcIlwiKSsoby50YXJnZXQ/J1xcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImxpbmtUb1wiIGNsYXNzPVwidHEtbGFiZWxcIj5UYXJnZXQ8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImxpbmtUb1wiIHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJ0cS11aS1wcm9wZXJ0eS1idXR0b25cIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgJzpcIlwiKSsoby50aGlja25lc3M/J1xcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cInRoaWNrbmVzc1wiIGNsYXNzPVwidHEtbGFiZWxcIj5UaGlja25lc3M8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHZhbHVlPVwiJytvLnRoaWNrbmVzcysnXCIgdHlwZT1cInRleHRcIiBjbGFzcz1cInRxLXVpLXByb3BlcnR5XCIgZGlzYWJsZWQ+PC9pbnB1dD5cXG4gICAgICAgICAgICAgICAgJzpcIlwiKSsoby5kYXRhP24oby5kYXRhKTpcIlwiKSsoby5yZWxhdGlvbnM/J1xcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cInJlbGF0ZWRFbGVtZW50c1wiIGNsYXNzPVwidHEtbGFiZWxcIj5SZWxhdGVkIGVsZW1lbnRzPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgICBpZD1cInJlbGF0ZWRFbGVtZW50c1wiIGNsYXNzPVwidHEtdWktaW5mby1wYW5lbF9yZWxhdGVkLWVsZW1lbnRzXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICc6XCJcIiksZS5sYXVuY2hFeHRlcm5hbCYmXCJub2RlXCI9PT1vLmRpYWdyYW1UeXBlKXt2YXIgcj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRxTGF1bmNoRXh0ZXJuYWxCdG5cIik7ci5vbmNsaWNrPWZ1bmN0aW9uKCl7ZS5sYXVuY2hFeHRlcm5hbChvKX19aWYoby5yZWxhdGlvbnMmJnQoby5yZWxhdGlvbnMpLG8uc291cmNlKXt2YXIgbD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxpbmtGcm9tXCIpO2wuaW5uZXJUZXh0PW8uc291cmNlLmxhYmVsLGwudGl0bGU9by5zb3VyY2UubGFiZWwrXCIoSUQ6IFwiK28uc291cmNlLmlkK1wiKVwiLGwub25jbGljaz1mdW5jdGlvbigpe2kudHJpZ2dlcihcInNlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZFwiLG8uc291cmNlLmlkKX19aWYoby50YXJnZXQpe3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGlua1RvXCIpO2EuaW5uZXJUZXh0PW8udGFyZ2V0LmxhYmVsLGEudGl0bGU9by50YXJnZXQubGFiZWwrXCIoSUQ6IFwiK28udGFyZ2V0LmlkK1wiKVwiLGEub25jbGljaz1mdW5jdGlvbigpe2kudHJpZ2dlcihcInNlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZFwiLG8udGFyZ2V0LmlkKX19fWVsc2UgaS5yb290SHRtbC5pbm5lckhUTUw9c30sZS5zZWxlY3RlZEVsZW1lbnQmJmkuc2V0U2VsZWN0ZWRFbGVtZW50KGUuc2VsZWN0ZWRFbGVtZW50KX1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLkluZm9QYW5lbD1pO3ZhciByPWUoXCIuL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlXCIpLGw9byhyKSxhPTA7bltcImRlZmF1bHRcIl09aX0se1wiLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZVwiOjh9XSw0OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtmdW5jdGlvbiB0KCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtyZXR1cm4gZS5pbm5lckhUTUw9bi5tYXJrdXAsZS5xdWVyeVNlbGVjdG9yKFwiLnRxLXVpLWxlZ2VuZC1wYW5lbF9ib2R5X2xlZ2VuZHNcIil9dmFyIG49dGhpcztlfHwoZT17fSk7dmFyIG89ZS5sZWdlbmRzfHxbXTtuLm1hcmt1cD0nXFxuICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktbGVnZW5kLXBhbmVsX2JvZHlfbGVnZW5kc1wiPlxcbiAgICAgICAgJytvLm1hcChmdW5jdGlvbihlKXtyZXR1cm4nXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1sZWdlbmQtcGFuZWxfYm9keV9sZWdlbmRzX2xlZ2VuZFwiIHRpdGxlPVwiJytlLmRlc2NyaXB0aW9uKydcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1sZWdlbmQtcGFuZWxfYm9keV9sZWdlbmRzX2xlZ2VuZF9pbWdcIj48aW1nIHNyYz1cIicrZS5pbWFnZSsnXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0cS1sYWJlbFwiPicrZS5sYWJlbCtcIjwvbGFiZWw+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIFwifSkuam9pbihcIlwiKStcIlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiLG4ucm9vdEh0bWw9dCgpLG4uaWQ9ZS5pZHx8XCJsZWdlbmRzLVwiK2krKyxuLnJvb3RIdG1sLmlkPW4uaWR9T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5MZWdlbmRzPW87dmFyIGk9MDtuW1wiZGVmYXVsdFwiXT1vfSx7fV0sNTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX12YXIgaT1lKFwiLi9jb2xvcmVkQnV0dG9uc0xpc3RcIikscj1vKGkpLGw9ZShcIi4vZmx5aW5nUGFuZWxcIiksYT1vKGwpLHM9ZShcIi4vaW5mb1BhbmVsXCIpLHU9byhzKSxkPWUoXCIuL2xlZ2VuZHNcIiksYz1vKGQpLGY9ZShcIi4vcHJvZ3Jlc3NTY3JlZW5cIikscD1vKGYpLGI9ZShcIi4vc2VhcmNoUGFuZWxcIiksbT1vKGIpLHk9ZShcIi4vc3dpdGNoZXJcIiksdj1vKHkpLGc9ZShcIi4vdGFiUGFuZWxcIiksaD1vKGcpLEg9ZShcIi4vdG9vbGJhclwiKSxxPW8oSCk7dC5leHBvcnRzPXtDb2xvcmVkQnV0dG9uc0xpc3Q6cltcImRlZmF1bHRcIl0sRmx5aW5nUGFuZWw6YVtcImRlZmF1bHRcIl0sSW5mb1BhbmVsOnVbXCJkZWZhdWx0XCJdLExlZ2VuZHM6Y1tcImRlZmF1bHRcIl0sUHJvZ3Jlc3NTY3JlZW46cFtcImRlZmF1bHRcIl0sU2VhcmNoUGFuZWw6bVtcImRlZmF1bHRcIl0sU3dpdGNoZXI6dltcImRlZmF1bHRcIl0sVGFiUGFuZWw6aFtcImRlZmF1bHRcIl0sVG9vbGJhcjpxW1wiZGVmYXVsdFwiXX19LHtcIi4vY29sb3JlZEJ1dHRvbnNMaXN0XCI6MSxcIi4vZmx5aW5nUGFuZWxcIjoyLFwiLi9pbmZvUGFuZWxcIjozLFwiLi9sZWdlbmRzXCI6NCxcIi4vcHJvZ3Jlc3NTY3JlZW5cIjo2LFwiLi9zZWFyY2hQYW5lbFwiOjcsXCIuL3N3aXRjaGVyXCI6OSxcIi4vdGFiUGFuZWxcIjoxMCxcIi4vdG9vbGJhclwiOjExfV0sNjpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBpKGUpe2Z1bmN0aW9uIHQoKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO3JldHVybiBlLmNsYXNzTmFtZT1cInRxLXVpLXByb2dyZXNzLXNjcmVlblwiLGUuaW5uZXJIVE1MPW8ubWFya3VwLGV9ZnVuY3Rpb24gbihlKXt2YXIgdD12b2lkIDA7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGU/dD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChlKTpcIm9iamVjdFwiPT09KFwidW5kZWZpbmVkXCI9PXR5cGVvZiBlP1widW5kZWZpbmVkXCI6cihlKSkmJih0PWUpLHR9YVtcImRlZmF1bHRcIl0uYXBwbHkodGhpcyk7dmFyIG89dGhpcztlfHwoZT17fSksby5tYXJrdXA9XCJcIixvLnN0YXRlPVwiY29tcGxldGVkXCIsby5yb290SHRtbD10KCksby5pZD1lLmlkfHxcInRhYlBhbmVsLVwiK3MrKyxvLnJvb3RIdG1sLmlkPW8uaWQ7dmFyIGk9bihlLmJhc2VFbGVtZW50KTtpLmFwcGVuZENoaWxkKG8ucm9vdEh0bWwpLG8uc2V0U3RhdGU9ZnVuY3Rpb24oZSx0KXtlJiYoby5zdGF0ZT1lLFwiYWN0aXZlXCI9PT1lPyhvLnJvb3RIdG1sLmlubmVySFRNTD1cIjxoMT5cIisodHx8dSkrJzwvaDE+PGRpdiBjbGFzcz1cInRxLXVpLXByb2dyZXNzLXNjcmVlbl9fcHJvZ3Jlc3NcIj48L2Rpdj4nLG8ucm9vdEh0bWwuc3R5bGUuZGlzcGxheT1udWxsKTpcImNvbXBsZXRlZFwiPT09ZT8oby5yb290SHRtbC5pbm5lckhUTUw9XCJcIixvLnJvb3RIdG1sLnN0eWxlLmRpc3BsYXk9XCJub25lXCIpOlwiZXJyb3JcIj09PWUmJihvLnJvb3RIdG1sLmlubmVySFRNTD1cIjxoMT5cIisodHx8ZCkrXCI8L2gxPlwiLG8ucm9vdEh0bWwuc3R5bGUuZGlzcGxheT1udWxsKSxvLnRyaWdnZXIoXCJkaWFncmFtLXN0YXRlLWNoYW5nZWRcIixlKSl9LG8uc2V0U3RhdGUoZS5zdGF0ZSxlLnRleHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9O24uUHJvZ3Jlc3NTY3JlZW49aTt2YXIgbD1lKFwiLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZVwiKSxhPW8obCkscz0wLHU9XCJMb2FkaW5nXCIsZD1cIkVycm9yIGhhcyBvY2N1cnJlZCFcIjtuW1wiZGVmYXVsdFwiXT1pfSx7XCIuL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlXCI6OH1dLDc6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gaShlKXtsW1wiZGVmYXVsdFwiXS5hcHBseSh0aGlzKSxlfHwoZT17fSk7dmFyIHQ9ZS5zZWFyY2hCdXR0b25JZHx8XCJ0cUxnU2VhcmNoQnV0dG9uXCIsbj1lLnNlYXJjaElkfHxcInNlYXJjaFwiO3NbXCJkZWZhdWx0XCJdLmFwcGx5KHRoaXMsW3tpZDplLmlkLGJhc2VFbGVtZW50OmUuYmFzZUVsZW1lbnQsYWN0aXZlOmUuYWN0aXZlLGhlYWRlcjplLmhlYWRlcnx8XCJTZWFyY2ggcGFuZWxcIix0cmlnZ2VyQnV0dG9uOmUudHJpZ2dlckJ1dHRvbixib2R5OlwiXFxuICAgICAgICAgICAgPHNwYW4gaWQ9IFwiK3QrJyBjbGFzcz1cInRxLXVpLXNlYXJjaC1pY29uIGdseXBoaWNvbiBnbHlwaGljb24tc2VhcmNoXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDxpbnB1dCBpZD1cIicrbisnXCIgcGxhY2VIb2xkZXI9XCJTZWFyY2guLi5cIiBjbGFzcz1cInRxLXVpLXNlYXJjaC1pbnB1dFwiPjwvaW5wdXQ+XFxuICAgICAgICAnLHJlbW92ZUJhY2tncm91bmQ6ITAsc2l6ZTp7d2lkdGg6XCIyNjBweFwiLGhlaWdodDpcIjcwcHhcIn19XSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5TZWFyY2hQYW5lbD1pO3ZhciByPWUoXCIuL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlXCIpLGw9byhyKSxhPWUoXCIuL2ZseWluZ1BhbmVsXCIpLHM9byhhKTtuW1wiZGVmYXVsdFwiXT1pfSx7XCIuL2ZseWluZ1BhbmVsXCI6MixcIi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGVcIjo4fV0sODpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oKXt2YXIgZT10aGlzO2UuX3N1YnNjcmlidGlvbnM9e30sZS5vbj1mdW5jdGlvbih0LG4pe2UuX3N1YnNjcmlidGlvbnNbdF18fChlLl9zdWJzY3JpYnRpb25zW3RdPVtdKSxlLl9zdWJzY3JpYnRpb25zW3RdLnB1c2gobil9LGUudW5zdWJzY3JpYmU9ZnVuY3Rpb24odCl7T2JqZWN0LmtleXMoZS5fc3Vic2NyaWJ0aW9ucykubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlLl9zdWJzY3JpYnRpb25zW3RdfSkuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgbj1lLmluZGV4T2YodCk7biE9PS0xJiZlLnNwbGljZShuLDEpfSl9LGUudHJpZ2dlcj1mdW5jdGlvbih0LG4pe3ZhciBvPXRoaXM7biBpbnN0YW5jZW9mIEFycmF5fHwobj1bbl0pLGUuX3N1YnNjcmlidGlvbnMmJmUuX3N1YnNjcmlidGlvbnNbdF0mJmUuX3N1YnNjcmlidGlvbnNbdF0uZm9yRWFjaChmdW5jdGlvbihlKXtlLmFwcGx5KG8sbil9KX19T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5TdWJzY3JpYmFibGU9byxuW1wiZGVmYXVsdFwiXT1vfSx7fV0sOTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBpKGUpe2Z1bmN0aW9uIHQoKXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO3JldHVybiB0LmNsYXNzTmFtZT1cInRxLXVpLXN3aXRjaC1idXR0b25zXCIrKGUudmVydGljYWxPcmllbnRhdGlvbj9cIi12ZXJ0aWNhbFwiOlwiXCIpLHQuaW5uZXJIVE1MPW4ubWFya3VwLHR9bFtcImRlZmF1bHRcIl0uYXBwbHkodGhpcyksZXx8KGU9e30pO3ZhciBuPXRoaXMsbz1lLnN0YXRlc3x8W107bi5tYXJrdXA9by5tYXAoZnVuY3Rpb24odCxuKXtyZXR1cm4nPGJ1dHRvbiBpZD1cIicrdC5pZCsnXCIgJysoMCE9PW4/XCJcIjpcImRpc2FibGVkXCIpKycgdGl0bGU9XCInKyh0LmxhYmVsfHx0LmlkKSsnXCI+XFxuICAgICAgICAgICAgJysoZS52ZXJ0aWNhbE9yaWVudGF0aW9uJiZ0Lmljb24/JzxzcGFuIGNsYXNzPVwiJyt0Lmljb24rJ1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj4nOnQubGFiZWx8fHQuaWQpK1wiXFxuICAgICAgICA8L2J1dHRvbj5cIn0pLmpvaW4oXCJcIiksbi5yb290SHRtbD10KCksbi5pZD1lLmlkfHxcInN3aXRjaGVyLVwiK2ErKyxuLnJvb3RIdG1sLmlkPW4uaWQ7dmFyIGk9bnVsbDtvLmZvckVhY2goZnVuY3Rpb24oZSx0KXt2YXIgbz1uLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIjXCIrZS5pZCk7MD09PXQmJihpPW8pLG8ub25jbGljaz1mdW5jdGlvbigpe28uZGlzYWJsZWQ9ITAsaS5kaXNhYmxlZD0hMSxpPW8sbi50cmlnZ2VyKFwic3RhdGUtY2hhbmdlZFwiLGUuaWQpfX0pLG4uc2V0U3RhdGU9ZnVuY3Rpb24oZSl7dmFyIHQ9bi5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiI1wiK2UpO3QmJmUhPT1pLmlkJiYodC5kaXNhYmxlZD0hMCxpLmRpc2FibGVkPSExLGk9dCl9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uU3dpdGNoZXI9aTt2YXIgcj1lKFwiLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZVwiKSxsPW8ociksYT0wO25bXCJkZWZhdWx0XCJdPWl9LHtcIi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGVcIjo4fV0sMTA6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe2Z1bmN0aW9uIHQoKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO3JldHVybiBlLmNsYXNzTmFtZT1cInRxLXVpLXRhYi1wYW5lbFwiLGUuaW5uZXJIVE1MPW4ubWFya3VwLGV9dmFyIG49dGhpcztlfHwoZT17fSk7dmFyIG89ZS50YWJzfHxbXTtuLm1hcmt1cD0nXFxuICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktdGFiLXN3aXRjaGVyIHRxLXVpLXN3aXRjaC1idXR0b25zXCI+JytvLm1hcChmdW5jdGlvbihlLHQpe3JldHVybidcXG4gICAgICAgICAgICA8YnV0dG9uIGlkPVwiJytlLmlkKydcIiAnKygwIT09dD9cIlwiOlwiZGlzYWJsZWRcIikrXCI+XFxuICAgICAgICAgICAgICAgIFwiKyhlLmxhYmVsfHxlLmlkKStcIlxcbiAgICAgICAgICAgIDwvYnV0dG9uPiAgXFxuICAgICAgICBcIn0pLmpvaW4oXCJcIikrXCI8L2Rpdj5cIitvLm1hcChmdW5jdGlvbihlLHQpe3JldHVybidcXG4gICAgICAgICAgICA8ZGl2IGlkPVwiJytlLmlkKydQYW5lbFwiIGNsYXNzPVwidHEtdWktdGFiLXBhbmVsX3BhZ2VcIiBzdHlsZT1cImRpc3BsYXk6ICcrKDA9PT10P1wiXCI6XCJub25lXCIpKydcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLXRhYi1wYW5lbF9wYWdlX2JvZHlcIj5cXG4gICAgICAgICAgICAgICAgICAgICcrKFwic3RyaW5nXCI9PXR5cGVvZiBlLmJvZHk/ZS5ib2R5OlwiXCIpK1wiXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgXCJ9KS5qb2luKFwiXCIpLG4ucm9vdEh0bWw9dCgpLG4uaWQ9ZS5pZHx8XCJ0YWJQYW5lbC1cIitpKyssbi5yb290SHRtbC5pZD1uLmlkLG8ubWFwKGZ1bmN0aW9uKGUpe2lmKGUuYm9keSBpbnN0YW5jZW9mIE9iamVjdCYmZS5ib2R5LnJvb3RIdG1sKXt2YXIgdD1uLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIjXCIrZS5pZCtcIlBhbmVsIC50cS11aS10YWItcGFuZWxfcGFnZV9ib2R5XCIpO3QuYXBwZW5kQ2hpbGQoZS5ib2R5LnJvb3RIdG1sKX19KTt2YXIgcj1udWxsO28uZm9yRWFjaChmdW5jdGlvbihlLHQpe3ZhciBvPW4ucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIiNcIitlLmlkKSxpPW4ucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIiNcIitlLmlkK1wiUGFuZWxcIik7MD09PXQmJihyPXt0YWJCdG46byx0YWJQYW5lbDppfSksby5vbmNsaWNrPWZ1bmN0aW9uKCl7by5kaXNhYmxlZD0hMCxpLnN0eWxlLmRpc3BsYXk9XCJcIixyLnRhYkJ0bi5kaXNhYmxlZD0hMSxyLnRhYlBhbmVsLnN0eWxlLmRpc3BsYXk9XCJub25lXCIscj17dGFiQnRuOm8sdGFiUGFuZWw6aX19fSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5UYWJQYW5lbD1vO3ZhciBpPTA7bltcImRlZmF1bHRcIl09b30se31dLDExOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtmdW5jdGlvbiB0KGUpe3ZhciB0PXZvaWQgMDtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtuLmlubmVySFRNTD1lLHQ9bi5maXJzdENoaWxkfWVsc2UgaWYoZS5pZCYmZS5pY29uKXt2YXIgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO2lmKG8uaW5uZXJIVE1MPSc8YnV0dG9uIGlkPVwiJytlLmlkKydcIiB0aXRsZT1cIicrKGUubGFiZWx8fGUuaWQpKydcIiBjbGFzcz1cInRxLXVpLXRvb2xiYXJfX2J1dHRvblwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIicrZS5pY29uKydcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9idXR0b24+Jyx0PW8uZmlyc3RDaGlsZCxlLmljb24yKXt2YXIgaT0hMDt0Lm9uY2xpY2s9ZnVuY3Rpb24obil7dC5pbm5lckhUTUw9JzxzcGFuIGNsYXNzPVwiJysoaT9lLmljb24yOmUuaWNvbikrJ1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj4nLGUuY2FsbGJhY2sobiksaT0haX19ZWxzZSB0Lm9uY2xpY2s9ZS5jYWxsYmFja31lbHNlIGUucm9vdEh0bWwmJih0PWUucm9vdEh0bWwpO3JldHVybiB0fWZ1bmN0aW9uIG4oKXt2YXIgdD12b2lkIDA7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGUuYmFzZUVsZW1lbnQ/dD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChlLmJhc2VFbGVtZW50KTpcIm9iamVjdFwiPT09aShlLmJhc2VFbGVtZW50KSYmKHQ9ZS5iYXNlRWxlbWVudCksdD8odC5pbm5lckhUTUw9by5tYXJrdXAsdCk6bnVsbH12YXIgbz10aGlzO2lmKGV8fChlPXt9KSxvLm1hcmt1cD0nXFxuICAgICAgICA8ZGl2IGlkPVwidG9vbGJhclJvb3RFbGVtZW50XCIgY2xhc3M9XCJ0cS11aS10b29sYmFyXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgJyxvLnJvb3RIdG1sPW4oKSxvLmlkPWUuaWR8fFwidG9vbGJhci1cIityKyssby5yb290SHRtbC5pZD1vLmlkLCFvLnJvb3RIdG1sKXRocm93IG5ldyBFcnJvcihcIlRoZSByb290IGVsZW1lbnQgaXMgbm90IHNwZWNpZmllZCFcIik7by5jb250YWluZXI9by5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiI3Rvb2xiYXJSb290RWxlbWVudFwiKSxvLnB1c2hUb29sPWZ1bmN0aW9uKGUpe3ZhciBuPXQoZSk7biYmKFwic3RyaW5nXCIhPXR5cGVvZiBuP2wucHVzaChlKTpsLnB1c2goe2lkOlwiY3VzdG9taHRtbFwiK3IrKyxtYXJrdXA6ZSxyb290SHRtbDpufSksby5jb250YWluZXIuYXBwZW5kQ2hpbGQobikpfSxvLmluc2VydFRvb2w9ZnVuY3Rpb24oZSxuKXt2YXIgaT1NYXRoLm1pbihNYXRoLm1heChuLDApLGwubGVuZ3RoLTEpLHI9by5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIiNcIitsW2ldLmlkKTtpZihyKXt2YXIgYT10KGUpO2EmJihsLnNwbGljZShpLDAsZSksby5jb250YWluZXIuaW5zZXJ0QmVmb3JlKGEscikpfWVsc2Ugby5wdXNoVG9vbChlKX0sby5yZW1vdmVUb29sPWZ1bmN0aW9uKGUpe3ZhciB0PVwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZS5pZDtsLnNwbGljZShsLmluZGV4T2YoZSksMSk7dmFyIG49by5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIiNcIit0KTtvLmNvbnRhaW5lci5yZW1vdmVDaGlsZChuKX07dmFyIGw9W107ZS50b29scy5mb3JFYWNoKGZ1bmN0aW9uKGUpe28ucHVzaFRvb2woZSl9KX1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfTtuLlRvb2xiYXI9bzt2YXIgcj0wO25bXCJkZWZhdWx0XCJdPW99LHt9XX0se30sWzVdKSg1KX0pOyIsIlwidXNlIHN0cmljdFwiO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvYWRhcHRvclwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9kM2FkYXB0b3JcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvZGVzY2VudFwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9nZW9tXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL2dyaWRyb3V0ZXJcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvaGFuZGxlZGlzY29ubmVjdGVkXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL2xheW91dFwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9sYXlvdXQzZFwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9saW5rbGVuZ3Roc1wiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9wb3dlcmdyYXBoXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL3BxdWV1ZVwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9yYnRyZWVcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvcmVjdGFuZ2xlXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL3Nob3J0ZXN0cGF0aHNcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvdnBzY1wiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9iYXRjaFwiKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbGF5b3V0XzEgPSByZXF1aXJlKFwiLi9sYXlvdXRcIik7XHJcbnZhciBMYXlvdXRBZGFwdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhMYXlvdXRBZGFwdG9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTGF5b3V0QWRhcHRvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICB2YXIgc2VsZiA9IF90aGlzO1xyXG4gICAgICAgIHZhciBvID0gb3B0aW9ucztcclxuICAgICAgICBpZiAoby50cmlnZ2VyKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnRyaWdnZXIgPSBvLnRyaWdnZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvLmtpY2spIHtcclxuICAgICAgICAgICAgX3RoaXMua2ljayA9IG8ua2ljaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG8uZHJhZykge1xyXG4gICAgICAgICAgICBfdGhpcy5kcmFnID0gby5kcmFnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoby5vbikge1xyXG4gICAgICAgICAgICBfdGhpcy5vbiA9IG8ub247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF90aGlzLmRyYWdzdGFydCA9IF90aGlzLmRyYWdTdGFydCA9IGxheW91dF8xLkxheW91dC5kcmFnU3RhcnQ7XHJcbiAgICAgICAgX3RoaXMuZHJhZ2VuZCA9IF90aGlzLmRyYWdFbmQgPSBsYXlvdXRfMS5MYXlvdXQuZHJhZ0VuZDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBMYXlvdXRBZGFwdG9yLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGUpIHsgfTtcclxuICAgIDtcclxuICAgIExheW91dEFkYXB0b3IucHJvdG90eXBlLmtpY2sgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICA7XHJcbiAgICBMYXlvdXRBZGFwdG9yLnByb3RvdHlwZS5kcmFnID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgO1xyXG4gICAgTGF5b3V0QWRhcHRvci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBsaXN0ZW5lcikgeyByZXR1cm4gdGhpczsgfTtcclxuICAgIDtcclxuICAgIHJldHVybiBMYXlvdXRBZGFwdG9yO1xyXG59KGxheW91dF8xLkxheW91dCkpO1xyXG5leHBvcnRzLkxheW91dEFkYXB0b3IgPSBMYXlvdXRBZGFwdG9yO1xyXG5mdW5jdGlvbiBhZGFwdG9yKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBuZXcgTGF5b3V0QWRhcHRvcihvcHRpb25zKTtcclxufVxyXG5leHBvcnRzLmFkYXB0b3IgPSBhZGFwdG9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGFwdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBsYXlvdXRfMSA9IHJlcXVpcmUoXCIuL2xheW91dFwiKTtcclxudmFyIGdyaWRyb3V0ZXJfMSA9IHJlcXVpcmUoXCIuL2dyaWRyb3V0ZXJcIik7XHJcbmZ1bmN0aW9uIGdyaWRpZnkocGdMYXlvdXQsIG51ZGdlR2FwLCBtYXJnaW4sIGdyb3VwTWFyZ2luKSB7XHJcbiAgICBwZ0xheW91dC5jb2xhLnN0YXJ0KDAsIDAsIDAsIDEwLCBmYWxzZSk7XHJcbiAgICB2YXIgZ3JpZHJvdXRlciA9IHJvdXRlKHBnTGF5b3V0LmNvbGEubm9kZXMoKSwgcGdMYXlvdXQuY29sYS5ncm91cHMoKSwgbWFyZ2luLCBncm91cE1hcmdpbik7XHJcbiAgICByZXR1cm4gZ3JpZHJvdXRlci5yb3V0ZUVkZ2VzKHBnTGF5b3V0LnBvd2VyR3JhcGgucG93ZXJFZGdlcywgbnVkZ2VHYXAsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnNvdXJjZS5yb3V0ZXJOb2RlLmlkOyB9LCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS50YXJnZXQucm91dGVyTm9kZS5pZDsgfSk7XHJcbn1cclxuZXhwb3J0cy5ncmlkaWZ5ID0gZ3JpZGlmeTtcclxuZnVuY3Rpb24gcm91dGUobm9kZXMsIGdyb3VwcywgbWFyZ2luLCBncm91cE1hcmdpbikge1xyXG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGQucm91dGVyTm9kZSA9IHtcclxuICAgICAgICAgICAgbmFtZTogZC5uYW1lLFxyXG4gICAgICAgICAgICBib3VuZHM6IGQuYm91bmRzLmluZmxhdGUoLW1hcmdpbilcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICBncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGQucm91dGVyTm9kZSA9IHtcclxuICAgICAgICAgICAgYm91bmRzOiBkLmJvdW5kcy5pbmZsYXRlKC1ncm91cE1hcmdpbiksXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiAodHlwZW9mIGQuZ3JvdXBzICE9PSAndW5kZWZpbmVkJyA/IGQuZ3JvdXBzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gbm9kZXMubGVuZ3RoICsgYy5pZDsgfSkgOiBbXSlcclxuICAgICAgICAgICAgICAgIC5jb25jYXQodHlwZW9mIGQubGVhdmVzICE9PSAndW5kZWZpbmVkJyA/IGQubGVhdmVzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5pbmRleDsgfSkgOiBbXSlcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICB2YXIgZ3JpZFJvdXRlck5vZGVzID0gbm9kZXMuY29uY2F0KGdyb3VwcykubWFwKGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgZC5yb3V0ZXJOb2RlLmlkID0gaTtcclxuICAgICAgICByZXR1cm4gZC5yb3V0ZXJOb2RlO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbmV3IGdyaWRyb3V0ZXJfMS5HcmlkUm91dGVyKGdyaWRSb3V0ZXJOb2Rlcywge1xyXG4gICAgICAgIGdldENoaWxkcmVuOiBmdW5jdGlvbiAodikgeyByZXR1cm4gdi5jaGlsZHJlbjsgfSxcclxuICAgICAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LmJvdW5kczsgfVxyXG4gICAgfSwgbWFyZ2luIC0gZ3JvdXBNYXJnaW4pO1xyXG59XHJcbmZ1bmN0aW9uIHBvd2VyR3JhcGhHcmlkTGF5b3V0KGdyYXBoLCBzaXplLCBncm91cHBhZGRpbmcpIHtcclxuICAgIHZhciBwb3dlckdyYXBoO1xyXG4gICAgZ3JhcGgubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gdi5pbmRleCA9IGk7IH0pO1xyXG4gICAgbmV3IGxheW91dF8xLkxheW91dCgpXHJcbiAgICAgICAgLmF2b2lkT3ZlcmxhcHMoZmFsc2UpXHJcbiAgICAgICAgLm5vZGVzKGdyYXBoLm5vZGVzKVxyXG4gICAgICAgIC5saW5rcyhncmFwaC5saW5rcylcclxuICAgICAgICAucG93ZXJHcmFwaEdyb3VwcyhmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHBvd2VyR3JhcGggPSBkO1xyXG4gICAgICAgIHBvd2VyR3JhcGguZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYucGFkZGluZyA9IGdyb3VwcGFkZGluZzsgfSk7XHJcbiAgICB9KTtcclxuICAgIHZhciBuID0gZ3JhcGgubm9kZXMubGVuZ3RoO1xyXG4gICAgdmFyIGVkZ2VzID0gW107XHJcbiAgICB2YXIgdnMgPSBncmFwaC5ub2Rlcy5zbGljZSgwKTtcclxuICAgIHZzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIHYuaW5kZXggPSBpOyB9KTtcclxuICAgIHBvd2VyR3JhcGguZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGcpIHtcclxuICAgICAgICB2YXIgc291cmNlSW5kID0gZy5pbmRleCA9IGcuaWQgKyBuO1xyXG4gICAgICAgIHZzLnB1c2goZyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBnLmxlYXZlcyAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIGcubGVhdmVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHNvdXJjZUluZCwgdGFyZ2V0OiB2LmluZGV4IH0pOyB9KTtcclxuICAgICAgICBpZiAodHlwZW9mIGcuZ3JvdXBzICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgZy5ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ2cpIHsgcmV0dXJuIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHNvdXJjZUluZCwgdGFyZ2V0OiBnZy5pZCArIG4gfSk7IH0pO1xyXG4gICAgfSk7XHJcbiAgICBwb3dlckdyYXBoLnBvd2VyRWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IGUuc291cmNlLmluZGV4LCB0YXJnZXQ6IGUudGFyZ2V0LmluZGV4IH0pO1xyXG4gICAgfSk7XHJcbiAgICBuZXcgbGF5b3V0XzEuTGF5b3V0KClcclxuICAgICAgICAuc2l6ZShzaXplKVxyXG4gICAgICAgIC5ub2Rlcyh2cylcclxuICAgICAgICAubGlua3MoZWRnZXMpXHJcbiAgICAgICAgLmF2b2lkT3ZlcmxhcHMoZmFsc2UpXHJcbiAgICAgICAgLmxpbmtEaXN0YW5jZSgzMClcclxuICAgICAgICAuc3ltbWV0cmljRGlmZkxpbmtMZW5ndGhzKDUpXHJcbiAgICAgICAgLmNvbnZlcmdlbmNlVGhyZXNob2xkKDFlLTQpXHJcbiAgICAgICAgLnN0YXJ0KDEwMCwgMCwgMCwgMCwgZmFsc2UpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjb2xhOiBuZXcgbGF5b3V0XzEuTGF5b3V0KClcclxuICAgICAgICAgICAgLmNvbnZlcmdlbmNlVGhyZXNob2xkKDFlLTMpXHJcbiAgICAgICAgICAgIC5zaXplKHNpemUpXHJcbiAgICAgICAgICAgIC5hdm9pZE92ZXJsYXBzKHRydWUpXHJcbiAgICAgICAgICAgIC5ub2RlcyhncmFwaC5ub2RlcylcclxuICAgICAgICAgICAgLmxpbmtzKGdyYXBoLmxpbmtzKVxyXG4gICAgICAgICAgICAuZ3JvdXBDb21wYWN0bmVzcygxZS00KVxyXG4gICAgICAgICAgICAubGlua0Rpc3RhbmNlKDMwKVxyXG4gICAgICAgICAgICAuc3ltbWV0cmljRGlmZkxpbmtMZW5ndGhzKDUpXHJcbiAgICAgICAgICAgIC5wb3dlckdyYXBoR3JvdXBzKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHBvd2VyR3JhcGggPSBkO1xyXG4gICAgICAgICAgICBwb3dlckdyYXBoLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICB2LnBhZGRpbmcgPSBncm91cHBhZGRpbmc7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pLnN0YXJ0KDUwLCAwLCAxMDAsIDAsIGZhbHNlKSxcclxuICAgICAgICBwb3dlckdyYXBoOiBwb3dlckdyYXBoXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucG93ZXJHcmFwaEdyaWRMYXlvdXQgPSBwb3dlckdyYXBoR3JpZExheW91dDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmF0Y2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGQzdjMgPSByZXF1aXJlKFwiLi9kM3YzYWRhcHRvclwiKTtcclxudmFyIGQzdjQgPSByZXF1aXJlKFwiLi9kM3Y0YWRhcHRvclwiKTtcclxuO1xyXG5mdW5jdGlvbiBkM2FkYXB0b3IoZDNDb250ZXh0KSB7XHJcbiAgICBpZiAoIWQzQ29udGV4dCB8fCBpc0QzVjMoZDNDb250ZXh0KSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgZDN2My5EM1N0eWxlTGF5b3V0QWRhcHRvcigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBkM3Y0LkQzU3R5bGVMYXlvdXRBZGFwdG9yKGQzQ29udGV4dCk7XHJcbn1cclxuZXhwb3J0cy5kM2FkYXB0b3IgPSBkM2FkYXB0b3I7XHJcbmZ1bmN0aW9uIGlzRDNWMyhkM0NvbnRleHQpIHtcclxuICAgIHZhciB2M2V4cCA9IC9eM1xcLi87XHJcbiAgICByZXR1cm4gZDNDb250ZXh0LnZlcnNpb24gJiYgZDNDb250ZXh0LnZlcnNpb24ubWF0Y2godjNleHApICE9PSBudWxsO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWQzYWRhcHRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGxheW91dF8xID0gcmVxdWlyZShcIi4vbGF5b3V0XCIpO1xyXG52YXIgRDNTdHlsZUxheW91dEFkYXB0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEQzU3R5bGVMYXlvdXRBZGFwdG9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRDNTdHlsZUxheW91dEFkYXB0b3IoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5ldmVudCA9IGQzLmRpc3BhdGNoKGxheW91dF8xLkV2ZW50VHlwZVtsYXlvdXRfMS5FdmVudFR5cGUuc3RhcnRdLCBsYXlvdXRfMS5FdmVudFR5cGVbbGF5b3V0XzEuRXZlbnRUeXBlLnRpY2tdLCBsYXlvdXRfMS5FdmVudFR5cGVbbGF5b3V0XzEuRXZlbnRUeXBlLmVuZF0pO1xyXG4gICAgICAgIHZhciBkM2xheW91dCA9IF90aGlzO1xyXG4gICAgICAgIHZhciBkcmFnO1xyXG4gICAgICAgIF90aGlzLmRyYWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghZHJhZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKClcclxuICAgICAgICAgICAgICAgICAgICAub3JpZ2luKGxheW91dF8xLkxheW91dC5kcmFnT3JpZ2luKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbihcImRyYWdzdGFydC5kM2FkYXB0b3JcIiwgbGF5b3V0XzEuTGF5b3V0LmRyYWdTdGFydClcclxuICAgICAgICAgICAgICAgICAgICAub24oXCJkcmFnLmQzYWRhcHRvclwiLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxheW91dF8xLkxheW91dC5kcmFnKGQsIGQzLmV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBkM2xheW91dC5yZXN1bWUoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwiZHJhZ2VuZC5kM2FkYXB0b3JcIiwgbGF5b3V0XzEuTGF5b3V0LmRyYWdFbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHJldHVybiBkcmFnO1xyXG4gICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgICAgICAuY2FsbChkcmFnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEQzU3R5bGVMYXlvdXRBZGFwdG9yLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICB2YXIgZDNldmVudCA9IHsgdHlwZTogbGF5b3V0XzEuRXZlbnRUeXBlW2UudHlwZV0sIGFscGhhOiBlLmFscGhhLCBzdHJlc3M6IGUuc3RyZXNzIH07XHJcbiAgICAgICAgdGhpcy5ldmVudFtkM2V2ZW50LnR5cGVdKGQzZXZlbnQpO1xyXG4gICAgfTtcclxuICAgIEQzU3R5bGVMYXlvdXRBZGFwdG9yLnByb3RvdHlwZS5raWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgZDMudGltZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS50aWNrLmNhbGwoX3RoaXMpOyB9KTtcclxuICAgIH07XHJcbiAgICBEM1N0eWxlTGF5b3V0QWRhcHRvci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnRUeXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50Lm9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudC5vbihsYXlvdXRfMS5FdmVudFR5cGVbZXZlbnRUeXBlXSwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gRDNTdHlsZUxheW91dEFkYXB0b3I7XHJcbn0obGF5b3V0XzEuTGF5b3V0KSk7XHJcbmV4cG9ydHMuRDNTdHlsZUxheW91dEFkYXB0b3IgPSBEM1N0eWxlTGF5b3V0QWRhcHRvcjtcclxuZnVuY3Rpb24gZDNhZGFwdG9yKCkge1xyXG4gICAgcmV0dXJuIG5ldyBEM1N0eWxlTGF5b3V0QWRhcHRvcigpO1xyXG59XHJcbmV4cG9ydHMuZDNhZGFwdG9yID0gZDNhZGFwdG9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kM3YzYWRhcHRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGxheW91dF8xID0gcmVxdWlyZShcIi4vbGF5b3V0XCIpO1xyXG52YXIgRDNTdHlsZUxheW91dEFkYXB0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEQzU3R5bGVMYXlvdXRBZGFwdG9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRDNTdHlsZUxheW91dEFkYXB0b3IoZDNDb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5kM0NvbnRleHQgPSBkM0NvbnRleHQ7XHJcbiAgICAgICAgX3RoaXMuZXZlbnQgPSBkM0NvbnRleHQuZGlzcGF0Y2gobGF5b3V0XzEuRXZlbnRUeXBlW2xheW91dF8xLkV2ZW50VHlwZS5zdGFydF0sIGxheW91dF8xLkV2ZW50VHlwZVtsYXlvdXRfMS5FdmVudFR5cGUudGlja10sIGxheW91dF8xLkV2ZW50VHlwZVtsYXlvdXRfMS5FdmVudFR5cGUuZW5kXSk7XHJcbiAgICAgICAgdmFyIGQzbGF5b3V0ID0gX3RoaXM7XHJcbiAgICAgICAgdmFyIGRyYWc7XHJcbiAgICAgICAgX3RoaXMuZHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFkcmFnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHJhZyA9IGQzQ29udGV4dC5kcmFnKClcclxuICAgICAgICAgICAgICAgICAgICAuc3ViamVjdChsYXlvdXRfMS5MYXlvdXQuZHJhZ09yaWdpbilcclxuICAgICAgICAgICAgICAgICAgICAub24oXCJzdGFydC5kM2FkYXB0b3JcIiwgbGF5b3V0XzEuTGF5b3V0LmRyYWdTdGFydClcclxuICAgICAgICAgICAgICAgICAgICAub24oXCJkcmFnLmQzYWRhcHRvclwiLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxheW91dF8xLkxheW91dC5kcmFnKGQsIGQzQ29udGV4dC5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZDNsYXlvdXQucmVzdW1lKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbihcImVuZC5kM2FkYXB0b3JcIiwgbGF5b3V0XzEuTGF5b3V0LmRyYWdFbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHJldHVybiBkcmFnO1xyXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0uY2FsbChkcmFnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEQzU3R5bGVMYXlvdXRBZGFwdG9yLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICB2YXIgZDNldmVudCA9IHsgdHlwZTogbGF5b3V0XzEuRXZlbnRUeXBlW2UudHlwZV0sIGFscGhhOiBlLmFscGhhLCBzdHJlc3M6IGUuc3RyZXNzIH07XHJcbiAgICAgICAgdGhpcy5ldmVudC5jYWxsKGQzZXZlbnQudHlwZSwgZDNldmVudCk7XHJcbiAgICB9O1xyXG4gICAgRDNTdHlsZUxheW91dEFkYXB0b3IucHJvdG90eXBlLmtpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdCA9IHRoaXMuZDNDb250ZXh0LnRpbWVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudGljay5jYWxsKF90aGlzKSAmJiB0LnN0b3AoKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgRDNTdHlsZUxheW91dEFkYXB0b3IucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50VHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudC5vbihldmVudFR5cGUsIGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnQub24obGF5b3V0XzEuRXZlbnRUeXBlW2V2ZW50VHlwZV0sIGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEQzU3R5bGVMYXlvdXRBZGFwdG9yO1xyXG59KGxheW91dF8xLkxheW91dCkpO1xyXG5leHBvcnRzLkQzU3R5bGVMYXlvdXRBZGFwdG9yID0gRDNTdHlsZUxheW91dEFkYXB0b3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWQzdjRhZGFwdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBMb2NrcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMb2NrcygpIHtcclxuICAgICAgICB0aGlzLmxvY2tzID0ge307XHJcbiAgICB9XHJcbiAgICBMb2Nrcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGlkLCB4KSB7XHJcbiAgICAgICAgdGhpcy5sb2Nrc1tpZF0gPSB4O1xyXG4gICAgfTtcclxuICAgIExvY2tzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmxvY2tzID0ge307XHJcbiAgICB9O1xyXG4gICAgTG9ja3MucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgbCBpbiB0aGlzLmxvY2tzKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgTG9ja3MucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICBmb3IgKHZhciBsIGluIHRoaXMubG9ja3MpIHtcclxuICAgICAgICAgICAgZihOdW1iZXIobCksIHRoaXMubG9ja3NbbF0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTG9ja3M7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTG9ja3MgPSBMb2NrcztcclxudmFyIERlc2NlbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGVzY2VudCh4LCBELCBHKSB7XHJcbiAgICAgICAgaWYgKEcgPT09IHZvaWQgMCkgeyBHID0gbnVsbDsgfVxyXG4gICAgICAgIHRoaXMuRCA9IEQ7XHJcbiAgICAgICAgdGhpcy5HID0gRztcclxuICAgICAgICB0aGlzLnRocmVzaG9sZCA9IDAuMDAwMTtcclxuICAgICAgICB0aGlzLm51bUdyaWRTbmFwTm9kZXMgPSAwO1xyXG4gICAgICAgIHRoaXMuc25hcEdyaWRTaXplID0gMTAwO1xyXG4gICAgICAgIHRoaXMuc25hcFN0cmVuZ3RoID0gMTAwMDtcclxuICAgICAgICB0aGlzLnNjYWxlU25hcEJ5TWF4SCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmFuZG9tID0gbmV3IFBzZXVkb1JhbmRvbSgpO1xyXG4gICAgICAgIHRoaXMucHJvamVjdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLmsgPSB4Lmxlbmd0aDtcclxuICAgICAgICB2YXIgbiA9IHRoaXMubiA9IHhbMF0ubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuSCA9IG5ldyBBcnJheSh0aGlzLmspO1xyXG4gICAgICAgIHRoaXMuZyA9IG5ldyBBcnJheSh0aGlzLmspO1xyXG4gICAgICAgIHRoaXMuSGQgPSBuZXcgQXJyYXkodGhpcy5rKTtcclxuICAgICAgICB0aGlzLmEgPSBuZXcgQXJyYXkodGhpcy5rKTtcclxuICAgICAgICB0aGlzLmIgPSBuZXcgQXJyYXkodGhpcy5rKTtcclxuICAgICAgICB0aGlzLmMgPSBuZXcgQXJyYXkodGhpcy5rKTtcclxuICAgICAgICB0aGlzLmQgPSBuZXcgQXJyYXkodGhpcy5rKTtcclxuICAgICAgICB0aGlzLmUgPSBuZXcgQXJyYXkodGhpcy5rKTtcclxuICAgICAgICB0aGlzLmlhID0gbmV3IEFycmF5KHRoaXMuayk7XHJcbiAgICAgICAgdGhpcy5pYiA9IG5ldyBBcnJheSh0aGlzLmspO1xyXG4gICAgICAgIHRoaXMueHRtcCA9IG5ldyBBcnJheSh0aGlzLmspO1xyXG4gICAgICAgIHRoaXMubG9ja3MgPSBuZXcgTG9ja3MoKTtcclxuICAgICAgICB0aGlzLm1pbkQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIHZhciBpID0gbiwgajtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIGogPSBuO1xyXG4gICAgICAgICAgICB3aGlsZSAoLS1qID4gaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBEW2ldW2pdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQgPiAwICYmIGQgPCB0aGlzLm1pbkQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbkQgPSBkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1pbkQgPT09IE51bWJlci5NQVhfVkFMVUUpXHJcbiAgICAgICAgICAgIHRoaXMubWluRCA9IDE7XHJcbiAgICAgICAgaSA9IHRoaXMuaztcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ1tpXSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICAgICAgdGhpcy5IW2ldID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgICAgICBqID0gbjtcclxuICAgICAgICAgICAgd2hpbGUgKGotLSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5IW2ldW2pdID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuSGRbaV0gPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgICAgIHRoaXMuYVtpXSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICAgICAgdGhpcy5iW2ldID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgICAgICB0aGlzLmNbaV0gPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgICAgIHRoaXMuZFtpXSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICAgICAgdGhpcy5lW2ldID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgICAgICB0aGlzLmlhW2ldID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgICAgICB0aGlzLmliW2ldID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgICAgICB0aGlzLnh0bXBbaV0gPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgRGVzY2VudC5jcmVhdGVTcXVhcmVNYXRyaXggPSBmdW5jdGlvbiAobiwgZikge1xyXG4gICAgICAgIHZhciBNID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgIE1baV0gPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBNW2ldW2pdID0gZihpLCBqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTTtcclxuICAgIH07XHJcbiAgICBEZXNjZW50LnByb3RvdHlwZS5vZmZzZXREaXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdSA9IG5ldyBBcnJheSh0aGlzLmspO1xyXG4gICAgICAgIHZhciBsID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuazsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gdVtpXSA9IHRoaXMucmFuZG9tLmdldE5leHRCZXR3ZWVuKDAuMDEsIDEpIC0gMC41O1xyXG4gICAgICAgICAgICBsICs9IHggKiB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsID0gTWF0aC5zcXJ0KGwpO1xyXG4gICAgICAgIHJldHVybiB1Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAqPSBfdGhpcy5taW5EIC8gbDsgfSk7XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC5wcm90b3R5cGUuY29tcHV0ZURlcml2YXRpdmVzID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBuID0gdGhpcy5uO1xyXG4gICAgICAgIGlmIChuIDwgMSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBkID0gbmV3IEFycmF5KHRoaXMuayk7XHJcbiAgICAgICAgdmFyIGQyID0gbmV3IEFycmF5KHRoaXMuayk7XHJcbiAgICAgICAgdmFyIEh1dSA9IG5ldyBBcnJheSh0aGlzLmspO1xyXG4gICAgICAgIHZhciBtYXhIID0gMDtcclxuICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IG47ICsrdSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5rOyArK2kpXHJcbiAgICAgICAgICAgICAgICBIdXVbaV0gPSB0aGlzLmdbaV1bdV0gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IG47ICsrdikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHUgPT09IHYpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF4RGlzcGxhY2VzID0gbjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChtYXhEaXNwbGFjZXMtLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZDIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLms7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBkW2ldID0geFtpXVt1XSAtIHhbaV1bdl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNkMiArPSBkMltpXSA9IGR4ICogZHg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZDIgPiAxZS05KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmQgPSB0aGlzLm9mZnNldERpcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLms7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgeFtpXVt2XSArPSByZFtpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBsID0gTWF0aC5zcXJ0KHNkMik7XHJcbiAgICAgICAgICAgICAgICB2YXIgRCA9IHRoaXMuRFt1XVt2XTtcclxuICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQgPSB0aGlzLkcgIT0gbnVsbCA/IHRoaXMuR1t1XVt2XSA6IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAod2VpZ2h0ID4gMSAmJiBsID4gRCB8fCAhaXNGaW5pdGUoRCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5rOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuSFtpXVt1XVt2XSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAod2VpZ2h0ID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgRDIgPSBEICogRDtcclxuICAgICAgICAgICAgICAgIHZhciBncyA9IDIgKiB3ZWlnaHQgKiAobCAtIEQpIC8gKEQyICogbCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbDMgPSBsICogbCAqIGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgaHMgPSAyICogLXdlaWdodCAvIChEMiAqIGwzKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoZ3MpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGdzKTtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLms7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ1tpXVt1XSArPSBkW2ldICogZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgSHV1W2ldIC09IHRoaXMuSFtpXVt1XVt2XSA9IGhzICogKGwzICsgRCAqIChkMltpXSAtIHNkMikgKyBsICogc2QyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5rOyArK2kpXHJcbiAgICAgICAgICAgICAgICBtYXhIID0gTWF0aC5tYXgobWF4SCwgdGhpcy5IW2ldW3VdW3VdID0gSHV1W2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHIgPSB0aGlzLnNuYXBHcmlkU2l6ZSAvIDI7XHJcbiAgICAgICAgdmFyIGcgPSB0aGlzLnNuYXBHcmlkU2l6ZTtcclxuICAgICAgICB2YXIgdyA9IHRoaXMuc25hcFN0cmVuZ3RoO1xyXG4gICAgICAgIHZhciBrID0gdyAvIChyICogcik7XHJcbiAgICAgICAgdmFyIG51bU5vZGVzID0gdGhpcy5udW1HcmlkU25hcE5vZGVzO1xyXG4gICAgICAgIGZvciAodmFyIHUgPSAwOyB1IDwgbnVtTm9kZXM7ICsrdSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5rOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciB4aXUgPSB0aGlzLnhbaV1bdV07XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHhpdSAvIGc7XHJcbiAgICAgICAgICAgICAgICB2YXIgZiA9IG0gJSAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIHEgPSBtIC0gZjtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gTWF0aC5hYnMoZik7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHggPSAoYSA8PSAwLjUpID8geGl1IC0gcSAqIGcgOlxyXG4gICAgICAgICAgICAgICAgICAgICh4aXUgPiAwKSA/IHhpdSAtIChxICsgMSkgKiBnIDogeGl1IC0gKHEgLSAxKSAqIGc7XHJcbiAgICAgICAgICAgICAgICBpZiAoLXIgPCBkeCAmJiBkeCA8PSByKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NhbGVTbmFwQnlNYXhIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ1tpXVt1XSArPSBtYXhIICogayAqIGR4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkhbaV1bdV1bdV0gKz0gbWF4SCAqIGs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdbaV1bdV0gKz0gayAqIGR4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkhbaV1bdV1bdV0gKz0gaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmxvY2tzLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvY2tzLmFwcGx5KGZ1bmN0aW9uICh1LCBwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX3RoaXMuazsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuSFtpXVt1XVt1XSArPSBtYXhIO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmdbaV1bdV0gLT0gbWF4SCAqIChwW2ldIC0geFtpXVt1XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEZXNjZW50LmRvdFByb2QgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHZhciB4ID0gMCwgaSA9IGEubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pXHJcbiAgICAgICAgICAgIHggKz0gYVtpXSAqIGJbaV07XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC5yaWdodE11bHRpcGx5ID0gZnVuY3Rpb24gKG0sIHYsIHIpIHtcclxuICAgICAgICB2YXIgaSA9IG0ubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pXHJcbiAgICAgICAgICAgIHJbaV0gPSBEZXNjZW50LmRvdFByb2QobVtpXSwgdik7XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC5wcm90b3R5cGUuY29tcHV0ZVN0ZXBTaXplID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICB2YXIgbnVtZXJhdG9yID0gMCwgZGVub21pbmF0b3IgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5rOyArK2kpIHtcclxuICAgICAgICAgICAgbnVtZXJhdG9yICs9IERlc2NlbnQuZG90UHJvZCh0aGlzLmdbaV0sIGRbaV0pO1xyXG4gICAgICAgICAgICBEZXNjZW50LnJpZ2h0TXVsdGlwbHkodGhpcy5IW2ldLCBkW2ldLCB0aGlzLkhkW2ldKTtcclxuICAgICAgICAgICAgZGVub21pbmF0b3IgKz0gRGVzY2VudC5kb3RQcm9kKGRbaV0sIHRoaXMuSGRbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVub21pbmF0b3IgPT09IDAgfHwgIWlzRmluaXRlKGRlbm9taW5hdG9yKSlcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgcmV0dXJuIDEgKiBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcclxuICAgIH07XHJcbiAgICBEZXNjZW50LnByb3RvdHlwZS5yZWR1Y2VTdHJlc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlRGVyaXZhdGl2ZXModGhpcy54KTtcclxuICAgICAgICB2YXIgYWxwaGEgPSB0aGlzLmNvbXB1dGVTdGVwU2l6ZSh0aGlzLmcpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5rOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy50YWtlRGVzY2VudFN0ZXAodGhpcy54W2ldLCB0aGlzLmdbaV0sIGFscGhhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZVN0cmVzcygpO1xyXG4gICAgfTtcclxuICAgIERlc2NlbnQuY29weSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgdmFyIG0gPSBhLmxlbmd0aCwgbiA9IGJbMF0ubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbTsgKytpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBiW2ldW2pdID0gYVtpXVtqXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEZXNjZW50LnByb3RvdHlwZS5zdGVwQW5kUHJvamVjdCA9IGZ1bmN0aW9uICh4MCwgciwgZCwgc3RlcFNpemUpIHtcclxuICAgICAgICBEZXNjZW50LmNvcHkoeDAsIHIpO1xyXG4gICAgICAgIHRoaXMudGFrZURlc2NlbnRTdGVwKHJbMF0sIGRbMF0sIHN0ZXBTaXplKTtcclxuICAgICAgICBpZiAodGhpcy5wcm9qZWN0KVxyXG4gICAgICAgICAgICB0aGlzLnByb2plY3RbMF0oeDBbMF0sIHgwWzFdLCByWzBdKTtcclxuICAgICAgICB0aGlzLnRha2VEZXNjZW50U3RlcChyWzFdLCBkWzFdLCBzdGVwU2l6ZSk7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvamVjdClcclxuICAgICAgICAgICAgdGhpcy5wcm9qZWN0WzFdKHJbMF0sIHgwWzFdLCByWzFdKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMjsgaSA8IHRoaXMuazsgaSsrKVxyXG4gICAgICAgICAgICB0aGlzLnRha2VEZXNjZW50U3RlcChyW2ldLCBkW2ldLCBzdGVwU2l6ZSk7XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC5tQXBwbHkgPSBmdW5jdGlvbiAobSwgbiwgZikge1xyXG4gICAgICAgIHZhciBpID0gbTtcclxuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgaiA9IG47XHJcbiAgICAgICAgICAgIHdoaWxlIChqLS0gPiAwKVxyXG4gICAgICAgICAgICAgICAgZihpLCBqKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC5wcm90b3R5cGUubWF0cml4QXBwbHkgPSBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgIERlc2NlbnQubUFwcGx5KHRoaXMuaywgdGhpcy5uLCBmKTtcclxuICAgIH07XHJcbiAgICBEZXNjZW50LnByb3RvdHlwZS5jb21wdXRlTmV4dFBvc2l0aW9uID0gZnVuY3Rpb24gKHgwLCByKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmNvbXB1dGVEZXJpdmF0aXZlcyh4MCk7XHJcbiAgICAgICAgdmFyIGFscGhhID0gdGhpcy5jb21wdXRlU3RlcFNpemUodGhpcy5nKTtcclxuICAgICAgICB0aGlzLnN0ZXBBbmRQcm9qZWN0KHgwLCByLCB0aGlzLmcsIGFscGhhKTtcclxuICAgICAgICBpZiAodGhpcy5wcm9qZWN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF0cml4QXBwbHkoZnVuY3Rpb24gKGksIGopIHsgcmV0dXJuIF90aGlzLmVbaV1bal0gPSB4MFtpXVtqXSAtIHJbaV1bal07IH0pO1xyXG4gICAgICAgICAgICB2YXIgYmV0YSA9IHRoaXMuY29tcHV0ZVN0ZXBTaXplKHRoaXMuZSk7XHJcbiAgICAgICAgICAgIGJldGEgPSBNYXRoLm1heCgwLjIsIE1hdGgubWluKGJldGEsIDEpKTtcclxuICAgICAgICAgICAgdGhpcy5zdGVwQW5kUHJvamVjdCh4MCwgciwgdGhpcy5lLCBiZXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGl0ZXJhdGlvbnMpIHtcclxuICAgICAgICB2YXIgc3RyZXNzID0gTnVtYmVyLk1BWF9WQUxVRSwgY29udmVyZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgd2hpbGUgKCFjb252ZXJnZWQgJiYgaXRlcmF0aW9ucy0tID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMucnVuZ2VLdXR0YSgpO1xyXG4gICAgICAgICAgICBjb252ZXJnZWQgPSBNYXRoLmFicyhzdHJlc3MgLyBzIC0gMSkgPCB0aGlzLnRocmVzaG9sZDtcclxuICAgICAgICAgICAgc3RyZXNzID0gcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0cmVzcztcclxuICAgIH07XHJcbiAgICBEZXNjZW50LnByb3RvdHlwZS5ydW5nZUt1dHRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlTmV4dFBvc2l0aW9uKHRoaXMueCwgdGhpcy5hKTtcclxuICAgICAgICBEZXNjZW50Lm1pZCh0aGlzLngsIHRoaXMuYSwgdGhpcy5pYSk7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlTmV4dFBvc2l0aW9uKHRoaXMuaWEsIHRoaXMuYik7XHJcbiAgICAgICAgRGVzY2VudC5taWQodGhpcy54LCB0aGlzLmIsIHRoaXMuaWIpO1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZU5leHRQb3NpdGlvbih0aGlzLmliLCB0aGlzLmMpO1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZU5leHRQb3NpdGlvbih0aGlzLmMsIHRoaXMuZCk7XHJcbiAgICAgICAgdmFyIGRpc3AgPSAwO1xyXG4gICAgICAgIHRoaXMubWF0cml4QXBwbHkoZnVuY3Rpb24gKGksIGopIHtcclxuICAgICAgICAgICAgdmFyIHggPSAoX3RoaXMuYVtpXVtqXSArIDIuMCAqIF90aGlzLmJbaV1bal0gKyAyLjAgKiBfdGhpcy5jW2ldW2pdICsgX3RoaXMuZFtpXVtqXSkgLyA2LjAsIGQgPSBfdGhpcy54W2ldW2pdIC0geDtcclxuICAgICAgICAgICAgZGlzcCArPSBkICogZDtcclxuICAgICAgICAgICAgX3RoaXMueFtpXVtqXSA9IHg7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRpc3A7XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC5taWQgPSBmdW5jdGlvbiAoYSwgYiwgbSkge1xyXG4gICAgICAgIERlc2NlbnQubUFwcGx5KGEubGVuZ3RoLCBhWzBdLmxlbmd0aCwgZnVuY3Rpb24gKGksIGopIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1baV1bal0gPSBhW2ldW2pdICsgKGJbaV1bal0gLSBhW2ldW2pdKSAvIDIuMDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEZXNjZW50LnByb3RvdHlwZS50YWtlRGVzY2VudFN0ZXAgPSBmdW5jdGlvbiAoeCwgZCwgc3RlcFNpemUpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubjsgKytpKSB7XHJcbiAgICAgICAgICAgIHhbaV0gPSB4W2ldIC0gc3RlcFNpemUgKiBkW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEZXNjZW50LnByb3RvdHlwZS5jb21wdXRlU3RyZXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzdHJlc3MgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIHUgPSAwLCBuTWludXMxID0gdGhpcy5uIC0gMTsgdSA8IG5NaW51czE7ICsrdSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB2ID0gdSArIDEsIG4gPSB0aGlzLm47IHYgPCBuOyArK3YpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5rOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSB0aGlzLnhbaV1bdV0gLSB0aGlzLnhbaV1bdl07XHJcbiAgICAgICAgICAgICAgICAgICAgbCArPSBkeCAqIGR4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbCA9IE1hdGguc3FydChsKTtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5EW3VdW3ZdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShkKSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIHZhciBybCA9IGQgLSBsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQyID0gZCAqIGQ7XHJcbiAgICAgICAgICAgICAgICBzdHJlc3MgKz0gcmwgKiBybCAvIGQyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHJlc3M7XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC56ZXJvRGlzdGFuY2UgPSAxZS0xMDtcclxuICAgIHJldHVybiBEZXNjZW50O1xyXG59KCkpO1xyXG5leHBvcnRzLkRlc2NlbnQgPSBEZXNjZW50O1xyXG52YXIgUHNldWRvUmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBzZXVkb1JhbmRvbShzZWVkKSB7XHJcbiAgICAgICAgaWYgKHNlZWQgPT09IHZvaWQgMCkgeyBzZWVkID0gMTsgfVxyXG4gICAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XHJcbiAgICAgICAgdGhpcy5hID0gMjE0MDEzO1xyXG4gICAgICAgIHRoaXMuYyA9IDI1MzEwMTE7XHJcbiAgICAgICAgdGhpcy5tID0gMjE0NzQ4MzY0ODtcclxuICAgICAgICB0aGlzLnJhbmdlID0gMzI3Njc7XHJcbiAgICB9XHJcbiAgICBQc2V1ZG9SYW5kb20ucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zZWVkID0gKHRoaXMuc2VlZCAqIHRoaXMuYSArIHRoaXMuYykgJSB0aGlzLm07XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnNlZWQgPj4gMTYpIC8gdGhpcy5yYW5nZTtcclxuICAgIH07XHJcbiAgICBQc2V1ZG9SYW5kb20ucHJvdG90eXBlLmdldE5leHRCZXR3ZWVuID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XHJcbiAgICAgICAgcmV0dXJuIG1pbiArIHRoaXMuZ2V0TmV4dCgpICogKG1heCAtIG1pbik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBzZXVkb1JhbmRvbTtcclxufSgpKTtcclxuZXhwb3J0cy5Qc2V1ZG9SYW5kb20gPSBQc2V1ZG9SYW5kb207XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlc2NlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciByZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL3JlY3RhbmdsZVwiKTtcclxudmFyIFBvaW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBvaW50KCkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFBvaW50O1xyXG59KCkpO1xyXG5leHBvcnRzLlBvaW50ID0gUG9pbnQ7XHJcbnZhciBMaW5lU2VnbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMaW5lU2VnbWVudCh4MSwgeTEsIHgyLCB5Mikge1xyXG4gICAgICAgIHRoaXMueDEgPSB4MTtcclxuICAgICAgICB0aGlzLnkxID0geTE7XHJcbiAgICAgICAgdGhpcy54MiA9IHgyO1xyXG4gICAgICAgIHRoaXMueTIgPSB5MjtcclxuICAgIH1cclxuICAgIHJldHVybiBMaW5lU2VnbWVudDtcclxufSgpKTtcclxuZXhwb3J0cy5MaW5lU2VnbWVudCA9IExpbmVTZWdtZW50O1xyXG52YXIgUG9seVBvaW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQb2x5UG9pbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQb2x5UG9pbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFBvbHlQb2ludDtcclxufShQb2ludCkpO1xyXG5leHBvcnRzLlBvbHlQb2ludCA9IFBvbHlQb2ludDtcclxuZnVuY3Rpb24gaXNMZWZ0KFAwLCBQMSwgUDIpIHtcclxuICAgIHJldHVybiAoUDEueCAtIFAwLngpICogKFAyLnkgLSBQMC55KSAtIChQMi54IC0gUDAueCkgKiAoUDEueSAtIFAwLnkpO1xyXG59XHJcbmV4cG9ydHMuaXNMZWZ0ID0gaXNMZWZ0O1xyXG5mdW5jdGlvbiBhYm92ZShwLCB2aSwgdmopIHtcclxuICAgIHJldHVybiBpc0xlZnQocCwgdmksIHZqKSA+IDA7XHJcbn1cclxuZnVuY3Rpb24gYmVsb3cocCwgdmksIHZqKSB7XHJcbiAgICByZXR1cm4gaXNMZWZ0KHAsIHZpLCB2aikgPCAwO1xyXG59XHJcbmZ1bmN0aW9uIENvbnZleEh1bGwoUykge1xyXG4gICAgdmFyIFAgPSBTLnNsaWNlKDApLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEueCAhPT0gYi54ID8gYi54IC0gYS54IDogYi55IC0gYS55OyB9KTtcclxuICAgIHZhciBuID0gUy5sZW5ndGgsIGk7XHJcbiAgICB2YXIgbWlubWluID0gMDtcclxuICAgIHZhciB4bWluID0gUFswXS54O1xyXG4gICAgZm9yIChpID0gMTsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIGlmIChQW2ldLnggIT09IHhtaW4pXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgdmFyIG1pbm1heCA9IGkgLSAxO1xyXG4gICAgdmFyIEggPSBbXTtcclxuICAgIEgucHVzaChQW21pbm1pbl0pO1xyXG4gICAgaWYgKG1pbm1heCA9PT0gbiAtIDEpIHtcclxuICAgICAgICBpZiAoUFttaW5tYXhdLnkgIT09IFBbbWlubWluXS55KVxyXG4gICAgICAgICAgICBILnB1c2goUFttaW5tYXhdKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBtYXhtaW4sIG1heG1heCA9IG4gLSAxO1xyXG4gICAgICAgIHZhciB4bWF4ID0gUFtuIC0gMV0ueDtcclxuICAgICAgICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgICAgIGlmIChQW2ldLnggIT09IHhtYXgpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICBtYXhtaW4gPSBpICsgMTtcclxuICAgICAgICBpID0gbWlubWF4O1xyXG4gICAgICAgIHdoaWxlICgrK2kgPD0gbWF4bWluKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0xlZnQoUFttaW5taW5dLCBQW21heG1pbl0sIFBbaV0pID49IDAgJiYgaSA8IG1heG1pbilcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB3aGlsZSAoSC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0KEhbSC5sZW5ndGggLSAyXSwgSFtILmxlbmd0aCAtIDFdLCBQW2ldKSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgSC5sZW5ndGggLT0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaSAhPSBtaW5taW4pXHJcbiAgICAgICAgICAgICAgICBILnB1c2goUFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXhtYXggIT0gbWF4bWluKVxyXG4gICAgICAgICAgICBILnB1c2goUFttYXhtYXhdKTtcclxuICAgICAgICB2YXIgYm90ID0gSC5sZW5ndGg7XHJcbiAgICAgICAgaSA9IG1heG1pbjtcclxuICAgICAgICB3aGlsZSAoLS1pID49IG1pbm1heCkge1xyXG4gICAgICAgICAgICBpZiAoaXNMZWZ0KFBbbWF4bWF4XSwgUFttaW5tYXhdLCBQW2ldKSA+PSAwICYmIGkgPiBtaW5tYXgpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgd2hpbGUgKEgubGVuZ3RoID4gYm90KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0KEhbSC5sZW5ndGggLSAyXSwgSFtILmxlbmd0aCAtIDFdLCBQW2ldKSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgSC5sZW5ndGggLT0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaSAhPSBtaW5taW4pXHJcbiAgICAgICAgICAgICAgICBILnB1c2goUFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIEg7XHJcbn1cclxuZXhwb3J0cy5Db252ZXhIdWxsID0gQ29udmV4SHVsbDtcclxuZnVuY3Rpb24gY2xvY2t3aXNlUmFkaWFsU3dlZXAocCwgUCwgZikge1xyXG4gICAgUC5zbGljZSgwKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBNYXRoLmF0YW4yKGEueSAtIHAueSwgYS54IC0gcC54KSAtIE1hdGguYXRhbjIoYi55IC0gcC55LCBiLnggLSBwLngpOyB9KS5mb3JFYWNoKGYpO1xyXG59XHJcbmV4cG9ydHMuY2xvY2t3aXNlUmFkaWFsU3dlZXAgPSBjbG9ja3dpc2VSYWRpYWxTd2VlcDtcclxuZnVuY3Rpb24gbmV4dFBvbHlQb2ludChwLCBwcykge1xyXG4gICAgaWYgKHAucG9seUluZGV4ID09PSBwcy5sZW5ndGggLSAxKVxyXG4gICAgICAgIHJldHVybiBwc1swXTtcclxuICAgIHJldHVybiBwc1twLnBvbHlJbmRleCArIDFdO1xyXG59XHJcbmZ1bmN0aW9uIHByZXZQb2x5UG9pbnQocCwgcHMpIHtcclxuICAgIGlmIChwLnBvbHlJbmRleCA9PT0gMClcclxuICAgICAgICByZXR1cm4gcHNbcHMubGVuZ3RoIC0gMV07XHJcbiAgICByZXR1cm4gcHNbcC5wb2x5SW5kZXggLSAxXTtcclxufVxyXG5mdW5jdGlvbiB0YW5nZW50X1BvaW50UG9seUMoUCwgVikge1xyXG4gICAgdmFyIFZjbG9zZWQgPSBWLnNsaWNlKDApO1xyXG4gICAgVmNsb3NlZC5wdXNoKFZbMF0pO1xyXG4gICAgcmV0dXJuIHsgcnRhbjogUnRhbmdlbnRfUG9pbnRQb2x5QyhQLCBWY2xvc2VkKSwgbHRhbjogTHRhbmdlbnRfUG9pbnRQb2x5QyhQLCBWY2xvc2VkKSB9O1xyXG59XHJcbmZ1bmN0aW9uIFJ0YW5nZW50X1BvaW50UG9seUMoUCwgVikge1xyXG4gICAgdmFyIG4gPSBWLmxlbmd0aCAtIDE7XHJcbiAgICB2YXIgYSwgYiwgYztcclxuICAgIHZhciB1cEEsIGRuQztcclxuICAgIGlmIChiZWxvdyhQLCBWWzFdLCBWWzBdKSAmJiAhYWJvdmUoUCwgVltuIC0gMV0sIFZbMF0pKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgZm9yIChhID0gMCwgYiA9IG47Oykge1xyXG4gICAgICAgIGlmIChiIC0gYSA9PT0gMSlcclxuICAgICAgICAgICAgaWYgKGFib3ZlKFAsIFZbYV0sIFZbYl0pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgIGMgPSBNYXRoLmZsb29yKChhICsgYikgLyAyKTtcclxuICAgICAgICBkbkMgPSBiZWxvdyhQLCBWW2MgKyAxXSwgVltjXSk7XHJcbiAgICAgICAgaWYgKGRuQyAmJiAhYWJvdmUoUCwgVltjIC0gMV0sIFZbY10pKVxyXG4gICAgICAgICAgICByZXR1cm4gYztcclxuICAgICAgICB1cEEgPSBhYm92ZShQLCBWW2EgKyAxXSwgVlthXSk7XHJcbiAgICAgICAgaWYgKHVwQSkge1xyXG4gICAgICAgICAgICBpZiAoZG5DKVxyXG4gICAgICAgICAgICAgICAgYiA9IGM7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFib3ZlKFAsIFZbYV0sIFZbY10pKVxyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBjO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWRuQylcclxuICAgICAgICAgICAgICAgIGEgPSBjO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChiZWxvdyhQLCBWW2FdLCBWW2NdKSlcclxuICAgICAgICAgICAgICAgICAgICBiID0gYztcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBhID0gYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBMdGFuZ2VudF9Qb2ludFBvbHlDKFAsIFYpIHtcclxuICAgIHZhciBuID0gVi5sZW5ndGggLSAxO1xyXG4gICAgdmFyIGEsIGIsIGM7XHJcbiAgICB2YXIgZG5BLCBkbkM7XHJcbiAgICBpZiAoYWJvdmUoUCwgVltuIC0gMV0sIFZbMF0pICYmICFiZWxvdyhQLCBWWzFdLCBWWzBdKSlcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIGZvciAoYSA9IDAsIGIgPSBuOzspIHtcclxuICAgICAgICBpZiAoYiAtIGEgPT09IDEpXHJcbiAgICAgICAgICAgIGlmIChiZWxvdyhQLCBWW2FdLCBWW2JdKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICBjID0gTWF0aC5mbG9vcigoYSArIGIpIC8gMik7XHJcbiAgICAgICAgZG5DID0gYmVsb3coUCwgVltjICsgMV0sIFZbY10pO1xyXG4gICAgICAgIGlmIChhYm92ZShQLCBWW2MgLSAxXSwgVltjXSkgJiYgIWRuQylcclxuICAgICAgICAgICAgcmV0dXJuIGM7XHJcbiAgICAgICAgZG5BID0gYmVsb3coUCwgVlthICsgMV0sIFZbYV0pO1xyXG4gICAgICAgIGlmIChkbkEpIHtcclxuICAgICAgICAgICAgaWYgKCFkbkMpXHJcbiAgICAgICAgICAgICAgICBiID0gYztcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmVsb3coUCwgVlthXSwgVltjXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGM7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChkbkMpXHJcbiAgICAgICAgICAgICAgICBhID0gYztcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWJvdmUoUCwgVlthXSwgVltjXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGM7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdGFuZ2VudF9Qb2x5UG9seUMoViwgVywgdDEsIHQyLCBjbXAxLCBjbXAyKSB7XHJcbiAgICB2YXIgaXgxLCBpeDI7XHJcbiAgICBpeDEgPSB0MShXWzBdLCBWKTtcclxuICAgIGl4MiA9IHQyKFZbaXgxXSwgVyk7XHJcbiAgICB2YXIgZG9uZSA9IGZhbHNlO1xyXG4gICAgd2hpbGUgKCFkb25lKSB7XHJcbiAgICAgICAgZG9uZSA9IHRydWU7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKGl4MSA9PT0gVi5sZW5ndGggLSAxKVxyXG4gICAgICAgICAgICAgICAgaXgxID0gMDtcclxuICAgICAgICAgICAgaWYgKGNtcDEoV1tpeDJdLCBWW2l4MV0sIFZbaXgxICsgMV0pKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICsraXgxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICBpZiAoaXgyID09PSAwKVxyXG4gICAgICAgICAgICAgICAgaXgyID0gVy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICBpZiAoY21wMihWW2l4MV0sIFdbaXgyXSwgV1tpeDIgLSAxXSkpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgLS1peDI7XHJcbiAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyB0MTogaXgxLCB0MjogaXgyIH07XHJcbn1cclxuZXhwb3J0cy50YW5nZW50X1BvbHlQb2x5QyA9IHRhbmdlbnRfUG9seVBvbHlDO1xyXG5mdW5jdGlvbiBMUnRhbmdlbnRfUG9seVBvbHlDKFYsIFcpIHtcclxuICAgIHZhciBybCA9IFJMdGFuZ2VudF9Qb2x5UG9seUMoVywgVik7XHJcbiAgICByZXR1cm4geyB0MTogcmwudDIsIHQyOiBybC50MSB9O1xyXG59XHJcbmV4cG9ydHMuTFJ0YW5nZW50X1BvbHlQb2x5QyA9IExSdGFuZ2VudF9Qb2x5UG9seUM7XHJcbmZ1bmN0aW9uIFJMdGFuZ2VudF9Qb2x5UG9seUMoViwgVykge1xyXG4gICAgcmV0dXJuIHRhbmdlbnRfUG9seVBvbHlDKFYsIFcsIFJ0YW5nZW50X1BvaW50UG9seUMsIEx0YW5nZW50X1BvaW50UG9seUMsIGFib3ZlLCBiZWxvdyk7XHJcbn1cclxuZXhwb3J0cy5STHRhbmdlbnRfUG9seVBvbHlDID0gUkx0YW5nZW50X1BvbHlQb2x5QztcclxuZnVuY3Rpb24gTEx0YW5nZW50X1BvbHlQb2x5QyhWLCBXKSB7XHJcbiAgICByZXR1cm4gdGFuZ2VudF9Qb2x5UG9seUMoViwgVywgTHRhbmdlbnRfUG9pbnRQb2x5QywgTHRhbmdlbnRfUG9pbnRQb2x5QywgYmVsb3csIGJlbG93KTtcclxufVxyXG5leHBvcnRzLkxMdGFuZ2VudF9Qb2x5UG9seUMgPSBMTHRhbmdlbnRfUG9seVBvbHlDO1xyXG5mdW5jdGlvbiBSUnRhbmdlbnRfUG9seVBvbHlDKFYsIFcpIHtcclxuICAgIHJldHVybiB0YW5nZW50X1BvbHlQb2x5QyhWLCBXLCBSdGFuZ2VudF9Qb2ludFBvbHlDLCBSdGFuZ2VudF9Qb2ludFBvbHlDLCBhYm92ZSwgYWJvdmUpO1xyXG59XHJcbmV4cG9ydHMuUlJ0YW5nZW50X1BvbHlQb2x5QyA9IFJSdGFuZ2VudF9Qb2x5UG9seUM7XHJcbnZhciBCaVRhbmdlbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQmlUYW5nZW50KHQxLCB0Mikge1xyXG4gICAgICAgIHRoaXMudDEgPSB0MTtcclxuICAgICAgICB0aGlzLnQyID0gdDI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQmlUYW5nZW50O1xyXG59KCkpO1xyXG5leHBvcnRzLkJpVGFuZ2VudCA9IEJpVGFuZ2VudDtcclxudmFyIEJpVGFuZ2VudHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQmlUYW5nZW50cygpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBCaVRhbmdlbnRzO1xyXG59KCkpO1xyXG5leHBvcnRzLkJpVGFuZ2VudHMgPSBCaVRhbmdlbnRzO1xyXG52YXIgVFZHUG9pbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRWR1BvaW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVFZHUG9pbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFRWR1BvaW50O1xyXG59KFBvaW50KSk7XHJcbmV4cG9ydHMuVFZHUG9pbnQgPSBUVkdQb2ludDtcclxudmFyIFZpc2liaWxpdHlWZXJ0ZXggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmlzaWJpbGl0eVZlcnRleChpZCwgcG9seWlkLCBwb2x5dmVydGlkLCBwKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMucG9seWlkID0gcG9seWlkO1xyXG4gICAgICAgIHRoaXMucG9seXZlcnRpZCA9IHBvbHl2ZXJ0aWQ7XHJcbiAgICAgICAgdGhpcy5wID0gcDtcclxuICAgICAgICBwLnZ2ID0gdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBWaXNpYmlsaXR5VmVydGV4O1xyXG59KCkpO1xyXG5leHBvcnRzLlZpc2liaWxpdHlWZXJ0ZXggPSBWaXNpYmlsaXR5VmVydGV4O1xyXG52YXIgVmlzaWJpbGl0eUVkZ2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmlzaWJpbGl0eUVkZ2Uoc291cmNlLCB0YXJnZXQpIHtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxuICAgIFZpc2liaWxpdHlFZGdlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGR4ID0gdGhpcy5zb3VyY2UucC54IC0gdGhpcy50YXJnZXQucC54O1xyXG4gICAgICAgIHZhciBkeSA9IHRoaXMuc291cmNlLnAueSAtIHRoaXMudGFyZ2V0LnAueTtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVmlzaWJpbGl0eUVkZ2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVmlzaWJpbGl0eUVkZ2UgPSBWaXNpYmlsaXR5RWRnZTtcclxudmFyIFRhbmdlbnRWaXNpYmlsaXR5R3JhcGggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGFuZ2VudFZpc2liaWxpdHlHcmFwaChQLCBnMCkge1xyXG4gICAgICAgIHRoaXMuUCA9IFA7XHJcbiAgICAgICAgdGhpcy5WID0gW107XHJcbiAgICAgICAgdGhpcy5FID0gW107XHJcbiAgICAgICAgaWYgKCFnMCkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IFAubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBQW2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBqID0gcFtqXSwgdnYgPSBuZXcgVmlzaWJpbGl0eVZlcnRleCh0aGlzLlYubGVuZ3RoLCBpLCBqLCBwaik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5WLnB1c2godnYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5FLnB1c2gobmV3IFZpc2liaWxpdHlFZGdlKHBbaiAtIDFdLnZ2LCB2dikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHAubGVuZ3RoID4gMSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLkUucHVzaChuZXcgVmlzaWJpbGl0eUVkZ2UocFswXS52diwgcFtwLmxlbmd0aCAtIDFdLnZ2KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgUGkgPSBQW2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIFBqID0gUFtqXSwgdCA9IHRhbmdlbnRzKFBpLCBQaik7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcSBpbiB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gdFtxXSwgc291cmNlID0gUGlbYy50MV0sIHRhcmdldCA9IFBqW2MudDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEVkZ2VJZlZpc2libGUoc291cmNlLCB0YXJnZXQsIGksIGopO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5WID0gZzAuVi5zbGljZSgwKTtcclxuICAgICAgICAgICAgdGhpcy5FID0gZzAuRS5zbGljZSgwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBUYW5nZW50VmlzaWJpbGl0eUdyYXBoLnByb3RvdHlwZS5hZGRFZGdlSWZWaXNpYmxlID0gZnVuY3Rpb24gKHUsIHYsIGkxLCBpMikge1xyXG4gICAgICAgIGlmICghdGhpcy5pbnRlcnNlY3RzUG9seXMobmV3IExpbmVTZWdtZW50KHUueCwgdS55LCB2LngsIHYueSksIGkxLCBpMikpIHtcclxuICAgICAgICAgICAgdGhpcy5FLnB1c2gobmV3IFZpc2liaWxpdHlFZGdlKHUudnYsIHYudnYpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGFuZ2VudFZpc2liaWxpdHlHcmFwaC5wcm90b3R5cGUuYWRkUG9pbnQgPSBmdW5jdGlvbiAocCwgaTEpIHtcclxuICAgICAgICB2YXIgbiA9IHRoaXMuUC5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5WLnB1c2gobmV3IFZpc2liaWxpdHlWZXJ0ZXgodGhpcy5WLmxlbmd0aCwgbiwgMCwgcCkpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChpID09PSBpMSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB2YXIgcG9seSA9IHRoaXMuUFtpXSwgdCA9IHRhbmdlbnRfUG9pbnRQb2x5QyhwLCBwb2x5KTtcclxuICAgICAgICAgICAgdGhpcy5hZGRFZGdlSWZWaXNpYmxlKHAsIHBvbHlbdC5sdGFuXSwgaTEsIGkpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVkZ2VJZlZpc2libGUocCwgcG9seVt0LnJ0YW5dLCBpMSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwLnZ2O1xyXG4gICAgfTtcclxuICAgIFRhbmdlbnRWaXNpYmlsaXR5R3JhcGgucHJvdG90eXBlLmludGVyc2VjdHNQb2x5cyA9IGZ1bmN0aW9uIChsLCBpMSwgaTIpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuUC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKGkgIT0gaTEgJiYgaSAhPSBpMiAmJiBpbnRlcnNlY3RzKGwsIHRoaXMuUFtpXSkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUYW5nZW50VmlzaWJpbGl0eUdyYXBoO1xyXG59KCkpO1xyXG5leHBvcnRzLlRhbmdlbnRWaXNpYmlsaXR5R3JhcGggPSBUYW5nZW50VmlzaWJpbGl0eUdyYXBoO1xyXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGwsIFApIHtcclxuICAgIHZhciBpbnRzID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMSwgbiA9IFAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgdmFyIGludCA9IHJlY3RhbmdsZV8xLlJlY3RhbmdsZS5saW5lSW50ZXJzZWN0aW9uKGwueDEsIGwueTEsIGwueDIsIGwueTIsIFBbaSAtIDFdLngsIFBbaSAtIDFdLnksIFBbaV0ueCwgUFtpXS55KTtcclxuICAgICAgICBpZiAoaW50KVxyXG4gICAgICAgICAgICBpbnRzLnB1c2goaW50KTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbnRzO1xyXG59XHJcbmZ1bmN0aW9uIHRhbmdlbnRzKFYsIFcpIHtcclxuICAgIHZhciBtID0gVi5sZW5ndGggLSAxLCBuID0gVy5sZW5ndGggLSAxO1xyXG4gICAgdmFyIGJ0ID0gbmV3IEJpVGFuZ2VudHMoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbTsgKytpKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyArK2opIHtcclxuICAgICAgICAgICAgdmFyIHYxID0gVltpID09IDAgPyBtIC0gMSA6IGkgLSAxXTtcclxuICAgICAgICAgICAgdmFyIHYyID0gVltpXTtcclxuICAgICAgICAgICAgdmFyIHYzID0gVltpICsgMV07XHJcbiAgICAgICAgICAgIHZhciB3MSA9IFdbaiA9PSAwID8gbiAtIDEgOiBqIC0gMV07XHJcbiAgICAgICAgICAgIHZhciB3MiA9IFdbal07XHJcbiAgICAgICAgICAgIHZhciB3MyA9IFdbaiArIDFdO1xyXG4gICAgICAgICAgICB2YXIgdjF2MncyID0gaXNMZWZ0KHYxLCB2MiwgdzIpO1xyXG4gICAgICAgICAgICB2YXIgdjJ3MXcyID0gaXNMZWZ0KHYyLCB3MSwgdzIpO1xyXG4gICAgICAgICAgICB2YXIgdjJ3MnczID0gaXNMZWZ0KHYyLCB3MiwgdzMpO1xyXG4gICAgICAgICAgICB2YXIgdzF3MnYyID0gaXNMZWZ0KHcxLCB3MiwgdjIpO1xyXG4gICAgICAgICAgICB2YXIgdzJ2MXYyID0gaXNMZWZ0KHcyLCB2MSwgdjIpO1xyXG4gICAgICAgICAgICB2YXIgdzJ2MnYzID0gaXNMZWZ0KHcyLCB2MiwgdjMpO1xyXG4gICAgICAgICAgICBpZiAodjF2MncyID49IDAgJiYgdjJ3MXcyID49IDAgJiYgdjJ3MnczIDwgMFxyXG4gICAgICAgICAgICAgICAgJiYgdzF3MnYyID49IDAgJiYgdzJ2MXYyID49IDAgJiYgdzJ2MnYzIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgYnQubGwgPSBuZXcgQmlUYW5nZW50KGksIGopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHYxdjJ3MiA8PSAwICYmIHYydzF3MiA8PSAwICYmIHYydzJ3MyA+IDBcclxuICAgICAgICAgICAgICAgICYmIHcxdzJ2MiA8PSAwICYmIHcydjF2MiA8PSAwICYmIHcydjJ2MyA+IDApIHtcclxuICAgICAgICAgICAgICAgIGJ0LnJyID0gbmV3IEJpVGFuZ2VudChpLCBqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2MXYydzIgPD0gMCAmJiB2MncxdzIgPiAwICYmIHYydzJ3MyA8PSAwXHJcbiAgICAgICAgICAgICAgICAmJiB3MXcydjIgPj0gMCAmJiB3MnYxdjIgPCAwICYmIHcydjJ2MyA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBidC5ybCA9IG5ldyBCaVRhbmdlbnQoaSwgaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodjF2MncyID49IDAgJiYgdjJ3MXcyIDwgMCAmJiB2MncydzMgPj0gMFxyXG4gICAgICAgICAgICAgICAgJiYgdzF3MnYyIDw9IDAgJiYgdzJ2MXYyID4gMCAmJiB3MnYydjMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgYnQubHIgPSBuZXcgQmlUYW5nZW50KGksIGopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJ0O1xyXG59XHJcbmV4cG9ydHMudGFuZ2VudHMgPSB0YW5nZW50cztcclxuZnVuY3Rpb24gaXNQb2ludEluc2lkZVBvbHkocCwgcG9seSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDEsIG4gPSBwb2x5Lmxlbmd0aDsgaSA8IG47ICsraSlcclxuICAgICAgICBpZiAoYmVsb3cocG9seVtpIC0gMV0sIHBvbHlbaV0sIHApKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBpc0FueVBJblEocCwgcSkge1xyXG4gICAgcmV0dXJuICFwLmV2ZXJ5KGZ1bmN0aW9uICh2KSB7IHJldHVybiAhaXNQb2ludEluc2lkZVBvbHkodiwgcSk7IH0pO1xyXG59XHJcbmZ1bmN0aW9uIHBvbHlzT3ZlcmxhcChwLCBxKSB7XHJcbiAgICBpZiAoaXNBbnlQSW5RKHAsIHEpKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgaWYgKGlzQW55UEluUShxLCBwKSlcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGZvciAodmFyIGkgPSAxLCBuID0gcC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICB2YXIgdiA9IHBbaV0sIHUgPSBwW2kgLSAxXTtcclxuICAgICAgICBpZiAoaW50ZXJzZWN0cyhuZXcgTGluZVNlZ21lbnQodS54LCB1LnksIHYueCwgdi55KSwgcSkubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZXhwb3J0cy5wb2x5c092ZXJsYXAgPSBwb2x5c092ZXJsYXA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlb20uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vcmVjdGFuZ2xlXCIpO1xyXG52YXIgdnBzY18xID0gcmVxdWlyZShcIi4vdnBzY1wiKTtcclxudmFyIHNob3J0ZXN0cGF0aHNfMSA9IHJlcXVpcmUoXCIuL3Nob3J0ZXN0cGF0aHNcIik7XHJcbnZhciBOb2RlV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb2RlV3JhcHBlcihpZCwgcmVjdCwgY2hpbGRyZW4pIHtcclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy5yZWN0ID0gcmVjdDtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAgICAgdGhpcy5sZWFmID0gdHlwZW9mIGNoaWxkcmVuID09PSAndW5kZWZpbmVkJyB8fCBjaGlsZHJlbi5sZW5ndGggPT09IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTm9kZVdyYXBwZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTm9kZVdyYXBwZXIgPSBOb2RlV3JhcHBlcjtcclxudmFyIFZlcnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmVydChpZCwgeCwgeSwgbm9kZSwgbGluZSkge1xyXG4gICAgICAgIGlmIChub2RlID09PSB2b2lkIDApIHsgbm9kZSA9IG51bGw7IH1cclxuICAgICAgICBpZiAobGluZSA9PT0gdm9pZCAwKSB7IGxpbmUgPSBudWxsOyB9XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVmVydDtcclxufSgpKTtcclxuZXhwb3J0cy5WZXJ0ID0gVmVydDtcclxudmFyIExvbmdlc3RDb21tb25TdWJzZXF1ZW5jZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMb25nZXN0Q29tbW9uU3Vic2VxdWVuY2UocywgdCkge1xyXG4gICAgICAgIHRoaXMucyA9IHM7XHJcbiAgICAgICAgdGhpcy50ID0gdDtcclxuICAgICAgICB2YXIgbWYgPSBMb25nZXN0Q29tbW9uU3Vic2VxdWVuY2UuZmluZE1hdGNoKHMsIHQpO1xyXG4gICAgICAgIHZhciB0ciA9IHQuc2xpY2UoMCkucmV2ZXJzZSgpO1xyXG4gICAgICAgIHZhciBtciA9IExvbmdlc3RDb21tb25TdWJzZXF1ZW5jZS5maW5kTWF0Y2gocywgdHIpO1xyXG4gICAgICAgIGlmIChtZi5sZW5ndGggPj0gbXIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbWYubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLnNpID0gbWYuc2k7XHJcbiAgICAgICAgICAgIHRoaXMudGkgPSBtZi50aTtcclxuICAgICAgICAgICAgdGhpcy5yZXZlcnNlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBtci5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMuc2kgPSBtci5zaTtcclxuICAgICAgICAgICAgdGhpcy50aSA9IHQubGVuZ3RoIC0gbXIudGkgLSBtci5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMucmV2ZXJzZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIExvbmdlc3RDb21tb25TdWJzZXF1ZW5jZS5maW5kTWF0Y2ggPSBmdW5jdGlvbiAocywgdCkge1xyXG4gICAgICAgIHZhciBtID0gcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIG4gPSB0Lmxlbmd0aDtcclxuICAgICAgICB2YXIgbWF0Y2ggPSB7IGxlbmd0aDogMCwgc2k6IC0xLCB0aTogLTEgfTtcclxuICAgICAgICB2YXIgbCA9IG5ldyBBcnJheShtKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG07IGkrKykge1xyXG4gICAgICAgICAgICBsW2ldID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKylcclxuICAgICAgICAgICAgICAgIGlmIChzW2ldID09PSB0W2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBsW2ldW2pdID0gKGkgPT09IDAgfHwgaiA9PT0gMCkgPyAxIDogbFtpIC0gMV1baiAtIDFdICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodiA+IG1hdGNoLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5sZW5ndGggPSB2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5zaSA9IGkgLSB2ICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2gudGkgPSBqIC0gdiArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBsW2ldW2pdID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgfTtcclxuICAgIExvbmdlc3RDb21tb25TdWJzZXF1ZW5jZS5wcm90b3R5cGUuZ2V0U2VxdWVuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID49IDAgPyB0aGlzLnMuc2xpY2UodGhpcy5zaSwgdGhpcy5zaSArIHRoaXMubGVuZ3RoKSA6IFtdO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMb25nZXN0Q29tbW9uU3Vic2VxdWVuY2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTG9uZ2VzdENvbW1vblN1YnNlcXVlbmNlID0gTG9uZ2VzdENvbW1vblN1YnNlcXVlbmNlO1xyXG52YXIgR3JpZFJvdXRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBHcmlkUm91dGVyKG9yaWdpbmFsbm9kZXMsIGFjY2Vzc29yLCBncm91cFBhZGRpbmcpIHtcclxuICAgICAgICBpZiAoZ3JvdXBQYWRkaW5nID09PSB2b2lkIDApIHsgZ3JvdXBQYWRkaW5nID0gMTI7IH1cclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxub2RlcyA9IG9yaWdpbmFsbm9kZXM7XHJcbiAgICAgICAgdGhpcy5ncm91cFBhZGRpbmcgPSBncm91cFBhZGRpbmc7XHJcbiAgICAgICAgdGhpcy5sZWF2ZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubm9kZXMgPSBvcmlnaW5hbG5vZGVzLm1hcChmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gbmV3IE5vZGVXcmFwcGVyKGksIGFjY2Vzc29yLmdldEJvdW5kcyh2KSwgYWNjZXNzb3IuZ2V0Q2hpbGRyZW4odikpOyB9KTtcclxuICAgICAgICB0aGlzLmxlYXZlcyA9IHRoaXMubm9kZXMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LmxlYWY7IH0pO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBzID0gdGhpcy5ub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKGcpIHsgcmV0dXJuICFnLmxlYWY7IH0pO1xyXG4gICAgICAgIHRoaXMuY29scyA9IHRoaXMuZ2V0R3JpZExpbmVzKCd4Jyk7XHJcbiAgICAgICAgdGhpcy5yb3dzID0gdGhpcy5nZXRHcmlkTGluZXMoJ3knKTtcclxuICAgICAgICB0aGlzLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIF90aGlzLm5vZGVzW2NdLnBhcmVudCA9IHY7IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucm9vdCA9IHsgY2hpbGRyZW46IFtdIH07XHJcbiAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygdi5wYXJlbnQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2LnBhcmVudCA9IF90aGlzLnJvb3Q7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5yb290LmNoaWxkcmVuLnB1c2godi5pZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdi5wb3J0cyA9IFtdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYmFja1RvRnJvbnQgPSB0aGlzLm5vZGVzLnNsaWNlKDApO1xyXG4gICAgICAgIHRoaXMuYmFja1RvRnJvbnQuc29ydChmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4gX3RoaXMuZ2V0RGVwdGgoeCkgLSBfdGhpcy5nZXREZXB0aCh5KTsgfSk7XHJcbiAgICAgICAgdmFyIGZyb250VG9CYWNrR3JvdXBzID0gdGhpcy5iYWNrVG9Gcm9udC5zbGljZSgwKS5yZXZlcnNlKCkuZmlsdGVyKGZ1bmN0aW9uIChnKSB7IHJldHVybiAhZy5sZWFmOyB9KTtcclxuICAgICAgICBmcm9udFRvQmFja0dyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHZhciByID0gcmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmVtcHR5KCk7XHJcbiAgICAgICAgICAgIHYuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gciA9IHIudW5pb24oX3RoaXMubm9kZXNbY10ucmVjdCk7IH0pO1xyXG4gICAgICAgICAgICB2LnJlY3QgPSByLmluZmxhdGUoX3RoaXMuZ3JvdXBQYWRkaW5nKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgY29sTWlkcyA9IHRoaXMubWlkUG9pbnRzKHRoaXMuY29scy5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIucG9zOyB9KSk7XHJcbiAgICAgICAgdmFyIHJvd01pZHMgPSB0aGlzLm1pZFBvaW50cyh0aGlzLnJvd3MubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnBvczsgfSkpO1xyXG4gICAgICAgIHZhciByb3d4ID0gY29sTWlkc1swXSwgcm93WCA9IGNvbE1pZHNbY29sTWlkcy5sZW5ndGggLSAxXTtcclxuICAgICAgICB2YXIgY29seSA9IHJvd01pZHNbMF0sIGNvbFkgPSByb3dNaWRzW3Jvd01pZHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgdmFyIGhsaW5lcyA9IHRoaXMucm93cy5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuICh7IHgxOiByb3d4LCB4Mjogcm93WCwgeTE6IHIucG9zLCB5Mjogci5wb3MgfSk7IH0pXHJcbiAgICAgICAgICAgIC5jb25jYXQocm93TWlkcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuICh7IHgxOiByb3d4LCB4Mjogcm93WCwgeTE6IG0sIHkyOiBtIH0pOyB9KSk7XHJcbiAgICAgICAgdmFyIHZsaW5lcyA9IHRoaXMuY29scy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuICh7IHgxOiBjLnBvcywgeDI6IGMucG9zLCB5MTogY29seSwgeTI6IGNvbFkgfSk7IH0pXHJcbiAgICAgICAgICAgIC5jb25jYXQoY29sTWlkcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuICh7IHgxOiBtLCB4MjogbSwgeTE6IGNvbHksIHkyOiBjb2xZIH0pOyB9KSk7XHJcbiAgICAgICAgdmFyIGxpbmVzID0gaGxpbmVzLmNvbmNhdCh2bGluZXMpO1xyXG4gICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwudmVydHMgPSBbXTsgfSk7XHJcbiAgICAgICAgdGhpcy52ZXJ0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZWRnZXMgPSBbXTtcclxuICAgICAgICBobGluZXMuZm9yRWFjaChmdW5jdGlvbiAoaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmxpbmVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gbmV3IFZlcnQoX3RoaXMudmVydHMubGVuZ3RoLCB2LngxLCBoLnkxKTtcclxuICAgICAgICAgICAgICAgIGgudmVydHMucHVzaChwKTtcclxuICAgICAgICAgICAgICAgIHYudmVydHMucHVzaChwKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnZlcnRzLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IF90aGlzLmJhY2tUb0Zyb250Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBfdGhpcy5iYWNrVG9Gcm9udFtpXSwgciA9IG5vZGUucmVjdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBNYXRoLmFicyhwLnggLSByLmN4KCkpLCBkeSA9IE1hdGguYWJzKHAueSAtIHIuY3koKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR4IDwgci53aWR0aCgpIC8gMiAmJiBkeSA8IHIuaGVpZ2h0KCkgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobCwgbGkpIHtcclxuICAgICAgICAgICAgX3RoaXMubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICAgICAgdi5yZWN0LmxpbmVJbnRlcnNlY3Rpb25zKGwueDEsIGwueTEsIGwueDIsIGwueTIpLmZvckVhY2goZnVuY3Rpb24gKGludGVyc2VjdCwgaikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gbmV3IFZlcnQoX3RoaXMudmVydHMubGVuZ3RoLCBpbnRlcnNlY3QueCwgaW50ZXJzZWN0LnksIHYsIGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZlcnRzLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbC52ZXJ0cy5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgICAgIHYucG9ydHMucHVzaChwKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGlzSG9yaXogPSBNYXRoLmFicyhsLnkxIC0gbC55MikgPCAwLjE7XHJcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBpc0hvcml6ID8gYi54IC0gYS54IDogYi55IC0gYS55OyB9O1xyXG4gICAgICAgICAgICBsLnZlcnRzLnNvcnQoZGVsdGEpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGwudmVydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB1ID0gbC52ZXJ0c1tpIC0gMV0sIHYgPSBsLnZlcnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHUubm9kZSAmJiB1Lm5vZGUgPT09IHYubm9kZSAmJiB1Lm5vZGUubGVhZilcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmVkZ2VzLnB1c2goeyBzb3VyY2U6IHUuaWQsIHRhcmdldDogdi5pZCwgbGVuZ3RoOiBNYXRoLmFicyhkZWx0YSh1LCB2KSkgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIEdyaWRSb3V0ZXIucHJvdG90eXBlLmF2ZyA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnJlZHVjZShmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCArIHk7IH0pIC8gYS5sZW5ndGg7IH07XHJcbiAgICBHcmlkUm91dGVyLnByb3RvdHlwZS5nZXRHcmlkTGluZXMgPSBmdW5jdGlvbiAoYXhpcykge1xyXG4gICAgICAgIHZhciBjb2x1bW5zID0gW107XHJcbiAgICAgICAgdmFyIGxzID0gdGhpcy5sZWF2ZXMuc2xpY2UoMCwgdGhpcy5sZWF2ZXMubGVuZ3RoKTtcclxuICAgICAgICB3aGlsZSAobHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgb3ZlcmxhcHBpbmcgPSBscy5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYucmVjdFsnb3ZlcmxhcCcgKyBheGlzLnRvVXBwZXJDYXNlKCldKGxzWzBdLnJlY3QpOyB9KTtcclxuICAgICAgICAgICAgdmFyIGNvbCA9IHtcclxuICAgICAgICAgICAgICAgIG5vZGVzOiBvdmVybGFwcGluZyxcclxuICAgICAgICAgICAgICAgIHBvczogdGhpcy5hdmcob3ZlcmxhcHBpbmcubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnJlY3RbJ2MnICsgYXhpc10oKTsgfSkpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbHVtbnMucHVzaChjb2wpO1xyXG4gICAgICAgICAgICBjb2wubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gbHMuc3BsaWNlKGxzLmluZGV4T2YodiksIDEpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29sdW1ucy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLnBvcyAtIGIucG9zOyB9KTtcclxuICAgICAgICByZXR1cm4gY29sdW1ucztcclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLnByb3RvdHlwZS5nZXREZXB0aCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIGRlcHRoID0gMDtcclxuICAgICAgICB3aGlsZSAodi5wYXJlbnQgIT09IHRoaXMucm9vdCkge1xyXG4gICAgICAgICAgICBkZXB0aCsrO1xyXG4gICAgICAgICAgICB2ID0gdi5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZXB0aDtcclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLnByb3RvdHlwZS5taWRQb2ludHMgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHZhciBnYXAgPSBhWzFdIC0gYVswXTtcclxuICAgICAgICB2YXIgbWlkcyA9IFthWzBdIC0gZ2FwIC8gMl07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG1pZHMucHVzaCgoYVtpXSArIGFbaSAtIDFdKSAvIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtaWRzLnB1c2goYVthLmxlbmd0aCAtIDFdICsgZ2FwIC8gMik7XHJcbiAgICAgICAgcmV0dXJuIG1pZHM7XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci5wcm90b3R5cGUuZmluZExpbmVhZ2UgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBsaW5lYWdlID0gW3ZdO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgdiA9IHYucGFyZW50O1xyXG4gICAgICAgICAgICBsaW5lYWdlLnB1c2godik7XHJcbiAgICAgICAgfSB3aGlsZSAodiAhPT0gdGhpcy5yb290KTtcclxuICAgICAgICByZXR1cm4gbGluZWFnZS5yZXZlcnNlKCk7XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci5wcm90b3R5cGUuZmluZEFuY2VzdG9yUGF0aEJldHdlZW4gPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHZhciBhYSA9IHRoaXMuZmluZExpbmVhZ2UoYSksIGJhID0gdGhpcy5maW5kTGluZWFnZShiKSwgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGFhW2ldID09PSBiYVtpXSlcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIHJldHVybiB7IGNvbW1vbkFuY2VzdG9yOiBhYVtpIC0gMV0sIGxpbmVhZ2VzOiBhYS5zbGljZShpKS5jb25jYXQoYmEuc2xpY2UoaSkpIH07XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci5wcm90b3R5cGUuc2libGluZ09ic3RhY2xlcyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuZmluZEFuY2VzdG9yUGF0aEJldHdlZW4oYSwgYik7XHJcbiAgICAgICAgdmFyIGxpbmVhZ2VMb29rdXAgPSB7fTtcclxuICAgICAgICBwYXRoLmxpbmVhZ2VzLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGxpbmVhZ2VMb29rdXBbdi5pZF0gPSB7fTsgfSk7XHJcbiAgICAgICAgdmFyIG9ic3RhY2xlcyA9IHBhdGguY29tbW9uQW5jZXN0b3IuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiAhKHYgaW4gbGluZWFnZUxvb2t1cCk7IH0pO1xyXG4gICAgICAgIHBhdGgubGluZWFnZXNcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodikgeyByZXR1cm4gdi5wYXJlbnQgIT09IHBhdGguY29tbW9uQW5jZXN0b3I7IH0pXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiBvYnN0YWNsZXMgPSBvYnN0YWNsZXMuY29uY2F0KHYucGFyZW50LmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAhPT0gdi5pZDsgfSkpOyB9KTtcclxuICAgICAgICByZXR1cm4gb2JzdGFjbGVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gX3RoaXMubm9kZXNbdl07IH0pO1xyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIuZ2V0U2VnbWVudFNldHMgPSBmdW5jdGlvbiAocm91dGVzLCB4LCB5KSB7XHJcbiAgICAgICAgdmFyIHZzZWdtZW50cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGVpID0gMDsgZWkgPCByb3V0ZXMubGVuZ3RoOyBlaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByb3V0ZSA9IHJvdXRlc1tlaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCByb3V0ZS5sZW5ndGg7IHNpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzID0gcm91dGVbc2ldO1xyXG4gICAgICAgICAgICAgICAgcy5lZGdlaWQgPSBlaTtcclxuICAgICAgICAgICAgICAgIHMuaSA9IHNpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNkeCA9IHNbMV1beF0gLSBzWzBdW3hdO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNkeCkgPCAwLjEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2c2VnbWVudHMucHVzaChzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2c2VnbWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVswXVt4XSAtIGJbMF1beF07IH0pO1xyXG4gICAgICAgIHZhciB2c2VnbWVudHNldHMgPSBbXTtcclxuICAgICAgICB2YXIgc2VnbWVudHNldCA9IG51bGw7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2c2VnbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHMgPSB2c2VnbWVudHNbaV07XHJcbiAgICAgICAgICAgIGlmICghc2VnbWVudHNldCB8fCBNYXRoLmFicyhzWzBdW3hdIC0gc2VnbWVudHNldC5wb3MpID4gMC4xKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50c2V0ID0geyBwb3M6IHNbMF1beF0sIHNlZ21lbnRzOiBbXSB9O1xyXG4gICAgICAgICAgICAgICAgdnNlZ21lbnRzZXRzLnB1c2goc2VnbWVudHNldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VnbWVudHNldC5zZWdtZW50cy5wdXNoKHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdnNlZ21lbnRzZXRzO1xyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIubnVkZ2VTZWdzID0gZnVuY3Rpb24gKHgsIHksIHJvdXRlcywgc2VnbWVudHMsIGxlZnRPZiwgZ2FwKSB7XHJcbiAgICAgICAgdmFyIG4gPSBzZWdtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKG4gPD0gMSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciB2cyA9IHNlZ21lbnRzLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gbmV3IHZwc2NfMS5WYXJpYWJsZShzWzBdW3hdKTsgfSk7XHJcbiAgICAgICAgdmFyIGNzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID09PSBqKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMxID0gc2VnbWVudHNbaV0sIHMyID0gc2VnbWVudHNbal0sIGUxID0gczEuZWRnZWlkLCBlMiA9IHMyLmVkZ2VpZCwgbGluZCA9IC0xLCByaW5kID0gLTE7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA9PSAneCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdE9mKGUxLCBlMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxWzBdW3ldIDwgczFbMV1beV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmQgPSBqLCByaW5kID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmQgPSBpLCByaW5kID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0T2YoZTEsIGUyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoczFbMF1beV0gPCBzMVsxXVt5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZCA9IGksIHJpbmQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZCA9IGosIHJpbmQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmQgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNzLnB1c2gobmV3IHZwc2NfMS5Db25zdHJhaW50KHZzW2xpbmRdLCB2c1tyaW5kXSwgZ2FwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNvbHZlciA9IG5ldyB2cHNjXzEuU29sdmVyKHZzLCBjcyk7XHJcbiAgICAgICAgc29sdmVyLnNvbHZlKCk7XHJcbiAgICAgICAgdnMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICB2YXIgcyA9IHNlZ21lbnRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gdi5wb3NpdGlvbigpO1xyXG4gICAgICAgICAgICBzWzBdW3hdID0gc1sxXVt4XSA9IHBvcztcclxuICAgICAgICAgICAgdmFyIHJvdXRlID0gcm91dGVzW3MuZWRnZWlkXTtcclxuICAgICAgICAgICAgaWYgKHMuaSA+IDApXHJcbiAgICAgICAgICAgICAgICByb3V0ZVtzLmkgLSAxXVsxXVt4XSA9IHBvcztcclxuICAgICAgICAgICAgaWYgKHMuaSA8IHJvdXRlLmxlbmd0aCAtIDEpXHJcbiAgICAgICAgICAgICAgICByb3V0ZVtzLmkgKyAxXVswXVt4XSA9IHBvcztcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLm51ZGdlU2VnbWVudHMgPSBmdW5jdGlvbiAocm91dGVzLCB4LCB5LCBsZWZ0T2YsIGdhcCkge1xyXG4gICAgICAgIHZhciB2c2VnbWVudHNldHMgPSBHcmlkUm91dGVyLmdldFNlZ21lbnRTZXRzKHJvdXRlcywgeCwgeSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2c2VnbWVudHNldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHNzID0gdnNlZ21lbnRzZXRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgZXZlbnRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3Muc2VnbWVudHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzID0gc3Muc2VnbWVudHNbal07XHJcbiAgICAgICAgICAgICAgICBldmVudHMucHVzaCh7IHR5cGU6IDAsIHM6IHMsIHBvczogTWF0aC5taW4oc1swXVt5XSwgc1sxXVt5XSkgfSk7XHJcbiAgICAgICAgICAgICAgICBldmVudHMucHVzaCh7IHR5cGU6IDEsIHM6IHMsIHBvczogTWF0aC5tYXgoc1swXVt5XSwgc1sxXVt5XSkgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXZlbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEucG9zIC0gYi5wb3MgKyBhLnR5cGUgLSBiLnR5cGU7IH0pO1xyXG4gICAgICAgICAgICB2YXIgb3BlbiA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgb3BlbkNvdW50ID0gMDtcclxuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVuLnB1c2goZS5zKTtcclxuICAgICAgICAgICAgICAgICAgICBvcGVuQ291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZW5Db3VudC0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wZW5Db3VudCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgR3JpZFJvdXRlci5udWRnZVNlZ3MoeCwgeSwgcm91dGVzLCBvcGVuLCBsZWZ0T2YsIGdhcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci5wcm90b3R5cGUucm91dGVFZGdlcyA9IGZ1bmN0aW9uIChlZGdlcywgbnVkZ2VHYXAsIHNvdXJjZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcm91dGVQYXRocyA9IGVkZ2VzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMucm91dGUoc291cmNlKGUpLCB0YXJnZXQoZSkpOyB9KTtcclxuICAgICAgICB2YXIgb3JkZXIgPSBHcmlkUm91dGVyLm9yZGVyRWRnZXMocm91dGVQYXRocyk7XHJcbiAgICAgICAgdmFyIHJvdXRlcyA9IHJvdXRlUGF0aHMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBHcmlkUm91dGVyLm1ha2VTZWdtZW50cyhlKTsgfSk7XHJcbiAgICAgICAgR3JpZFJvdXRlci5udWRnZVNlZ21lbnRzKHJvdXRlcywgJ3gnLCAneScsIG9yZGVyLCBudWRnZUdhcCk7XHJcbiAgICAgICAgR3JpZFJvdXRlci5udWRnZVNlZ21lbnRzKHJvdXRlcywgJ3knLCAneCcsIG9yZGVyLCBudWRnZUdhcCk7XHJcbiAgICAgICAgR3JpZFJvdXRlci51bnJldmVyc2VFZGdlcyhyb3V0ZXMsIHJvdXRlUGF0aHMpO1xyXG4gICAgICAgIHJldHVybiByb3V0ZXM7XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci51bnJldmVyc2VFZGdlcyA9IGZ1bmN0aW9uIChyb3V0ZXMsIHJvdXRlUGF0aHMpIHtcclxuICAgICAgICByb3V0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc2VnbWVudHMsIGkpIHtcclxuICAgICAgICAgICAgdmFyIHBhdGggPSByb3V0ZVBhdGhzW2ldO1xyXG4gICAgICAgICAgICBpZiAocGF0aC5yZXZlcnNlZCkge1xyXG4gICAgICAgICAgICAgICAgc2VnbWVudHMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgICAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2VnbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLmFuZ2xlQmV0d2VlbjJMaW5lcyA9IGZ1bmN0aW9uIChsaW5lMSwgbGluZTIpIHtcclxuICAgICAgICB2YXIgYW5nbGUxID0gTWF0aC5hdGFuMihsaW5lMVswXS55IC0gbGluZTFbMV0ueSwgbGluZTFbMF0ueCAtIGxpbmUxWzFdLngpO1xyXG4gICAgICAgIHZhciBhbmdsZTIgPSBNYXRoLmF0YW4yKGxpbmUyWzBdLnkgLSBsaW5lMlsxXS55LCBsaW5lMlswXS54IC0gbGluZTJbMV0ueCk7XHJcbiAgICAgICAgdmFyIGRpZmYgPSBhbmdsZTEgLSBhbmdsZTI7XHJcbiAgICAgICAgaWYgKGRpZmYgPiBNYXRoLlBJIHx8IGRpZmYgPCAtTWF0aC5QSSkge1xyXG4gICAgICAgICAgICBkaWZmID0gYW5nbGUyIC0gYW5nbGUxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGlmZjtcclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLmlzTGVmdCA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgcmV0dXJuICgoYi54IC0gYS54KSAqIChjLnkgLSBhLnkpIC0gKGIueSAtIGEueSkgKiAoYy54IC0gYS54KSkgPD0gMDtcclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLmdldE9yZGVyID0gZnVuY3Rpb24gKHBhaXJzKSB7XHJcbiAgICAgICAgdmFyIG91dGdvaW5nID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcCA9IHBhaXJzW2ldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG91dGdvaW5nW3AubF0gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgb3V0Z29pbmdbcC5sXSA9IHt9O1xyXG4gICAgICAgICAgICBvdXRnb2luZ1twLmxdW3Aucl0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGwsIHIpIHsgcmV0dXJuIHR5cGVvZiBvdXRnb2luZ1tsXSAhPT0gJ3VuZGVmaW5lZCcgJiYgb3V0Z29pbmdbbF1bcl07IH07XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci5vcmRlckVkZ2VzID0gZnVuY3Rpb24gKGVkZ2VzKSB7XHJcbiAgICAgICAgdmFyIGVkZ2VPcmRlciA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGVkZ2VzW2ldLCBmID0gZWRnZXNbal0sIGxjcyA9IG5ldyBMb25nZXN0Q29tbW9uU3Vic2VxdWVuY2UoZSwgZik7XHJcbiAgICAgICAgICAgICAgICB2YXIgdSwgdmksIHZqO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxjcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBpZiAobGNzLnJldmVyc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZi5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZi5yZXZlcnNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGNzID0gbmV3IExvbmdlc3RDb21tb25TdWJzZXF1ZW5jZShlLCBmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgobGNzLnNpIDw9IDAgfHwgbGNzLnRpIDw9IDApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGxjcy5zaSArIGxjcy5sZW5ndGggPj0gZS5sZW5ndGggfHwgbGNzLnRpICsgbGNzLmxlbmd0aCA+PSBmLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlZGdlT3JkZXIucHVzaCh7IGw6IGksIHI6IGogfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobGNzLnNpICsgbGNzLmxlbmd0aCA+PSBlLmxlbmd0aCB8fCBsY3MudGkgKyBsY3MubGVuZ3RoID49IGYubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IGVbbGNzLnNpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmogPSBlW2xjcy5zaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZpID0gZltsY3MudGkgLSAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHUgPSBlW2xjcy5zaSArIGxjcy5sZW5ndGggLSAyXTtcclxuICAgICAgICAgICAgICAgICAgICB2aSA9IGVbbGNzLnNpICsgbGNzLmxlbmd0aF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmogPSBmW2xjcy50aSArIGxjcy5sZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKEdyaWRSb3V0ZXIuaXNMZWZ0KHUsIHZpLCB2aikpIHtcclxuICAgICAgICAgICAgICAgICAgICBlZGdlT3JkZXIucHVzaCh7IGw6IGosIHI6IGkgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlZGdlT3JkZXIucHVzaCh7IGw6IGksIHI6IGogfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEdyaWRSb3V0ZXIuZ2V0T3JkZXIoZWRnZU9yZGVyKTtcclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLm1ha2VTZWdtZW50cyA9IGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gY29weVBvaW50KHApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgeDogcC54LCB5OiBwLnkgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlzU3RyYWlnaHQgPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gTWF0aC5hYnMoKGIueCAtIGEueCkgKiAoYy55IC0gYS55KSAtIChiLnkgLSBhLnkpICogKGMueCAtIGEueCkpIDwgMC4wMDE7IH07XHJcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gW107XHJcbiAgICAgICAgdmFyIGEgPSBjb3B5UG9pbnQocGF0aFswXSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gY29weVBvaW50KHBhdGhbaV0pLCBjID0gaSA8IHBhdGgubGVuZ3RoIC0gMSA/IHBhdGhbaSArIDFdIDogbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFjIHx8ICFpc1N0cmFpZ2h0KGEsIGIsIGMpKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKFthLCBiXSk7XHJcbiAgICAgICAgICAgICAgICBhID0gYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VnbWVudHM7XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci5wcm90b3R5cGUucm91dGUgPSBmdW5jdGlvbiAocywgdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMubm9kZXNbc10sIHRhcmdldCA9IHRoaXMubm9kZXNbdF07XHJcbiAgICAgICAgdGhpcy5vYnN0YWNsZXMgPSB0aGlzLnNpYmxpbmdPYnN0YWNsZXMoc291cmNlLCB0YXJnZXQpO1xyXG4gICAgICAgIHZhciBvYnN0YWNsZUxvb2t1cCA9IHt9O1xyXG4gICAgICAgIHRoaXMub2JzdGFjbGVzLmZvckVhY2goZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG9ic3RhY2xlTG9va3VwW28uaWRdID0gbzsgfSk7XHJcbiAgICAgICAgdGhpcy5wYXNzYWJsZUVkZ2VzID0gdGhpcy5lZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdmFyIHUgPSBfdGhpcy52ZXJ0c1tlLnNvdXJjZV0sIHYgPSBfdGhpcy52ZXJ0c1tlLnRhcmdldF07XHJcbiAgICAgICAgICAgIHJldHVybiAhKHUubm9kZSAmJiB1Lm5vZGUuaWQgaW4gb2JzdGFjbGVMb29rdXBcclxuICAgICAgICAgICAgICAgIHx8IHYubm9kZSAmJiB2Lm5vZGUuaWQgaW4gb2JzdGFjbGVMb29rdXApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc291cmNlLnBvcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB1ID0gc291cmNlLnBvcnRzWzBdLmlkO1xyXG4gICAgICAgICAgICB2YXIgdiA9IHNvdXJjZS5wb3J0c1tpXS5pZDtcclxuICAgICAgICAgICAgdGhpcy5wYXNzYWJsZUVkZ2VzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgc291cmNlOiB1LFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB2LFxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRhcmdldC5wb3J0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdSA9IHRhcmdldC5wb3J0c1swXS5pZDtcclxuICAgICAgICAgICAgdmFyIHYgPSB0YXJnZXQucG9ydHNbaV0uaWQ7XHJcbiAgICAgICAgICAgIHRoaXMucGFzc2FibGVFZGdlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogdSxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogdixcclxuICAgICAgICAgICAgICAgIGxlbmd0aDogMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGdldFNvdXJjZSA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnNvdXJjZTsgfSwgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUudGFyZ2V0OyB9LCBnZXRMZW5ndGggPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5sZW5ndGg7IH07XHJcbiAgICAgICAgdmFyIHNob3J0ZXN0UGF0aENhbGN1bGF0b3IgPSBuZXcgc2hvcnRlc3RwYXRoc18xLkNhbGN1bGF0b3IodGhpcy52ZXJ0cy5sZW5ndGgsIHRoaXMucGFzc2FibGVFZGdlcywgZ2V0U291cmNlLCBnZXRUYXJnZXQsIGdldExlbmd0aCk7XHJcbiAgICAgICAgdmFyIGJlbmRQZW5hbHR5ID0gZnVuY3Rpb24gKHUsIHYsIHcpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBfdGhpcy52ZXJ0c1t1XSwgYiA9IF90aGlzLnZlcnRzW3ZdLCBjID0gX3RoaXMudmVydHNbd107XHJcbiAgICAgICAgICAgIHZhciBkeCA9IE1hdGguYWJzKGMueCAtIGEueCksIGR5ID0gTWF0aC5hYnMoYy55IC0gYS55KTtcclxuICAgICAgICAgICAgaWYgKGEubm9kZSA9PT0gc291cmNlICYmIGEubm9kZSA9PT0gYi5ub2RlIHx8IGIubm9kZSA9PT0gdGFyZ2V0ICYmIGIubm9kZSA9PT0gYy5ub2RlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIHJldHVybiBkeCA+IDEgJiYgZHkgPiAxID8gMTAwMCA6IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgc2hvcnRlc3RQYXRoID0gc2hvcnRlc3RQYXRoQ2FsY3VsYXRvci5QYXRoRnJvbU5vZGVUb05vZGVXaXRoUHJldkNvc3Qoc291cmNlLnBvcnRzWzBdLmlkLCB0YXJnZXQucG9ydHNbMF0uaWQsIGJlbmRQZW5hbHR5KTtcclxuICAgICAgICB2YXIgcGF0aFBvaW50cyA9IHNob3J0ZXN0UGF0aC5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uICh2aSkgeyByZXR1cm4gX3RoaXMudmVydHNbdmldOyB9KTtcclxuICAgICAgICBwYXRoUG9pbnRzLnB1c2godGhpcy5ub2Rlc1t0YXJnZXQuaWRdLnBvcnRzWzBdKTtcclxuICAgICAgICByZXR1cm4gcGF0aFBvaW50cy5maWx0ZXIoZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEoaSA8IHBhdGhQb2ludHMubGVuZ3RoIC0gMSAmJiBwYXRoUG9pbnRzW2kgKyAxXS5ub2RlID09PSBzb3VyY2UgJiYgdi5ub2RlID09PSBzb3VyY2VcclxuICAgICAgICAgICAgICAgIHx8IGkgPiAwICYmIHYubm9kZSA9PT0gdGFyZ2V0ICYmIHBhdGhQb2ludHNbaSAtIDFdLm5vZGUgPT09IHRhcmdldCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci5nZXRSb3V0ZVBhdGggPSBmdW5jdGlvbiAocm91dGUsIGNvcm5lcnJhZGl1cywgYXJyb3d3aWR0aCwgYXJyb3doZWlnaHQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICByb3V0ZXBhdGg6ICdNICcgKyByb3V0ZVswXVswXS54ICsgJyAnICsgcm91dGVbMF1bMF0ueSArICcgJyxcclxuICAgICAgICAgICAgYXJyb3dwYXRoOiAnJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHJvdXRlLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3V0ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpID0gcm91dGVbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGxpWzFdLngsIHkgPSBsaVsxXS55O1xyXG4gICAgICAgICAgICAgICAgdmFyIGR4ID0geCAtIGxpWzBdLng7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHkgPSB5IC0gbGlbMF0ueTtcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgcm91dGUubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkeCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggLT0gZHggLyBNYXRoLmFicyhkeCkgKiBjb3JuZXJyYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5IC09IGR5IC8gTWF0aC5hYnMoZHkpICogY29ybmVycmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucm91dGVwYXRoICs9ICdMICcgKyB4ICsgJyAnICsgeSArICcgJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHJvdXRlW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeDAgPSBsWzBdLngsIHkwID0gbFswXS55O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IGxbMV0ueDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeTEgPSBsWzFdLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgZHggPSB4MSAtIHgwO1xyXG4gICAgICAgICAgICAgICAgICAgIGR5ID0geTEgLSB5MDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBHcmlkUm91dGVyLmFuZ2xlQmV0d2VlbjJMaW5lcyhsaSwgbCkgPCAwID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgyLCB5MjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZHgpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHgwICsgZHggLyBNYXRoLmFicyhkeCkgKiBjb3JuZXJyYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0geTA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHgwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHkwICsgZHkgLyBNYXRoLmFicyhkeSkgKiBjb3JuZXJyYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IE1hdGguYWJzKHgyIC0geCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gTWF0aC5hYnMoeTIgLSB5KTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucm91dGVwYXRoICs9ICdBICcgKyBjeCArICcgJyArIGN5ICsgJyAwIDAgJyArIGFuZ2xlICsgJyAnICsgeDIgKyAnICcgKyB5MiArICcgJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJvd3RpcCA9IFt4LCB5XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyb3djb3JuZXIxLCBhcnJvd2Nvcm5lcjI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGR4KSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCAtPSBkeCAvIE1hdGguYWJzKGR4KSAqIGFycm93aGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJvd2Nvcm5lcjEgPSBbeCwgeSArIGFycm93d2lkdGhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJvd2Nvcm5lcjIgPSBbeCwgeSAtIGFycm93d2lkdGhdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSBkeSAvIE1hdGguYWJzKGR5KSAqIGFycm93aGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJvd2Nvcm5lcjEgPSBbeCArIGFycm93d2lkdGgsIHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJvd2Nvcm5lcjIgPSBbeCAtIGFycm93d2lkdGgsIHldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucm91dGVwYXRoICs9ICdMICcgKyB4ICsgJyAnICsgeSArICcgJztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyb3doZWlnaHQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcnJvd3BhdGggPSAnTSAnICsgYXJyb3d0aXBbMF0gKyAnICcgKyBhcnJvd3RpcFsxXSArICcgTCAnICsgYXJyb3djb3JuZXIxWzBdICsgJyAnICsgYXJyb3djb3JuZXIxWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArICcgTCAnICsgYXJyb3djb3JuZXIyWzBdICsgJyAnICsgYXJyb3djb3JuZXIyWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGxpID0gcm91dGVbMF07XHJcbiAgICAgICAgICAgIHZhciB4ID0gbGlbMV0ueCwgeSA9IGxpWzFdLnk7XHJcbiAgICAgICAgICAgIHZhciBkeCA9IHggLSBsaVswXS54O1xyXG4gICAgICAgICAgICB2YXIgZHkgPSB5IC0gbGlbMF0ueTtcclxuICAgICAgICAgICAgdmFyIGFycm93dGlwID0gW3gsIHldO1xyXG4gICAgICAgICAgICB2YXIgYXJyb3djb3JuZXIxLCBhcnJvd2Nvcm5lcjI7XHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkeCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB4IC09IGR4IC8gTWF0aC5hYnMoZHgpICogYXJyb3doZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBhcnJvd2Nvcm5lcjEgPSBbeCwgeSArIGFycm93d2lkdGhdO1xyXG4gICAgICAgICAgICAgICAgYXJyb3djb3JuZXIyID0gW3gsIHkgLSBhcnJvd3dpZHRoXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHkgLT0gZHkgLyBNYXRoLmFicyhkeSkgKiBhcnJvd2hlaWdodDtcclxuICAgICAgICAgICAgICAgIGFycm93Y29ybmVyMSA9IFt4ICsgYXJyb3d3aWR0aCwgeV07XHJcbiAgICAgICAgICAgICAgICBhcnJvd2Nvcm5lcjIgPSBbeCAtIGFycm93d2lkdGgsIHldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5yb3V0ZXBhdGggKz0gJ0wgJyArIHggKyAnICcgKyB5ICsgJyAnO1xyXG4gICAgICAgICAgICBpZiAoYXJyb3doZWlnaHQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuYXJyb3dwYXRoID0gJ00gJyArIGFycm93dGlwWzBdICsgJyAnICsgYXJyb3d0aXBbMV0gKyAnIEwgJyArIGFycm93Y29ybmVyMVswXSArICcgJyArIGFycm93Y29ybmVyMVsxXVxyXG4gICAgICAgICAgICAgICAgICAgICsgJyBMICcgKyBhcnJvd2Nvcm5lcjJbMF0gKyAnICcgKyBhcnJvd2Nvcm5lcjJbMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gR3JpZFJvdXRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5HcmlkUm91dGVyID0gR3JpZFJvdXRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JpZHJvdXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgcGFja2luZ09wdGlvbnMgPSB7XHJcbiAgICBQQURESU5HOiAxMCxcclxuICAgIEdPTERFTl9TRUNUSU9OOiAoMSArIE1hdGguc3FydCg1KSkgLyAyLFxyXG4gICAgRkxPQVRfRVBTSUxPTjogMC4wMDAxLFxyXG4gICAgTUFYX0lORVJBVElPTlM6IDEwMFxyXG59O1xyXG5mdW5jdGlvbiBhcHBseVBhY2tpbmcoZ3JhcGhzLCB3LCBoLCBub2RlX3NpemUsIGRlc2lyZWRfcmF0aW8pIHtcclxuICAgIGlmIChkZXNpcmVkX3JhdGlvID09PSB2b2lkIDApIHsgZGVzaXJlZF9yYXRpbyA9IDE7IH1cclxuICAgIHZhciBpbml0X3ggPSAwLCBpbml0X3kgPSAwLCBzdmdfd2lkdGggPSB3LCBzdmdfaGVpZ2h0ID0gaCwgZGVzaXJlZF9yYXRpbyA9IHR5cGVvZiBkZXNpcmVkX3JhdGlvICE9PSAndW5kZWZpbmVkJyA/IGRlc2lyZWRfcmF0aW8gOiAxLCBub2RlX3NpemUgPSB0eXBlb2Ygbm9kZV9zaXplICE9PSAndW5kZWZpbmVkJyA/IG5vZGVfc2l6ZSA6IDAsIHJlYWxfd2lkdGggPSAwLCByZWFsX2hlaWdodCA9IDAsIG1pbl93aWR0aCA9IDAsIGdsb2JhbF9ib3R0b20gPSAwLCBsaW5lID0gW107XHJcbiAgICBpZiAoZ3JhcGhzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGNhbGN1bGF0ZV9iYihncmFwaHMpO1xyXG4gICAgYXBwbHkoZ3JhcGhzLCBkZXNpcmVkX3JhdGlvKTtcclxuICAgIHB1dF9ub2Rlc190b19yaWdodF9wb3NpdGlvbnMoZ3JhcGhzKTtcclxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZV9iYihncmFwaHMpIHtcclxuICAgICAgICBncmFwaHMuZm9yRWFjaChmdW5jdGlvbiAoZykge1xyXG4gICAgICAgICAgICBjYWxjdWxhdGVfc2luZ2xlX2JiKGcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZV9zaW5nbGVfYmIoZ3JhcGgpIHtcclxuICAgICAgICAgICAgdmFyIG1pbl94ID0gTnVtYmVyLk1BWF9WQUxVRSwgbWluX3kgPSBOdW1iZXIuTUFYX1ZBTFVFLCBtYXhfeCA9IDAsIG1heF95ID0gMDtcclxuICAgICAgICAgICAgZ3JhcGguYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHcgPSB0eXBlb2Ygdi53aWR0aCAhPT0gJ3VuZGVmaW5lZCcgPyB2LndpZHRoIDogbm9kZV9zaXplO1xyXG4gICAgICAgICAgICAgICAgdmFyIGggPSB0eXBlb2Ygdi5oZWlnaHQgIT09ICd1bmRlZmluZWQnID8gdi5oZWlnaHQgOiBub2RlX3NpemU7XHJcbiAgICAgICAgICAgICAgICB3IC89IDI7XHJcbiAgICAgICAgICAgICAgICBoIC89IDI7XHJcbiAgICAgICAgICAgICAgICBtYXhfeCA9IE1hdGgubWF4KHYueCArIHcsIG1heF94KTtcclxuICAgICAgICAgICAgICAgIG1pbl94ID0gTWF0aC5taW4odi54IC0gdywgbWluX3gpO1xyXG4gICAgICAgICAgICAgICAgbWF4X3kgPSBNYXRoLm1heCh2LnkgKyBoLCBtYXhfeSk7XHJcbiAgICAgICAgICAgICAgICBtaW5feSA9IE1hdGgubWluKHYueSAtIGgsIG1pbl95KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGdyYXBoLndpZHRoID0gbWF4X3ggLSBtaW5feDtcclxuICAgICAgICAgICAgZ3JhcGguaGVpZ2h0ID0gbWF4X3kgLSBtaW5feTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwdXRfbm9kZXNfdG9fcmlnaHRfcG9zaXRpb25zKGdyYXBocykge1xyXG4gICAgICAgIGdyYXBocy5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XHJcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICAgICAgZy5hcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXIueCArPSBub2RlLng7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXIueSArPSBub2RlLnk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjZW50ZXIueCAvPSBnLmFycmF5Lmxlbmd0aDtcclxuICAgICAgICAgICAgY2VudGVyLnkgLz0gZy5hcnJheS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBjb3JuZXIgPSB7IHg6IGNlbnRlci54IC0gZy53aWR0aCAvIDIsIHk6IGNlbnRlci55IC0gZy5oZWlnaHQgLyAyIH07XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB7IHg6IGcueCAtIGNvcm5lci54ICsgc3ZnX3dpZHRoIC8gMiAtIHJlYWxfd2lkdGggLyAyLCB5OiBnLnkgLSBjb3JuZXIueSArIHN2Z19oZWlnaHQgLyAyIC0gcmVhbF9oZWlnaHQgLyAyIH07XHJcbiAgICAgICAgICAgIGcuYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS54ICs9IG9mZnNldC54O1xyXG4gICAgICAgICAgICAgICAgbm9kZS55ICs9IG9mZnNldC55O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFwcGx5KGRhdGEsIGRlc2lyZWRfcmF0aW8pIHtcclxuICAgICAgICB2YXIgY3Vycl9iZXN0X2YgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgdmFyIGN1cnJfYmVzdCA9IDA7XHJcbiAgICAgICAgZGF0YS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiLmhlaWdodCAtIGEuaGVpZ2h0OyB9KTtcclxuICAgICAgICBtaW5fd2lkdGggPSBkYXRhLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS53aWR0aCA8IGIud2lkdGggPyBhLndpZHRoIDogYi53aWR0aDtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgbGVmdCA9IHgxID0gbWluX3dpZHRoO1xyXG4gICAgICAgIHZhciByaWdodCA9IHgyID0gZ2V0X2VudGlyZV93aWR0aChkYXRhKTtcclxuICAgICAgICB2YXIgaXRlcmF0aW9uQ291bnRlciA9IDA7XHJcbiAgICAgICAgdmFyIGZfeDEgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIHZhciBmX3gyID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICB2YXIgZmxhZyA9IC0xO1xyXG4gICAgICAgIHZhciBkeCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgdmFyIGRmID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICB3aGlsZSAoKGR4ID4gbWluX3dpZHRoKSB8fCBkZiA+IHBhY2tpbmdPcHRpb25zLkZMT0FUX0VQU0lMT04pIHtcclxuICAgICAgICAgICAgaWYgKGZsYWcgIT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHgxID0gcmlnaHQgLSAocmlnaHQgLSBsZWZ0KSAvIHBhY2tpbmdPcHRpb25zLkdPTERFTl9TRUNUSU9OO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZfeDEgPSBzdGVwKGRhdGEsIHgxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmxhZyAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeDIgPSBsZWZ0ICsgKHJpZ2h0IC0gbGVmdCkgLyBwYWNraW5nT3B0aW9ucy5HT0xERU5fU0VDVElPTjtcclxuICAgICAgICAgICAgICAgIHZhciBmX3gyID0gc3RlcChkYXRhLCB4Mik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZHggPSBNYXRoLmFicyh4MSAtIHgyKTtcclxuICAgICAgICAgICAgZGYgPSBNYXRoLmFicyhmX3gxIC0gZl94Mik7XHJcbiAgICAgICAgICAgIGlmIChmX3gxIDwgY3Vycl9iZXN0X2YpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJfYmVzdF9mID0gZl94MTtcclxuICAgICAgICAgICAgICAgIGN1cnJfYmVzdCA9IHgxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmX3gyIDwgY3Vycl9iZXN0X2YpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJfYmVzdF9mID0gZl94MjtcclxuICAgICAgICAgICAgICAgIGN1cnJfYmVzdCA9IHgyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmX3gxID4gZl94Mikge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IHgxO1xyXG4gICAgICAgICAgICAgICAgeDEgPSB4MjtcclxuICAgICAgICAgICAgICAgIGZfeDEgPSBmX3gyO1xyXG4gICAgICAgICAgICAgICAgZmxhZyA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IHgyO1xyXG4gICAgICAgICAgICAgICAgeDIgPSB4MTtcclxuICAgICAgICAgICAgICAgIGZfeDIgPSBmX3gxO1xyXG4gICAgICAgICAgICAgICAgZmxhZyA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGl0ZXJhdGlvbkNvdW50ZXIrKyA+IDEwMCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3RlcChkYXRhLCBjdXJyX2Jlc3QpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChkYXRhLCBtYXhfd2lkdGgpIHtcclxuICAgICAgICBsaW5lID0gW107XHJcbiAgICAgICAgcmVhbF93aWR0aCA9IDA7XHJcbiAgICAgICAgcmVhbF9oZWlnaHQgPSAwO1xyXG4gICAgICAgIGdsb2JhbF9ib3R0b20gPSBpbml0X3k7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBvID0gZGF0YVtpXTtcclxuICAgICAgICAgICAgcHV0X3JlY3QobywgbWF4X3dpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGdldF9yZWFsX3JhdGlvKCkgLSBkZXNpcmVkX3JhdGlvKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHB1dF9yZWN0KHJlY3QsIG1heF93aWR0aCkge1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICgobGluZVtpXS5zcGFjZV9sZWZ0ID49IHJlY3QuaGVpZ2h0KSAmJiAobGluZVtpXS54ICsgbGluZVtpXS53aWR0aCArIHJlY3Qud2lkdGggKyBwYWNraW5nT3B0aW9ucy5QQURESU5HIC0gbWF4X3dpZHRoKSA8PSBwYWNraW5nT3B0aW9ucy5GTE9BVF9FUFNJTE9OKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBsaW5lW2ldO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGluZS5wdXNoKHJlY3QpO1xyXG4gICAgICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZWN0LnggPSBwYXJlbnQueCArIHBhcmVudC53aWR0aCArIHBhY2tpbmdPcHRpb25zLlBBRERJTkc7XHJcbiAgICAgICAgICAgIHJlY3QueSA9IHBhcmVudC5ib3R0b207XHJcbiAgICAgICAgICAgIHJlY3Quc3BhY2VfbGVmdCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICByZWN0LmJvdHRvbSA9IHJlY3QueTtcclxuICAgICAgICAgICAgcGFyZW50LnNwYWNlX2xlZnQgLT0gcmVjdC5oZWlnaHQgKyBwYWNraW5nT3B0aW9ucy5QQURESU5HO1xyXG4gICAgICAgICAgICBwYXJlbnQuYm90dG9tICs9IHJlY3QuaGVpZ2h0ICsgcGFja2luZ09wdGlvbnMuUEFERElORztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlY3QueSA9IGdsb2JhbF9ib3R0b207XHJcbiAgICAgICAgICAgIGdsb2JhbF9ib3R0b20gKz0gcmVjdC5oZWlnaHQgKyBwYWNraW5nT3B0aW9ucy5QQURESU5HO1xyXG4gICAgICAgICAgICByZWN0LnggPSBpbml0X3g7XHJcbiAgICAgICAgICAgIHJlY3QuYm90dG9tID0gcmVjdC55O1xyXG4gICAgICAgICAgICByZWN0LnNwYWNlX2xlZnQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlY3QueSArIHJlY3QuaGVpZ2h0IC0gcmVhbF9oZWlnaHQgPiAtcGFja2luZ09wdGlvbnMuRkxPQVRfRVBTSUxPTilcclxuICAgICAgICAgICAgcmVhbF9oZWlnaHQgPSByZWN0LnkgKyByZWN0LmhlaWdodCAtIGluaXRfeTtcclxuICAgICAgICBpZiAocmVjdC54ICsgcmVjdC53aWR0aCAtIHJlYWxfd2lkdGggPiAtcGFja2luZ09wdGlvbnMuRkxPQVRfRVBTSUxPTilcclxuICAgICAgICAgICAgcmVhbF93aWR0aCA9IHJlY3QueCArIHJlY3Qud2lkdGggLSBpbml0X3g7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBmdW5jdGlvbiBnZXRfZW50aXJlX3dpZHRoKGRhdGEpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSAwO1xyXG4gICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gd2lkdGggKz0gZC53aWR0aCArIHBhY2tpbmdPcHRpb25zLlBBRERJTkc7IH0pO1xyXG4gICAgICAgIHJldHVybiB3aWR0aDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldF9yZWFsX3JhdGlvKCkge1xyXG4gICAgICAgIHJldHVybiAocmVhbF93aWR0aCAvIHJlYWxfaGVpZ2h0KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmFwcGx5UGFja2luZyA9IGFwcGx5UGFja2luZztcclxuZnVuY3Rpb24gc2VwYXJhdGVHcmFwaHMobm9kZXMsIGxpbmtzKSB7XHJcbiAgICB2YXIgbWFya3MgPSB7fTtcclxuICAgIHZhciB3YXlzID0ge307XHJcbiAgICB2YXIgZ3JhcGhzID0gW107XHJcbiAgICB2YXIgY2x1c3RlcnMgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBsaW5rID0gbGlua3NbaV07XHJcbiAgICAgICAgdmFyIG4xID0gbGluay5zb3VyY2U7XHJcbiAgICAgICAgdmFyIG4yID0gbGluay50YXJnZXQ7XHJcbiAgICAgICAgaWYgKHdheXNbbjEuaW5kZXhdKVxyXG4gICAgICAgICAgICB3YXlzW24xLmluZGV4XS5wdXNoKG4yKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHdheXNbbjEuaW5kZXhdID0gW24yXTtcclxuICAgICAgICBpZiAod2F5c1tuMi5pbmRleF0pXHJcbiAgICAgICAgICAgIHdheXNbbjIuaW5kZXhdLnB1c2gobjEpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgd2F5c1tuMi5pbmRleF0gPSBbbjFdO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgaWYgKG1hcmtzW25vZGUuaW5kZXhdKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBleHBsb3JlX25vZGUobm9kZSwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHBsb3JlX25vZGUobiwgaXNfbmV3KSB7XHJcbiAgICAgICAgaWYgKG1hcmtzW24uaW5kZXhdICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAoaXNfbmV3KSB7XHJcbiAgICAgICAgICAgIGNsdXN0ZXJzKys7XHJcbiAgICAgICAgICAgIGdyYXBocy5wdXNoKHsgYXJyYXk6IFtdIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrc1tuLmluZGV4XSA9IGNsdXN0ZXJzO1xyXG4gICAgICAgIGdyYXBoc1tjbHVzdGVycyAtIDFdLmFycmF5LnB1c2gobik7XHJcbiAgICAgICAgdmFyIGFkamFjZW50ID0gd2F5c1tuLmluZGV4XTtcclxuICAgICAgICBpZiAoIWFkamFjZW50KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhZGphY2VudC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBleHBsb3JlX25vZGUoYWRqYWNlbnRbal0sIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ3JhcGhzO1xyXG59XHJcbmV4cG9ydHMuc2VwYXJhdGVHcmFwaHMgPSBzZXBhcmF0ZUdyYXBocztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFuZGxlZGlzY29ubmVjdGVkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBwb3dlcmdyYXBoID0gcmVxdWlyZShcIi4vcG93ZXJncmFwaFwiKTtcclxudmFyIGxpbmtsZW5ndGhzXzEgPSByZXF1aXJlKFwiLi9saW5rbGVuZ3Roc1wiKTtcclxudmFyIGRlc2NlbnRfMSA9IHJlcXVpcmUoXCIuL2Rlc2NlbnRcIik7XHJcbnZhciByZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL3JlY3RhbmdsZVwiKTtcclxudmFyIHNob3J0ZXN0cGF0aHNfMSA9IHJlcXVpcmUoXCIuL3Nob3J0ZXN0cGF0aHNcIik7XHJcbnZhciBnZW9tXzEgPSByZXF1aXJlKFwiLi9nZW9tXCIpO1xyXG52YXIgaGFuZGxlZGlzY29ubmVjdGVkXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVkaXNjb25uZWN0ZWRcIik7XHJcbnZhciBFdmVudFR5cGU7XHJcbihmdW5jdGlvbiAoRXZlbnRUeXBlKSB7XHJcbiAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wic3RhcnRcIl0gPSAwXSA9IFwic3RhcnRcIjtcclxuICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJ0aWNrXCJdID0gMV0gPSBcInRpY2tcIjtcclxuICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJlbmRcIl0gPSAyXSA9IFwiZW5kXCI7XHJcbn0pKEV2ZW50VHlwZSA9IGV4cG9ydHMuRXZlbnRUeXBlIHx8IChleHBvcnRzLkV2ZW50VHlwZSA9IHt9KSk7XHJcbjtcclxuZnVuY3Rpb24gaXNHcm91cChnKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGcubGVhdmVzICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZy5ncm91cHMgIT09ICd1bmRlZmluZWQnO1xyXG59XHJcbnZhciBMYXlvdXQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTGF5b3V0KCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzU2l6ZSA9IFsxLCAxXTtcclxuICAgICAgICB0aGlzLl9saW5rRGlzdGFuY2UgPSAyMDtcclxuICAgICAgICB0aGlzLl9kZWZhdWx0Tm9kZVNpemUgPSAxMDtcclxuICAgICAgICB0aGlzLl9saW5rTGVuZ3RoQ2FsY3VsYXRvciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbGlua1R5cGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2F2b2lkT3ZlcmxhcHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVEaXNjb25uZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9ub2RlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2dyb3VwcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3Jvb3RHcm91cCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbGlua3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9jb25zdHJhaW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlTWF0cml4ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9kZXNjZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9kaXJlY3RlZExpbmtDb25zdHJhaW50cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGhyZXNob2xkID0gMC4wMTtcclxuICAgICAgICB0aGlzLl92aXNpYmlsaXR5R3JhcGggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2dyb3VwQ29tcGFjdG5lc3MgPSAxZS02O1xyXG4gICAgICAgIHRoaXMuZXZlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGlua0FjY2Vzc29yID0ge1xyXG4gICAgICAgICAgICBnZXRTb3VyY2VJbmRleDogTGF5b3V0LmdldFNvdXJjZUluZGV4LFxyXG4gICAgICAgICAgICBnZXRUYXJnZXRJbmRleDogTGF5b3V0LmdldFRhcmdldEluZGV4LFxyXG4gICAgICAgICAgICBzZXRMZW5ndGg6IExheW91dC5zZXRMaW5rTGVuZ3RoLFxyXG4gICAgICAgICAgICBnZXRUeXBlOiBmdW5jdGlvbiAobCkgeyByZXR1cm4gdHlwZW9mIF90aGlzLl9saW5rVHlwZSA9PT0gXCJmdW5jdGlvblwiID8gX3RoaXMuX2xpbmtUeXBlKGwpIDogMDsgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmV2ZW50KVxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50ID0ge307XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50W0V2ZW50VHlwZVtlXV0gPSBsaXN0ZW5lcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRbZV0gPSBsaXN0ZW5lcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBpZiAodGhpcy5ldmVudCAmJiB0eXBlb2YgdGhpcy5ldmVudFtlLnR5cGVdICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50W2UudHlwZV0oZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUua2ljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB3aGlsZSAoIXRoaXMudGljaygpKVxyXG4gICAgICAgICAgICA7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9hbHBoYSA8IHRoaXMuX3RocmVzaG9sZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6IEV2ZW50VHlwZS5lbmQsIGFscGhhOiB0aGlzLl9hbHBoYSA9IDAsIHN0cmVzczogdGhpcy5fbGFzdFN0cmVzcyB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuID0gdGhpcy5fbm9kZXMubGVuZ3RoLCBtID0gdGhpcy5fbGlua3MubGVuZ3RoO1xyXG4gICAgICAgIHZhciBvLCBpO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NlbnQubG9ja3MuY2xlYXIoKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgIG8gPSB0aGlzLl9ub2Rlc1tpXTtcclxuICAgICAgICAgICAgaWYgKG8uZml4ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygby5weCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIG8ucHkgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5weCA9IG8ueDtcclxuICAgICAgICAgICAgICAgICAgICBvLnB5ID0gby55O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBbby5weCwgby5weV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXNjZW50LmxvY2tzLmFkZChpLCBwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgczEgPSB0aGlzLl9kZXNjZW50LnJ1bmdlS3V0dGEoKTtcclxuICAgICAgICBpZiAoczEgPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fYWxwaGEgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5fbGFzdFN0cmVzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWxwaGEgPSBzMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbGFzdFN0cmVzcyA9IHMxO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTm9kZVBvc2l0aW9ucygpO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6IEV2ZW50VHlwZS50aWNrLCBhbHBoYTogdGhpcy5fYWxwaGEsIHN0cmVzczogdGhpcy5fbGFzdFN0cmVzcyB9KTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS51cGRhdGVOb2RlUG9zaXRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcy5fZGVzY2VudC54WzBdLCB5ID0gdGhpcy5fZGVzY2VudC54WzFdO1xyXG4gICAgICAgIHZhciBvLCBpID0gdGhpcy5fbm9kZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgbyA9IHRoaXMuX25vZGVzW2ldO1xyXG4gICAgICAgICAgICBvLnggPSB4W2ldO1xyXG4gICAgICAgICAgICBvLnkgPSB5W2ldO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLm5vZGVzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIXYpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX25vZGVzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLl9saW5rcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IE1hdGgubWF4KG4sIGwuc291cmNlLCBsLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX25vZGVzID0gbmV3IEFycmF5KCsrbik7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25vZGVzW2ldID0ge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ub2RlcyA9IHY7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5ncm91cHMgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCF4KVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBzO1xyXG4gICAgICAgIHRoaXMuX2dyb3VwcyA9IHg7XHJcbiAgICAgICAgdGhpcy5fcm9vdEdyb3VwID0ge307XHJcbiAgICAgICAgdGhpcy5fZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGcpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBnLnBhZGRpbmcgPT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgICAgICAgICBnLnBhZGRpbmcgPSAxO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGcubGVhdmVzICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBnLmxlYXZlcy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGcubGVhdmVzW2ldID0gX3RoaXMuX25vZGVzW3ZdKS5wYXJlbnQgPSBnO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBnLmdyb3VwcyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgZy5ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ2ksIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGdpID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGcuZ3JvdXBzW2ldID0gX3RoaXMuX2dyb3Vwc1tnaV0pLnBhcmVudCA9IGc7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3Jvb3RHcm91cC5sZWF2ZXMgPSB0aGlzLl9ub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHR5cGVvZiB2LnBhcmVudCA9PT0gJ3VuZGVmaW5lZCc7IH0pO1xyXG4gICAgICAgIHRoaXMuX3Jvb3RHcm91cC5ncm91cHMgPSB0aGlzLl9ncm91cHMuZmlsdGVyKGZ1bmN0aW9uIChnKSB7IHJldHVybiB0eXBlb2YgZy5wYXJlbnQgPT09ICd1bmRlZmluZWQnOyB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLnBvd2VyR3JhcGhHcm91cHMgPSBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgIHZhciBnID0gcG93ZXJncmFwaC5nZXRHcm91cHModGhpcy5fbm9kZXMsIHRoaXMuX2xpbmtzLCB0aGlzLmxpbmtBY2Nlc3NvciwgdGhpcy5fcm9vdEdyb3VwKTtcclxuICAgICAgICB0aGlzLmdyb3VwcyhnLmdyb3Vwcyk7XHJcbiAgICAgICAgZihnKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmF2b2lkT3ZlcmxhcHMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F2b2lkT3ZlcmxhcHM7XHJcbiAgICAgICAgdGhpcy5fYXZvaWRPdmVybGFwcyA9IHY7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5oYW5kbGVEaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZURpc2Nvbm5lY3RlZDtcclxuICAgICAgICB0aGlzLl9oYW5kbGVEaXNjb25uZWN0ZWQgPSB2O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuZmxvd0xheW91dCA9IGZ1bmN0aW9uIChheGlzLCBtaW5TZXBhcmF0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgICAgICBheGlzID0gJ3knO1xyXG4gICAgICAgIHRoaXMuX2RpcmVjdGVkTGlua0NvbnN0cmFpbnRzID0ge1xyXG4gICAgICAgICAgICBheGlzOiBheGlzLFxyXG4gICAgICAgICAgICBnZXRNaW5TZXBhcmF0aW9uOiB0eXBlb2YgbWluU2VwYXJhdGlvbiA9PT0gJ251bWJlcicgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBtaW5TZXBhcmF0aW9uOyB9IDogbWluU2VwYXJhdGlvblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5saW5rcyA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlua3M7XHJcbiAgICAgICAgdGhpcy5fbGlua3MgPSB4O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuY29uc3RyYWludHMgPSBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0cmFpbnRzO1xyXG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gYztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmRpc3RhbmNlTWF0cml4ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZU1hdHJpeDtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZU1hdHJpeCA9IGQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZiAoIXgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNTaXplO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhc1NpemUgPSB4O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuZGVmYXVsdE5vZGVTaXplID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZiAoIXgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0Tm9kZVNpemU7XHJcbiAgICAgICAgdGhpcy5fZGVmYXVsdE5vZGVTaXplID0geDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmdyb3VwQ29tcGFjdG5lc3MgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICgheClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwQ29tcGFjdG5lc3M7XHJcbiAgICAgICAgdGhpcy5fZ3JvdXBDb21wYWN0bmVzcyA9IHg7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5saW5rRGlzdGFuY2UgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICgheCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlua0Rpc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9saW5rRGlzdGFuY2UgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6ICt4O1xyXG4gICAgICAgIHRoaXMuX2xpbmtMZW5ndGhDYWxjdWxhdG9yID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmxpbmtUeXBlID0gZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICB0aGlzLl9saW5rVHlwZSA9IGY7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5jb252ZXJnZW5jZVRocmVzaG9sZCA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKCF4KVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyZXNob2xkO1xyXG4gICAgICAgIHRoaXMuX3RocmVzaG9sZCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogK3g7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5hbHBoYSA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxwaGE7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHggPSAreDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2FscGhhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWxwaGEgPSB4O1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FscGhhID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ydW5uaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogRXZlbnRUeXBlLnN0YXJ0LCBhbHBoYTogdGhpcy5fYWxwaGEgPSB4IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2ljaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmdldExpbmtMZW5ndGggPSBmdW5jdGlvbiAobGluaykge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fbGlua0Rpc3RhbmNlID09PSBcImZ1bmN0aW9uXCIgPyArKHRoaXMuX2xpbmtEaXN0YW5jZShsaW5rKSkgOiB0aGlzLl9saW5rRGlzdGFuY2U7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnNldExpbmtMZW5ndGggPSBmdW5jdGlvbiAobGluaywgbGVuZ3RoKSB7XHJcbiAgICAgICAgbGluay5sZW5ndGggPSBsZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5nZXRMaW5rVHlwZSA9IGZ1bmN0aW9uIChsaW5rKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9saW5rVHlwZSA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5fbGlua1R5cGUobGluaykgOiAwO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuc3ltbWV0cmljRGlmZkxpbmtMZW5ndGhzID0gZnVuY3Rpb24gKGlkZWFsTGVuZ3RoLCB3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodyA9PT0gdm9pZCAwKSB7IHcgPSAxOyB9XHJcbiAgICAgICAgdGhpcy5saW5rRGlzdGFuY2UoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGlkZWFsTGVuZ3RoICogbC5sZW5ndGg7IH0pO1xyXG4gICAgICAgIHRoaXMuX2xpbmtMZW5ndGhDYWxjdWxhdG9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2xlbmd0aHNfMS5zeW1tZXRyaWNEaWZmTGlua0xlbmd0aHMoX3RoaXMuX2xpbmtzLCBfdGhpcy5saW5rQWNjZXNzb3IsIHcpOyB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuamFjY2FyZExpbmtMZW5ndGhzID0gZnVuY3Rpb24gKGlkZWFsTGVuZ3RoLCB3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodyA9PT0gdm9pZCAwKSB7IHcgPSAxOyB9XHJcbiAgICAgICAgdGhpcy5saW5rRGlzdGFuY2UoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGlkZWFsTGVuZ3RoICogbC5sZW5ndGg7IH0pO1xyXG4gICAgICAgIHRoaXMuX2xpbmtMZW5ndGhDYWxjdWxhdG9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2xlbmd0aHNfMS5qYWNjYXJkTGlua0xlbmd0aHMoX3RoaXMuX2xpbmtzLCBfdGhpcy5saW5rQWNjZXNzb3IsIHcpOyB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoaW5pdGlhbFVuY29uc3RyYWluZWRJdGVyYXRpb25zLCBpbml0aWFsVXNlckNvbnN0cmFpbnRJdGVyYXRpb25zLCBpbml0aWFsQWxsQ29uc3RyYWludHNJdGVyYXRpb25zLCBncmlkU25hcEl0ZXJhdGlvbnMsIGtlZXBSdW5uaW5nKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoaW5pdGlhbFVuY29uc3RyYWluZWRJdGVyYXRpb25zID09PSB2b2lkIDApIHsgaW5pdGlhbFVuY29uc3RyYWluZWRJdGVyYXRpb25zID0gMDsgfVxyXG4gICAgICAgIGlmIChpbml0aWFsVXNlckNvbnN0cmFpbnRJdGVyYXRpb25zID09PSB2b2lkIDApIHsgaW5pdGlhbFVzZXJDb25zdHJhaW50SXRlcmF0aW9ucyA9IDA7IH1cclxuICAgICAgICBpZiAoaW5pdGlhbEFsbENvbnN0cmFpbnRzSXRlcmF0aW9ucyA9PT0gdm9pZCAwKSB7IGluaXRpYWxBbGxDb25zdHJhaW50c0l0ZXJhdGlvbnMgPSAwOyB9XHJcbiAgICAgICAgaWYgKGdyaWRTbmFwSXRlcmF0aW9ucyA9PT0gdm9pZCAwKSB7IGdyaWRTbmFwSXRlcmF0aW9ucyA9IDA7IH1cclxuICAgICAgICBpZiAoa2VlcFJ1bm5pbmcgPT09IHZvaWQgMCkgeyBrZWVwUnVubmluZyA9IHRydWU7IH1cclxuICAgICAgICB2YXIgaSwgaiwgbiA9IHRoaXMubm9kZXMoKS5sZW5ndGgsIE4gPSBuICsgMiAqIHRoaXMuX2dyb3Vwcy5sZW5ndGgsIG0gPSB0aGlzLl9saW5rcy5sZW5ndGgsIHcgPSB0aGlzLl9jYW52YXNTaXplWzBdLCBoID0gdGhpcy5fY2FudmFzU2l6ZVsxXTtcclxuICAgICAgICB2YXIgeCA9IG5ldyBBcnJheShOKSwgeSA9IG5ldyBBcnJheShOKTtcclxuICAgICAgICB2YXIgRyA9IG51bGw7XHJcbiAgICAgICAgdmFyIGFvID0gdGhpcy5fYXZvaWRPdmVybGFwcztcclxuICAgICAgICB0aGlzLl9ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XHJcbiAgICAgICAgICAgIHYuaW5kZXggPSBpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYueCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIHYueCA9IHcgLyAyLCB2LnkgPSBoIC8gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4W2ldID0gdi54LCB5W2ldID0gdi55O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLl9saW5rTGVuZ3RoQ2FsY3VsYXRvcilcclxuICAgICAgICAgICAgdGhpcy5fbGlua0xlbmd0aENhbGN1bGF0b3IoKTtcclxuICAgICAgICB2YXIgZGlzdGFuY2VzO1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXN0YW5jZU1hdHJpeCkge1xyXG4gICAgICAgICAgICBkaXN0YW5jZXMgPSB0aGlzLl9kaXN0YW5jZU1hdHJpeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRpc3RhbmNlcyA9IChuZXcgc2hvcnRlc3RwYXRoc18xLkNhbGN1bGF0b3IoTiwgdGhpcy5fbGlua3MsIExheW91dC5nZXRTb3VyY2VJbmRleCwgTGF5b3V0LmdldFRhcmdldEluZGV4LCBmdW5jdGlvbiAobCkgeyByZXR1cm4gX3RoaXMuZ2V0TGlua0xlbmd0aChsKTsgfSkpLkRpc3RhbmNlTWF0cml4KCk7XHJcbiAgICAgICAgICAgIEcgPSBkZXNjZW50XzEuRGVzY2VudC5jcmVhdGVTcXVhcmVNYXRyaXgoTiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gMjsgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmtzLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbC5zb3VyY2UgPT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgICAgICAgICBsLnNvdXJjZSA9IF90aGlzLl9ub2Rlc1tsLnNvdXJjZV07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGwudGFyZ2V0ID09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbC50YXJnZXQgPSBfdGhpcy5fbm9kZXNbbC50YXJnZXRdO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fbGlua3MuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHUgPSBMYXlvdXQuZ2V0U291cmNlSW5kZXgoZSksIHYgPSBMYXlvdXQuZ2V0VGFyZ2V0SW5kZXgoZSk7XHJcbiAgICAgICAgICAgICAgICBHW3VdW3ZdID0gR1t2XVt1XSA9IGUud2VpZ2h0IHx8IDE7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgRCA9IGRlc2NlbnRfMS5EZXNjZW50LmNyZWF0ZVNxdWFyZU1hdHJpeChOLCBmdW5jdGlvbiAoaSwgaikge1xyXG4gICAgICAgICAgICByZXR1cm4gZGlzdGFuY2VzW2ldW2pdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290R3JvdXAgJiYgdHlwZW9mIHRoaXMuX3Jvb3RHcm91cC5ncm91cHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gbjtcclxuICAgICAgICAgICAgdmFyIGFkZEF0dHJhY3Rpb24gPSBmdW5jdGlvbiAoaSwgaiwgc3RyZW5ndGgsIGlkZWFsRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIEdbaV1bal0gPSBHW2pdW2ldID0gc3RyZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBEW2ldW2pdID0gRFtqXVtpXSA9IGlkZWFsRGlzdGFuY2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX2dyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRBdHRyYWN0aW9uKGksIGkgKyAxLCBfdGhpcy5fZ3JvdXBDb21wYWN0bmVzcywgMC4xKTtcclxuICAgICAgICAgICAgICAgIHhbaV0gPSAwLCB5W2krK10gPSAwO1xyXG4gICAgICAgICAgICAgICAgeFtpXSA9IDAsIHlbaSsrXSA9IDA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RHcm91cCA9IHsgbGVhdmVzOiB0aGlzLl9ub2RlcywgZ3JvdXBzOiBbXSB9O1xyXG4gICAgICAgIHZhciBjdXJDb25zdHJhaW50cyA9IHRoaXMuX2NvbnN0cmFpbnRzIHx8IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3RlZExpbmtDb25zdHJhaW50cykge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmtBY2Nlc3Nvci5nZXRNaW5TZXBhcmF0aW9uID0gdGhpcy5fZGlyZWN0ZWRMaW5rQ29uc3RyYWludHMuZ2V0TWluU2VwYXJhdGlvbjtcclxuICAgICAgICAgICAgY3VyQ29uc3RyYWludHMgPSBjdXJDb25zdHJhaW50cy5jb25jYXQobGlua2xlbmd0aHNfMS5nZW5lcmF0ZURpcmVjdGVkRWRnZUNvbnN0cmFpbnRzKG4sIHRoaXMuX2xpbmtzLCB0aGlzLl9kaXJlY3RlZExpbmtDb25zdHJhaW50cy5heGlzLCAodGhpcy5saW5rQWNjZXNzb3IpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXZvaWRPdmVybGFwcyhmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5fZGVzY2VudCA9IG5ldyBkZXNjZW50XzEuRGVzY2VudChbeCwgeV0sIEQpO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NlbnQubG9ja3MuY2xlYXIoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgbyA9IHRoaXMuX25vZGVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoby5maXhlZCkge1xyXG4gICAgICAgICAgICAgICAgby5weCA9IG8ueDtcclxuICAgICAgICAgICAgICAgIG8ucHkgPSBvLnk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IFtvLngsIG8ueV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXNjZW50LmxvY2tzLmFkZChpLCBwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kZXNjZW50LnRocmVzaG9sZCA9IHRoaXMuX3RocmVzaG9sZDtcclxuICAgICAgICB0aGlzLmluaXRpYWxMYXlvdXQoaW5pdGlhbFVuY29uc3RyYWluZWRJdGVyYXRpb25zLCB4LCB5KTtcclxuICAgICAgICBpZiAoY3VyQ29uc3RyYWludHMubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgdGhpcy5fZGVzY2VudC5wcm9qZWN0ID0gbmV3IHJlY3RhbmdsZV8xLlByb2plY3Rpb24odGhpcy5fbm9kZXMsIHRoaXMuX2dyb3VwcywgdGhpcy5fcm9vdEdyb3VwLCBjdXJDb25zdHJhaW50cykucHJvamVjdEZ1bmN0aW9ucygpO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NlbnQucnVuKGluaXRpYWxVc2VyQ29uc3RyYWludEl0ZXJhdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuc2VwYXJhdGVPdmVybGFwcGluZ0NvbXBvbmVudHModywgaCk7XHJcbiAgICAgICAgdGhpcy5hdm9pZE92ZXJsYXBzKGFvKTtcclxuICAgICAgICBpZiAoYW8pIHtcclxuICAgICAgICAgICAgdGhpcy5fbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkgeyB2LnggPSB4W2ldLCB2LnkgPSB5W2ldOyB9KTtcclxuICAgICAgICAgICAgdGhpcy5fZGVzY2VudC5wcm9qZWN0ID0gbmV3IHJlY3RhbmdsZV8xLlByb2plY3Rpb24odGhpcy5fbm9kZXMsIHRoaXMuX2dyb3VwcywgdGhpcy5fcm9vdEdyb3VwLCBjdXJDb25zdHJhaW50cywgdHJ1ZSkucHJvamVjdEZ1bmN0aW9ucygpO1xyXG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7IHhbaV0gPSB2LngsIHlbaV0gPSB2Lnk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kZXNjZW50LkcgPSBHO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NlbnQucnVuKGluaXRpYWxBbGxDb25zdHJhaW50c0l0ZXJhdGlvbnMpO1xyXG4gICAgICAgIGlmIChncmlkU25hcEl0ZXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVzY2VudC5zbmFwU3RyZW5ndGggPSAxMDAwO1xyXG4gICAgICAgICAgICB0aGlzLl9kZXNjZW50LnNuYXBHcmlkU2l6ZSA9IHRoaXMuX25vZGVzWzBdLndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLl9kZXNjZW50Lm51bUdyaWRTbmFwTm9kZXMgPSBuO1xyXG4gICAgICAgICAgICB0aGlzLl9kZXNjZW50LnNjYWxlU25hcEJ5TWF4SCA9IG4gIT0gTjtcclxuICAgICAgICAgICAgdmFyIEcwID0gZGVzY2VudF8xLkRlc2NlbnQuY3JlYXRlU3F1YXJlTWF0cml4KE4sIGZ1bmN0aW9uIChpLCBqKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBuIHx8IGogPj0gbilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gR1tpXVtqXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fZGVzY2VudC5HID0gRzA7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc2NlbnQucnVuKGdyaWRTbmFwSXRlcmF0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlTm9kZVBvc2l0aW9ucygpO1xyXG4gICAgICAgIHRoaXMuc2VwYXJhdGVPdmVybGFwcGluZ0NvbXBvbmVudHModywgaCk7XHJcbiAgICAgICAgcmV0dXJuIGtlZXBSdW5uaW5nID8gdGhpcy5yZXN1bWUoKSA6IHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5pbml0aWFsTGF5b3V0ID0gZnVuY3Rpb24gKGl0ZXJhdGlvbnMsIHgsIHkpIHtcclxuICAgICAgICBpZiAodGhpcy5fZ3JvdXBzLmxlbmd0aCA+IDAgJiYgaXRlcmF0aW9ucyA+IDApIHtcclxuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLl9ub2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBlZGdlcyA9IHRoaXMuX2xpbmtzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKHsgc291cmNlOiBlLnNvdXJjZS5pbmRleCwgdGFyZ2V0OiBlLnRhcmdldC5pbmRleCB9KTsgfSk7XHJcbiAgICAgICAgICAgIHZhciB2cyA9IHRoaXMuX25vZGVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gKHsgaW5kZXg6IHYuaW5kZXggfSk7IH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZywgaSkge1xyXG4gICAgICAgICAgICAgICAgdnMucHVzaCh7IGluZGV4OiBnLmluZGV4ID0gbiArIGkgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZywgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnLmxlYXZlcyAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgZy5sZWF2ZXMuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gZWRnZXMucHVzaCh7IHNvdXJjZTogZy5pbmRleCwgdGFyZ2V0OiB2LmluZGV4IH0pOyB9KTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZy5ncm91cHMgIT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgIGcuZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdnKSB7IHJldHVybiBlZGdlcy5wdXNoKHsgc291cmNlOiBnLmluZGV4LCB0YXJnZXQ6IGdnLmluZGV4IH0pOyB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG5ldyBMYXlvdXQoKVxyXG4gICAgICAgICAgICAgICAgLnNpemUodGhpcy5zaXplKCkpXHJcbiAgICAgICAgICAgICAgICAubm9kZXModnMpXHJcbiAgICAgICAgICAgICAgICAubGlua3MoZWRnZXMpXHJcbiAgICAgICAgICAgICAgICAuYXZvaWRPdmVybGFwcyhmYWxzZSlcclxuICAgICAgICAgICAgICAgIC5saW5rRGlzdGFuY2UodGhpcy5saW5rRGlzdGFuY2UoKSlcclxuICAgICAgICAgICAgICAgIC5zeW1tZXRyaWNEaWZmTGlua0xlbmd0aHMoNSlcclxuICAgICAgICAgICAgICAgIC5jb252ZXJnZW5jZVRocmVzaG9sZCgxZS00KVxyXG4gICAgICAgICAgICAgICAgLnN0YXJ0KGl0ZXJhdGlvbnMsIDAsIDAsIDAsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5fbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgeFt2LmluZGV4XSA9IHZzW3YuaW5kZXhdLng7XHJcbiAgICAgICAgICAgICAgICB5W3YuaW5kZXhdID0gdnNbdi5pbmRleF0ueTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXNjZW50LnJ1bihpdGVyYXRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5zZXBhcmF0ZU92ZXJsYXBwaW5nQ29tcG9uZW50cyA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIXRoaXMuX2Rpc3RhbmNlTWF0cml4ICYmIHRoaXMuX2hhbmRsZURpc2Nvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICB2YXIgeF8xID0gdGhpcy5fZGVzY2VudC54WzBdLCB5XzEgPSB0aGlzLl9kZXNjZW50LnhbMV07XHJcbiAgICAgICAgICAgIHRoaXMuX25vZGVzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHsgdi54ID0geF8xW2ldLCB2LnkgPSB5XzFbaV07IH0pO1xyXG4gICAgICAgICAgICB2YXIgZ3JhcGhzID0gaGFuZGxlZGlzY29ubmVjdGVkXzEuc2VwYXJhdGVHcmFwaHModGhpcy5fbm9kZXMsIHRoaXMuX2xpbmtzKTtcclxuICAgICAgICAgICAgaGFuZGxlZGlzY29ubmVjdGVkXzEuYXBwbHlQYWNraW5nKGdyYXBocywgd2lkdGgsIGhlaWdodCwgdGhpcy5fZGVmYXVsdE5vZGVTaXplKTtcclxuICAgICAgICAgICAgdGhpcy5fbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2Rlc2NlbnQueFswXVtpXSA9IHYueCwgX3RoaXMuX2Rlc2NlbnQueFsxXVtpXSA9IHYueTtcclxuICAgICAgICAgICAgICAgIGlmICh2LmJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHYuYm91bmRzLnNldFhDZW50cmUodi54KTtcclxuICAgICAgICAgICAgICAgICAgICB2LmJvdW5kcy5zZXRZQ2VudHJlKHYueSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hbHBoYSgwLjEpO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hbHBoYSgwKTtcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLnByZXBhcmVFZGdlUm91dGluZyA9IGZ1bmN0aW9uIChub2RlTWFyZ2luKSB7XHJcbiAgICAgICAgaWYgKG5vZGVNYXJnaW4gPT09IHZvaWQgMCkgeyBub2RlTWFyZ2luID0gMDsgfVxyXG4gICAgICAgIHRoaXMuX3Zpc2liaWxpdHlHcmFwaCA9IG5ldyBnZW9tXzEuVGFuZ2VudFZpc2liaWxpdHlHcmFwaCh0aGlzLl9ub2Rlcy5tYXAoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHYuYm91bmRzLmluZmxhdGUoLW5vZGVNYXJnaW4pLnZlcnRpY2VzKCk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUucm91dGVFZGdlID0gZnVuY3Rpb24gKGVkZ2UsIGFoLCBkcmF3KSB7XHJcbiAgICAgICAgaWYgKGFoID09PSB2b2lkIDApIHsgYWggPSA1OyB9XHJcbiAgICAgICAgdmFyIGxpbmVEYXRhID0gW107XHJcbiAgICAgICAgdmFyIHZnMiA9IG5ldyBnZW9tXzEuVGFuZ2VudFZpc2liaWxpdHlHcmFwaCh0aGlzLl92aXNpYmlsaXR5R3JhcGguUCwgeyBWOiB0aGlzLl92aXNpYmlsaXR5R3JhcGguViwgRTogdGhpcy5fdmlzaWJpbGl0eUdyYXBoLkUgfSksIHBvcnQxID0geyB4OiBlZGdlLnNvdXJjZS54LCB5OiBlZGdlLnNvdXJjZS55IH0sIHBvcnQyID0geyB4OiBlZGdlLnRhcmdldC54LCB5OiBlZGdlLnRhcmdldC55IH0sIHN0YXJ0ID0gdmcyLmFkZFBvaW50KHBvcnQxLCBlZGdlLnNvdXJjZS5pbmRleCksIGVuZCA9IHZnMi5hZGRQb2ludChwb3J0MiwgZWRnZS50YXJnZXQuaW5kZXgpO1xyXG4gICAgICAgIHZnMi5hZGRFZGdlSWZWaXNpYmxlKHBvcnQxLCBwb3J0MiwgZWRnZS5zb3VyY2UuaW5kZXgsIGVkZ2UudGFyZ2V0LmluZGV4KTtcclxuICAgICAgICBpZiAodHlwZW9mIGRyYXcgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGRyYXcodmcyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNvdXJjZUluZCA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnNvdXJjZS5pZDsgfSwgdGFyZ2V0SW5kID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUudGFyZ2V0LmlkOyB9LCBsZW5ndGggPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5sZW5ndGgoKTsgfSwgc3BDYWxjID0gbmV3IHNob3J0ZXN0cGF0aHNfMS5DYWxjdWxhdG9yKHZnMi5WLmxlbmd0aCwgdmcyLkUsIHNvdXJjZUluZCwgdGFyZ2V0SW5kLCBsZW5ndGgpLCBzaG9ydGVzdFBhdGggPSBzcENhbGMuUGF0aEZyb21Ob2RlVG9Ob2RlKHN0YXJ0LmlkLCBlbmQuaWQpO1xyXG4gICAgICAgIGlmIChzaG9ydGVzdFBhdGgubGVuZ3RoID09PSAxIHx8IHNob3J0ZXN0UGF0aC5sZW5ndGggPT09IHZnMi5WLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgcm91dGUgPSByZWN0YW5nbGVfMS5tYWtlRWRnZUJldHdlZW4oZWRnZS5zb3VyY2UuaW5uZXJCb3VuZHMsIGVkZ2UudGFyZ2V0LmlubmVyQm91bmRzLCBhaCk7XHJcbiAgICAgICAgICAgIGxpbmVEYXRhID0gW3JvdXRlLnNvdXJjZUludGVyc2VjdGlvbiwgcm91dGUuYXJyb3dTdGFydF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbiA9IHNob3J0ZXN0UGF0aC5sZW5ndGggLSAyLCBwID0gdmcyLlZbc2hvcnRlc3RQYXRoW25dXS5wLCBxID0gdmcyLlZbc2hvcnRlc3RQYXRoWzBdXS5wLCBsaW5lRGF0YSA9IFtlZGdlLnNvdXJjZS5pbm5lckJvdW5kcy5yYXlJbnRlcnNlY3Rpb24ocC54LCBwLnkpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IG47IGkgPj0gMDsgLS1pKVxyXG4gICAgICAgICAgICAgICAgbGluZURhdGEucHVzaCh2ZzIuVltzaG9ydGVzdFBhdGhbaV1dLnApO1xyXG4gICAgICAgICAgICBsaW5lRGF0YS5wdXNoKHJlY3RhbmdsZV8xLm1ha2VFZGdlVG8ocSwgZWRnZS50YXJnZXQuaW5uZXJCb3VuZHMsIGFoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaW5lRGF0YTtcclxuICAgIH07XHJcbiAgICBMYXlvdXQuZ2V0U291cmNlSW5kZXggPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgZS5zb3VyY2UgPT09ICdudW1iZXInID8gZS5zb3VyY2UgOiBlLnNvdXJjZS5pbmRleDtcclxuICAgIH07XHJcbiAgICBMYXlvdXQuZ2V0VGFyZ2V0SW5kZXggPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgZS50YXJnZXQgPT09ICdudW1iZXInID8gZS50YXJnZXQgOiBlLnRhcmdldC5pbmRleDtcclxuICAgIH07XHJcbiAgICBMYXlvdXQubGlua0lkID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICByZXR1cm4gTGF5b3V0LmdldFNvdXJjZUluZGV4KGUpICsgXCItXCIgKyBMYXlvdXQuZ2V0VGFyZ2V0SW5kZXgoZSk7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LmRyYWdTdGFydCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgaWYgKGlzR3JvdXAoZCkpIHtcclxuICAgICAgICAgICAgTGF5b3V0LnN0b3JlT2Zmc2V0KGQsIExheW91dC5kcmFnT3JpZ2luKGQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIExheW91dC5zdG9wTm9kZShkKTtcclxuICAgICAgICAgICAgZC5maXhlZCB8PSAyO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMYXlvdXQuc3RvcE5vZGUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHYucHggPSB2Lng7XHJcbiAgICAgICAgdi5weSA9IHYueTtcclxuICAgIH07XHJcbiAgICBMYXlvdXQuc3RvcmVPZmZzZXQgPSBmdW5jdGlvbiAoZCwgb3JpZ2luKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkLmxlYXZlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgZC5sZWF2ZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgdi5maXhlZCB8PSAyO1xyXG4gICAgICAgICAgICAgICAgTGF5b3V0LnN0b3BOb2RlKHYpO1xyXG4gICAgICAgICAgICAgICAgdi5fZHJhZ0dyb3VwT2Zmc2V0WCA9IHYueCAtIG9yaWdpbi54O1xyXG4gICAgICAgICAgICAgICAgdi5fZHJhZ0dyb3VwT2Zmc2V0WSA9IHYueSAtIG9yaWdpbi55O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkLmdyb3VwcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgZC5ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZykgeyByZXR1cm4gTGF5b3V0LnN0b3JlT2Zmc2V0KGcsIG9yaWdpbik7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMYXlvdXQuZHJhZ09yaWdpbiA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgaWYgKGlzR3JvdXAoZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IGQuYm91bmRzLmN4KCksXHJcbiAgICAgICAgICAgICAgICB5OiBkLmJvdW5kcy5jeSgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LmRyYWcgPSBmdW5jdGlvbiAoZCwgcG9zaXRpb24pIHtcclxuICAgICAgICBpZiAoaXNHcm91cChkKSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGQubGVhdmVzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgZC5sZWF2ZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgIGQuYm91bmRzLnNldFhDZW50cmUocG9zaXRpb24ueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5ib3VuZHMuc2V0WUNlbnRyZShwb3NpdGlvbi55KTtcclxuICAgICAgICAgICAgICAgICAgICB2LnB4ID0gdi5fZHJhZ0dyb3VwT2Zmc2V0WCArIHBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5weSA9IHYuX2RyYWdHcm91cE9mZnNldFkgKyBwb3NpdGlvbi55O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkLmdyb3VwcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGQuZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGcpIHsgcmV0dXJuIExheW91dC5kcmFnKGcsIHBvc2l0aW9uKTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGQucHggPSBwb3NpdGlvbi54O1xyXG4gICAgICAgICAgICBkLnB5ID0gcG9zaXRpb24ueTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LmRyYWdFbmQgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGlmIChpc0dyb3VwKGQpKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZC5sZWF2ZXMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBkLmxlYXZlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTGF5b3V0LmRyYWdFbmQodik7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHYuX2RyYWdHcm91cE9mZnNldFg7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHYuX2RyYWdHcm91cE9mZnNldFk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGQuZ3JvdXBzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgZC5ncm91cHMuZm9yRWFjaChMYXlvdXQuZHJhZ0VuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGQuZml4ZWQgJj0gfjY7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExheW91dC5tb3VzZU92ZXIgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGQuZml4ZWQgfD0gNDtcclxuICAgICAgICBkLnB4ID0gZC54LCBkLnB5ID0gZC55O1xyXG4gICAgfTtcclxuICAgIExheW91dC5tb3VzZU91dCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgZC5maXhlZCAmPSB+NDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTGF5b3V0O1xyXG59KCkpO1xyXG5leHBvcnRzLkxheW91dCA9IExheW91dDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGF5b3V0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBzaG9ydGVzdHBhdGhzXzEgPSByZXF1aXJlKFwiLi9zaG9ydGVzdHBhdGhzXCIpO1xyXG52YXIgZGVzY2VudF8xID0gcmVxdWlyZShcIi4vZGVzY2VudFwiKTtcclxudmFyIHJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vcmVjdGFuZ2xlXCIpO1xyXG52YXIgbGlua2xlbmd0aHNfMSA9IHJlcXVpcmUoXCIuL2xpbmtsZW5ndGhzXCIpO1xyXG52YXIgTGluazNEID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExpbmszRChzb3VyY2UsIHRhcmdldCkge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgTGluazNELnByb3RvdHlwZS5hY3R1YWxMZW5ndGggPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4LnJlZHVjZShmdW5jdGlvbiAoYywgdikge1xyXG4gICAgICAgICAgICB2YXIgZHggPSB2W190aGlzLnRhcmdldF0gLSB2W190aGlzLnNvdXJjZV07XHJcbiAgICAgICAgICAgIHJldHVybiBjICsgZHggKiBkeDtcclxuICAgICAgICB9LCAwKSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExpbmszRDtcclxufSgpKTtcclxuZXhwb3J0cy5MaW5rM0QgPSBMaW5rM0Q7XHJcbnZhciBOb2RlM0QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTm9kZTNEKHgsIHksIHopIHtcclxuICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7IHggPSAwOyB9XHJcbiAgICAgICAgaWYgKHkgPT09IHZvaWQgMCkgeyB5ID0gMDsgfVxyXG4gICAgICAgIGlmICh6ID09PSB2b2lkIDApIHsgeiA9IDA7IH1cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy56ID0gejtcclxuICAgIH1cclxuICAgIHJldHVybiBOb2RlM0Q7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTm9kZTNEID0gTm9kZTNEO1xyXG52YXIgTGF5b3V0M0QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTGF5b3V0M0Qobm9kZXMsIGxpbmtzLCBpZGVhbExpbmtMZW5ndGgpIHtcclxuICAgICAgICBpZiAoaWRlYWxMaW5rTGVuZ3RoID09PSB2b2lkIDApIHsgaWRlYWxMaW5rTGVuZ3RoID0gMTsgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xyXG4gICAgICAgIHRoaXMubGlua3MgPSBsaW5rcztcclxuICAgICAgICB0aGlzLmlkZWFsTGlua0xlbmd0aCA9IGlkZWFsTGlua0xlbmd0aDtcclxuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnVzZUphY2NhcmRMaW5rTGVuZ3RocyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5yZXN1bHQgPSBuZXcgQXJyYXkoTGF5b3V0M0Quayk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBMYXlvdXQzRC5rOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXN1bHRbaV0gPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gTGF5b3V0M0QuZGltczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaW0gPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZbZGltXSA9PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICB2W2RpbV0gPSBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLnJlc3VsdFswXVtpXSA9IHYueDtcclxuICAgICAgICAgICAgX3RoaXMucmVzdWx0WzFdW2ldID0gdi55O1xyXG4gICAgICAgICAgICBfdGhpcy5yZXN1bHRbMl1baV0gPSB2Lno7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBMYXlvdXQzRC5wcm90b3R5cGUubGlua0xlbmd0aCA9IGZ1bmN0aW9uIChsKSB7XHJcbiAgICAgICAgcmV0dXJuIGwuYWN0dWFsTGVuZ3RoKHRoaXMucmVzdWx0KTtcclxuICAgIH07XHJcbiAgICBMYXlvdXQzRC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoaXRlcmF0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGl0ZXJhdGlvbnMgPT09IHZvaWQgMCkgeyBpdGVyYXRpb25zID0gMTAwOyB9XHJcbiAgICAgICAgdmFyIG4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcclxuICAgICAgICB2YXIgbGlua0FjY2Vzc29yID0gbmV3IExpbmtBY2Nlc3NvcigpO1xyXG4gICAgICAgIGlmICh0aGlzLnVzZUphY2NhcmRMaW5rTGVuZ3RocylcclxuICAgICAgICAgICAgbGlua2xlbmd0aHNfMS5qYWNjYXJkTGlua0xlbmd0aHModGhpcy5saW5rcywgbGlua0FjY2Vzc29yLCAxLjUpO1xyXG4gICAgICAgIHRoaXMubGlua3MuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5sZW5ndGggKj0gX3RoaXMuaWRlYWxMaW5rTGVuZ3RoOyB9KTtcclxuICAgICAgICB2YXIgZGlzdGFuY2VNYXRyaXggPSAobmV3IHNob3J0ZXN0cGF0aHNfMS5DYWxjdWxhdG9yKG4sIHRoaXMubGlua3MsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnNvdXJjZTsgfSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUudGFyZ2V0OyB9LCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5sZW5ndGg7IH0pKS5EaXN0YW5jZU1hdHJpeCgpO1xyXG4gICAgICAgIHZhciBEID0gZGVzY2VudF8xLkRlc2NlbnQuY3JlYXRlU3F1YXJlTWF0cml4KG4sIGZ1bmN0aW9uIChpLCBqKSB7IHJldHVybiBkaXN0YW5jZU1hdHJpeFtpXVtqXTsgfSk7XHJcbiAgICAgICAgdmFyIEcgPSBkZXNjZW50XzEuRGVzY2VudC5jcmVhdGVTcXVhcmVNYXRyaXgobiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gMjsgfSk7XHJcbiAgICAgICAgdGhpcy5saW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgc291cmNlID0gX2Euc291cmNlLCB0YXJnZXQgPSBfYS50YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBHW3NvdXJjZV1bdGFyZ2V0XSA9IEdbdGFyZ2V0XVtzb3VyY2VdID0gMTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRlc2NlbnQgPSBuZXcgZGVzY2VudF8xLkRlc2NlbnQodGhpcy5yZXN1bHQsIEQpO1xyXG4gICAgICAgIHRoaXMuZGVzY2VudC50aHJlc2hvbGQgPSAxZS0zO1xyXG4gICAgICAgIHRoaXMuZGVzY2VudC5HID0gRztcclxuICAgICAgICBpZiAodGhpcy5jb25zdHJhaW50cylcclxuICAgICAgICAgICAgdGhpcy5kZXNjZW50LnByb2plY3QgPSBuZXcgcmVjdGFuZ2xlXzEuUHJvamVjdGlvbih0aGlzLm5vZGVzLCBudWxsLCBudWxsLCB0aGlzLmNvbnN0cmFpbnRzKS5wcm9qZWN0RnVuY3Rpb25zKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5ub2Rlc1tpXTtcclxuICAgICAgICAgICAgaWYgKHYuZml4ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVzY2VudC5sb2Nrcy5hZGQoaSwgW3YueCwgdi55LCB2LnpdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRlc2NlbnQucnVuKGl0ZXJhdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dDNELnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZGVzY2VudC5sb2Nrcy5jbGVhcigpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMubm9kZXNbaV07XHJcbiAgICAgICAgICAgIGlmICh2LmZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlc2NlbnQubG9ja3MuYWRkKGksIFt2LngsIHYueSwgdi56XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzY2VudC5ydW5nZUt1dHRhKCk7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0M0QuZGltcyA9IFsneCcsICd5JywgJ3onXTtcclxuICAgIExheW91dDNELmsgPSBMYXlvdXQzRC5kaW1zLmxlbmd0aDtcclxuICAgIHJldHVybiBMYXlvdXQzRDtcclxufSgpKTtcclxuZXhwb3J0cy5MYXlvdXQzRCA9IExheW91dDNEO1xyXG52YXIgTGlua0FjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExpbmtBY2Nlc3NvcigpIHtcclxuICAgIH1cclxuICAgIExpbmtBY2Nlc3Nvci5wcm90b3R5cGUuZ2V0U291cmNlSW5kZXggPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5zb3VyY2U7IH07XHJcbiAgICBMaW5rQWNjZXNzb3IucHJvdG90eXBlLmdldFRhcmdldEluZGV4ID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUudGFyZ2V0OyB9O1xyXG4gICAgTGlua0FjY2Vzc29yLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5sZW5ndGg7IH07XHJcbiAgICBMaW5rQWNjZXNzb3IucHJvdG90eXBlLnNldExlbmd0aCA9IGZ1bmN0aW9uIChlLCBsKSB7IGUubGVuZ3RoID0gbDsgfTtcclxuICAgIHJldHVybiBMaW5rQWNjZXNzb3I7XHJcbn0oKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxheW91dDNkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmZ1bmN0aW9uIHVuaW9uQ291bnQoYSwgYikge1xyXG4gICAgdmFyIHUgPSB7fTtcclxuICAgIGZvciAodmFyIGkgaW4gYSlcclxuICAgICAgICB1W2ldID0ge307XHJcbiAgICBmb3IgKHZhciBpIGluIGIpXHJcbiAgICAgICAgdVtpXSA9IHt9O1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHUpLmxlbmd0aDtcclxufVxyXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb25Db3VudChhLCBiKSB7XHJcbiAgICB2YXIgbiA9IDA7XHJcbiAgICBmb3IgKHZhciBpIGluIGEpXHJcbiAgICAgICAgaWYgKHR5cGVvZiBiW2ldICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgKytuO1xyXG4gICAgcmV0dXJuIG47XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmVpZ2hib3VycyhsaW5rcywgbGEpIHtcclxuICAgIHZhciBuZWlnaGJvdXJzID0ge307XHJcbiAgICB2YXIgYWRkTmVpZ2hib3VycyA9IGZ1bmN0aW9uICh1LCB2KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZWlnaGJvdXJzW3VdID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgbmVpZ2hib3Vyc1t1XSA9IHt9O1xyXG4gICAgICAgIG5laWdoYm91cnNbdV1bdl0gPSB7fTtcclxuICAgIH07XHJcbiAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdmFyIHUgPSBsYS5nZXRTb3VyY2VJbmRleChlKSwgdiA9IGxhLmdldFRhcmdldEluZGV4KGUpO1xyXG4gICAgICAgIGFkZE5laWdoYm91cnModSwgdik7XHJcbiAgICAgICAgYWRkTmVpZ2hib3Vycyh2LCB1KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5laWdoYm91cnM7XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZUxpbmtMZW5ndGhzKGxpbmtzLCB3LCBmLCBsYSkge1xyXG4gICAgdmFyIG5laWdoYm91cnMgPSBnZXROZWlnaGJvdXJzKGxpbmtzLCBsYSk7XHJcbiAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XHJcbiAgICAgICAgdmFyIGEgPSBuZWlnaGJvdXJzW2xhLmdldFNvdXJjZUluZGV4KGwpXTtcclxuICAgICAgICB2YXIgYiA9IG5laWdoYm91cnNbbGEuZ2V0VGFyZ2V0SW5kZXgobCldO1xyXG4gICAgICAgIGxhLnNldExlbmd0aChsLCAxICsgdyAqIGYoYSwgYikpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gc3ltbWV0cmljRGlmZkxpbmtMZW5ndGhzKGxpbmtzLCBsYSwgdykge1xyXG4gICAgaWYgKHcgPT09IHZvaWQgMCkgeyB3ID0gMTsgfVxyXG4gICAgY29tcHV0ZUxpbmtMZW5ndGhzKGxpbmtzLCB3LCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gTWF0aC5zcXJ0KHVuaW9uQ291bnQoYSwgYikgLSBpbnRlcnNlY3Rpb25Db3VudChhLCBiKSk7IH0sIGxhKTtcclxufVxyXG5leHBvcnRzLnN5bW1ldHJpY0RpZmZMaW5rTGVuZ3RocyA9IHN5bW1ldHJpY0RpZmZMaW5rTGVuZ3RocztcclxuZnVuY3Rpb24gamFjY2FyZExpbmtMZW5ndGhzKGxpbmtzLCBsYSwgdykge1xyXG4gICAgaWYgKHcgPT09IHZvaWQgMCkgeyB3ID0gMTsgfVxyXG4gICAgY29tcHV0ZUxpbmtMZW5ndGhzKGxpbmtzLCB3LCBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1pbihPYmplY3Qua2V5cyhhKS5sZW5ndGgsIE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgPCAxLjEgPyAwIDogaW50ZXJzZWN0aW9uQ291bnQoYSwgYikgLyB1bmlvbkNvdW50KGEsIGIpO1xyXG4gICAgfSwgbGEpO1xyXG59XHJcbmV4cG9ydHMuamFjY2FyZExpbmtMZW5ndGhzID0gamFjY2FyZExpbmtMZW5ndGhzO1xyXG5mdW5jdGlvbiBnZW5lcmF0ZURpcmVjdGVkRWRnZUNvbnN0cmFpbnRzKG4sIGxpbmtzLCBheGlzLCBsYSkge1xyXG4gICAgdmFyIGNvbXBvbmVudHMgPSBzdHJvbmdseUNvbm5lY3RlZENvbXBvbmVudHMobiwgbGlua3MsIGxhKTtcclxuICAgIHZhciBub2RlcyA9IHt9O1xyXG4gICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7XHJcbiAgICAgICAgcmV0dXJuIGMuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gbm9kZXNbdl0gPSBpOyB9KTtcclxuICAgIH0pO1xyXG4gICAgdmFyIGNvbnN0cmFpbnRzID0gW107XHJcbiAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XHJcbiAgICAgICAgdmFyIHVpID0gbGEuZ2V0U291cmNlSW5kZXgobCksIHZpID0gbGEuZ2V0VGFyZ2V0SW5kZXgobCksIHUgPSBub2Rlc1t1aV0sIHYgPSBub2Rlc1t2aV07XHJcbiAgICAgICAgaWYgKHUgIT09IHYpIHtcclxuICAgICAgICAgICAgY29uc3RyYWludHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBheGlzOiBheGlzLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogdWksXHJcbiAgICAgICAgICAgICAgICByaWdodDogdmksXHJcbiAgICAgICAgICAgICAgICBnYXA6IGxhLmdldE1pblNlcGFyYXRpb24obClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY29uc3RyYWludHM7XHJcbn1cclxuZXhwb3J0cy5nZW5lcmF0ZURpcmVjdGVkRWRnZUNvbnN0cmFpbnRzID0gZ2VuZXJhdGVEaXJlY3RlZEVkZ2VDb25zdHJhaW50cztcclxuZnVuY3Rpb24gc3Ryb25nbHlDb25uZWN0ZWRDb21wb25lbnRzKG51bVZlcnRpY2VzLCBlZGdlcywgbGEpIHtcclxuICAgIHZhciBub2RlcyA9IFtdO1xyXG4gICAgdmFyIGluZGV4ID0gMDtcclxuICAgIHZhciBzdGFjayA9IFtdO1xyXG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcclxuICAgIGZ1bmN0aW9uIHN0cm9uZ0Nvbm5lY3Qodikge1xyXG4gICAgICAgIHYuaW5kZXggPSB2Lmxvd2xpbmsgPSBpbmRleCsrO1xyXG4gICAgICAgIHN0YWNrLnB1c2godik7XHJcbiAgICAgICAgdi5vblN0YWNrID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdi5vdXQ7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB3ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHcuaW5kZXggPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBzdHJvbmdDb25uZWN0KHcpO1xyXG4gICAgICAgICAgICAgICAgdi5sb3dsaW5rID0gTWF0aC5taW4odi5sb3dsaW5rLCB3Lmxvd2xpbmspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHcub25TdGFjaykge1xyXG4gICAgICAgICAgICAgICAgdi5sb3dsaW5rID0gTWF0aC5taW4odi5sb3dsaW5rLCB3LmluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodi5sb3dsaW5rID09PSB2LmluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBbXTtcclxuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdyA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgdy5vblN0YWNrID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQucHVzaCh3KTtcclxuICAgICAgICAgICAgICAgIGlmICh3ID09PSB2KVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LmlkOyB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WZXJ0aWNlczsgaSsrKSB7XHJcbiAgICAgICAgbm9kZXMucHVzaCh7IGlkOiBpLCBvdXQ6IFtdIH0pO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBlZGdlc18xID0gZWRnZXM7IF9pIDwgZWRnZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgZSA9IGVkZ2VzXzFbX2ldO1xyXG4gICAgICAgIHZhciB2XzEgPSBub2Rlc1tsYS5nZXRTb3VyY2VJbmRleChlKV0sIHcgPSBub2Rlc1tsYS5nZXRUYXJnZXRJbmRleChlKV07XHJcbiAgICAgICAgdl8xLm91dC5wdXNoKHcpO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgX2EgPSAwLCBub2Rlc18xID0gbm9kZXM7IF9hIDwgbm9kZXNfMS5sZW5ndGg7IF9hKyspIHtcclxuICAgICAgICB2YXIgdiA9IG5vZGVzXzFbX2FdO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygdi5pbmRleCA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIHN0cm9uZ0Nvbm5lY3Qodik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29tcG9uZW50cztcclxufVxyXG5leHBvcnRzLnN0cm9uZ2x5Q29ubmVjdGVkQ29tcG9uZW50cyA9IHN0cm9uZ2x5Q29ubmVjdGVkQ29tcG9uZW50cztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlua2xlbmd0aHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFBvd2VyRWRnZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQb3dlckVkZ2Uoc291cmNlLCB0YXJnZXQsIHR5cGUpIHtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFBvd2VyRWRnZTtcclxufSgpKTtcclxuZXhwb3J0cy5Qb3dlckVkZ2UgPSBQb3dlckVkZ2U7XHJcbnZhciBDb25maWd1cmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24obiwgZWRnZXMsIGxpbmtBY2Nlc3Nvciwgcm9vdEdyb3VwKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmxpbmtBY2Nlc3NvciA9IGxpbmtBY2Nlc3NvcjtcclxuICAgICAgICB0aGlzLm1vZHVsZXMgPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgdGhpcy5yb290cyA9IFtdO1xyXG4gICAgICAgIGlmIChyb290R3JvdXApIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0TW9kdWxlc0Zyb21Hcm91cChyb290R3JvdXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yb290cy5wdXNoKG5ldyBNb2R1bGVTZXQoKSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290c1swXS5hZGQodGhpcy5tb2R1bGVzW2ldID0gbmV3IE1vZHVsZShpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuUiA9IGVkZ2VzLmxlbmd0aDtcclxuICAgICAgICBlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gX3RoaXMubW9kdWxlc1tsaW5rQWNjZXNzb3IuZ2V0U291cmNlSW5kZXgoZSldLCB0ID0gX3RoaXMubW9kdWxlc1tsaW5rQWNjZXNzb3IuZ2V0VGFyZ2V0SW5kZXgoZSldLCB0eXBlID0gbGlua0FjY2Vzc29yLmdldFR5cGUoZSk7XHJcbiAgICAgICAgICAgIHMub3V0Z29pbmcuYWRkKHR5cGUsIHQpO1xyXG4gICAgICAgICAgICB0LmluY29taW5nLmFkZCh0eXBlLCBzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIENvbmZpZ3VyYXRpb24ucHJvdG90eXBlLmluaXRNb2R1bGVzRnJvbUdyb3VwID0gZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgdmFyIG1vZHVsZVNldCA9IG5ldyBNb2R1bGVTZXQoKTtcclxuICAgICAgICB0aGlzLnJvb3RzLnB1c2gobW9kdWxlU2V0KTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlYXZlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IGdyb3VwLmxlYXZlc1tpXTtcclxuICAgICAgICAgICAgdmFyIG1vZHVsZSA9IG5ldyBNb2R1bGUobm9kZS5pZCk7XHJcbiAgICAgICAgICAgIHRoaXMubW9kdWxlc1tub2RlLmlkXSA9IG1vZHVsZTtcclxuICAgICAgICAgICAgbW9kdWxlU2V0LmFkZChtb2R1bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ3JvdXAuZ3JvdXBzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JvdXAuZ3JvdXBzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBncm91cC5ncm91cHNbal07XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvbiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBjaGlsZClcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCAhPT0gXCJsZWF2ZXNcIiAmJiBwcm9wICE9PSBcImdyb3Vwc1wiICYmIGNoaWxkLmhhc093blByb3BlcnR5KHByb3ApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uW3Byb3BdID0gY2hpbGRbcHJvcF07XHJcbiAgICAgICAgICAgICAgICBtb2R1bGVTZXQuYWRkKG5ldyBNb2R1bGUoLTEgLSBqLCBuZXcgTGlua1NldHMoKSwgbmV3IExpbmtTZXRzKCksIHRoaXMuaW5pdE1vZHVsZXNGcm9tR3JvdXAoY2hpbGQpLCBkZWZpbml0aW9uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1vZHVsZVNldDtcclxuICAgIH07XHJcbiAgICBDb25maWd1cmF0aW9uLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChhLCBiLCBrKSB7XHJcbiAgICAgICAgaWYgKGsgPT09IHZvaWQgMCkgeyBrID0gMDsgfVxyXG4gICAgICAgIHZhciBpbkludCA9IGEuaW5jb21pbmcuaW50ZXJzZWN0aW9uKGIuaW5jb21pbmcpLCBvdXRJbnQgPSBhLm91dGdvaW5nLmludGVyc2VjdGlvbihiLm91dGdvaW5nKTtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBuZXcgTW9kdWxlU2V0KCk7XHJcbiAgICAgICAgY2hpbGRyZW4uYWRkKGEpO1xyXG4gICAgICAgIGNoaWxkcmVuLmFkZChiKTtcclxuICAgICAgICB2YXIgbSA9IG5ldyBNb2R1bGUodGhpcy5tb2R1bGVzLmxlbmd0aCwgb3V0SW50LCBpbkludCwgY2hpbGRyZW4pO1xyXG4gICAgICAgIHRoaXMubW9kdWxlcy5wdXNoKG0pO1xyXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAocywgaSwgbykge1xyXG4gICAgICAgICAgICBzLmZvckFsbChmdW5jdGlvbiAobXMsIGxpbmt0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBtcy5mb3JBbGwoZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmxzID0gbltpXTtcclxuICAgICAgICAgICAgICAgICAgICBubHMuYWRkKGxpbmt0eXBlLCBtKTtcclxuICAgICAgICAgICAgICAgICAgICBubHMucmVtb3ZlKGxpbmt0eXBlLCBhKTtcclxuICAgICAgICAgICAgICAgICAgICBubHMucmVtb3ZlKGxpbmt0eXBlLCBiKTtcclxuICAgICAgICAgICAgICAgICAgICBhW29dLnJlbW92ZShsaW5rdHlwZSwgbik7XHJcbiAgICAgICAgICAgICAgICAgICAgYltvXS5yZW1vdmUobGlua3R5cGUsIG4pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdXBkYXRlKG91dEludCwgXCJpbmNvbWluZ1wiLCBcIm91dGdvaW5nXCIpO1xyXG4gICAgICAgIHVwZGF0ZShpbkludCwgXCJvdXRnb2luZ1wiLCBcImluY29taW5nXCIpO1xyXG4gICAgICAgIHRoaXMuUiAtPSBpbkludC5jb3VudCgpICsgb3V0SW50LmNvdW50KCk7XHJcbiAgICAgICAgdGhpcy5yb290c1trXS5yZW1vdmUoYSk7XHJcbiAgICAgICAgdGhpcy5yb290c1trXS5yZW1vdmUoYik7XHJcbiAgICAgICAgdGhpcy5yb290c1trXS5hZGQobSk7XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9O1xyXG4gICAgQ29uZmlndXJhdGlvbi5wcm90b3R5cGUucm9vdE1lcmdlcyA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgICAgaWYgKGsgPT09IHZvaWQgMCkgeyBrID0gMDsgfVxyXG4gICAgICAgIHZhciBycyA9IHRoaXMucm9vdHNba10ubW9kdWxlcygpO1xyXG4gICAgICAgIHZhciBuID0gcnMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBtZXJnZXMgPSBuZXcgQXJyYXkobiAqIChuIC0gMSkpO1xyXG4gICAgICAgIHZhciBjdHIgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpXyA9IG4gLSAxOyBpIDwgaV87ICsraSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBuOyArK2opIHtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gcnNbaV0sIGIgPSByc1tqXTtcclxuICAgICAgICAgICAgICAgIG1lcmdlc1tjdHJdID0geyBpZDogY3RyLCBuRWRnZXM6IHRoaXMubkVkZ2VzKGEsIGIpLCBhOiBhLCBiOiBiIH07XHJcbiAgICAgICAgICAgICAgICBjdHIrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWVyZ2VzO1xyXG4gICAgfTtcclxuICAgIENvbmZpZ3VyYXRpb24ucHJvdG90eXBlLmdyZWVkeU1lcmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb290cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yb290c1tpXS5tb2R1bGVzKCkubGVuZ3RoIDwgMilcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB2YXIgbXMgPSB0aGlzLnJvb3RNZXJnZXMoaSkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5uRWRnZXMgPT0gYi5uRWRnZXMgPyBhLmlkIC0gYi5pZCA6IGEubkVkZ2VzIC0gYi5uRWRnZXM7IH0pO1xyXG4gICAgICAgICAgICB2YXIgbSA9IG1zWzBdO1xyXG4gICAgICAgICAgICBpZiAobS5uRWRnZXMgPj0gdGhpcy5SKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIHRoaXMubWVyZ2UobS5hLCBtLmIsIGkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29uZmlndXJhdGlvbi5wcm90b3R5cGUubkVkZ2VzID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICB2YXIgaW5JbnQgPSBhLmluY29taW5nLmludGVyc2VjdGlvbihiLmluY29taW5nKSwgb3V0SW50ID0gYS5vdXRnb2luZy5pbnRlcnNlY3Rpb24oYi5vdXRnb2luZyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuUiAtIGluSW50LmNvdW50KCkgLSBvdXRJbnQuY291bnQoKTtcclxuICAgIH07XHJcbiAgICBDb25maWd1cmF0aW9uLnByb3RvdHlwZS5nZXRHcm91cEhpZXJhcmNoeSA9IGZ1bmN0aW9uIChyZXRhcmdldGVkRWRnZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBncm91cHMgPSBbXTtcclxuICAgICAgICB2YXIgcm9vdCA9IHt9O1xyXG4gICAgICAgIHRvR3JvdXBzKHRoaXMucm9vdHNbMF0sIHJvb3QsIGdyb3Vwcyk7XHJcbiAgICAgICAgdmFyIGVzID0gdGhpcy5hbGxFZGdlcygpO1xyXG4gICAgICAgIGVzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBfdGhpcy5tb2R1bGVzW2Uuc291cmNlXTtcclxuICAgICAgICAgICAgdmFyIGIgPSBfdGhpcy5tb2R1bGVzW2UudGFyZ2V0XTtcclxuICAgICAgICAgICAgcmV0YXJnZXRlZEVkZ2VzLnB1c2gobmV3IFBvd2VyRWRnZSh0eXBlb2YgYS5naWQgPT09IFwidW5kZWZpbmVkXCIgPyBlLnNvdXJjZSA6IGdyb3Vwc1thLmdpZF0sIHR5cGVvZiBiLmdpZCA9PT0gXCJ1bmRlZmluZWRcIiA/IGUudGFyZ2V0IDogZ3JvdXBzW2IuZ2lkXSwgZS50eXBlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGdyb3VwcztcclxuICAgIH07XHJcbiAgICBDb25maWd1cmF0aW9uLnByb3RvdHlwZS5hbGxFZGdlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZXMgPSBbXTtcclxuICAgICAgICBDb25maWd1cmF0aW9uLmdldEVkZ2VzKHRoaXMucm9vdHNbMF0sIGVzKTtcclxuICAgICAgICByZXR1cm4gZXM7XHJcbiAgICB9O1xyXG4gICAgQ29uZmlndXJhdGlvbi5nZXRFZGdlcyA9IGZ1bmN0aW9uIChtb2R1bGVzLCBlcykge1xyXG4gICAgICAgIG1vZHVsZXMuZm9yQWxsKGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgIG0uZ2V0RWRnZXMoZXMpO1xyXG4gICAgICAgICAgICBDb25maWd1cmF0aW9uLmdldEVkZ2VzKG0uY2hpbGRyZW4sIGVzKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29uZmlndXJhdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5Db25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbjtcclxuZnVuY3Rpb24gdG9Hcm91cHMobW9kdWxlcywgZ3JvdXAsIGdyb3Vwcykge1xyXG4gICAgbW9kdWxlcy5mb3JBbGwoZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICBpZiAobS5pc0xlYWYoKSkge1xyXG4gICAgICAgICAgICBpZiAoIWdyb3VwLmxlYXZlcylcclxuICAgICAgICAgICAgICAgIGdyb3VwLmxlYXZlcyA9IFtdO1xyXG4gICAgICAgICAgICBncm91cC5sZWF2ZXMucHVzaChtLmlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBnID0gZ3JvdXA7XHJcbiAgICAgICAgICAgIG0uZ2lkID0gZ3JvdXBzLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKCFtLmlzSXNsYW5kKCkgfHwgbS5pc1ByZWRlZmluZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgZyA9IHsgaWQ6IG0uZ2lkIH07XHJcbiAgICAgICAgICAgICAgICBpZiAobS5pc1ByZWRlZmluZWQoKSlcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG0uZGVmaW5pdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ1twcm9wXSA9IG0uZGVmaW5pdGlvbltwcm9wXTtcclxuICAgICAgICAgICAgICAgIGlmICghZ3JvdXAuZ3JvdXBzKVxyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmdyb3VwcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZ3JvdXAuZ3JvdXBzLnB1c2gobS5naWQpO1xyXG4gICAgICAgICAgICAgICAgZ3JvdXBzLnB1c2goZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdG9Hcm91cHMobS5jaGlsZHJlbiwgZywgZ3JvdXBzKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG52YXIgTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1vZHVsZShpZCwgb3V0Z29pbmcsIGluY29taW5nLCBjaGlsZHJlbiwgZGVmaW5pdGlvbikge1xyXG4gICAgICAgIGlmIChvdXRnb2luZyA9PT0gdm9pZCAwKSB7IG91dGdvaW5nID0gbmV3IExpbmtTZXRzKCk7IH1cclxuICAgICAgICBpZiAoaW5jb21pbmcgPT09IHZvaWQgMCkgeyBpbmNvbWluZyA9IG5ldyBMaW5rU2V0cygpOyB9XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHsgY2hpbGRyZW4gPSBuZXcgTW9kdWxlU2V0KCk7IH1cclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy5vdXRnb2luZyA9IG91dGdvaW5nO1xyXG4gICAgICAgIHRoaXMuaW5jb21pbmcgPSBpbmNvbWluZztcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcclxuICAgIH1cclxuICAgIE1vZHVsZS5wcm90b3R5cGUuZ2V0RWRnZXMgPSBmdW5jdGlvbiAoZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMub3V0Z29pbmcuZm9yQWxsKGZ1bmN0aW9uIChtcywgZWRnZXR5cGUpIHtcclxuICAgICAgICAgICAgbXMuZm9yQWxsKGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIGVzLnB1c2gobmV3IFBvd2VyRWRnZShfdGhpcy5pZCwgdGFyZ2V0LmlkLCBlZGdldHlwZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNb2R1bGUucHJvdG90eXBlLmlzTGVhZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5jb3VudCgpID09PSAwO1xyXG4gICAgfTtcclxuICAgIE1vZHVsZS5wcm90b3R5cGUuaXNJc2xhbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0Z29pbmcuY291bnQoKSA9PT0gMCAmJiB0aGlzLmluY29taW5nLmNvdW50KCkgPT09IDA7XHJcbiAgICB9O1xyXG4gICAgTW9kdWxlLnByb3RvdHlwZS5pc1ByZWRlZmluZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLmRlZmluaXRpb24gIT09IFwidW5kZWZpbmVkXCI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1vZHVsZTtcclxufSgpKTtcclxuZXhwb3J0cy5Nb2R1bGUgPSBNb2R1bGU7XHJcbmZ1bmN0aW9uIGludGVyc2VjdGlvbihtLCBuKSB7XHJcbiAgICB2YXIgaSA9IHt9O1xyXG4gICAgZm9yICh2YXIgdiBpbiBtKVxyXG4gICAgICAgIGlmICh2IGluIG4pXHJcbiAgICAgICAgICAgIGlbdl0gPSBtW3ZdO1xyXG4gICAgcmV0dXJuIGk7XHJcbn1cclxudmFyIE1vZHVsZVNldCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNb2R1bGVTZXQoKSB7XHJcbiAgICAgICAgdGhpcy50YWJsZSA9IHt9O1xyXG4gICAgfVxyXG4gICAgTW9kdWxlU2V0LnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy50YWJsZSkubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIE1vZHVsZVNldC5wcm90b3R5cGUuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBNb2R1bGVTZXQoKTtcclxuICAgICAgICByZXN1bHQudGFibGUgPSBpbnRlcnNlY3Rpb24odGhpcy50YWJsZSwgb3RoZXIudGFibGUpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgTW9kdWxlU2V0LnByb3RvdHlwZS5pbnRlcnNlY3Rpb25Db3VudCA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdGlvbihvdGhlcikuY291bnQoKTtcclxuICAgIH07XHJcbiAgICBNb2R1bGVTZXQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIGlkIGluIHRoaXMudGFibGU7XHJcbiAgICB9O1xyXG4gICAgTW9kdWxlU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgIHRoaXMudGFibGVbbS5pZF0gPSBtO1xyXG4gICAgfTtcclxuICAgIE1vZHVsZVNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICBkZWxldGUgdGhpcy50YWJsZVttLmlkXTtcclxuICAgIH07XHJcbiAgICBNb2R1bGVTZXQucHJvdG90eXBlLmZvckFsbCA9IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgZm9yICh2YXIgbWlkIGluIHRoaXMudGFibGUpIHtcclxuICAgICAgICAgICAgZih0aGlzLnRhYmxlW21pZF0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2R1bGVTZXQucHJvdG90eXBlLm1vZHVsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZzID0gW107XHJcbiAgICAgICAgdGhpcy5mb3JBbGwoZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgaWYgKCFtLmlzUHJlZGVmaW5lZCgpKVxyXG4gICAgICAgICAgICAgICAgdnMucHVzaChtKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdnM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1vZHVsZVNldDtcclxufSgpKTtcclxuZXhwb3J0cy5Nb2R1bGVTZXQgPSBNb2R1bGVTZXQ7XHJcbnZhciBMaW5rU2V0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMaW5rU2V0cygpIHtcclxuICAgICAgICB0aGlzLnNldHMgPSB7fTtcclxuICAgICAgICB0aGlzLm4gPSAwO1xyXG4gICAgfVxyXG4gICAgTGlua1NldHMucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm47XHJcbiAgICB9O1xyXG4gICAgTGlua1NldHMucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZm9yQWxsTW9kdWxlcyhmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICBpZiAoIXJlc3VsdCAmJiBtLmlkID09IGlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBMaW5rU2V0cy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGxpbmt0eXBlLCBtKSB7XHJcbiAgICAgICAgdmFyIHMgPSBsaW5rdHlwZSBpbiB0aGlzLnNldHMgPyB0aGlzLnNldHNbbGlua3R5cGVdIDogdGhpcy5zZXRzW2xpbmt0eXBlXSA9IG5ldyBNb2R1bGVTZXQoKTtcclxuICAgICAgICBzLmFkZChtKTtcclxuICAgICAgICArK3RoaXMubjtcclxuICAgIH07XHJcbiAgICBMaW5rU2V0cy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGxpbmt0eXBlLCBtKSB7XHJcbiAgICAgICAgdmFyIG1zID0gdGhpcy5zZXRzW2xpbmt0eXBlXTtcclxuICAgICAgICBtcy5yZW1vdmUobSk7XHJcbiAgICAgICAgaWYgKG1zLmNvdW50KCkgPT09IDApIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2V0c1tsaW5rdHlwZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC0tdGhpcy5uO1xyXG4gICAgfTtcclxuICAgIExpbmtTZXRzLnByb3RvdHlwZS5mb3JBbGwgPSBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgIGZvciAodmFyIGxpbmt0eXBlIGluIHRoaXMuc2V0cykge1xyXG4gICAgICAgICAgICBmKHRoaXMuc2V0c1tsaW5rdHlwZV0sIE51bWJlcihsaW5rdHlwZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMaW5rU2V0cy5wcm90b3R5cGUuZm9yQWxsTW9kdWxlcyA9IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgdGhpcy5mb3JBbGwoZnVuY3Rpb24gKG1zLCBsdCkgeyByZXR1cm4gbXMuZm9yQWxsKGYpOyB9KTtcclxuICAgIH07XHJcbiAgICBMaW5rU2V0cy5wcm90b3R5cGUuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMaW5rU2V0cygpO1xyXG4gICAgICAgIHRoaXMuZm9yQWxsKGZ1bmN0aW9uIChtcywgbHQpIHtcclxuICAgICAgICAgICAgaWYgKGx0IGluIG90aGVyLnNldHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gbXMuaW50ZXJzZWN0aW9uKG90aGVyLnNldHNbbHRdKSwgbiA9IGkuY291bnQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChuID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRzW2x0XSA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm4gKz0gbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExpbmtTZXRzO1xyXG59KCkpO1xyXG5leHBvcnRzLkxpbmtTZXRzID0gTGlua1NldHM7XHJcbmZ1bmN0aW9uIGludGVyc2VjdGlvbkNvdW50KG0sIG4pIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhpbnRlcnNlY3Rpb24obSwgbikpLmxlbmd0aDtcclxufVxyXG5mdW5jdGlvbiBnZXRHcm91cHMobm9kZXMsIGxpbmtzLCBsYSwgcm9vdEdyb3VwKSB7XHJcbiAgICB2YXIgbiA9IG5vZGVzLmxlbmd0aCwgYyA9IG5ldyBDb25maWd1cmF0aW9uKG4sIGxpbmtzLCBsYSwgcm9vdEdyb3VwKTtcclxuICAgIHdoaWxlIChjLmdyZWVkeU1lcmdlKCkpXHJcbiAgICAgICAgO1xyXG4gICAgdmFyIHBvd2VyRWRnZXMgPSBbXTtcclxuICAgIHZhciBnID0gYy5nZXRHcm91cEhpZXJhcmNoeShwb3dlckVkZ2VzKTtcclxuICAgIHBvd2VyRWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHZhciBmID0gZnVuY3Rpb24gKGVuZCkge1xyXG4gICAgICAgICAgICB2YXIgZyA9IGVbZW5kXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBnID09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICBlW2VuZF0gPSBub2Rlc1tnXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGYoXCJzb3VyY2VcIik7XHJcbiAgICAgICAgZihcInRhcmdldFwiKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHsgZ3JvdXBzOiBnLCBwb3dlckVkZ2VzOiBwb3dlckVkZ2VzIH07XHJcbn1cclxuZXhwb3J0cy5nZXRHcm91cHMgPSBnZXRHcm91cHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvd2VyZ3JhcGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFBhaXJpbmdIZWFwID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBhaXJpbmdIZWFwKGVsZW0pIHtcclxuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgICAgIHRoaXMuc3ViaGVhcHMgPSBbXTtcclxuICAgIH1cclxuICAgIFBhaXJpbmdIZWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgIHZhciBzdHIgPSBcIlwiLCBuZWVkQ29tbWEgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3ViaGVhcHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHN1YmhlYXAgPSB0aGlzLnN1YmhlYXBzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIXN1YmhlYXAuZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgbmVlZENvbW1hID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmVlZENvbW1hKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIgKyBcIixcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHIgPSBzdHIgKyBzdWJoZWFwLnRvU3RyaW5nKHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgbmVlZENvbW1hID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0ciAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICBzdHIgPSBcIihcIiArIHN0ciArIFwiKVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHRoaXMuZWxlbSA/IHNlbGVjdG9yKHRoaXMuZWxlbSkgOiBcIlwiKSArIHN0cjtcclxuICAgIH07XHJcbiAgICBQYWlyaW5nSGVhcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmVtcHR5KCkpIHtcclxuICAgICAgICAgICAgZih0aGlzLmVsZW0sIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnN1YmhlYXBzLmZvckVhY2goZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuZm9yRWFjaChmKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBhaXJpbmdIZWFwLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbXB0eSgpID8gMCA6IDEgKyB0aGlzLnN1YmhlYXBzLnJlZHVjZShmdW5jdGlvbiAobiwgaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbiArIGguY291bnQoKTtcclxuICAgICAgICB9LCAwKTtcclxuICAgIH07XHJcbiAgICBQYWlyaW5nSGVhcC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW07XHJcbiAgICB9O1xyXG4gICAgUGFpcmluZ0hlYXAucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW0gPT0gbnVsbDtcclxuICAgIH07XHJcbiAgICBQYWlyaW5nSGVhcC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoaCkge1xyXG4gICAgICAgIGlmICh0aGlzID09PSBoKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3ViaGVhcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3ViaGVhcHNbaV0uY29udGFpbnMoaCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIFBhaXJpbmdIZWFwLnByb3RvdHlwZS5pc0hlYXAgPSBmdW5jdGlvbiAobGVzc1RoYW4pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YmhlYXBzLmV2ZXJ5KGZ1bmN0aW9uIChoKSB7IHJldHVybiBsZXNzVGhhbihfdGhpcy5lbGVtLCBoLmVsZW0pICYmIGguaXNIZWFwKGxlc3NUaGFuKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgUGFpcmluZ0hlYXAucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChvYmosIGxlc3NUaGFuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2UobmV3IFBhaXJpbmdIZWFwKG9iaiksIGxlc3NUaGFuKTtcclxuICAgIH07XHJcbiAgICBQYWlyaW5nSGVhcC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAoaGVhcDIsIGxlc3NUaGFuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW1wdHkoKSlcclxuICAgICAgICAgICAgcmV0dXJuIGhlYXAyO1xyXG4gICAgICAgIGVsc2UgaWYgKGhlYXAyLmVtcHR5KCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIGVsc2UgaWYgKGxlc3NUaGFuKHRoaXMuZWxlbSwgaGVhcDIuZWxlbSkpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWJoZWFwcy5wdXNoKGhlYXAyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBoZWFwMi5zdWJoZWFwcy5wdXNoKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gaGVhcDI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBhaXJpbmdIZWFwLnByb3RvdHlwZS5yZW1vdmVNaW4gPSBmdW5jdGlvbiAobGVzc1RoYW4pIHtcclxuICAgICAgICBpZiAodGhpcy5lbXB0eSgpKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lcmdlUGFpcnMobGVzc1RoYW4pO1xyXG4gICAgfTtcclxuICAgIFBhaXJpbmdIZWFwLnByb3RvdHlwZS5tZXJnZVBhaXJzID0gZnVuY3Rpb24gKGxlc3NUaGFuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3ViaGVhcHMubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFpcmluZ0hlYXAobnVsbCk7XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdWJoZWFwcy5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJoZWFwc1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFBhaXIgPSB0aGlzLnN1YmhlYXBzLnBvcCgpLm1lcmdlKHRoaXMuc3ViaGVhcHMucG9wKCksIGxlc3NUaGFuKTtcclxuICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHRoaXMubWVyZ2VQYWlycyhsZXNzVGhhbik7XHJcbiAgICAgICAgICAgIHJldHVybiBmaXJzdFBhaXIubWVyZ2UocmVtYWluaW5nLCBsZXNzVGhhbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBhaXJpbmdIZWFwLnByb3RvdHlwZS5kZWNyZWFzZUtleSA9IGZ1bmN0aW9uIChzdWJoZWFwLCBuZXdWYWx1ZSwgc2V0SGVhcE5vZGUsIGxlc3NUaGFuKSB7XHJcbiAgICAgICAgdmFyIG5ld0hlYXAgPSBzdWJoZWFwLnJlbW92ZU1pbihsZXNzVGhhbik7XHJcbiAgICAgICAgc3ViaGVhcC5lbGVtID0gbmV3SGVhcC5lbGVtO1xyXG4gICAgICAgIHN1YmhlYXAuc3ViaGVhcHMgPSBuZXdIZWFwLnN1YmhlYXBzO1xyXG4gICAgICAgIGlmIChzZXRIZWFwTm9kZSAhPT0gbnVsbCAmJiBuZXdIZWFwLmVsZW0gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgc2V0SGVhcE5vZGUoc3ViaGVhcC5lbGVtLCBzdWJoZWFwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhaXJpbmdOb2RlID0gbmV3IFBhaXJpbmdIZWFwKG5ld1ZhbHVlKTtcclxuICAgICAgICBpZiAoc2V0SGVhcE5vZGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgc2V0SGVhcE5vZGUobmV3VmFsdWUsIHBhaXJpbmdOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2UocGFpcmluZ05vZGUsIGxlc3NUaGFuKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUGFpcmluZ0hlYXA7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUGFpcmluZ0hlYXAgPSBQYWlyaW5nSGVhcDtcclxudmFyIFByaW9yaXR5UXVldWUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJpb3JpdHlRdWV1ZShsZXNzVGhhbikge1xyXG4gICAgICAgIHRoaXMubGVzc1RoYW4gPSBsZXNzVGhhbjtcclxuICAgIH1cclxuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5yb290LmVsZW07XHJcbiAgICB9O1xyXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhaXJpbmdOb2RlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBhcmc7IGFyZyA9IGFyZ3NbaV07ICsraSkge1xyXG4gICAgICAgICAgICBwYWlyaW5nTm9kZSA9IG5ldyBQYWlyaW5nSGVhcChhcmcpO1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLmVtcHR5KCkgP1xyXG4gICAgICAgICAgICAgICAgcGFpcmluZ05vZGUgOiB0aGlzLnJvb3QubWVyZ2UocGFpcmluZ05vZGUsIHRoaXMubGVzc1RoYW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFpcmluZ05vZGU7XHJcbiAgICB9O1xyXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLnJvb3QgfHwgIXRoaXMucm9vdC5lbGVtO1xyXG4gICAgfTtcclxuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmlzSGVhcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290LmlzSGVhcCh0aGlzLmxlc3NUaGFuKTtcclxuICAgIH07XHJcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICB0aGlzLnJvb3QuZm9yRWFjaChmKTtcclxuICAgIH07XHJcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMucm9vdC5taW4oKTtcclxuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLnJvb3QucmVtb3ZlTWluKHRoaXMubGVzc1RoYW4pO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9O1xyXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucmVkdWNlS2V5ID0gZnVuY3Rpb24gKGhlYXBOb2RlLCBuZXdLZXksIHNldEhlYXBOb2RlKSB7XHJcbiAgICAgICAgaWYgKHNldEhlYXBOb2RlID09PSB2b2lkIDApIHsgc2V0SGVhcE5vZGUgPSBudWxsOyB9XHJcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5yb290LmRlY3JlYXNlS2V5KGhlYXBOb2RlLCBuZXdLZXksIHNldEhlYXBOb2RlLCB0aGlzLmxlc3NUaGFuKTtcclxuICAgIH07XHJcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QudG9TdHJpbmcoc2VsZWN0b3IpO1xyXG4gICAgfTtcclxuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuY291bnQoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJpb3JpdHlRdWV1ZTtcclxufSgpKTtcclxuZXhwb3J0cy5Qcmlvcml0eVF1ZXVlID0gUHJpb3JpdHlRdWV1ZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHF1ZXVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVHJlZUJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVHJlZUJhc2UoKSB7XHJcbiAgICAgICAgdGhpcy5maW5kSXRlciA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLl9yb290O1xyXG4gICAgICAgICAgICB2YXIgaXRlciA9IHRoaXMuaXRlcmF0b3IoKTtcclxuICAgICAgICAgICAgd2hpbGUgKHJlcyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLl9jb21wYXJhdG9yKGRhdGEsIHJlcy5kYXRhKTtcclxuICAgICAgICAgICAgICAgIGlmIChjID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlci5fY3Vyc29yID0gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlci5fYW5jZXN0b3JzLnB1c2gocmVzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuZ2V0X2NoaWxkKGMgPiAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgVHJlZUJhc2UucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgVHJlZUJhc2UucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHZhciByZXMgPSB0aGlzLl9yb290O1xyXG4gICAgICAgIHdoaWxlIChyZXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLl9jb21wYXJhdG9yKGRhdGEsIHJlcy5kYXRhKTtcclxuICAgICAgICAgICAgaWYgKGMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXMuZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5nZXRfY2hpbGQoYyA+IDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFRyZWVCYXNlLnByb3RvdHlwZS5sb3dlckJvdW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmQoZGF0YSwgdGhpcy5fY29tcGFyYXRvcik7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgVHJlZUJhc2UucHJvdG90eXBlLnVwcGVyQm91bmQgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHZhciBjbXAgPSB0aGlzLl9jb21wYXJhdG9yO1xyXG4gICAgICAgIGZ1bmN0aW9uIHJldmVyc2VfY21wKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNtcChiLCBhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kKGRhdGEsIHJldmVyc2VfY21wKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBUcmVlQmFzZS5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXMgPSB0aGlzLl9yb290O1xyXG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChyZXMubGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXMgPSByZXMubGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcy5kYXRhO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFRyZWVCYXNlLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHJlcy5yaWdodCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXMgPSByZXMucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXMuZGF0YTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBUcmVlQmFzZS5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcih0aGlzKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBUcmVlQmFzZS5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChjYikge1xyXG4gICAgICAgIHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKSwgZGF0YTtcclxuICAgICAgICB3aGlsZSAoKGRhdGEgPSBpdC5uZXh0KCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNiKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBUcmVlQmFzZS5wcm90b3R5cGUucmVhY2ggPSBmdW5jdGlvbiAoY2IpIHtcclxuICAgICAgICB2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCksIGRhdGE7XHJcbiAgICAgICAgd2hpbGUgKChkYXRhID0gaXQucHJldigpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjYihkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgVHJlZUJhc2UucHJvdG90eXBlLl9ib3VuZCA9IGZ1bmN0aW9uIChkYXRhLCBjbXApIHtcclxuICAgICAgICB2YXIgY3VyID0gdGhpcy5fcm9vdDtcclxuICAgICAgICB2YXIgaXRlciA9IHRoaXMuaXRlcmF0b3IoKTtcclxuICAgICAgICB3aGlsZSAoY3VyICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5fY29tcGFyYXRvcihkYXRhLCBjdXIuZGF0YSk7XHJcbiAgICAgICAgICAgIGlmIChjID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVyLl9jdXJzb3IgPSBjdXI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpdGVyLl9hbmNlc3RvcnMucHVzaChjdXIpO1xyXG4gICAgICAgICAgICBjdXIgPSBjdXIuZ2V0X2NoaWxkKGMgPiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGl0ZXIuX2FuY2VzdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICBjdXIgPSBpdGVyLl9hbmNlc3RvcnNbaV07XHJcbiAgICAgICAgICAgIGlmIChjbXAoZGF0YSwgY3VyLmRhdGEpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaXRlci5fY3Vyc29yID0gY3VyO1xyXG4gICAgICAgICAgICAgICAgaXRlci5fYW5jZXN0b3JzLmxlbmd0aCA9IGk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpdGVyLl9hbmNlc3RvcnMubGVuZ3RoID0gMDtcclxuICAgICAgICByZXR1cm4gaXRlcjtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gVHJlZUJhc2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVHJlZUJhc2UgPSBUcmVlQmFzZTtcclxudmFyIEl0ZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEl0ZXJhdG9yKHRyZWUpIHtcclxuICAgICAgICB0aGlzLl90cmVlID0gdHJlZTtcclxuICAgICAgICB0aGlzLl9hbmNlc3RvcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9jdXJzb3IgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgSXRlcmF0b3IucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnNvciAhPT0gbnVsbCA/IHRoaXMuX2N1cnNvci5kYXRhIDogbnVsbDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fY3Vyc29yID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5fdHJlZS5fcm9vdDtcclxuICAgICAgICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21pbk5vZGUocm9vdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJzb3IucmlnaHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzYXZlO1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNhdmUgPSB0aGlzLl9jdXJzb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FuY2VzdG9ycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gdGhpcy5fYW5jZXN0b3JzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5fY3Vyc29yLnJpZ2h0ID09PSBzYXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FuY2VzdG9ycy5wdXNoKHRoaXMuX2N1cnNvcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5Ob2RlKHRoaXMuX2N1cnNvci5yaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnNvciAhPT0gbnVsbCA/IHRoaXMuX2N1cnNvci5kYXRhIDogbnVsbDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBJdGVyYXRvci5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fY3Vyc29yID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5fdHJlZS5fcm9vdDtcclxuICAgICAgICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21heE5vZGUocm9vdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJzb3IubGVmdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNhdmU7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2F2ZSA9IHRoaXMuX2N1cnNvcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYW5jZXN0b3JzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSB0aGlzLl9hbmNlc3RvcnMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0aGlzLl9jdXJzb3IubGVmdCA9PT0gc2F2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmNlc3RvcnMucHVzaCh0aGlzLl9jdXJzb3IpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWF4Tm9kZSh0aGlzLl9jdXJzb3IubGVmdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnNvciAhPT0gbnVsbCA/IHRoaXMuX2N1cnNvci5kYXRhIDogbnVsbDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBJdGVyYXRvci5wcm90b3R5cGUuX21pbk5vZGUgPSBmdW5jdGlvbiAoc3RhcnQpIHtcclxuICAgICAgICB3aGlsZSAoc3RhcnQubGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hbmNlc3RvcnMucHVzaChzdGFydCk7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQubGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY3Vyc29yID0gc3RhcnQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgSXRlcmF0b3IucHJvdG90eXBlLl9tYXhOb2RlID0gZnVuY3Rpb24gKHN0YXJ0KSB7XHJcbiAgICAgICAgd2hpbGUgKHN0YXJ0LnJpZ2h0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FuY2VzdG9ycy5wdXNoKHN0YXJ0KTtcclxuICAgICAgICAgICAgc3RhcnQgPSBzdGFydC5yaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY3Vyc29yID0gc3RhcnQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIEl0ZXJhdG9yO1xyXG59KCkpO1xyXG5leHBvcnRzLkl0ZXJhdG9yID0gSXRlcmF0b3I7XHJcbnZhciBOb2RlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5vZGUoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBOb2RlLnByb3RvdHlwZS5nZXRfY2hpbGQgPSBmdW5jdGlvbiAoZGlyKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpciA/IHRoaXMucmlnaHQgOiB0aGlzLmxlZnQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgTm9kZS5wcm90b3R5cGUuc2V0X2NoaWxkID0gZnVuY3Rpb24gKGRpciwgdmFsKSB7XHJcbiAgICAgICAgaWYgKGRpcikge1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gTm9kZTtcclxufSgpKTtcclxudmFyIFJCVHJlZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUkJUcmVlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUkJUcmVlKGNvbXBhcmF0b3IpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl9yb290ID0gbnVsbDtcclxuICAgICAgICBfdGhpcy5fY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XHJcbiAgICAgICAgX3RoaXMuc2l6ZSA9IDA7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgUkJUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHZhciByZXQgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5fcm9vdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gbmV3IE5vZGUoZGF0YSk7XHJcbiAgICAgICAgICAgIHJldCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc2l6ZSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGhlYWQgPSBuZXcgTm9kZSh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB2YXIgZGlyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBsYXN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBncCA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBnZ3AgPSBoZWFkO1xyXG4gICAgICAgICAgICB2YXIgcCA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fcm9vdDtcclxuICAgICAgICAgICAgZ2dwLnJpZ2h0ID0gdGhpcy5fcm9vdDtcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBOb2RlKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHAuc2V0X2NoaWxkKGRpciwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFJCVHJlZS5pc19yZWQobm9kZS5sZWZ0KSAmJiBSQlRyZWUuaXNfcmVkKG5vZGUucmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGVmdC5yZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnJpZ2h0LnJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKFJCVHJlZS5pc19yZWQobm9kZSkgJiYgUkJUcmVlLmlzX3JlZChwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXIyID0gZ2dwLnJpZ2h0ID09PSBncDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gcC5nZXRfY2hpbGQobGFzdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2dwLnNldF9jaGlsZChkaXIyLCBSQlRyZWUuc2luZ2xlX3JvdGF0ZShncCwgIWxhc3QpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdncC5zZXRfY2hpbGQoZGlyMiwgUkJUcmVlLmRvdWJsZV9yb3RhdGUoZ3AsICFsYXN0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmF0b3Iobm9kZS5kYXRhLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhc3QgPSBkaXI7XHJcbiAgICAgICAgICAgICAgICBkaXIgPSBjbXAgPCAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdwICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2dwID0gZ3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBncCA9IHA7XHJcbiAgICAgICAgICAgICAgICBwID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmdldF9jaGlsZChkaXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBoZWFkLnJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yb290LnJlZCA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgUkJUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGhlYWQgPSBuZXcgTm9kZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIHZhciBub2RlID0gaGVhZDtcclxuICAgICAgICBub2RlLnJpZ2h0ID0gdGhpcy5fcm9vdDtcclxuICAgICAgICB2YXIgcCA9IG51bGw7XHJcbiAgICAgICAgdmFyIGdwID0gbnVsbDtcclxuICAgICAgICB2YXIgZm91bmQgPSBudWxsO1xyXG4gICAgICAgIHZhciBkaXIgPSB0cnVlO1xyXG4gICAgICAgIHdoaWxlIChub2RlLmdldF9jaGlsZChkaXIpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXN0ID0gZGlyO1xyXG4gICAgICAgICAgICBncCA9IHA7XHJcbiAgICAgICAgICAgIHAgPSBub2RlO1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS5nZXRfY2hpbGQoZGlyKTtcclxuICAgICAgICAgICAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmF0b3IoZGF0YSwgbm9kZS5kYXRhKTtcclxuICAgICAgICAgICAgZGlyID0gY21wID4gMDtcclxuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZm91bmQgPSBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghUkJUcmVlLmlzX3JlZChub2RlKSAmJiAhUkJUcmVlLmlzX3JlZChub2RlLmdldF9jaGlsZChkaXIpKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFJCVHJlZS5pc19yZWQobm9kZS5nZXRfY2hpbGQoIWRpcikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNyID0gUkJUcmVlLnNpbmdsZV9yb3RhdGUobm9kZSwgZGlyKTtcclxuICAgICAgICAgICAgICAgICAgICBwLnNldF9jaGlsZChsYXN0LCBzcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IHNyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIVJCVHJlZS5pc19yZWQobm9kZS5nZXRfY2hpbGQoIWRpcikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSBwLmdldF9jaGlsZCghbGFzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFSQlRyZWUuaXNfcmVkKHNpYmxpbmcuZ2V0X2NoaWxkKCFsYXN0KSkgJiYgIVJCVHJlZS5pc19yZWQoc2libGluZy5nZXRfY2hpbGQobGFzdCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLnJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZy5yZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpcjIgPSBncC5yaWdodCA9PT0gcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSQlRyZWUuaXNfcmVkKHNpYmxpbmcuZ2V0X2NoaWxkKGxhc3QpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdwLnNldF9jaGlsZChkaXIyLCBSQlRyZWUuZG91YmxlX3JvdGF0ZShwLCBsYXN0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChSQlRyZWUuaXNfcmVkKHNpYmxpbmcuZ2V0X2NoaWxkKCFsYXN0KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncC5zZXRfY2hpbGQoZGlyMiwgUkJUcmVlLnNpbmdsZV9yb3RhdGUocCwgbGFzdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdwYyA9IGdwLmdldF9jaGlsZChkaXIyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdwYy5yZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3BjLmxlZnQucmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncGMucmlnaHQucmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvdW5kICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvdW5kLmRhdGEgPSBub2RlLmRhdGE7XHJcbiAgICAgICAgICAgIHAuc2V0X2NoaWxkKHAucmlnaHQgPT09IG5vZGUsIG5vZGUuZ2V0X2NoaWxkKG5vZGUubGVmdCA9PT0gbnVsbCkpO1xyXG4gICAgICAgICAgICB0aGlzLnNpemUtLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcm9vdCA9IGhlYWQucmlnaHQ7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fcm9vdC5yZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZvdW5kICE9PSBudWxsO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFJCVHJlZS5pc19yZWQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHJldHVybiBub2RlICE9PSBudWxsICYmIG5vZGUucmVkO1xyXG4gICAgfTtcclxuICAgIFJCVHJlZS5zaW5nbGVfcm90YXRlID0gZnVuY3Rpb24gKHJvb3QsIGRpcikge1xyXG4gICAgICAgIHZhciBzYXZlID0gcm9vdC5nZXRfY2hpbGQoIWRpcik7XHJcbiAgICAgICAgcm9vdC5zZXRfY2hpbGQoIWRpciwgc2F2ZS5nZXRfY2hpbGQoZGlyKSk7XHJcbiAgICAgICAgc2F2ZS5zZXRfY2hpbGQoZGlyLCByb290KTtcclxuICAgICAgICByb290LnJlZCA9IHRydWU7XHJcbiAgICAgICAgc2F2ZS5yZWQgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gc2F2ZTtcclxuICAgIH07XHJcbiAgICBSQlRyZWUuZG91YmxlX3JvdGF0ZSA9IGZ1bmN0aW9uIChyb290LCBkaXIpIHtcclxuICAgICAgICByb290LnNldF9jaGlsZCghZGlyLCBSQlRyZWUuc2luZ2xlX3JvdGF0ZShyb290LmdldF9jaGlsZCghZGlyKSwgIWRpcikpO1xyXG4gICAgICAgIHJldHVybiBSQlRyZWUuc2luZ2xlX3JvdGF0ZShyb290LCBkaXIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSQlRyZWU7XHJcbn0oVHJlZUJhc2UpKTtcclxuZXhwb3J0cy5SQlRyZWUgPSBSQlRyZWU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJidHJlZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHZwc2NfMSA9IHJlcXVpcmUoXCIuL3Zwc2NcIik7XHJcbnZhciByYnRyZWVfMSA9IHJlcXVpcmUoXCIuL3JidHJlZVwiKTtcclxuZnVuY3Rpb24gY29tcHV0ZUdyb3VwQm91bmRzKGcpIHtcclxuICAgIGcuYm91bmRzID0gdHlwZW9mIGcubGVhdmVzICE9PSBcInVuZGVmaW5lZFwiID9cclxuICAgICAgICBnLmxlYXZlcy5yZWR1Y2UoZnVuY3Rpb24gKHIsIGMpIHsgcmV0dXJuIGMuYm91bmRzLnVuaW9uKHIpOyB9LCBSZWN0YW5nbGUuZW1wdHkoKSkgOlxyXG4gICAgICAgIFJlY3RhbmdsZS5lbXB0eSgpO1xyXG4gICAgaWYgKHR5cGVvZiBnLmdyb3VwcyAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICBnLmJvdW5kcyA9IGcuZ3JvdXBzLnJlZHVjZShmdW5jdGlvbiAociwgYykgeyByZXR1cm4gY29tcHV0ZUdyb3VwQm91bmRzKGMpLnVuaW9uKHIpOyB9LCBnLmJvdW5kcyk7XHJcbiAgICBnLmJvdW5kcyA9IGcuYm91bmRzLmluZmxhdGUoZy5wYWRkaW5nKTtcclxuICAgIHJldHVybiBnLmJvdW5kcztcclxufVxyXG5leHBvcnRzLmNvbXB1dGVHcm91cEJvdW5kcyA9IGNvbXB1dGVHcm91cEJvdW5kcztcclxudmFyIFJlY3RhbmdsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZWN0YW5nbGUoeCwgWCwgeSwgWSkge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy5YID0gWDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMuWSA9IFk7XHJcbiAgICB9XHJcbiAgICBSZWN0YW5nbGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUmVjdGFuZ2xlKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7IH07XHJcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLmN4ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMueCArIHRoaXMuWCkgLyAyOyB9O1xyXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5jeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLnkgKyB0aGlzLlkpIC8gMjsgfTtcclxuICAgIFJlY3RhbmdsZS5wcm90b3R5cGUub3ZlcmxhcFggPSBmdW5jdGlvbiAocikge1xyXG4gICAgICAgIHZhciB1eCA9IHRoaXMuY3goKSwgdnggPSByLmN4KCk7XHJcbiAgICAgICAgaWYgKHV4IDw9IHZ4ICYmIHIueCA8IHRoaXMuWClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuWCAtIHIueDtcclxuICAgICAgICBpZiAodnggPD0gdXggJiYgdGhpcy54IDwgci5YKVxyXG4gICAgICAgICAgICByZXR1cm4gci5YIC0gdGhpcy54O1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIFJlY3RhbmdsZS5wcm90b3R5cGUub3ZlcmxhcFkgPSBmdW5jdGlvbiAocikge1xyXG4gICAgICAgIHZhciB1eSA9IHRoaXMuY3koKSwgdnkgPSByLmN5KCk7XHJcbiAgICAgICAgaWYgKHV5IDw9IHZ5ICYmIHIueSA8IHRoaXMuWSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuWSAtIHIueTtcclxuICAgICAgICBpZiAodnkgPD0gdXkgJiYgdGhpcy55IDwgci5ZKVxyXG4gICAgICAgICAgICByZXR1cm4gci5ZIC0gdGhpcy55O1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuc2V0WENlbnRyZSA9IGZ1bmN0aW9uIChjeCkge1xyXG4gICAgICAgIHZhciBkeCA9IGN4IC0gdGhpcy5jeCgpO1xyXG4gICAgICAgIHRoaXMueCArPSBkeDtcclxuICAgICAgICB0aGlzLlggKz0gZHg7XHJcbiAgICB9O1xyXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5zZXRZQ2VudHJlID0gZnVuY3Rpb24gKGN5KSB7XHJcbiAgICAgICAgdmFyIGR5ID0gY3kgLSB0aGlzLmN5KCk7XHJcbiAgICAgICAgdGhpcy55ICs9IGR5O1xyXG4gICAgICAgIHRoaXMuWSArPSBkeTtcclxuICAgIH07XHJcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLlggLSB0aGlzLng7XHJcbiAgICB9O1xyXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuWSAtIHRoaXMueTtcclxuICAgIH07XHJcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShNYXRoLm1pbih0aGlzLngsIHIueCksIE1hdGgubWF4KHRoaXMuWCwgci5YKSwgTWF0aC5taW4odGhpcy55LCByLnkpLCBNYXRoLm1heCh0aGlzLlksIHIuWSkpO1xyXG4gICAgfTtcclxuICAgIFJlY3RhbmdsZS5wcm90b3R5cGUubGluZUludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcclxuICAgICAgICB2YXIgc2lkZXMgPSBbW3RoaXMueCwgdGhpcy55LCB0aGlzLlgsIHRoaXMueV0sXHJcbiAgICAgICAgICAgIFt0aGlzLlgsIHRoaXMueSwgdGhpcy5YLCB0aGlzLlldLFxyXG4gICAgICAgICAgICBbdGhpcy5YLCB0aGlzLlksIHRoaXMueCwgdGhpcy5ZXSxcclxuICAgICAgICAgICAgW3RoaXMueCwgdGhpcy5ZLCB0aGlzLngsIHRoaXMueV1dO1xyXG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25zID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHIgPSBSZWN0YW5nbGUubGluZUludGVyc2VjdGlvbih4MSwgeTEsIHgyLCB5Miwgc2lkZXNbaV1bMF0sIHNpZGVzW2ldWzFdLCBzaWRlc1tpXVsyXSwgc2lkZXNbaV1bM10pO1xyXG4gICAgICAgICAgICBpZiAociAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbnMucHVzaCh7IHg6IHIueCwgeTogci55IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcclxuICAgIH07XHJcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLnJheUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uICh4MiwgeTIpIHtcclxuICAgICAgICB2YXIgaW50cyA9IHRoaXMubGluZUludGVyc2VjdGlvbnModGhpcy5jeCgpLCB0aGlzLmN5KCksIHgyLCB5Mik7XHJcbiAgICAgICAgcmV0dXJuIGludHMubGVuZ3RoID4gMCA/IGludHNbMF0gOiBudWxsO1xyXG4gICAgfTtcclxuICAgIFJlY3RhbmdsZS5wcm90b3R5cGUudmVydGljZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgeyB4OiB0aGlzLngsIHk6IHRoaXMueSB9LFxyXG4gICAgICAgICAgICB7IHg6IHRoaXMuWCwgeTogdGhpcy55IH0sXHJcbiAgICAgICAgICAgIHsgeDogdGhpcy5YLCB5OiB0aGlzLlkgfSxcclxuICAgICAgICAgICAgeyB4OiB0aGlzLngsIHk6IHRoaXMuWSB9XHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcbiAgICBSZWN0YW5nbGUubGluZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQpIHtcclxuICAgICAgICB2YXIgZHgxMiA9IHgyIC0geDEsIGR4MzQgPSB4NCAtIHgzLCBkeTEyID0geTIgLSB5MSwgZHkzNCA9IHk0IC0geTMsIGRlbm9taW5hdG9yID0gZHkzNCAqIGR4MTIgLSBkeDM0ICogZHkxMjtcclxuICAgICAgICBpZiAoZGVub21pbmF0b3IgPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgdmFyIGR4MzEgPSB4MSAtIHgzLCBkeTMxID0geTEgLSB5MywgbnVtYSA9IGR4MzQgKiBkeTMxIC0gZHkzNCAqIGR4MzEsIGEgPSBudW1hIC8gZGVub21pbmF0b3IsIG51bWIgPSBkeDEyICogZHkzMSAtIGR5MTIgKiBkeDMxLCBiID0gbnVtYiAvIGRlbm9taW5hdG9yO1xyXG4gICAgICAgIGlmIChhID49IDAgJiYgYSA8PSAxICYmIGIgPj0gMCAmJiBiIDw9IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IHgxICsgYSAqIGR4MTIsXHJcbiAgICAgICAgICAgICAgICB5OiB5MSArIGEgKiBkeTEyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuaW5mbGF0ZSA9IGZ1bmN0aW9uIChwYWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSBwYWQsIHRoaXMuWCArIHBhZCwgdGhpcy55IC0gcGFkLCB0aGlzLlkgKyBwYWQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZWN0YW5nbGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlO1xyXG5mdW5jdGlvbiBtYWtlRWRnZUJldHdlZW4oc291cmNlLCB0YXJnZXQsIGFoKSB7XHJcbiAgICB2YXIgc2kgPSBzb3VyY2UucmF5SW50ZXJzZWN0aW9uKHRhcmdldC5jeCgpLCB0YXJnZXQuY3koKSkgfHwgeyB4OiBzb3VyY2UuY3goKSwgeTogc291cmNlLmN5KCkgfSwgdGkgPSB0YXJnZXQucmF5SW50ZXJzZWN0aW9uKHNvdXJjZS5jeCgpLCBzb3VyY2UuY3koKSkgfHwgeyB4OiB0YXJnZXQuY3goKSwgeTogdGFyZ2V0LmN5KCkgfSwgZHggPSB0aS54IC0gc2kueCwgZHkgPSB0aS55IC0gc2kueSwgbCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSksIGFsID0gbCAtIGFoO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzb3VyY2VJbnRlcnNlY3Rpb246IHNpLFxyXG4gICAgICAgIHRhcmdldEludGVyc2VjdGlvbjogdGksXHJcbiAgICAgICAgYXJyb3dTdGFydDogeyB4OiBzaS54ICsgYWwgKiBkeCAvIGwsIHk6IHNpLnkgKyBhbCAqIGR5IC8gbCB9XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMubWFrZUVkZ2VCZXR3ZWVuID0gbWFrZUVkZ2VCZXR3ZWVuO1xyXG5mdW5jdGlvbiBtYWtlRWRnZVRvKHMsIHRhcmdldCwgYWgpIHtcclxuICAgIHZhciB0aSA9IHRhcmdldC5yYXlJbnRlcnNlY3Rpb24ocy54LCBzLnkpO1xyXG4gICAgaWYgKCF0aSlcclxuICAgICAgICB0aSA9IHsgeDogdGFyZ2V0LmN4KCksIHk6IHRhcmdldC5jeSgpIH07XHJcbiAgICB2YXIgZHggPSB0aS54IC0gcy54LCBkeSA9IHRpLnkgLSBzLnksIGwgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gICAgcmV0dXJuIHsgeDogdGkueCAtIGFoICogZHggLyBsLCB5OiB0aS55IC0gYWggKiBkeSAvIGwgfTtcclxufVxyXG5leHBvcnRzLm1ha2VFZGdlVG8gPSBtYWtlRWRnZVRvO1xyXG52YXIgTm9kZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb2RlKHYsIHIsIHBvcykge1xyXG4gICAgICAgIHRoaXMudiA9IHY7XHJcbiAgICAgICAgdGhpcy5yID0gcjtcclxuICAgICAgICB0aGlzLnBvcyA9IHBvcztcclxuICAgICAgICB0aGlzLnByZXYgPSBtYWtlUkJUcmVlKCk7XHJcbiAgICAgICAgdGhpcy5uZXh0ID0gbWFrZVJCVHJlZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE5vZGU7XHJcbn0oKSk7XHJcbnZhciBFdmVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudChpc09wZW4sIHYsIHBvcykge1xyXG4gICAgICAgIHRoaXMuaXNPcGVuID0gaXNPcGVuO1xyXG4gICAgICAgIHRoaXMudiA9IHY7XHJcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRXZlbnQ7XHJcbn0oKSk7XHJcbmZ1bmN0aW9uIGNvbXBhcmVFdmVudHMoYSwgYikge1xyXG4gICAgaWYgKGEucG9zID4gYi5wb3MpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGlmIChhLnBvcyA8IGIucG9zKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgaWYgKGEuaXNPcGVuKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgaWYgKGIuaXNPcGVuKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5mdW5jdGlvbiBtYWtlUkJUcmVlKCkge1xyXG4gICAgcmV0dXJuIG5ldyByYnRyZWVfMS5SQlRyZWUoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEucG9zIC0gYi5wb3M7IH0pO1xyXG59XHJcbnZhciB4UmVjdCA9IHtcclxuICAgIGdldENlbnRyZTogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIuY3goKTsgfSxcclxuICAgIGdldE9wZW46IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnk7IH0sXHJcbiAgICBnZXRDbG9zZTogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIuWTsgfSxcclxuICAgIGdldFNpemU6IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLndpZHRoKCk7IH0sXHJcbiAgICBtYWtlUmVjdDogZnVuY3Rpb24gKG9wZW4sIGNsb3NlLCBjZW50ZXIsIHNpemUpIHsgcmV0dXJuIG5ldyBSZWN0YW5nbGUoY2VudGVyIC0gc2l6ZSAvIDIsIGNlbnRlciArIHNpemUgLyAyLCBvcGVuLCBjbG9zZSk7IH0sXHJcbiAgICBmaW5kTmVpZ2hib3VyczogZmluZFhOZWlnaGJvdXJzXHJcbn07XHJcbnZhciB5UmVjdCA9IHtcclxuICAgIGdldENlbnRyZTogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIuY3koKTsgfSxcclxuICAgIGdldE9wZW46IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLng7IH0sXHJcbiAgICBnZXRDbG9zZTogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIuWDsgfSxcclxuICAgIGdldFNpemU6IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLmhlaWdodCgpOyB9LFxyXG4gICAgbWFrZVJlY3Q6IGZ1bmN0aW9uIChvcGVuLCBjbG9zZSwgY2VudGVyLCBzaXplKSB7IHJldHVybiBuZXcgUmVjdGFuZ2xlKG9wZW4sIGNsb3NlLCBjZW50ZXIgLSBzaXplIC8gMiwgY2VudGVyICsgc2l6ZSAvIDIpOyB9LFxyXG4gICAgZmluZE5laWdoYm91cnM6IGZpbmRZTmVpZ2hib3Vyc1xyXG59O1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUdyb3VwQ29uc3RyYWludHMocm9vdCwgZiwgbWluU2VwLCBpc0NvbnRhaW5lZCkge1xyXG4gICAgaWYgKGlzQ29udGFpbmVkID09PSB2b2lkIDApIHsgaXNDb250YWluZWQgPSBmYWxzZTsgfVxyXG4gICAgdmFyIHBhZGRpbmcgPSByb290LnBhZGRpbmcsIGduID0gdHlwZW9mIHJvb3QuZ3JvdXBzICE9PSAndW5kZWZpbmVkJyA/IHJvb3QuZ3JvdXBzLmxlbmd0aCA6IDAsIGxuID0gdHlwZW9mIHJvb3QubGVhdmVzICE9PSAndW5kZWZpbmVkJyA/IHJvb3QubGVhdmVzLmxlbmd0aCA6IDAsIGNoaWxkQ29uc3RyYWludHMgPSAhZ24gPyBbXVxyXG4gICAgICAgIDogcm9vdC5ncm91cHMucmVkdWNlKGZ1bmN0aW9uIChjY3MsIGcpIHsgcmV0dXJuIGNjcy5jb25jYXQoZ2VuZXJhdGVHcm91cENvbnN0cmFpbnRzKGcsIGYsIG1pblNlcCwgdHJ1ZSkpOyB9LCBbXSksIG4gPSAoaXNDb250YWluZWQgPyAyIDogMCkgKyBsbiArIGduLCB2cyA9IG5ldyBBcnJheShuKSwgcnMgPSBuZXcgQXJyYXkobiksIGkgPSAwLCBhZGQgPSBmdW5jdGlvbiAociwgdikgeyByc1tpXSA9IHI7IHZzW2krK10gPSB2OyB9O1xyXG4gICAgaWYgKGlzQ29udGFpbmVkKSB7XHJcbiAgICAgICAgdmFyIGIgPSByb290LmJvdW5kcywgYyA9IGYuZ2V0Q2VudHJlKGIpLCBzID0gZi5nZXRTaXplKGIpIC8gMiwgb3BlbiA9IGYuZ2V0T3BlbihiKSwgY2xvc2UgPSBmLmdldENsb3NlKGIpLCBtaW4gPSBjIC0gcyArIHBhZGRpbmcgLyAyLCBtYXggPSBjICsgcyAtIHBhZGRpbmcgLyAyO1xyXG4gICAgICAgIHJvb3QubWluVmFyLmRlc2lyZWRQb3NpdGlvbiA9IG1pbjtcclxuICAgICAgICBhZGQoZi5tYWtlUmVjdChvcGVuLCBjbG9zZSwgbWluLCBwYWRkaW5nKSwgcm9vdC5taW5WYXIpO1xyXG4gICAgICAgIHJvb3QubWF4VmFyLmRlc2lyZWRQb3NpdGlvbiA9IG1heDtcclxuICAgICAgICBhZGQoZi5tYWtlUmVjdChvcGVuLCBjbG9zZSwgbWF4LCBwYWRkaW5nKSwgcm9vdC5tYXhWYXIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGxuKVxyXG4gICAgICAgIHJvb3QubGVhdmVzLmZvckVhY2goZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGFkZChsLmJvdW5kcywgbC52YXJpYWJsZSk7IH0pO1xyXG4gICAgaWYgKGduKVxyXG4gICAgICAgIHJvb3QuZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGcpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBnLmJvdW5kcztcclxuICAgICAgICAgICAgYWRkKGYubWFrZVJlY3QoZi5nZXRPcGVuKGIpLCBmLmdldENsb3NlKGIpLCBmLmdldENlbnRyZShiKSwgZi5nZXRTaXplKGIpKSwgZy5taW5WYXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgdmFyIGNzID0gZ2VuZXJhdGVDb25zdHJhaW50cyhycywgdnMsIGYsIG1pblNlcCk7XHJcbiAgICBpZiAoZ24pIHtcclxuICAgICAgICB2cy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHYuY091dCA9IFtdLCB2LmNJbiA9IFtdOyB9KTtcclxuICAgICAgICBjcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IGMubGVmdC5jT3V0LnB1c2goYyksIGMucmlnaHQuY0luLnB1c2goYyk7IH0pO1xyXG4gICAgICAgIHJvb3QuZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGcpIHtcclxuICAgICAgICAgICAgdmFyIGdhcEFkanVzdG1lbnQgPSAoZy5wYWRkaW5nIC0gZi5nZXRTaXplKGcuYm91bmRzKSkgLyAyO1xyXG4gICAgICAgICAgICBnLm1pblZhci5jSW4uZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5nYXAgKz0gZ2FwQWRqdXN0bWVudDsgfSk7XHJcbiAgICAgICAgICAgIGcubWluVmFyLmNPdXQuZm9yRWFjaChmdW5jdGlvbiAoYykgeyBjLmxlZnQgPSBnLm1heFZhcjsgYy5nYXAgKz0gZ2FwQWRqdXN0bWVudDsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hpbGRDb25zdHJhaW50cy5jb25jYXQoY3MpO1xyXG59XHJcbmZ1bmN0aW9uIGdlbmVyYXRlQ29uc3RyYWludHMocnMsIHZhcnMsIHJlY3QsIG1pblNlcCkge1xyXG4gICAgdmFyIGksIG4gPSBycy5sZW5ndGg7XHJcbiAgICB2YXIgTiA9IDIgKiBuO1xyXG4gICAgY29uc29sZS5hc3NlcnQodmFycy5sZW5ndGggPj0gbik7XHJcbiAgICB2YXIgZXZlbnRzID0gbmV3IEFycmF5KE4pO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIHZhciByID0gcnNbaV07XHJcbiAgICAgICAgdmFyIHYgPSBuZXcgTm9kZSh2YXJzW2ldLCByLCByZWN0LmdldENlbnRyZShyKSk7XHJcbiAgICAgICAgZXZlbnRzW2ldID0gbmV3IEV2ZW50KHRydWUsIHYsIHJlY3QuZ2V0T3BlbihyKSk7XHJcbiAgICAgICAgZXZlbnRzW2kgKyBuXSA9IG5ldyBFdmVudChmYWxzZSwgdiwgcmVjdC5nZXRDbG9zZShyKSk7XHJcbiAgICB9XHJcbiAgICBldmVudHMuc29ydChjb21wYXJlRXZlbnRzKTtcclxuICAgIHZhciBjcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgdmFyIHNjYW5saW5lID0gbWFrZVJCVHJlZSgpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IE47ICsraSkge1xyXG4gICAgICAgIHZhciBlID0gZXZlbnRzW2ldO1xyXG4gICAgICAgIHZhciB2ID0gZS52O1xyXG4gICAgICAgIGlmIChlLmlzT3Blbikge1xyXG4gICAgICAgICAgICBzY2FubGluZS5pbnNlcnQodik7XHJcbiAgICAgICAgICAgIHJlY3QuZmluZE5laWdoYm91cnModiwgc2NhbmxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2NhbmxpbmUucmVtb3ZlKHYpO1xyXG4gICAgICAgICAgICB2YXIgbWFrZUNvbnN0cmFpbnQgPSBmdW5jdGlvbiAobCwgcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlcCA9IChyZWN0LmdldFNpemUobC5yKSArIHJlY3QuZ2V0U2l6ZShyLnIpKSAvIDIgKyBtaW5TZXA7XHJcbiAgICAgICAgICAgICAgICBjcy5wdXNoKG5ldyB2cHNjXzEuQ29uc3RyYWludChsLnYsIHIudiwgc2VwKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciB2aXNpdE5laWdoYm91cnMgPSBmdW5jdGlvbiAoZm9yd2FyZCwgcmV2ZXJzZSwgbWtjb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciB1LCBpdCA9IHZbZm9yd2FyZF0uaXRlcmF0b3IoKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgodSA9IGl0W2ZvcndhcmRdKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWtjb24odSwgdik7XHJcbiAgICAgICAgICAgICAgICAgICAgdVtyZXZlcnNlXS5yZW1vdmUodik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZpc2l0TmVpZ2hib3VycyhcInByZXZcIiwgXCJuZXh0XCIsIGZ1bmN0aW9uICh1LCB2KSB7IHJldHVybiBtYWtlQ29uc3RyYWludCh1LCB2KTsgfSk7XHJcbiAgICAgICAgICAgIHZpc2l0TmVpZ2hib3VycyhcIm5leHRcIiwgXCJwcmV2XCIsIGZ1bmN0aW9uICh1LCB2KSB7IHJldHVybiBtYWtlQ29uc3RyYWludCh2LCB1KTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc29sZS5hc3NlcnQoc2NhbmxpbmUuc2l6ZSA9PT0gMCk7XHJcbiAgICByZXR1cm4gY3M7XHJcbn1cclxuZnVuY3Rpb24gZmluZFhOZWlnaGJvdXJzKHYsIHNjYW5saW5lKSB7XHJcbiAgICB2YXIgZiA9IGZ1bmN0aW9uIChmb3J3YXJkLCByZXZlcnNlKSB7XHJcbiAgICAgICAgdmFyIGl0ID0gc2NhbmxpbmUuZmluZEl0ZXIodik7XHJcbiAgICAgICAgdmFyIHU7XHJcbiAgICAgICAgd2hpbGUgKCh1ID0gaXRbZm9yd2FyZF0oKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIHVvdmVydlggPSB1LnIub3ZlcmxhcFgodi5yKTtcclxuICAgICAgICAgICAgaWYgKHVvdmVydlggPD0gMCB8fCB1b3ZlcnZYIDw9IHUuci5vdmVybGFwWSh2LnIpKSB7XHJcbiAgICAgICAgICAgICAgICB2W2ZvcndhcmRdLmluc2VydCh1KTtcclxuICAgICAgICAgICAgICAgIHVbcmV2ZXJzZV0uaW5zZXJ0KHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1b3ZlcnZYIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGYoXCJuZXh0XCIsIFwicHJldlwiKTtcclxuICAgIGYoXCJwcmV2XCIsIFwibmV4dFwiKTtcclxufVxyXG5mdW5jdGlvbiBmaW5kWU5laWdoYm91cnModiwgc2NhbmxpbmUpIHtcclxuICAgIHZhciBmID0gZnVuY3Rpb24gKGZvcndhcmQsIHJldmVyc2UpIHtcclxuICAgICAgICB2YXIgdSA9IHNjYW5saW5lLmZpbmRJdGVyKHYpW2ZvcndhcmRdKCk7XHJcbiAgICAgICAgaWYgKHUgIT09IG51bGwgJiYgdS5yLm92ZXJsYXBYKHYucikgPiAwKSB7XHJcbiAgICAgICAgICAgIHZbZm9yd2FyZF0uaW5zZXJ0KHUpO1xyXG4gICAgICAgICAgICB1W3JldmVyc2VdLmluc2VydCh2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZihcIm5leHRcIiwgXCJwcmV2XCIpO1xyXG4gICAgZihcInByZXZcIiwgXCJuZXh0XCIpO1xyXG59XHJcbmZ1bmN0aW9uIGdlbmVyYXRlWENvbnN0cmFpbnRzKHJzLCB2YXJzKSB7XHJcbiAgICByZXR1cm4gZ2VuZXJhdGVDb25zdHJhaW50cyhycywgdmFycywgeFJlY3QsIDFlLTYpO1xyXG59XHJcbmV4cG9ydHMuZ2VuZXJhdGVYQ29uc3RyYWludHMgPSBnZW5lcmF0ZVhDb25zdHJhaW50cztcclxuZnVuY3Rpb24gZ2VuZXJhdGVZQ29uc3RyYWludHMocnMsIHZhcnMpIHtcclxuICAgIHJldHVybiBnZW5lcmF0ZUNvbnN0cmFpbnRzKHJzLCB2YXJzLCB5UmVjdCwgMWUtNik7XHJcbn1cclxuZXhwb3J0cy5nZW5lcmF0ZVlDb25zdHJhaW50cyA9IGdlbmVyYXRlWUNvbnN0cmFpbnRzO1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVhHcm91cENvbnN0cmFpbnRzKHJvb3QpIHtcclxuICAgIHJldHVybiBnZW5lcmF0ZUdyb3VwQ29uc3RyYWludHMocm9vdCwgeFJlY3QsIDFlLTYpO1xyXG59XHJcbmV4cG9ydHMuZ2VuZXJhdGVYR3JvdXBDb25zdHJhaW50cyA9IGdlbmVyYXRlWEdyb3VwQ29uc3RyYWludHM7XHJcbmZ1bmN0aW9uIGdlbmVyYXRlWUdyb3VwQ29uc3RyYWludHMocm9vdCkge1xyXG4gICAgcmV0dXJuIGdlbmVyYXRlR3JvdXBDb25zdHJhaW50cyhyb290LCB5UmVjdCwgMWUtNik7XHJcbn1cclxuZXhwb3J0cy5nZW5lcmF0ZVlHcm91cENvbnN0cmFpbnRzID0gZ2VuZXJhdGVZR3JvdXBDb25zdHJhaW50cztcclxuZnVuY3Rpb24gcmVtb3ZlT3ZlcmxhcHMocnMpIHtcclxuICAgIHZhciB2cyA9IHJzLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gbmV3IHZwc2NfMS5WYXJpYWJsZShyLmN4KCkpOyB9KTtcclxuICAgIHZhciBjcyA9IGdlbmVyYXRlWENvbnN0cmFpbnRzKHJzLCB2cyk7XHJcbiAgICB2YXIgc29sdmVyID0gbmV3IHZwc2NfMS5Tb2x2ZXIodnMsIGNzKTtcclxuICAgIHNvbHZlci5zb2x2ZSgpO1xyXG4gICAgdnMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gcnNbaV0uc2V0WENlbnRyZSh2LnBvc2l0aW9uKCkpOyB9KTtcclxuICAgIHZzID0gcnMubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiBuZXcgdnBzY18xLlZhcmlhYmxlKHIuY3koKSk7IH0pO1xyXG4gICAgY3MgPSBnZW5lcmF0ZVlDb25zdHJhaW50cyhycywgdnMpO1xyXG4gICAgc29sdmVyID0gbmV3IHZwc2NfMS5Tb2x2ZXIodnMsIGNzKTtcclxuICAgIHNvbHZlci5zb2x2ZSgpO1xyXG4gICAgdnMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gcnNbaV0uc2V0WUNlbnRyZSh2LnBvc2l0aW9uKCkpOyB9KTtcclxufVxyXG5leHBvcnRzLnJlbW92ZU92ZXJsYXBzID0gcmVtb3ZlT3ZlcmxhcHM7XHJcbnZhciBJbmRleGVkVmFyaWFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEluZGV4ZWRWYXJpYWJsZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEluZGV4ZWRWYXJpYWJsZShpbmRleCwgdykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDAsIHcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSW5kZXhlZFZhcmlhYmxlO1xyXG59KHZwc2NfMS5WYXJpYWJsZSkpO1xyXG5leHBvcnRzLkluZGV4ZWRWYXJpYWJsZSA9IEluZGV4ZWRWYXJpYWJsZTtcclxudmFyIFByb2plY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJvamVjdGlvbihub2RlcywgZ3JvdXBzLCByb290R3JvdXAsIGNvbnN0cmFpbnRzLCBhdm9pZE92ZXJsYXBzKSB7XHJcbiAgICAgICAgaWYgKHJvb3RHcm91cCA9PT0gdm9pZCAwKSB7IHJvb3RHcm91cCA9IG51bGw7IH1cclxuICAgICAgICBpZiAoY29uc3RyYWludHMgPT09IHZvaWQgMCkgeyBjb25zdHJhaW50cyA9IG51bGw7IH1cclxuICAgICAgICBpZiAoYXZvaWRPdmVybGFwcyA9PT0gdm9pZCAwKSB7IGF2b2lkT3ZlcmxhcHMgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xyXG4gICAgICAgIHRoaXMucm9vdEdyb3VwID0gcm9vdEdyb3VwO1xyXG4gICAgICAgIHRoaXMuYXZvaWRPdmVybGFwcyA9IGF2b2lkT3ZlcmxhcHM7XHJcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSBub2Rlcy5tYXAoZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHYudmFyaWFibGUgPSBuZXcgSW5kZXhlZFZhcmlhYmxlKGksIDEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChjb25zdHJhaW50cylcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVDb25zdHJhaW50cyhjb25zdHJhaW50cyk7XHJcbiAgICAgICAgaWYgKGF2b2lkT3ZlcmxhcHMgJiYgcm9vdEdyb3VwICYmIHR5cGVvZiByb290R3JvdXAuZ3JvdXBzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXYud2lkdGggfHwgIXYuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5ib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKHYueCwgdi54LCB2LnksIHYueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHcyID0gdi53aWR0aCAvIDIsIGgyID0gdi5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICAgICAgdi5ib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKHYueCAtIHcyLCB2LnggKyB3Miwgdi55IC0gaDIsIHYueSArIGgyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbXB1dGVHcm91cEJvdW5kcyhyb290R3JvdXApO1xyXG4gICAgICAgICAgICB2YXIgaSA9IG5vZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGcpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlc1tpXSA9IGcubWluVmFyID0gbmV3IEluZGV4ZWRWYXJpYWJsZShpKyssIHR5cGVvZiBnLnN0aWZmbmVzcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGcuc3RpZmZuZXNzIDogMC4wMSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy52YXJpYWJsZXNbaV0gPSBnLm1heFZhciA9IG5ldyBJbmRleGVkVmFyaWFibGUoaSsrLCB0eXBlb2YgZy5zdGlmZm5lc3MgIT09IFwidW5kZWZpbmVkXCIgPyBnLnN0aWZmbmVzcyA6IDAuMDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBQcm9qZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVTZXBhcmF0aW9uID0gZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IHZwc2NfMS5Db25zdHJhaW50KHRoaXMubm9kZXNbYy5sZWZ0XS52YXJpYWJsZSwgdGhpcy5ub2Rlc1tjLnJpZ2h0XS52YXJpYWJsZSwgYy5nYXAsIHR5cGVvZiBjLmVxdWFsaXR5ICE9PSBcInVuZGVmaW5lZFwiID8gYy5lcXVhbGl0eSA6IGZhbHNlKTtcclxuICAgIH07XHJcbiAgICBQcm9qZWN0aW9uLnByb3RvdHlwZS5tYWtlRmVhc2libGUgPSBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCF0aGlzLmF2b2lkT3ZlcmxhcHMpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgYXhpcyA9ICd4JywgZGltID0gJ3dpZHRoJztcclxuICAgICAgICBpZiAoYy5heGlzID09PSAneCcpXHJcbiAgICAgICAgICAgIGF4aXMgPSAneScsIGRpbSA9ICdoZWlnaHQnO1xyXG4gICAgICAgIHZhciB2cyA9IGMub2Zmc2V0cy5tYXAoZnVuY3Rpb24gKG8pIHsgcmV0dXJuIF90aGlzLm5vZGVzW28ubm9kZV07IH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbYXhpc10gLSBiW2F4aXNdOyB9KTtcclxuICAgICAgICB2YXIgcCA9IG51bGw7XHJcbiAgICAgICAgdnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAocCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRQb3MgPSBwW2F4aXNdICsgcFtkaW1dO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRQb3MgPiB2W2F4aXNdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdltheGlzXSA9IG5leHRQb3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcCA9IHY7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUHJvamVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQWxpZ25tZW50ID0gZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB1ID0gdGhpcy5ub2Rlc1tjLm9mZnNldHNbMF0ubm9kZV0udmFyaWFibGU7XHJcbiAgICAgICAgdGhpcy5tYWtlRmVhc2libGUoYyk7XHJcbiAgICAgICAgdmFyIGNzID0gYy5heGlzID09PSAneCcgPyB0aGlzLnhDb25zdHJhaW50cyA6IHRoaXMueUNvbnN0cmFpbnRzO1xyXG4gICAgICAgIGMub2Zmc2V0cy5zbGljZSgxKS5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gX3RoaXMubm9kZXNbby5ub2RlXS52YXJpYWJsZTtcclxuICAgICAgICAgICAgY3MucHVzaChuZXcgdnBzY18xLkNvbnN0cmFpbnQodSwgdiwgby5vZmZzZXQsIHRydWUpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBQcm9qZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChjb25zdHJhaW50cykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGlzU2VwID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHR5cGVvZiBjLnR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGMudHlwZSA9PT0gJ3NlcGFyYXRpb24nOyB9O1xyXG4gICAgICAgIHRoaXMueENvbnN0cmFpbnRzID0gY29uc3RyYWludHNcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5heGlzID09PSBcInhcIiAmJiBpc1NlcChjKTsgfSlcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gX3RoaXMuY3JlYXRlU2VwYXJhdGlvbihjKTsgfSk7XHJcbiAgICAgICAgdGhpcy55Q29uc3RyYWludHMgPSBjb25zdHJhaW50c1xyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmF4aXMgPT09IFwieVwiICYmIGlzU2VwKGMpOyB9KVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBfdGhpcy5jcmVhdGVTZXBhcmF0aW9uKGMpOyB9KTtcclxuICAgICAgICBjb25zdHJhaW50c1xyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnR5cGUgPT09ICdhbGlnbm1lbnQnOyB9KVxyXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gX3RoaXMuY3JlYXRlQWxpZ25tZW50KGMpOyB9KTtcclxuICAgIH07XHJcbiAgICBQcm9qZWN0aW9uLnByb3RvdHlwZS5zZXR1cFZhcmlhYmxlc0FuZEJvdW5kcyA9IGZ1bmN0aW9uICh4MCwgeTAsIGRlc2lyZWQsIGdldERlc2lyZWQpIHtcclxuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgICAgaWYgKHYuZml4ZWQpIHtcclxuICAgICAgICAgICAgICAgIHYudmFyaWFibGUud2VpZ2h0ID0gdi5maXhlZFdlaWdodCA/IHYuZml4ZWRXZWlnaHQgOiAxMDAwO1xyXG4gICAgICAgICAgICAgICAgZGVzaXJlZFtpXSA9IGdldERlc2lyZWQodik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2LnZhcmlhYmxlLndlaWdodCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHcgPSAodi53aWR0aCB8fCAwKSAvIDIsIGggPSAodi5oZWlnaHQgfHwgMCkgLyAyO1xyXG4gICAgICAgICAgICB2YXIgaXggPSB4MFtpXSwgaXkgPSB5MFtpXTtcclxuICAgICAgICAgICAgdi5ib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKGl4IC0gdywgaXggKyB3LCBpeSAtIGgsIGl5ICsgaCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUHJvamVjdGlvbi5wcm90b3R5cGUueFByb2plY3QgPSBmdW5jdGlvbiAoeDAsIHkwLCB4KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJvb3RHcm91cCAmJiAhKHRoaXMuYXZvaWRPdmVybGFwcyB8fCB0aGlzLnhDb25zdHJhaW50cykpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLnByb2plY3QoeDAsIHkwLCB4MCwgeCwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYucHg7IH0sIHRoaXMueENvbnN0cmFpbnRzLCBnZW5lcmF0ZVhHcm91cENvbnN0cmFpbnRzLCBmdW5jdGlvbiAodikgeyByZXR1cm4gdi5ib3VuZHMuc2V0WENlbnRyZSh4W3YudmFyaWFibGUuaW5kZXhdID0gdi52YXJpYWJsZS5wb3NpdGlvbigpKTsgfSwgZnVuY3Rpb24gKGcpIHtcclxuICAgICAgICAgICAgdmFyIHhtaW4gPSB4W2cubWluVmFyLmluZGV4XSA9IGcubWluVmFyLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIHZhciB4bWF4ID0geFtnLm1heFZhci5pbmRleF0gPSBnLm1heFZhci5wb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB2YXIgcDIgPSBnLnBhZGRpbmcgLyAyO1xyXG4gICAgICAgICAgICBnLmJvdW5kcy54ID0geG1pbiAtIHAyO1xyXG4gICAgICAgICAgICBnLmJvdW5kcy5YID0geG1heCArIHAyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFByb2plY3Rpb24ucHJvdG90eXBlLnlQcm9qZWN0ID0gZnVuY3Rpb24gKHgwLCB5MCwgeSkge1xyXG4gICAgICAgIGlmICghdGhpcy5yb290R3JvdXAgJiYgIXRoaXMueUNvbnN0cmFpbnRzKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0KHgwLCB5MCwgeTAsIHksIGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnB5OyB9LCB0aGlzLnlDb25zdHJhaW50cywgZ2VuZXJhdGVZR3JvdXBDb25zdHJhaW50cywgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuYm91bmRzLnNldFlDZW50cmUoeVt2LnZhcmlhYmxlLmluZGV4XSA9IHYudmFyaWFibGUucG9zaXRpb24oKSk7IH0sIGZ1bmN0aW9uIChnKSB7XHJcbiAgICAgICAgICAgIHZhciB5bWluID0geVtnLm1pblZhci5pbmRleF0gPSBnLm1pblZhci5wb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB2YXIgeW1heCA9IHlbZy5tYXhWYXIuaW5kZXhdID0gZy5tYXhWYXIucG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdmFyIHAyID0gZy5wYWRkaW5nIC8gMjtcclxuICAgICAgICAgICAgZy5ib3VuZHMueSA9IHltaW4gLSBwMjtcclxuICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICBnLmJvdW5kcy5ZID0geW1heCArIHAyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFByb2plY3Rpb24ucHJvdG90eXBlLnByb2plY3RGdW5jdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBmdW5jdGlvbiAoeDAsIHkwLCB4KSB7IHJldHVybiBfdGhpcy54UHJvamVjdCh4MCwgeTAsIHgpOyB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoeDAsIHkwLCB5KSB7IHJldHVybiBfdGhpcy55UHJvamVjdCh4MCwgeTAsIHkpOyB9XHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcbiAgICBQcm9qZWN0aW9uLnByb3RvdHlwZS5wcm9qZWN0ID0gZnVuY3Rpb24gKHgwLCB5MCwgc3RhcnQsIGRlc2lyZWQsIGdldERlc2lyZWQsIGNzLCBnZW5lcmF0ZUNvbnN0cmFpbnRzLCB1cGRhdGVOb2RlQm91bmRzLCB1cGRhdGVHcm91cEJvdW5kcykge1xyXG4gICAgICAgIHRoaXMuc2V0dXBWYXJpYWJsZXNBbmRCb3VuZHMoeDAsIHkwLCBkZXNpcmVkLCBnZXREZXNpcmVkKTtcclxuICAgICAgICBpZiAodGhpcy5yb290R3JvdXAgJiYgdGhpcy5hdm9pZE92ZXJsYXBzKSB7XHJcbiAgICAgICAgICAgIGNvbXB1dGVHcm91cEJvdW5kcyh0aGlzLnJvb3RHcm91cCk7XHJcbiAgICAgICAgICAgIGNzID0gY3MuY29uY2F0KGdlbmVyYXRlQ29uc3RyYWludHModGhpcy5yb290R3JvdXApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zb2x2ZSh0aGlzLnZhcmlhYmxlcywgY3MsIHN0YXJ0LCBkZXNpcmVkKTtcclxuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2godXBkYXRlTm9kZUJvdW5kcyk7XHJcbiAgICAgICAgaWYgKHRoaXMucm9vdEdyb3VwICYmIHRoaXMuYXZvaWRPdmVybGFwcykge1xyXG4gICAgICAgICAgICB0aGlzLmdyb3Vwcy5mb3JFYWNoKHVwZGF0ZUdyb3VwQm91bmRzKTtcclxuICAgICAgICAgICAgY29tcHV0ZUdyb3VwQm91bmRzKHRoaXMucm9vdEdyb3VwKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUHJvamVjdGlvbi5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbiAodnMsIGNzLCBzdGFydGluZywgZGVzaXJlZCkge1xyXG4gICAgICAgIHZhciBzb2x2ZXIgPSBuZXcgdnBzY18xLlNvbHZlcih2cywgY3MpO1xyXG4gICAgICAgIHNvbHZlci5zZXRTdGFydGluZ1Bvc2l0aW9ucyhzdGFydGluZyk7XHJcbiAgICAgICAgc29sdmVyLnNldERlc2lyZWRQb3NpdGlvbnMoZGVzaXJlZCk7XHJcbiAgICAgICAgc29sdmVyLnNvbHZlKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByb2plY3Rpb247XHJcbn0oKSk7XHJcbmV4cG9ydHMuUHJvamVjdGlvbiA9IFByb2plY3Rpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY3RhbmdsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgcHF1ZXVlXzEgPSByZXF1aXJlKFwiLi9wcXVldWVcIik7XHJcbnZhciBOZWlnaGJvdXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmVpZ2hib3VyKGlkLCBkaXN0YW5jZSkge1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTmVpZ2hib3VyO1xyXG59KCkpO1xyXG52YXIgTm9kZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb2RlKGlkKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMubmVpZ2hib3VycyA9IFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE5vZGU7XHJcbn0oKSk7XHJcbnZhciBRdWV1ZUVudHJ5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFF1ZXVlRW50cnkobm9kZSwgcHJldiwgZCkge1xyXG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcclxuICAgICAgICB0aGlzLmQgPSBkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFF1ZXVlRW50cnk7XHJcbn0oKSk7XHJcbnZhciBDYWxjdWxhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENhbGN1bGF0b3IobiwgZXMsIGdldFNvdXJjZUluZGV4LCBnZXRUYXJnZXRJbmRleCwgZ2V0TGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5uID0gbjtcclxuICAgICAgICB0aGlzLmVzID0gZXM7XHJcbiAgICAgICAgdGhpcy5uZWlnaGJvdXJzID0gbmV3IEFycmF5KHRoaXMubik7XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLm47XHJcbiAgICAgICAgd2hpbGUgKGktLSlcclxuICAgICAgICAgICAgdGhpcy5uZWlnaGJvdXJzW2ldID0gbmV3IE5vZGUoaSk7XHJcbiAgICAgICAgaSA9IHRoaXMuZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmVzW2ldO1xyXG4gICAgICAgICAgICB2YXIgdSA9IGdldFNvdXJjZUluZGV4KGUpLCB2ID0gZ2V0VGFyZ2V0SW5kZXgoZSk7XHJcbiAgICAgICAgICAgIHZhciBkID0gZ2V0TGVuZ3RoKGUpO1xyXG4gICAgICAgICAgICB0aGlzLm5laWdoYm91cnNbdV0ubmVpZ2hib3Vycy5wdXNoKG5ldyBOZWlnaGJvdXIodiwgZCkpO1xyXG4gICAgICAgICAgICB0aGlzLm5laWdoYm91cnNbdl0ubmVpZ2hib3Vycy5wdXNoKG5ldyBOZWlnaGJvdXIodSwgZCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIENhbGN1bGF0b3IucHJvdG90eXBlLkRpc3RhbmNlTWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBEID0gbmV3IEFycmF5KHRoaXMubik7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm47ICsraSkge1xyXG4gICAgICAgICAgICBEW2ldID0gdGhpcy5kaWprc3RyYU5laWdoYm91cnMoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBEO1xyXG4gICAgfTtcclxuICAgIENhbGN1bGF0b3IucHJvdG90eXBlLkRpc3RhbmNlc0Zyb21Ob2RlID0gZnVuY3Rpb24gKHN0YXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlqa3N0cmFOZWlnaGJvdXJzKHN0YXJ0KTtcclxuICAgIH07XHJcbiAgICBDYWxjdWxhdG9yLnByb3RvdHlwZS5QYXRoRnJvbU5vZGVUb05vZGUgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpamtzdHJhTmVpZ2hib3VycyhzdGFydCwgZW5kKTtcclxuICAgIH07XHJcbiAgICBDYWxjdWxhdG9yLnByb3RvdHlwZS5QYXRoRnJvbU5vZGVUb05vZGVXaXRoUHJldkNvc3QgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcHJldkNvc3QpIHtcclxuICAgICAgICB2YXIgcSA9IG5ldyBwcXVldWVfMS5Qcmlvcml0eVF1ZXVlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmQgPD0gYi5kOyB9KSwgdSA9IHRoaXMubmVpZ2hib3Vyc1tzdGFydF0sIHF1ID0gbmV3IFF1ZXVlRW50cnkodSwgbnVsbCwgMCksIHZpc2l0ZWRGcm9tID0ge307XHJcbiAgICAgICAgcS5wdXNoKHF1KTtcclxuICAgICAgICB3aGlsZSAoIXEuZW1wdHkoKSkge1xyXG4gICAgICAgICAgICBxdSA9IHEucG9wKCk7XHJcbiAgICAgICAgICAgIHUgPSBxdS5ub2RlO1xyXG4gICAgICAgICAgICBpZiAodS5pZCA9PT0gZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaSA9IHUubmVpZ2hib3Vycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZWlnaGJvdXIgPSB1Lm5laWdoYm91cnNbaV0sIHYgPSB0aGlzLm5laWdoYm91cnNbbmVpZ2hib3VyLmlkXTtcclxuICAgICAgICAgICAgICAgIGlmIChxdS5wcmV2ICYmIHYuaWQgPT09IHF1LnByZXYubm9kZS5pZClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIHZhciB2aWR1aWQgPSB2LmlkICsgJywnICsgdS5pZDtcclxuICAgICAgICAgICAgICAgIGlmICh2aWR1aWQgaW4gdmlzaXRlZEZyb20gJiYgdmlzaXRlZEZyb21bdmlkdWlkXSA8PSBxdS5kKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNjID0gcXUucHJldiA/IHByZXZDb3N0KHF1LnByZXYubm9kZS5pZCwgdS5pZCwgdi5pZCkgOiAwLCB0ID0gcXUuZCArIG5laWdoYm91ci5kaXN0YW5jZSArIGNjO1xyXG4gICAgICAgICAgICAgICAgdmlzaXRlZEZyb21bdmlkdWlkXSA9IHQ7XHJcbiAgICAgICAgICAgICAgICBxLnB1c2gobmV3IFF1ZXVlRW50cnkodiwgcXUsIHQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGF0aCA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChxdS5wcmV2KSB7XHJcbiAgICAgICAgICAgIHF1ID0gcXUucHJldjtcclxuICAgICAgICAgICAgcGF0aC5wdXNoKHF1Lm5vZGUuaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH07XHJcbiAgICBDYWxjdWxhdG9yLnByb3RvdHlwZS5kaWprc3RyYU5laWdoYm91cnMgPSBmdW5jdGlvbiAoc3RhcnQsIGRlc3QpIHtcclxuICAgICAgICBpZiAoZGVzdCA9PT0gdm9pZCAwKSB7IGRlc3QgPSAtMTsgfVxyXG4gICAgICAgIHZhciBxID0gbmV3IHBxdWV1ZV8xLlByaW9yaXR5UXVldWUoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuZCA8PSBiLmQ7IH0pLCBpID0gdGhpcy5uZWlnaGJvdXJzLmxlbmd0aCwgZCA9IG5ldyBBcnJheShpKTtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5uZWlnaGJvdXJzW2ldO1xyXG4gICAgICAgICAgICBub2RlLmQgPSBpID09PSBzdGFydCA/IDAgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgICAgIG5vZGUucSA9IHEucHVzaChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKCFxLmVtcHR5KCkpIHtcclxuICAgICAgICAgICAgdmFyIHUgPSBxLnBvcCgpO1xyXG4gICAgICAgICAgICBkW3UuaWRdID0gdS5kO1xyXG4gICAgICAgICAgICBpZiAodS5pZCA9PT0gZGVzdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBbXTtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gdTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0eXBlb2Ygdi5wcmV2ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaCh2LnByZXYuaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHYgPSB2LnByZXY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gdS5uZWlnaGJvdXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5laWdoYm91ciA9IHUubmVpZ2hib3Vyc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gdGhpcy5uZWlnaGJvdXJzW25laWdoYm91ci5pZF07XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHUuZCArIG5laWdoYm91ci5kaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGlmICh1LmQgIT09IE51bWJlci5NQVhfVkFMVUUgJiYgdi5kID4gdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHYuZCA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5wcmV2ID0gdTtcclxuICAgICAgICAgICAgICAgICAgICBxLnJlZHVjZUtleSh2LnEsIHYsIGZ1bmN0aW9uIChlLCBxKSB7IHJldHVybiBlLnEgPSBxOyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2FsY3VsYXRvcjtcclxufSgpKTtcclxuZXhwb3J0cy5DYWxjdWxhdG9yID0gQ2FsY3VsYXRvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hvcnRlc3RwYXRocy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgUG9zaXRpb25TdGF0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQb3NpdGlvblN0YXRzKHNjYWxlKSB7XHJcbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgIHRoaXMuQUIgPSAwO1xyXG4gICAgICAgIHRoaXMuQUQgPSAwO1xyXG4gICAgICAgIHRoaXMuQTIgPSAwO1xyXG4gICAgfVxyXG4gICAgUG9zaXRpb25TdGF0cy5wcm90b3R5cGUuYWRkVmFyaWFibGUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBhaSA9IHRoaXMuc2NhbGUgLyB2LnNjYWxlO1xyXG4gICAgICAgIHZhciBiaSA9IHYub2Zmc2V0IC8gdi5zY2FsZTtcclxuICAgICAgICB2YXIgd2kgPSB2LndlaWdodDtcclxuICAgICAgICB0aGlzLkFCICs9IHdpICogYWkgKiBiaTtcclxuICAgICAgICB0aGlzLkFEICs9IHdpICogYWkgKiB2LmRlc2lyZWRQb3NpdGlvbjtcclxuICAgICAgICB0aGlzLkEyICs9IHdpICogYWkgKiBhaTtcclxuICAgIH07XHJcbiAgICBQb3NpdGlvblN0YXRzLnByb3RvdHlwZS5nZXRQb3NuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5BRCAtIHRoaXMuQUIpIC8gdGhpcy5BMjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUG9zaXRpb25TdGF0cztcclxufSgpKTtcclxuZXhwb3J0cy5Qb3NpdGlvblN0YXRzID0gUG9zaXRpb25TdGF0cztcclxudmFyIENvbnN0cmFpbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29uc3RyYWludChsZWZ0LCByaWdodCwgZ2FwLCBlcXVhbGl0eSkge1xyXG4gICAgICAgIGlmIChlcXVhbGl0eSA9PT0gdm9pZCAwKSB7IGVxdWFsaXR5ID0gZmFsc2U7IH1cclxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuICAgICAgICB0aGlzLmdhcCA9IGdhcDtcclxuICAgICAgICB0aGlzLmVxdWFsaXR5ID0gZXF1YWxpdHk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVuc2F0aXNmaWFibGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuICAgICAgICB0aGlzLmdhcCA9IGdhcDtcclxuICAgICAgICB0aGlzLmVxdWFsaXR5ID0gZXF1YWxpdHk7XHJcbiAgICB9XHJcbiAgICBDb25zdHJhaW50LnByb3RvdHlwZS5zbGFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNhdGlzZmlhYmxlID8gTnVtYmVyLk1BWF9WQUxVRVxyXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQuc2NhbGUgKiB0aGlzLnJpZ2h0LnBvc2l0aW9uKCkgLSB0aGlzLmdhcFxyXG4gICAgICAgICAgICAgICAgLSB0aGlzLmxlZnQuc2NhbGUgKiB0aGlzLmxlZnQucG9zaXRpb24oKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29uc3RyYWludDtcclxufSgpKTtcclxuZXhwb3J0cy5Db25zdHJhaW50ID0gQ29uc3RyYWludDtcclxudmFyIFZhcmlhYmxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZhcmlhYmxlKGRlc2lyZWRQb3NpdGlvbiwgd2VpZ2h0LCBzY2FsZSkge1xyXG4gICAgICAgIGlmICh3ZWlnaHQgPT09IHZvaWQgMCkgeyB3ZWlnaHQgPSAxOyB9XHJcbiAgICAgICAgaWYgKHNjYWxlID09PSB2b2lkIDApIHsgc2NhbGUgPSAxOyB9XHJcbiAgICAgICAgdGhpcy5kZXNpcmVkUG9zaXRpb24gPSBkZXNpcmVkUG9zaXRpb247XHJcbiAgICAgICAgdGhpcy53ZWlnaHQgPSB3ZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuICAgIH1cclxuICAgIFZhcmlhYmxlLnByb3RvdHlwZS5kZmR2ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAyLjAgKiB0aGlzLndlaWdodCAqICh0aGlzLnBvc2l0aW9uKCkgLSB0aGlzLmRlc2lyZWRQb3NpdGlvbik7XHJcbiAgICB9O1xyXG4gICAgVmFyaWFibGUucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5ibG9jay5wcy5zY2FsZSAqIHRoaXMuYmxvY2sucG9zbiArIHRoaXMub2Zmc2V0KSAvIHRoaXMuc2NhbGU7XHJcbiAgICB9O1xyXG4gICAgVmFyaWFibGUucHJvdG90eXBlLnZpc2l0TmVpZ2hib3VycyA9IGZ1bmN0aW9uIChwcmV2LCBmKSB7XHJcbiAgICAgICAgdmFyIGZmID0gZnVuY3Rpb24gKGMsIG5leHQpIHsgcmV0dXJuIGMuYWN0aXZlICYmIHByZXYgIT09IG5leHQgJiYgZihjLCBuZXh0KTsgfTtcclxuICAgICAgICB0aGlzLmNPdXQuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZmYoYywgYy5yaWdodCk7IH0pO1xyXG4gICAgICAgIHRoaXMuY0luLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGZmKGMsIGMubGVmdCk7IH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBWYXJpYWJsZTtcclxufSgpKTtcclxuZXhwb3J0cy5WYXJpYWJsZSA9IFZhcmlhYmxlO1xyXG52YXIgQmxvY2sgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQmxvY2sodikge1xyXG4gICAgICAgIHRoaXMudmFycyA9IFtdO1xyXG4gICAgICAgIHYub2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLnBzID0gbmV3IFBvc2l0aW9uU3RhdHModi5zY2FsZSk7XHJcbiAgICAgICAgdGhpcy5hZGRWYXJpYWJsZSh2KTtcclxuICAgIH1cclxuICAgIEJsb2NrLnByb3RvdHlwZS5hZGRWYXJpYWJsZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdi5ibG9jayA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy52YXJzLnB1c2godik7XHJcbiAgICAgICAgdGhpcy5wcy5hZGRWYXJpYWJsZSh2KTtcclxuICAgICAgICB0aGlzLnBvc24gPSB0aGlzLnBzLmdldFBvc24oKTtcclxuICAgIH07XHJcbiAgICBCbG9jay5wcm90b3R5cGUudXBkYXRlV2VpZ2h0ZWRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnBzLkFCID0gdGhpcy5wcy5BRCA9IHRoaXMucHMuQTIgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy52YXJzLmxlbmd0aDsgaSA8IG47ICsraSlcclxuICAgICAgICAgICAgdGhpcy5wcy5hZGRWYXJpYWJsZSh0aGlzLnZhcnNbaV0pO1xyXG4gICAgICAgIHRoaXMucG9zbiA9IHRoaXMucHMuZ2V0UG9zbigpO1xyXG4gICAgfTtcclxuICAgIEJsb2NrLnByb3RvdHlwZS5jb21wdXRlX2xtID0gZnVuY3Rpb24gKHYsIHUsIHBvc3RBY3Rpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBkZmR2ID0gdi5kZmR2KCk7XHJcbiAgICAgICAgdi52aXNpdE5laWdoYm91cnModSwgZnVuY3Rpb24gKGMsIG5leHQpIHtcclxuICAgICAgICAgICAgdmFyIF9kZmR2ID0gX3RoaXMuY29tcHV0ZV9sbShuZXh0LCB2LCBwb3N0QWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKG5leHQgPT09IGMucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGRmZHYgKz0gX2RmZHYgKiBjLmxlZnQuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICBjLmxtID0gX2RmZHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZmR2ICs9IF9kZmR2ICogYy5yaWdodC5zY2FsZTtcclxuICAgICAgICAgICAgICAgIGMubG0gPSAtX2RmZHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9zdEFjdGlvbihjKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGZkdiAvIHYuc2NhbGU7XHJcbiAgICB9O1xyXG4gICAgQmxvY2sucHJvdG90eXBlLnBvcHVsYXRlU3BsaXRCbG9jayA9IGZ1bmN0aW9uICh2LCBwcmV2KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2LnZpc2l0TmVpZ2hib3VycyhwcmV2LCBmdW5jdGlvbiAoYywgbmV4dCkge1xyXG4gICAgICAgICAgICBuZXh0Lm9mZnNldCA9IHYub2Zmc2V0ICsgKG5leHQgPT09IGMucmlnaHQgPyBjLmdhcCA6IC1jLmdhcCk7XHJcbiAgICAgICAgICAgIF90aGlzLmFkZFZhcmlhYmxlKG5leHQpO1xyXG4gICAgICAgICAgICBfdGhpcy5wb3B1bGF0ZVNwbGl0QmxvY2sobmV4dCwgdik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQmxvY2sucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24gKHZpc2l0LCBhY2MsIHYsIHByZXYpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh2ID09PSB2b2lkIDApIHsgdiA9IHRoaXMudmFyc1swXTsgfVxyXG4gICAgICAgIGlmIChwcmV2ID09PSB2b2lkIDApIHsgcHJldiA9IG51bGw7IH1cclxuICAgICAgICB2LnZpc2l0TmVpZ2hib3VycyhwcmV2LCBmdW5jdGlvbiAoYywgbmV4dCkge1xyXG4gICAgICAgICAgICBhY2MucHVzaCh2aXNpdChjKSk7XHJcbiAgICAgICAgICAgIF90aGlzLnRyYXZlcnNlKHZpc2l0LCBhY2MsIG5leHQsIHYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEJsb2NrLnByb3RvdHlwZS5maW5kTWluTE0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG0gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZV9sbSh0aGlzLnZhcnNbMF0sIG51bGwsIGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgIGlmICghYy5lcXVhbGl0eSAmJiAobSA9PT0gbnVsbCB8fCBjLmxtIDwgbS5sbSkpXHJcbiAgICAgICAgICAgICAgICBtID0gYztcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH07XHJcbiAgICBCbG9jay5wcm90b3R5cGUuZmluZE1pbkxNQmV0d2VlbiA9IGZ1bmN0aW9uIChsdiwgcnYpIHtcclxuICAgICAgICB0aGlzLmNvbXB1dGVfbG0obHYsIG51bGwsIGZ1bmN0aW9uICgpIHsgfSk7XHJcbiAgICAgICAgdmFyIG0gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZmluZFBhdGgobHYsIG51bGwsIHJ2LCBmdW5jdGlvbiAoYywgbmV4dCkge1xyXG4gICAgICAgICAgICBpZiAoIWMuZXF1YWxpdHkgJiYgYy5yaWdodCA9PT0gbmV4dCAmJiAobSA9PT0gbnVsbCB8fCBjLmxtIDwgbS5sbSkpXHJcbiAgICAgICAgICAgICAgICBtID0gYztcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH07XHJcbiAgICBCbG9jay5wcm90b3R5cGUuZmluZFBhdGggPSBmdW5jdGlvbiAodiwgcHJldiwgdG8sIHZpc2l0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgZW5kRm91bmQgPSBmYWxzZTtcclxuICAgICAgICB2LnZpc2l0TmVpZ2hib3VycyhwcmV2LCBmdW5jdGlvbiAoYywgbmV4dCkge1xyXG4gICAgICAgICAgICBpZiAoIWVuZEZvdW5kICYmIChuZXh0ID09PSB0byB8fCBfdGhpcy5maW5kUGF0aChuZXh0LCB2LCB0bywgdmlzaXQpKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmlzaXQoYywgbmV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZW5kRm91bmQ7XHJcbiAgICB9O1xyXG4gICAgQmxvY2sucHJvdG90eXBlLmlzQWN0aXZlRGlyZWN0ZWRQYXRoQmV0d2VlbiA9IGZ1bmN0aW9uICh1LCB2KSB7XHJcbiAgICAgICAgaWYgKHUgPT09IHYpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIHZhciBpID0gdS5jT3V0Lmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdS5jT3V0W2ldO1xyXG4gICAgICAgICAgICBpZiAoYy5hY3RpdmUgJiYgdGhpcy5pc0FjdGl2ZURpcmVjdGVkUGF0aEJldHdlZW4oYy5yaWdodCwgdikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEJsb2NrLnNwbGl0ID0gZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICBjLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBbQmxvY2suY3JlYXRlU3BsaXRCbG9jayhjLmxlZnQpLCBCbG9jay5jcmVhdGVTcGxpdEJsb2NrKGMucmlnaHQpXTtcclxuICAgIH07XHJcbiAgICBCbG9jay5jcmVhdGVTcGxpdEJsb2NrID0gZnVuY3Rpb24gKHN0YXJ0VmFyKSB7XHJcbiAgICAgICAgdmFyIGIgPSBuZXcgQmxvY2soc3RhcnRWYXIpO1xyXG4gICAgICAgIGIucG9wdWxhdGVTcGxpdEJsb2NrKHN0YXJ0VmFyLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gYjtcclxuICAgIH07XHJcbiAgICBCbG9jay5wcm90b3R5cGUuc3BsaXRCZXR3ZWVuID0gZnVuY3Rpb24gKHZsLCB2cikge1xyXG4gICAgICAgIHZhciBjID0gdGhpcy5maW5kTWluTE1CZXR3ZWVuKHZsLCB2cik7XHJcbiAgICAgICAgaWYgKGMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIGJzID0gQmxvY2suc3BsaXQoYyk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGNvbnN0cmFpbnQ6IGMsIGxiOiBic1swXSwgcmI6IGJzWzFdIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIEJsb2NrLnByb3RvdHlwZS5tZXJnZUFjcm9zcyA9IGZ1bmN0aW9uIChiLCBjLCBkaXN0KSB7XHJcbiAgICAgICAgYy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYi52YXJzLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgdiA9IGIudmFyc1tpXTtcclxuICAgICAgICAgICAgdi5vZmZzZXQgKz0gZGlzdDtcclxuICAgICAgICAgICAgdGhpcy5hZGRWYXJpYWJsZSh2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wb3NuID0gdGhpcy5wcy5nZXRQb3NuKCk7XHJcbiAgICB9O1xyXG4gICAgQmxvY2sucHJvdG90eXBlLmNvc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN1bSA9IDAsIGkgPSB0aGlzLnZhcnMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLnZhcnNbaV0sIGQgPSB2LnBvc2l0aW9uKCkgLSB2LmRlc2lyZWRQb3NpdGlvbjtcclxuICAgICAgICAgICAgc3VtICs9IGQgKiBkICogdi53ZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJsb2NrO1xyXG59KCkpO1xyXG5leHBvcnRzLkJsb2NrID0gQmxvY2s7XHJcbnZhciBCbG9ja3MgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQmxvY2tzKHZzKSB7XHJcbiAgICAgICAgdGhpcy52cyA9IHZzO1xyXG4gICAgICAgIHZhciBuID0gdnMubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMubGlzdCA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICB3aGlsZSAobi0tKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gbmV3IEJsb2NrKHZzW25dKTtcclxuICAgICAgICAgICAgdGhpcy5saXN0W25dID0gYjtcclxuICAgICAgICAgICAgYi5ibG9ja0luZCA9IG47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgQmxvY2tzLnByb3RvdHlwZS5jb3N0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzdW0gPSAwLCBpID0gdGhpcy5saXN0Lmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKVxyXG4gICAgICAgICAgICBzdW0gKz0gdGhpcy5saXN0W2ldLmNvc3QoKTtcclxuICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgfTtcclxuICAgIEJsb2Nrcy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICBiLmJsb2NrSW5kID0gdGhpcy5saXN0Lmxlbmd0aDtcclxuICAgICAgICB0aGlzLmxpc3QucHVzaChiKTtcclxuICAgIH07XHJcbiAgICBCbG9ja3MucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLmxpc3QubGVuZ3RoIC0gMTtcclxuICAgICAgICB2YXIgc3dhcEJsb2NrID0gdGhpcy5saXN0W2xhc3RdO1xyXG4gICAgICAgIHRoaXMubGlzdC5sZW5ndGggPSBsYXN0O1xyXG4gICAgICAgIGlmIChiICE9PSBzd2FwQmxvY2spIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0W2IuYmxvY2tJbmRdID0gc3dhcEJsb2NrO1xyXG4gICAgICAgICAgICBzd2FwQmxvY2suYmxvY2tJbmQgPSBiLmJsb2NrSW5kO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCbG9ja3MucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICB2YXIgbCA9IGMubGVmdC5ibG9jaywgciA9IGMucmlnaHQuYmxvY2s7XHJcbiAgICAgICAgdmFyIGRpc3QgPSBjLnJpZ2h0Lm9mZnNldCAtIGMubGVmdC5vZmZzZXQgLSBjLmdhcDtcclxuICAgICAgICBpZiAobC52YXJzLmxlbmd0aCA8IHIudmFycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgci5tZXJnZUFjcm9zcyhsLCBjLCBkaXN0KTtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUobCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsLm1lcmdlQWNyb3NzKHIsIGMsIC1kaXN0KTtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUocik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJsb2Nrcy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgdGhpcy5saXN0LmZvckVhY2goZik7XHJcbiAgICB9O1xyXG4gICAgQmxvY2tzLnByb3RvdHlwZS51cGRhdGVCbG9ja1Bvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmxpc3QuZm9yRWFjaChmdW5jdGlvbiAoYikgeyByZXR1cm4gYi51cGRhdGVXZWlnaHRlZFBvc2l0aW9uKCk7IH0pO1xyXG4gICAgfTtcclxuICAgIEJsb2Nrcy5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoaW5hY3RpdmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQmxvY2tQb3NpdGlvbnMoKTtcclxuICAgICAgICB0aGlzLmxpc3QuZm9yRWFjaChmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICB2YXIgdiA9IGIuZmluZE1pbkxNKCk7XHJcbiAgICAgICAgICAgIGlmICh2ICE9PSBudWxsICYmIHYubG0gPCBTb2x2ZXIuTEFHUkFOR0lBTl9UT0xFUkFOQ0UpIHtcclxuICAgICAgICAgICAgICAgIGIgPSB2LmxlZnQuYmxvY2s7XHJcbiAgICAgICAgICAgICAgICBCbG9jay5zcGxpdCh2KS5mb3JFYWNoKGZ1bmN0aW9uIChuYikgeyByZXR1cm4gX3RoaXMuaW5zZXJ0KG5iKTsgfSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmUoYik7XHJcbiAgICAgICAgICAgICAgICBpbmFjdGl2ZS5wdXNoKHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJsb2NrcztcclxufSgpKTtcclxuZXhwb3J0cy5CbG9ja3MgPSBCbG9ja3M7XHJcbnZhciBTb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU29sdmVyKHZzLCBjcykge1xyXG4gICAgICAgIHRoaXMudnMgPSB2cztcclxuICAgICAgICB0aGlzLmNzID0gY3M7XHJcbiAgICAgICAgdGhpcy52cyA9IHZzO1xyXG4gICAgICAgIHZzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdi5jSW4gPSBbXSwgdi5jT3V0ID0gW107XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jcyA9IGNzO1xyXG4gICAgICAgIGNzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgYy5sZWZ0LmNPdXQucHVzaChjKTtcclxuICAgICAgICAgICAgYy5yaWdodC5jSW4ucHVzaChjKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmluYWN0aXZlID0gY3MubWFwKGZ1bmN0aW9uIChjKSB7IGMuYWN0aXZlID0gZmFsc2U7IHJldHVybiBjOyB9KTtcclxuICAgICAgICB0aGlzLmJzID0gbnVsbDtcclxuICAgIH1cclxuICAgIFNvbHZlci5wcm90b3R5cGUuY29zdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5icy5jb3N0KCk7XHJcbiAgICB9O1xyXG4gICAgU29sdmVyLnByb3RvdHlwZS5zZXRTdGFydGluZ1Bvc2l0aW9ucyA9IGZ1bmN0aW9uIChwcykge1xyXG4gICAgICAgIHRoaXMuaW5hY3RpdmUgPSB0aGlzLmNzLm1hcChmdW5jdGlvbiAoYykgeyBjLmFjdGl2ZSA9IGZhbHNlOyByZXR1cm4gYzsgfSk7XHJcbiAgICAgICAgdGhpcy5icyA9IG5ldyBCbG9ja3ModGhpcy52cyk7XHJcbiAgICAgICAgdGhpcy5icy5mb3JFYWNoKGZ1bmN0aW9uIChiLCBpKSB7IHJldHVybiBiLnBvc24gPSBwc1tpXTsgfSk7XHJcbiAgICB9O1xyXG4gICAgU29sdmVyLnByb3RvdHlwZS5zZXREZXNpcmVkUG9zaXRpb25zID0gZnVuY3Rpb24gKHBzKSB7XHJcbiAgICAgICAgdGhpcy52cy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiB2LmRlc2lyZWRQb3NpdGlvbiA9IHBzW2ldOyB9KTtcclxuICAgIH07XHJcbiAgICBTb2x2ZXIucHJvdG90eXBlLm1vc3RWaW9sYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbWluU2xhY2sgPSBOdW1iZXIuTUFYX1ZBTFVFLCB2ID0gbnVsbCwgbCA9IHRoaXMuaW5hY3RpdmUsIG4gPSBsLmxlbmd0aCwgZGVsZXRlUG9pbnQgPSBuO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gbFtpXTtcclxuICAgICAgICAgICAgaWYgKGMudW5zYXRpc2ZpYWJsZSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB2YXIgc2xhY2sgPSBjLnNsYWNrKCk7XHJcbiAgICAgICAgICAgIGlmIChjLmVxdWFsaXR5IHx8IHNsYWNrIDwgbWluU2xhY2spIHtcclxuICAgICAgICAgICAgICAgIG1pblNsYWNrID0gc2xhY2s7XHJcbiAgICAgICAgICAgICAgICB2ID0gYztcclxuICAgICAgICAgICAgICAgIGRlbGV0ZVBvaW50ID0gaTtcclxuICAgICAgICAgICAgICAgIGlmIChjLmVxdWFsaXR5KVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWxldGVQb2ludCAhPT0gbiAmJlxyXG4gICAgICAgICAgICAobWluU2xhY2sgPCBTb2x2ZXIuWkVST19VUFBFUkJPVU5EICYmICF2LmFjdGl2ZSB8fCB2LmVxdWFsaXR5KSkge1xyXG4gICAgICAgICAgICBsW2RlbGV0ZVBvaW50XSA9IGxbbiAtIDFdO1xyXG4gICAgICAgICAgICBsLmxlbmd0aCA9IG4gLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH07XHJcbiAgICBTb2x2ZXIucHJvdG90eXBlLnNhdGlzZnkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYnMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmJzID0gbmV3IEJsb2Nrcyh0aGlzLnZzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5icy5zcGxpdCh0aGlzLmluYWN0aXZlKTtcclxuICAgICAgICB2YXIgdiA9IG51bGw7XHJcbiAgICAgICAgd2hpbGUgKCh2ID0gdGhpcy5tb3N0VmlvbGF0ZWQoKSkgJiYgKHYuZXF1YWxpdHkgfHwgdi5zbGFjaygpIDwgU29sdmVyLlpFUk9fVVBQRVJCT1VORCAmJiAhdi5hY3RpdmUpKSB7XHJcbiAgICAgICAgICAgIHZhciBsYiA9IHYubGVmdC5ibG9jaywgcmIgPSB2LnJpZ2h0LmJsb2NrO1xyXG4gICAgICAgICAgICBpZiAobGIgIT09IHJiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJzLm1lcmdlKHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxiLmlzQWN0aXZlRGlyZWN0ZWRQYXRoQmV0d2Vlbih2LnJpZ2h0LCB2LmxlZnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdi51bnNhdGlzZmlhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzcGxpdCA9IGxiLnNwbGl0QmV0d2Vlbih2LmxlZnQsIHYucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5icy5pbnNlcnQoc3BsaXQubGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnMuaW5zZXJ0KHNwbGl0LnJiKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJzLnJlbW92ZShsYik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmFjdGl2ZS5wdXNoKHNwbGl0LmNvbnN0cmFpbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdi51bnNhdGlzZmlhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh2LnNsYWNrKCkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5hY3RpdmUucHVzaCh2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnMubWVyZ2Uodik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU29sdmVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNhdGlzZnkoKTtcclxuICAgICAgICB2YXIgbGFzdGNvc3QgPSBOdW1iZXIuTUFYX1ZBTFVFLCBjb3N0ID0gdGhpcy5icy5jb3N0KCk7XHJcbiAgICAgICAgd2hpbGUgKE1hdGguYWJzKGxhc3Rjb3N0IC0gY29zdCkgPiAwLjAwMDEpIHtcclxuICAgICAgICAgICAgdGhpcy5zYXRpc2Z5KCk7XHJcbiAgICAgICAgICAgIGxhc3Rjb3N0ID0gY29zdDtcclxuICAgICAgICAgICAgY29zdCA9IHRoaXMuYnMuY29zdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29zdDtcclxuICAgIH07XHJcbiAgICBTb2x2ZXIuTEFHUkFOR0lBTl9UT0xFUkFOQ0UgPSAtMWUtNDtcclxuICAgIFNvbHZlci5aRVJPX1VQUEVSQk9VTkQgPSAtMWUtMTA7XHJcbiAgICByZXR1cm4gU29sdmVyO1xyXG59KCkpO1xyXG5leHBvcnRzLlNvbHZlciA9IFNvbHZlcjtcclxuZnVuY3Rpb24gcmVtb3ZlT3ZlcmxhcEluT25lRGltZW5zaW9uKHNwYW5zLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XHJcbiAgICB2YXIgdnMgPSBzcGFucy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIG5ldyBWYXJpYWJsZShzLmRlc2lyZWRDZW50ZXIpOyB9KTtcclxuICAgIHZhciBjcyA9IFtdO1xyXG4gICAgdmFyIG4gPSBzcGFucy5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcclxuICAgICAgICB2YXIgbGVmdCA9IHNwYW5zW2ldLCByaWdodCA9IHNwYW5zW2kgKyAxXTtcclxuICAgICAgICBjcy5wdXNoKG5ldyBDb25zdHJhaW50KHZzW2ldLCB2c1tpICsgMV0sIChsZWZ0LnNpemUgKyByaWdodC5zaXplKSAvIDIpKTtcclxuICAgIH1cclxuICAgIHZhciBsZWZ0TW9zdCA9IHZzWzBdLCByaWdodE1vc3QgPSB2c1tuIC0gMV0sIGxlZnRNb3N0U2l6ZSA9IHNwYW5zWzBdLnNpemUgLyAyLCByaWdodE1vc3RTaXplID0gc3BhbnNbbiAtIDFdLnNpemUgLyAyO1xyXG4gICAgdmFyIHZMb3dlciA9IG51bGwsIHZVcHBlciA9IG51bGw7XHJcbiAgICBpZiAobG93ZXJCb3VuZCkge1xyXG4gICAgICAgIHZMb3dlciA9IG5ldyBWYXJpYWJsZShsb3dlckJvdW5kLCBsZWZ0TW9zdC53ZWlnaHQgKiAxMDAwKTtcclxuICAgICAgICB2cy5wdXNoKHZMb3dlcik7XHJcbiAgICAgICAgY3MucHVzaChuZXcgQ29uc3RyYWludCh2TG93ZXIsIGxlZnRNb3N0LCBsZWZ0TW9zdFNpemUpKTtcclxuICAgIH1cclxuICAgIGlmICh1cHBlckJvdW5kKSB7XHJcbiAgICAgICAgdlVwcGVyID0gbmV3IFZhcmlhYmxlKHVwcGVyQm91bmQsIHJpZ2h0TW9zdC53ZWlnaHQgKiAxMDAwKTtcclxuICAgICAgICB2cy5wdXNoKHZVcHBlcik7XHJcbiAgICAgICAgY3MucHVzaChuZXcgQ29uc3RyYWludChyaWdodE1vc3QsIHZVcHBlciwgcmlnaHRNb3N0U2l6ZSkpO1xyXG4gICAgfVxyXG4gICAgdmFyIHNvbHZlciA9IG5ldyBTb2x2ZXIodnMsIGNzKTtcclxuICAgIHNvbHZlci5zb2x2ZSgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXdDZW50ZXJzOiB2cy5zbGljZSgwLCBzcGFucy5sZW5ndGgpLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdi5wb3NpdGlvbigpOyB9KSxcclxuICAgICAgICBsb3dlckJvdW5kOiB2TG93ZXIgPyB2TG93ZXIucG9zaXRpb24oKSA6IGxlZnRNb3N0LnBvc2l0aW9uKCkgLSBsZWZ0TW9zdFNpemUsXHJcbiAgICAgICAgdXBwZXJCb3VuZDogdlVwcGVyID8gdlVwcGVyLnBvc2l0aW9uKCkgOiByaWdodE1vc3QucG9zaXRpb24oKSArIHJpZ2h0TW9zdFNpemVcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5yZW1vdmVPdmVybGFwSW5PbmVEaW1lbnNpb24gPSByZW1vdmVPdmVybGFwSW5PbmVEaW1lbnNpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZwc2MuanMubWFwIiwiKGZ1bmN0aW9uKHNlbGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmIChzZWxmLmZldGNoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gICAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gc2VsZixcbiAgICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBzZWxmXG4gIH1cblxuICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICAgIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICAgIF1cblxuICAgIHZhciBpc0RhdGFWaWV3ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbiAgICB9XG5cbiAgICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXcgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLlxcXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuICBmdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICAgIHZhciBpdGVyYXRvciA9IHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpXG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVyYXRvclxuICB9XG5cbiAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdGhpcy5tYXAgPSB7fVxuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICB9LCB0aGlzKVxuXG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gICAgdmFyIGxpc3QgPSB0aGlzLm1hcFtuYW1lXVxuICAgIGlmICghbGlzdCkge1xuICAgICAgbGlzdCA9IFtdXG4gICAgICB0aGlzLm1hcFtuYW1lXSA9IGxpc3RcbiAgICB9XG4gICAgbGlzdC5wdXNoKHZhbHVlKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICAgIHJldHVybiB2YWx1ZXMgPyB2YWx1ZXNbMF0gOiBudWxsXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldIHx8IFtdXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gW25vcm1hbGl6ZVZhbHVlKHZhbHVlKV1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMubWFwKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHRoaXMubWFwW25hbWVdLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgbmFtZSwgdGhpcylcbiAgICAgIH0sIHRoaXMpXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXVxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkgeyBpdGVtcy5wdXNoKG5hbWUpIH0pXG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHsgaXRlbXMucHVzaCh2YWx1ZSkgfSlcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKSB9KVxuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfVxuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICAgIH1cbiAgICBib2R5LmJvZHlVc2VkID0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KVxuICAgICAgfVxuICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICB2YXIgY2hhcnMgPSBuZXcgQXJyYXkodmlldy5sZW5ndGgpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKVxuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aClcbiAgICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgICByZXR1cm4gdmlldy5idWZmZXJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBCb2R5KCkge1xuICAgIHRoaXMuYm9keVVzZWQgPSBmYWxzZVxuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHlcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKClcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcilcbiAgICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgICAgdGhpcy5fYm9keUluaXQgPSBuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIEJvZHlJbml0IHR5cGUnKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JylcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSlcbiAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gY29uc3VtZWQodGhpcykgfHwgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ11cblxuICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICAgIHJldHVybiAobWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEpID8gdXBjYXNlZCA6IG1ldGhvZFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHlcblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnVybCA9IGlucHV0XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmxcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFsc1xuICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycylcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlXG4gICAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdFxuICAgICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdvbWl0J1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJylcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbFxuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KVxuICB9XG5cbiAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywgeyBib2R5OiB0aGlzLl9ib2R5SW5pdCB9KVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgYm9keS50cmltKCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAgIHJhd0hlYWRlcnMuc3BsaXQoJ1xcclxcbicpLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKClcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKVxuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gICAgdGhpcy5zdGF0dXMgPSAnc3RhdHVzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXMgOiAyMDBcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snXG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfVxuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfVxuXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnNcbiAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdFxuICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2VcblxuICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpXG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gICAgfSlcbiAgfVxuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuIiwiZXhwb3J0IGNvbnN0IFVOS05PV19JTUFHRSA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUpBQUFBQzdDQVlBQUFDS0xSZE5BQUFBQkhOQ1NWUUlDQWdJZkFoa2lBQUFBQWx3U0ZsekFBQVM2d0FBRXVzQnhJOHRPd0FBQUJsMFJWaDBVMjltZEhkaGNtVUFkM2QzTG1sdWEzTmpZWEJsTG05eVo1dnVQQm9BQUFuc1NVUkJWSGljN2R4WlNGVDlIOGZ4ejh6a282SXBhSm9vTGJaUlp0RVlGVUVVYWhkdEJtTExoYlJSMW9XUllFbGlsQzAzU1JzWmJiU0wwWUkzbFZGVXRPRlM0QkpXVHY3VEpFaXhiTTl3eXpuL2l4N2kzL1BYSGozZjM4eVpjVDR2R0NpbTM2K3Y4dVljblRsemdKOVNBTHdFb1BIQlJ5OGVML0d6R1pnQXJBVndIRVI5dDg0RTREOEFSaHM5Q2JtbGx5WUFYUURNUms5Q2JzbHV3czl6R3BFdVBQS1F5SUNlbmdnT0RvYlZhblhtTE9TaUtpc3I4ZUhEaDI2ZjZ6R2dLVk9tNE1hTkd3NGJpdHpIM0xsemNmUG16VzZmNHltTVJCZ1FpVEFnRW1GQUpNS0FTSVFCa1FnREloRUdSQ0lNaUVRWUVJa3dJQkpoUUNUQ2dFaUVBWkVJQXlJUkJrUWlESWhFR0JDSk1DQVNZVUFrd29CSWhBR1JDQU1pRVFaRUlneUlSQmdRaVRBZ0VtRkFKTUtBU0lRQmtRZ0RJcEVlN3cva0tSb2JHOUhRMElEbTVtYThmLzhlemMzTitQSGpCejU5K3ZUYnZ3c01ESVRaYk1hZ1FZTVFGaGFHaUlnSWhJZUhJelEwMUtESlhZTkhCTlRaMlFtYnpZYXFxaXBVVlZXaHVyb2FyMTY5UW4xOVBkcmEya1I3QndVRlljS0VDWWlPanNhMGFkTVFIeCtQOFBCd1JaTzd2bjRaVUZOVEUwcEtTbEJVVklUUzBsSlVWRlNnbzZQRElmL1h4NDhmOGVEQkF6eDQ4QUNIRHg4R0FJd2JOdzd6NXMxRGNuSnl2NzlOWUw4SXFLNnVEbmZ1M0VGSlNRbUtpNHRSVjFkbjZEdzJtdzAybXczNzl1M0QrUEhqc1diTkdxeFpzd2IrL3Y2R3p1VW8zZDdPZnM2Y09acXJzdHZ0V25GeHNiWnAweVp0N05peFJ0LzJ2MWVQNE9CZ2JmdjI3ZHJuejUrTi92YjEyWnc1Yy83MHRibFhRUHYyN2RNaUl5TU5EMEx2SXl3c1RNdkx5OVBzZHJ2UjM4cGUrMU5BYnZkcmZINStQdXJyNjQwZVE3ZW1waVlzWDc0Y2NYRnhlUFBtamRIamlMbGRRUDNGL2Z2M1liVmFlN3g5cnJ0Z1FBWjYvLzQ5NXMrZmo5emNYS05IMFkwQkdjeHV0eU10TFEyWm1abEdqNklMQTNJUk9UazUyTFp0bTlGajlCa0RjaUc3ZHUzQzBhTkhqUjZqVHhpUWkwbExTME5KU1luUlkvUmF2M2dsdXE4c0ZndWlvcUpndFZveFlzUUlEQjgrSE1PR0RVTkVSQVM4dkx3UUdCZ0liMjl2bU0xbWZQbnk1ZGVqcWFrSlQ1NDhRVmxaR2NyTHk5SFEwS0I4dHM3T1RxeFlzUUpQbmp5Qm41K2Y4djFWODRpQXpHWXpwazZkaW9TRUJNeVlNUU14TVRHOWZsdkJ4OGNIZ3djUC92WDNoSVNFWDMrdXE2dERRVUVCenB3NWc1cWFHbVh6MXRiV0lqTXpFNGNPSFZLMnB5TzUxU3ZSVnF1MVY2LzRta3dtTFRZMlZqdDU4cVRXMU5UazBKbnNkcnQyL2ZwMUxTWW1SdGtyMWdNR0ROQnFhbW9jT25kdjlhdTNNdjR0b05EUVVDMGpJOE9RYjc3ZGJ0ZE9uRGloQlFRRUtJbG82ZEtsVHY4YXV0UHZBektaVE5yczJiTzFTNWN1YWUzdDdVYVBxTlhYMTJ1VEprMFNCMlEybTdWWHIxNFovZVgwci9mQy9wZkZZa0Z5Y2pLZVBYdUcyN2R2WThtU0pmanJyNytNSGd2RGh3OUhVVkVSWnMyYUpkckhicmZqN05temFvWnlFTGNOS0NrcENUYWJEZm41K1lpS2lqSjZuUC9qNStlSHExZXZJam82V3JUUHVYUG5vR21hb3FuVWM3dUFrcEtTY1BmdVhSUVVGR0QwNk5GR2ovTkhBUUVCdUhEaEFyeTl2WFh2OGZyMWExUlhWeXVjU2kyM0MyakxsaTJJalkwMWVveGVpNDZPUm1wcXFtaVB1M2Z2S3BwR1BiY0x5QjFsWm1hS2ZqWjcrUENod21uVVlrQk9FQklTOHRzTGtIMmw4a1ZLMVJpUWt5eFlzRUQzMnRyYVd0anRkb1hUcU1PQW5HVG16Sm02MTdhMnR1TGR1M2NLcDFHSEFUbEpaR1FrZkgxOWRhLy85dTJid21uVVlVQk9ZaktaTUd6WU1OM3JHUkFoSUNCQTkxcnBSN0FkaFFFNWtlUVU1cXJYQmpFZ0ovcisvYnZ1dGE3NnNXZ0c1RVF0TFMyNjF6SWd3dWZQbjNXdDgvYjJ4cUJCZ3hSUG93WURjcEt2WDcvaTdkdTN1dGFPR0RFQ0ZvdEY4VVJxTUNBbnNkbHN1aS9MY09XckRoaVFrMVJVVk9oZU8zSGlSSVdUcU1XQW5LU3dzRkQzMnJpNE9JV1RxTVdBbktDbHBRWDM3dDNUdGRiSHh3ZlRwMDlYUEpFNkRNZ0pUcDgramRiV1ZsMXI0K0xpNE9Qam8zZ2lkUmlRZzNWMmRtTC8vdjI2MTY5Y3VWTGRNQTdBZ0J4czc5NjllUDM2dGE2MXdjSEJXTGh3b2VLSjFHSkFEbFJUVTRPZE8zZnFYcCtTa2lLNklOOFpHSkNEdExXMUlUazVXZmU3NlA3Ky9raFBUMWM4bFhvTXlFSFdyMStQOHZKeTNldlQwOU1SRWhLaWNDTEhZRUFPc0h2M2JwdzZkVXIzK2lGRGhpQWpJMFBoUkk3RGdCUTdmZm8wc3JLeVJIc2NQSGpRWmQ5OS95Y0dwTkNaTTJld2R1MWEwVWVSRXhNVGtaaVlxSEFxeDJKQWlodzVjZ1NyVjY5R1YxZVg3ajJHRGgyS2t5ZFBLcHpLOFJpUWtLWnB5TXJLUW1wcXF1akk0K1hsaFlzWEx5SW9LRWpoZEk3bkViZTRjNVNXbGhhc1hyMGFseTlmRnUxak1wbHcvUGh4bDM3UHF5Y01TS2VhbWhvc1dyUUl6NTQ5RSsrMVk4Y09yRnExU3NGVXpzZFRXQjkxZFhYaHdJRURpSW1KVVJKUGVubzZ0bTdkcW1BeVkvQUkxQWRQbno1RlNrb0tIajkrckdTL3paczNZL2Z1M1VyMk1ncVBRTDNRM3Q2T3JWdTNZdkxreVVyaU1adk4yTE5uajl2SEEvQUk5Szl1M2JxRnRMUTB2SGp4UXNsK1BqNCtPSGZ1SEpZc1dhSmtQNk14b0I3VTF0Wmk0OGFOdUhyMXFySTlod3daZ2t1WExybmxiMXM5WVVELzhQMzdkK3pac3djNU9UbEtQNDhlSHgrUDgrZlAvM2JYKy82QVB3UDlUZE0wNU9YbFlkU29VZGl4WTRleWVDd1dDN0t6czNIcjFxMStGdy9BSXhBQW9LeXNEQnMyYkVCcGFhblNmVU5EUTNIKy9Ibk1uajFiNmI2dXhLT1BRSTJOalZpM2JoMm1UWnVtUEo3Rml4ZmorZlBuL1RvZXdJT1BRRisrZk1HWU1XTkVkOHpvVGtSRUJJNGRPeWE2SjZJNzhkZ2pVRWRIaDlKNFRDWVRsaTFiaHFxcUtvK0pCL0RnSTVCS28wYU53ckZqeHhBZkgyLzBLRTduc1VjZ0ZYeDlmWkdkblkyblQ1OTZaRHdBajBDNkxWaXdBTG01dVlpTWpEUjZGRVB4Q05SSEkwZU9SR0ZoSWE1ZHUrYng4UUE4QXZYWm8wZVBYUFp1WVViZ0VhaVB2THk4akI3QnBUQWdFbUZBSk1LQVNJUUJrUWdESWhFR1JDSU1pRVFZRUlrd0lCSmhRQ1RDZ0VpRUFaRUlBeUlSQmtRaUhuczlrTGUzTnhZdlh0em5kYnljNDNjZUcxQkFRSUQ0em1MRVV4Z0pNU0FTWVVBa3dvQkloQUdSQ0FNaUVRWkVJZ3lJUkJnUWlUQWdFbUZBSk1LQVNNUmozMHd0TEN4RVkyT2pyclVMRnk1RVdGaVk0b25jazhjR3RILy9mdHk3ZDAvWDJxaW9LQWIwTjU3Q1NJUUJrUWdESWhFR1JDSU1pRVFZRUlrd0lCSmhRQ1RDZ0VpRUFaRUlBeUlSQmtRaURJaEVHQkNKZU96bEhGZXVYTUdQSHo5MHJSMDRjS0RpYWR5WHh3YkVDTlRnS1l4RUdCQ0pNQ0FTWVVBa3dvQkloQUdSQ0FNaUVRWkVJZ3lJUkJnUWlUQWdFbUZBSk1LQVNJUUJrUWdESWhFR1JDSU1pRVFZRUlrd0lCSmhRQ1RDZ0VpRUFaRUlBeUlSQmtRaURJaEVHQkNKTUNBU01RSFF1bnNpT0RnWVZxdlZ5ZU9RSzZxc3JNU0hEeCs2ZmE3SGdJaDZnNmN3RWpFRHNCczlCTGt0dXhsQW5kRlRrTnVxc3dCb0I1Qmc5Q1RrbHJJc0FNb0JOQUlZQnlESTJIbklUZFFDeUFSdzRyKzBLaDJ1UDNaNmFBQUFBQUJKUlU1RXJrSmdnZz09JztcbmV4cG9ydCBjb25zdCBMSU5LX09QVElPTlMgPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFKWUFBQUNXQ0FZQUFBQThBWEhpQUFBQUJITkNTVlFJQ0FnSWZBaGtpQUFBQUFsd1NGbHpBQUFHN0FBQUJ1d0JIblU0TlFBQUFCbDBSVmgwVTI5bWRIZGhjbVVBZDNkM0xtbHVhM05qWVhCbExtOXlaNXZ1UEJvQUFCZVVTVVJCVkhpYzdaMTVkRlJWbnNjL3I2cVN5aTZRQlZvZ0lRa0VSRmxNdERzcVFRVkVqNGJqYUxzMEtEU2l3b0JIUUp3TUNMUWdPS2ljWnRoVW1vRzRSQnRSYkJ3VkI3VnBSRUFKQW1FTElwSEZCQUlFa3JBWVFwSksxWjAvWGhJQ1pubTM2bFc5U25pZmMzNkhVSFh2ZTNmNTFuMzMzZVYzRmE1ZUFvREVHb3NEWW9GT1FDVFFyc1lpYThMYWdaQ2F2OHVCU2tBQXBmV3NCRGdHNUFNRndLRWFjM2cvSy82SFluUUNmRVFvY0JPUUN0d0lYQThrQVlGZXZtOFZjQUQ0RWNnQnNvRWR3QVV2Mzlkd1dxdXdRb0EwNEM1Z0lIQURZRE0wUlplb0J2WUE2NEYvQXB1QWk0YW15S1JKMmdPamdhOVFLMHEwRUxzSXJBV2VCcUoxTHhVVHQ0Z0FuZ0srUlcwSmpCYUpwMVlOZkFPTUFzSjFMQ2NUamZRSDNrUHRxeGd0Qm0vWkJTQUw5WkZ1NGtYc3dBaGdGOFpYdXE5dEorcGp2dmJOMUVRSHdvQUp3SEdNcjJDajdUUXdFN2pHa3dLOTJna0RYa1FkSHpLNlF2M05pb0ZwcU1Nb0pocXhvVGI3SnpDK0F2M2RUcU8yNXY0eWxPSzNEQVord3ZnS2EybTJIeGprUm5sN0RYOFpJTDBXbUE4ODR1c2JCd1FFa0ppWVNKY3VYWWlOamFWVHAwNUVSVVhScmwwNzJyVnJSMUJRRUNFaGwvZVp5OHZMcWFpb29MUzBsSktTRWtwS1NqaDY5Q2dGQlFYODhzc3ZIRDU4R0lmRGtKbWNsY0FrMU5iZVVJd1dsb0k2RHZWWDFERXByeElhR2twS1NncC8rTU1mU0VsSjRZWWJiaUFwS1ltQWdBQmQ3K053T0RodzRBRDc5dTFqKy9idGJOMjZsUjA3ZGxCZVhxN3JmUnJoSFBBOGtPbUxtL2tqbllBdjhlSWp3bWF6aWJTME5ERjc5bXlSblowdEhBNkhNQXFId3lHMmJOa2lYbnJwSmRHdlh6OWhzOW04L1hqOEF2VkpjRlh4SUhBR0x4U28zVzRYNmVucDR1MjMzeFlsSlNXR0NhazVpb3VMUldabXByanZ2dnRFWUdDZ3Q4UlZBdHp2bFJyME0rekFJcnhRaUNrcEtXTHg0c1dpdUxqWWFNMUljL3IwYWJGdzRVS1JuSnpzRFhHNVVQdXYzbDdKWVJpZGdCL1F1WFVhTVdLRTJMWnRtOUhhMEkwZmZ2aEJQUDc0NDhKdXQrc3RzR3hhNGFNeEZSMUh6c1BEdzhXVUtWTkVVVkdSMFRyd0dpZE9uQkFaR1JraUxDeE1UM0VWQWpkN3NaNTl5akIwV3NZU0dob3FwaytmN3RkOUo3MHBMaTRXVTZkT0ZTRWhJWHFKNnlMd3FGZHIzQWRNUkgzR2UxUVlOcHROakJrelJwdzRjY0xvZWphTXdzSkM4ZFJUVHdtcjFhcUh1SnpBZUMvWHZWZFFnRG5vOEF1NzdiYmJ4TzdkdTQydVY3OWg1ODZkSWpVMVZhL1c2Nzh3Zml4VE13cXdFQTh6M2FaTkc3RjgrWExoY3JtTXJrdS93K2wwaXFWTGw0cHJycmxHRDNITnB3V0lTeGRSRFI0OFdCUVVGQmhkZjM3UDhlUEhSWHA2dWg3aVdvS2ZpMnMrSG1Rd0tDaEl2UEhHRzJZckpZSEw1UktMRmkzU1kzamlyejdRaDF0TXc0T01kZW5TUld6ZHV0WG9lbXF4N05peFEzVHQydFZUY2YybkQzUWl4Vk40OFBaMzc3MzNpblBuemhsZE55MmVNMmZPaUh2dXVjY1RZYm1Ba2Q2WGl6WUdvZTcyZFNzekdSa1pvcnE2MnVnNmFUVlVWMWVMU1pNbWVTS3VLdUJPSCtpbVNSSlFWekZLWjhCcXRZb2xTNVlZWFErdGx0ZGZmMTFZTEJaM3hWVUNkUFdKZ2hvZ0FuWGxvblRDN1hhN1dMVnFsZEZsMytyNThNTVBQZW5VNzhPZ3ZZMS9keU94SWpBd1VIejIyV2RHbC9sVnc5cTFhMFZRVUpDNzRscnBJeTNWTWM2ZGhOcnRkbE5VQnVDaHVKNzJrYWJvalJ1VHlqYWJ6UlNWZ1h6eXlTZnV6ak9XbzNybjhTbzJZTHRzNGhSRkVabVptVWFYN1ZYUHUrKytLeFJGY1VkY09hait4RFJqbFJUV1RPQlBrbkdZUFhzMkV5Wk1rSTFtb2pOOSt2VEI1WEx4N2JmZnlrYjlIZXFRMGtiOVV3VjljV084YXVqUW9lWVVqUi9oY3JuRVF3ODk1RTZyVllrWEhva0s4SjFzWWxKU1VrUjVlYm5SWldseUJSY3VYQkI5K3ZSeFIxemZvdk5rOVNqWlJJU0hoNHNEQnc0WVhZWW1qZkR6enorTGlJZ0lkOFExWEM5UlJRQ25aQlB3MFVjZkdWMTJKczJ3WXNVS2Q0UjFFdFZoaThlOExIdnprU05IR2wxbUpocDU3TEhIM0JIWHpPWkUwOXp6OG5mQXowaTR5K25Zc1NONzkrNmxiZHUyV3FPWUdNalpzMmZwMWFzWHg0NGRrNGxXQm5SRGJiMGF4TkxNQmFZajZZTnAyYkpscHFoYUVHM2F0T0gxMTErWGpSWUd2T0R1UGR1ampycHFiaUlmZlBCQm8xdDJFemNaTW1TSTdPUHdJdERCSFdHOUpuT2prSkFRa1orZmIzVDVtTGpKNGNPSFJYQndzS3k0NWpRbW5zWWVoZGNBL3k2andrbVRKaEViR3lzVHhjU1BpSStQZDJkMlpCeU51SjlxclBNK0VYVmpoQ2Fpb3FJNGRPZ1FFUkZlZDNGbDRrWE9uajFMMTY1ZEtTa3BrWW4yTFBDYlRscERMWllDakpHNTh0U3BVMDFSdFFMYXRHbkQ1TW1UWmFNMStHUnJxTVVhQ0t6VGV0V29xQ2grK2VVWFFrTk5CNzZ0Z2JLeU11TGk0aWd0TFpXSmRnZnFkRThkRGJWWVQ4aGNjZno0OGFhb1doRmhZV0U4Kyt5enN0RkdYdm5CbFMxV0tCSkQ5c0hCd1J3OWVwVEl5TWptQTV1MEdJcUxpK25jdVRNVkZSVmFvNXhISFhxb084WHN5aGJyZmlUbWdZWU9IV3FLcWhVU0ZSWEZ3dzgvTEJNbEFraXYvOEdWd3BKeWh6MTI3RmlaNENZdENEZnE5aktmVy9VZmhjR29SMmxvT2dpb1o4K2U3TnUzVC9ibUppMkk2Nisvbmg5Ly9GRnI4RElnQ25WQjRHVXQxZ0FrVHBjYU1XS0UxcUFtTFpRLy9VbHFGWG9ZY0h2dGYrb0w2MTZ0VjFBVVJmYW1KaTJRWWNPR3lVYTVyL2FQK3NMU3ZGOC9PVG1adUxnNDJadWF0REFTRXhQcDFhdVhUSlE3YXYrb0ZWWTAwRU5yN1BUMDlPWURtYlFJaEJCTkhzVXlaTWdRbWN2MUFpTGhrckRTa0Zna2YrKzltcCthSm42S3krVmkxYXBWWEhmZGRmVHAwd2NoUklQaEpPdGFBZnJWLzJBdUVwc2tqRHlUeHNRenFxcXF4RHZ2dkNQaTR1SXU4MFp6Nk5DaFJzT0hob2JLTEtWNUZTNjFXRGRxbGVSdHQ5Mkd6V2FldTlqU3FLaW80TTAzM3lRMk5wWW5uM3lTL1B4OEFOTFMwdGk0Y1NNSkNRa054Z3NJQ0NBMU5WWG1WbjNna3JENmFJMTE2NjIzeXR6RXhHQXVYTGpBZ2dVTDZOU3BFK1BIajZlb3FBaUFRWU1HOGYzMzM3Tng0MGJTMHRLYXZFWnozMTlCMzlvL3JrVmkxZURubjMvdTQ4YmJ4QjNPblRzblhubmxGUkVlSGw3bnI4RmlzWWk3Nzc1YjdOaXhRK3BhbjM3NnFlekswdlkySUVsR2pqZmVxUG1wYVFnZmZ2Z2htWm1aalhaRy9ZV2twQ1FXTFZxRTFTcnJQcU5wVHA4K3plTEZpNWszYng0VkZSVUlJYkJhcmZ6eGozOWsxcXhaSkNWSlZUY0FmZnYyYlQ3UTVYUURkWm1NSmlXMmE5Zk9LNzh1UGVuYnQ2ODcrK1FNc2YzNzkrdVc3L3o4ZlBITU04L1VuWDJvS0lvSUNBZ1FvMGFORWtlUEh2WDQrcEtIRll5d29Qb1IxVVJpWXFMV29JYmhkRHFOVG9KbXFxdXJQYjdHa1NOSEdEZHVIRjI3ZG1YSmtpVlVWMWRqdDlzWk4yNGMrZm41WkdabTBxbFRKNC92STFuM0NUWkE4dzZJeHQ0Y1RIeFBibTR1czJmUDV1T1BQMFlJZ2FJb2hJYUdNbkhpUko1NzdqbmQ5M1ltSmlhU2s1T2pOWGljRFhYVVhSTmR1blJ4SjAwbU9ySnIxeTVtekpqQm1qVnJjTGxjS0lwQ1JFUUVFeVpNNFBubm4vZmEzZ1BKdW8rMkFURmFROGZFYUE1cW9qT2JOMjltNXN5WmJOaXdBWmZMaGNWaUlTWW1ocWxUcHpKbXpCaUNnb0s4ZXYvb2FNM3REMEMwaFpxNUhTMUVSVVZKSjhqWCtQdGJheTNSMGRHYStqN3IxcTBqSlNXRi92Mzc4NjkvL1F1WHk4VzExMTdMbTIrK1NXRmhJUk1tVFBDNnFHclRLMEdVRFltbHlDMWhHZkxiYjcvTnJGbXovTDRUMzc1OSswWTNvYmhjTHI3NDRndGVlT0VGZnZycEo1eE9KMWFybFlTRUJLWlBuODVqanoybSt6QkZjMGpXZlpnTjlXUjVUZmppbCtFcEZvdWx4UzdwY1RnY2ZQREJCOHlZTVlQOC9QeTZNYWprNUdSbXpweEplbm82aW1MTTZXK1NkVytYRXBiZHJqbW9ZUlFWRmZIZGQ5LzVmWXZWdDI5ZnVuWHJCa0JWVlJVclY2NWsyclJwbkRoeEFxZlRpYUlvcEtTa01HUEdETm1sSzE1QnN1N3RvSjRQckduZ0t6czcyK09CTm0rVG5KeHMrTUNuRmdzTEN4T25UcDBTOCtmUEY1R1JrY0pxdFFwRlVZVFZhaFdEQmczeXU3TGVzbVdMVFA2Y3RocGhOZWNuQzJoK1FPLzgrZk9HdHhTRmhZV0czbDhyWldWbEpDUWtjT0hDQllRUVdDd1dCZzhlekp3NWMwaE9Ualk2ZWIvQjRYRElCSysyb2U2cTBPUWN2ckt5c3RIdnRtL2Z6czAzM3l4ejg2dWVzckl5UU8yL2hJV0ZzV3ZYTGtNV1VWcXRWbGFzV01IdHQ5L2VhSmltNnI2aDRMWEMwdlJtMk5URkwxNjhpTVZpTWJ3ZlZqdngybEpRRklYS3lrclppdE05RGJYcnN4ckRIV0dWbzNFczY4eVpNNDErbDVxYXl1clZxNm1xcXBKSmdPNk1HVE9teVhUNkU0cWkxRDBHdTNmdlRscGFtaUZ1TnExV0szZmNjVWVUWVNUTDlBS281NlJvNnBRdFdMREE0QzVrOHlRa0pCamVNZGRpaXFLSUYxOThVWVNGaFFtYnpWYlhjYi8vL3Z0MVhmV2dGL1BtelpQSjN6WWI2Z21wbWpoOVduTlF3OGpNek9UTEw3ODBPaGwxVkZSVWtKZVh4M1hYWFVkQXdLV3ViTy9ldlJrMmJCZ1pHUmtzWDc2Y1diTm1jZjc4ZVQ3NzdEUFdyRm5EZ0FFRGVQWFZWLzJtSXkvcGpLMFlKQTYwSEQ1OHVORS9uRlpMUlVXRldMcDBxWWlPanY3TjBNTVBQL3hnZFBKay9jRm5XUURORHI0UEh6NHNvMW9UQ2V4Mk82TkhqK2JZc1dPODlkWmJkT3pZRVZEbkNsTlRVMGxMU3lNN085dXc5QjA2ZEVnbStORmF0NUIvMHhLNlE0Y09uRGh4d3AxMCtZeXZ2LzZhK2ZQbjY3S0l6cHZFeDhlemVQSGlSdCtpYTZkMy92S1h2MUJZV0ZnM1g5aW5UeDltenB6cDg5SDQ5dTNiYytyVUthM0Jud2E0QzRsTzUrblRwNDF1bFp2a3JydnVNcnhqcnRVMmJkclViSDZjVHFmNDZLT1BSSHg4dkxEWmJBSVFWcXRWSkNjbisrekUycUtpSXRtODNXa0JEbXFWSWFnTHpmd1pmMitwNnFNbHJSYUxoWWNmZnBpREJ3K3lldlZxcnI5ZVBUSXdKeWVIQng1NGdCNDllckJxMVNxdmp0M3QzcjFiTnNwQkMvQUxxcXMvVGZpN3NGb3JGb3VGSVVPR2tKdWJ5NWRmZmtudjNyMEJPSERnQUVPSERpVXBLWW1zckN5dlRLbnQzTGxUSnZnWjRKZ0Z0ZW5TTE1rdFc3WklKc3RFYndZTkdzVHUzYnZac0dGRDNRYmlnd2NQTW1yVUtMcDE2MFpXVnBhdUxmZDMzMzBuRTN3WHFxWUFXSVRHNTJkVVZKUmZIOFY3NTUxM0d0NTMwbXJmZlBPTkxubmV0R21UR0RCZ3dHWERGTzNidHhjTEZpd1FGUlVWSGwzYjZYU0t5TWhJbVh4ZGR2REU0eklGa3B1YnEwdUJlSVB4NDhjYkxoZ3RGaG9hcXZ2WlF6azVPV0xJa0NHWENTdzZPbHJNbnovZjdTT1VkKzNhSlp1M1lYREpkVkVjYWw5TEUzUG56aVVqSTBOcmNKL2ljcmtvS0NqQTVYSVpuWlFtYWR1MnJkZm1CZmZzMmNQTEw3L002dFdyNnpaZWhJV0ZNV1hLRk1hUEgwOUlpR2FQb015Wk00ZHAwNmJKM0Q0V09Gci9nM3cwcXJKLy8vNjYvdEpNdkVOdWJxNTQ1SkZITG12QndzUER4WXN2dmlqT25qMnI2UnEzM0hLTFRHdlY0QWhEbHRZTDJHdzJ2eC9QTXJuRW9VT0h4Qk5QUEZFMzJXMnhXRVJ3Y0xESXlNZ1FwYVdsamNZN2VmS2tzRnF0TXNKYTNwQ3dIcFc0Z0ZpeVpJa1BpOFpFRHc0ZlBpeWVlT0lKRVJBUUlDd1dpN0JZTENJb0tFaTg4TUlMb3JLeThqZmhGeTVjS051L2VxQWhZVjBEVkdtOVNMOSsvUXdvR2hNOUtDZ29FR1BIamhXQmdZSENZckVJUlZGRVFVSEJiOEw5L3ZlL2x4RlZCUkJlSzZZcjl4S3RSNlAzWkVWUnlNdkxvMnZYcmxxQ20vZ2hKMCtlWk83Y3VadzZkWXIzMzMvL3N1LzI3OTlQejU0OVpTNzNOWEIzWTErT1E2THBlLzc1NXczNHZabjRBamVHYlo2dUw2UXJXNngyd0FrZ1VJdEUyN1JwUTJGaG9kVHJxNG4vYy9IaVJUcDI3Q2l6SExrSytCMVFkOGpobGR1K1NsR2JORTJjUFh1V3JLd3NyY0ZOV2dpWm1abXlhOXkvb0o2b29HSGY3ZzhCcTdSZU1UNCtucnk4UE5PVGNpdkI0WERRclZ1M1puZnRYTUVEd1AvVy82Q2hqYXFmQXNlMVh2SElrU09zWExsU0poRW1mc3o3Nzc4dks2cGp3QnF0Z1djaTBYR0xqNC8zZUxMVHhIZ3FLeXZkMmVVMHZTRUJOYmExZmhscWgwd1RSNDRjWWRteVpWcURtL2dwYjd6eGh1eStoa29nczZFdm12S0prd21NMG5xSDZPaG9EaHc0WU1pR1N4UFBLU2twb1h2MzdyTGJ2SllCb3h2Nm9pbnZYUWRReDdVME9XUXFMeStuckt6TVBNQ3BoVEp4NGtRMmI5NHNFOFdKdWtTbXRMbUFEZkVSRXM5YnE5VXF0bS9mYm5SWHdVU1M3T3pzeXc1czBtaC9iMG80emJWRzNZRmNRUE5ZUXUvZXZkbTJiUnVCZ1pyR1dFME1wckt5a3B0dXVvbmMzRnlaYUE3Z2V1RG54Z0kwNThpeUJPZ01wR2k5WTFGUkVZcWljT2VkbWc5c05UR1E2ZE9uODhrbm44aEcreHZ3ZnJPaG11RmFWTzhobXB0Sm04MG12di8rZTZOYmVKTm0yTGh4byt4Nkt3SDhDblJvVGpSYVBQa2RCMTdSTEVQVS9YS1BQdnFvN0J1R2lROHBMUzFsK1BEaDdtd1htdzJjMUNzZGR0UzNSQ2wxcDZlbkM2ZlRhZlFQMCtRS25FNm51T2VlZTJSYktnSHNRNlAzUjYzT3dwMUFIakJjWTNnQTh2THlxSzZ1WnVEQWdUTFJUTHpNbENsVGVQZmRkMldqQ2RSVnhsN3hEUE1Xa2lwWEZFV3NXTEhDNkIrcFNRMVpXVm51dEZRQ1dPb05RZFZ5RFJLN2VXb3RNREJRZlAzMTEwYVg2VlhQK3ZYcmhkMXVkMGRVUjZpMzdOaGJEQVpjc29tTGlJZ1FPVGs1UnBmdFZjdjI3ZHRGZUhpNE82SnlBZ084TGFwYVhuTWpnU0ltSnNhdmQxRzNWdmJzMlNPaW82UGRmUVRPOFpHbUFIVWtmck03Q1kyT2poWjc5dXd4dXF5dkd2YnYzeTg2ZE9qZ3JxZzJJakhyb2hlZGdWUHVKRGdtSnNhY1UvUUIyN1p0ODZTbE9nbDA5SW1TR3VBMjFQMWswZ2tQQ3dzVGE5ZXVOYnJzV3kzcjFxMFRFUkVSN29xcUN1anZFd1Uxd1ZPNGwzZ1JHQmdvM25yckxhUHJvTld4Yk5reUVSQVE0SzZvQkREU0Y4TFJnbHVkK1ZxYk5HbVNxSzZ1TnJvK1dqd09oME5NbUREQkUwRUpmTnhaYnc0RmVBY1BNalJ3NEVCeDh1UkpvK3VteFhMOCtIRTluTTR0UitQQ1RsOWlBejdIZzR4MTZOQkJyRnUzenVnNmFuRjg5ZFZYSWlZbXhsTlI1YUI5aXMvbkJBS2Y0VUVHRlVVUm8wZVBGbVZsWlViWGw5OVRYbDR1SmsrZTdNN3F6NGJNQWZqMXVuSTc4SDk0bU5IdTNidUx6WnMzRzExM2ZzdW1UWnRFVWxLU0hvS3FiK1hBcmQ0VWg2ZllnVS93TUtPS29vZ25uM3pTZFBKV2oxT25Ub21SSTBjS1JWSDBGbFd0RlFNOXZDY056N0VDLzRNT21ZMk1qQlFMRml4bzBEblkxVUpGUllXWU4yK2VhTnUycmJjRVZkOE9venI1OEZzVVlCWnVURm8zWkltSmlXTEZpaFZYMWVMQjZ1cHE4ZDU3NzRuNCtIaGZDS3ErN1FRaTlKZUV2anlLNUxyNXBpd2hJVUVzWGJwVU9Cd09vK3ZkYTlTZW9kT2pSdzlmQzZxK3JVT2pTeXNqdVJrb1JNZU14OFhGaWRkZWUwMlVsSlFZclFQZEtDNHVGcSs4OG9ybzNMbXprWUtxYngrZ2JXK0VvY1NnK3QvU05mTWhJU0hpejMvK3M5aXdZWU5mbjVyUkdFNm5VNnhmdjE2TUdERkNCQWNIR3kya2h1eS85UktBTjdFQTAxREhUWFF2aFBqNGVERmx5aFN4YmRzMnZ4YVp5K1VTVzdkdUZaTW5UeFp4Y1hGR0MwZUwvWWZuVmU4YmJzR05uVDh5RmhjWEo4YU9IU3YrOFk5L2lETm56aGl0SlZGYVdpbysvdmhqTVdiTUdIOTYxR2sxRityUk9Kb3dlbDRvQkhYUzgxbTgvQnkzV3EzMDd0MmJXMjY1aGRUVVZGSlNVdWpXcmR0bEI0RHJpY1BoSUM4dmp4MDdkcENkbmMyV0xWdll1M2V2VjQ1OTh5RU9JQjBON2tTTkZsWXR0d0p2QW4xOGVkUEF3RUNTa3BMbzBhTUhjWEZ4eE1iRzBxVkxGOXExYTFkbmRydWQ0T0JnZ29LQ0FOWHhhMFZGQlpXVmxaU1dsbEphV2twSlNRbjUrZmwxOXROUFA1R1hsNGZENGZCbGRuekZyNmd1MjNjWW5SQ3QySUNKd0RtTWIvWk5hOXBPQW9rTlY2UC9FZ204aXBzclU2OHkwMlhnMlUwN0FJUTFVb2QrVFRmVU1SUW54bGVndjFrMXFuK3FHNEc5QnFianBVWnJyd1dRZ0xvTDF5dkRFeTNNbktqTzhPcFBFbmNDQ2d4S3o2RUdhNnlGa1lCNkxPeFpqSzlnWDlzWjRLOUFmQ05sMHhQVmw1bXYwK1hDanhjSHloSUdQTU9sUTYxYnMrMEV4cUt0TDlNUGRUMlZMOVAzcTRaMHRVajZBZ3VBSW93WGdWNTJFclZsZG1mbzVkOVErMSsrU3V0bHAxRzBSaXlvdjlpRnFPY1JHeTBPV1N0QTdVY093Zk9keDJOOGxHWUhjSk9IYVcxUktFQXZZQkt3RmlqRGVPRmNhV1dveTdlZkEyN3dRaG04NU9YME80QVJYa2gzaThLRzZwejNHZUE5VkMvUW1rK1MxY0dxYXU3NVhrMGFrdkdOUDRSbFhzcFBNZENzSnoxL21kTHhOUUdvcnNaN29yNXB4UUd4TmRhdXhvSTFYdXNpcWhQOVV0UkhXbjdOdjBkUVhTdm1vZjdDZlkwVmRXamlRUjJ2dVJlMUg5ZXNWNytyVlZoYUNFRjlHNnQ5SXd1dCtmZEN6YjlsTlZidTQzVEpFQXo4RTlYSGhxZXNBUjREenV0d0xaTldRQ1N3SC9jZmZVN2dMNWlOa0VrRHVEczYveXZxSVpjbUpvMXlBMm8vVUt1b2ZrWTkxc1RFcEZsdVIzM1phRTVVWHdIbStZQW1VdHhGNC9PdExtQXVyV2orejhTM3hBS0xVVmNuVkFNbmdJL1I1KzBSZ1A4SCs0c252aVZKdXJVQUFBQUFTVVZPUks1Q1lJST0nO1xuZXhwb3J0IGNvbnN0IEZFRURfUElQRSA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVhvQUFBRjZDQVlBQUFBWG9KT1FBQUFBQkhOQ1NWUUlDQWdJZkFoa2lBQUFBQWx3U0ZsekFBQU94QUFBRHNRQmxTc09Hd0FBQUJsMFJWaDBVMjltZEhkaGNtVUFkM2QzTG1sdWEzTmpZWEJsTG05eVo1dnVQQm9BQUNBQVNVUkJWSGljN2QxNWZGWFZ2ZmZ4ejhsSW1FbkNIQ0JoUm9Rd2lFcVF0aktLUXEwVlVSOEVGSEhxVmJ4YWV4MmU5bkpmclczdmM5dmJZcTFDQk51SzFGWVFSQm1WeVJJbWhZSUpZQUVGd2lSam1BS1prLzM4c1JNTUdDREpXWHZ2TTN6ZnI5ZCtoU0hudHpaNjlqZnJyTDMyV2o1RUFsOFVrRkRwU0N6LzJ2U3lQMjhFMUN0L1RYMGd1dnpYVGNxL3hsVDYrd3RBVWZtdlQ1ZC9MUWJPVi9yN3MwQk8rWEVTT0ZIcDk1V1BFaVAvU2hHSCtMdytBWkZ5VFlEMlZ6amFZb2Q5b0RvTjdMM0NzUjhvOWU3VVJCVDA0cTRvb0JQUUEwZ3QvM29kZHBCSFgrVjF3YXdJT0FoOEFXd0RNc3UvZm9rK0NZaExGUFRpbEhpZ0Q5QVRPOUI3WW9kNkhTOVBLb0FVWUlkL0ZuYndad0ZiZ0ZOZW5wU0VKZ1c5bU5JS0dBRGNVdjYxTnhEaDZSa0ZwNzNBT21CdCtkY3ZBTXZUTTVLZ3A2Q1gyb2dCK2dKcDJNR2VCalR6OUl4QzF6RmdQWGJ3YndBMlk5ODBGcWsyQmIxVVZ3b3dGQmdDRE1PZTRTTHV5OE1PL2tYQUIwQzJwMmNqUVVGQkwxZFNCN3UzUHFUODZPdnQ2Y2dWN0FWV1lBZi9jdXl4ZjVGTEtPaWxzbWJBM2NBbzRIdEFuS2RuSXpXVkIzd0NmQWpNeDU3M0x5SkNJdkFvZHErd0JQdkduNDdnUDBxQWo0RkoyQStUaVVpWWFReU1CeFppei9QMk9wUjBPQi82YTRHbnNaOG1GcEVRRlF2Y2l6MldXNGozNGFQRG02TVErd2Y4UGRpenAwUWtCSFFHL2h0N21wN1hJYU1qc0k1VFFEcjJBMjBpRW1SaXNYdHN5NEV5dkE4VUhZRi9iTWErVjFNWEVRbG9QWUJYc1JmWjhqbzRkQVRuY1FwNEJiZ2VFUWtvdDJDUHU2cjNyc1Brc1JaN3FxMm1ZWXQ0SkFaNzVrd1czZ2VDanRBK01yR0hkYlFnblloTEdtSlBrenVJOXdHZ0k3eU9vOEIvWWE5TUtrRkVIOG1DUnh2Z09XQWk5dTVKWWExaHc0WWtKaVplUEJJU0VraElTS0JSbzBiRXhjVmQvSjdJeUVnaUlpSm8xTWhlbXFkT25UcFlsa1ZoWVNFQVo4K2VwYXlzakpLU0VuSnpjd0hJejgvbnpKa3o1T1RrWER4T25qekp5Wk1uT1hmdW5EZi80TUNTQzd3Si9CWTQ3UEc1U0RVbzZBTmZTK0JGN0kvT3NSNmZpeXZpNCtOSlRrNis1RWhKU1NFNU9mbGlxRWRIZTdOUFNYRng4Y1hnejg3T1p0KytmWmQ4emM3TzV2VHAwOWN1RkJvS3NLZG4vaHA3K3E0RUtBVjk0R29LUEEvOGlCQmRjeVlsSllVZVBYclFvMGNQVWxOVDZkeTVNOG5KeVJkNzM4SHE3Tm16N051M2o5MjdkNU9abWNtMmJkdll0bTBiMmRuWlhwK2FVL0tBMTREL3dkNWJWd0tNZ2o3d3hHTVAwVHhGaUF6UnhNYkcwcWRQSDFKVFUwbE5UYjBZN2cwYk52VDYxRngxOXV6Wmk2R2ZtWmxKWm1ZbVc3WnNvYWlvNk5vdkRnNjUyRk16ZjhjM0c2NUxBRkRRQjQ2R3dEUGxSMUIzYVJNVEUwbExTMlBBZ0FHa3BhVnh3dzAzVUtlT0pteFVwYUNnZ0UyYk5yRisvWHJXclZ2SCt2WHJ5Y25KOGZxMC9IVUcrSDM1a2V2eHVRZ0sra0FRQVR3RS9CSm83dkc1MUVxYk5tMFlNbVFJQXdjT3BILy8vblR0MnRYclV3cGFsbVd4YytkT05tellRRVpHQml0V3JPRFFvVU5lbjFadEhRSCtML0FXOWpNZTRoRUZ2YmR1QXFZQ04zdDlJalVSRlJYRlRUZmR4S2hSb3hneVpBaDkrdlRCNTlOYnlTbDc5KzVsNGNLRkxGcTBpSXlNaklzemhvTElGdURmZ1F5dlR5UmM2ZXIwUmpMMmphdDdQRDZQYW12WHJoMGpSb3pndHR0dVkvRGd3ZFN2SHhLM0Q0Sk9ibTR1SzFldVpPblNwU3hidG93REJ3NTRmVXJWWlFIdllrOHdDSnFURnFtTnV0Z1BuT1RoL2NNdjF6emF0bTFyVFo0ODJjckl5TERLeXNvc0NUemJ0MiszcGt5WlluWHMyTkh6OTBzMWp6enMxVlFiVlAreUVRa2VZN0FmTHZINlFydG11UC80eHorMlB2MzBVNFY3RUNrcks3TTJiTmhnUGZQTU0xWlNVcExuNzZOcUhBZUJIOWJ3R2hJSldFbkFCM2gvWVYzeFNFeE10SjUrK21sci9mcjFDdmNRVUZwYWFxMWR1OVo2NnFtbnJJU0VCTS9mWDljNDVnT3RhbnhWaVFRSUgvYWlZemw0ZnpGVmVmVHQyOWRLVDArMzh2THl2TTRtY1VoQlFZRTFaODRjYThpUUlaYlA1L1A4UFhlRjR3ejIrazBSTmIvTVJMelRFVmlKOXhmUXQ0NFdMVnBZenovL3ZQWFZWMTk1blVIaXNpKy8vTkthTW1XSzFhWk5HOC9maDFjNE1nRE56WldBRnczOEZNakgrNHZtNHVIeithemh3NGRiOCtmUHQ0cUtpcnpPRy9GWVVWR1I5ZDU3NzFuRGhnMEx4RjUrUHZiYVR0NHNaaVJ5RFQydzErMzIra0s1ZU1UR3hsb1BQZlNRdFczYk5xK3pSUUpVVmxhVzllQ0REMW94TVRHZXYxOHZPN1lDM1d0OU5Zb1k1c05lV2ZJQzNsOGNGbUExYk5qUW1qeDVzblh3NEVHdmMwU0N4TkdqUjYwcFU2Wlk4Zkh4bnI5L0t4MzUyUFB1TlhZdm5tb0dMTUw3QzhJQ3JKU1VGR3ZxMUtuVytmUG52YzROQ1ZLNXVibFdlbnE2MWFWTEY4L2Z6NVdPajlITUhQSEk5NEhqZUg4UldKMDZkYkptejU1dGxaU1VlSjBURWlKS1NrcXNXYk5tQmRLRFdNZUFPL3k2WWtWcUlBNTdLVmJQTitKdTI3YXRsWjZlYmhVWEYzdWRDeEtpU2t0THJUbHo1bGdkT25Ud091Z3JqbGxBUGIrdVlKRnI2QW44QzQvZjdFbEpTZGIwNmRPdHdzSkNyM05Bd2tSaFlhSDEybXV2V2ExYnQvWTY2QzFnQjNDOW45ZXlTSlhHNHZFTjF4WXRXbGl2dlBLS1ZWQlE0UFYxTDJFcVB6L2YrdjN2ZjI4MWI5N2M2N0EvRDl6bjkxVXRVaTRLZXhFbXo5N1VNVEV4MXVUSms2MnpaODk2ZloyTFdKWmxXZWZQbjdlbVRKbGkxYWxUeCt2QVQwZHo3c1ZQVGZINENkZVJJMGRhZS9iczhmcTZGcW5TZ1FNSHJISGp4bmtkOWhsQVM3K3ZkZ2xMQTRDdjhlak4yNjFiTjJ2WnNtVmVYOGNpMWJKcTFTb3JOVFhWeTdBL0RLUVp1TzRsakR3S0ZPTEJHelloSWNHYU9uV3Fwa3BLMENrdExiWGVldXN0TDhmdmk3RWZzQks1cW1qZ1RUeDRrL3A4UG12aXhJbldxVk9udkw1ZVJmeVNrNU5qUGZqZ2cxNnVvL01HOXIwMUthZXRCTC9SQUh1cnN4RnVOOXkrZlh1bVQ1L08wS0ZEM1c1YXhERnIxcXpoa1VjZVlmZnUzVjQwdndJWURaejFvdkZBRStuMUNRU0kxc0J5WUtDYmpVWkZSZkhrazA4eWQrNWN1blhyNW1iVElvNXIxNjRka3laTm9xU2toSTBiTjJKWmxwdk50d2RHQW90UjJLdEhqLzBRMUdMc25hRGNhN1JuVDJiT25FbS9mdjNjYkZiRUU1bVptVXlhTkluTm16ZTczZlFSWUJUd1Q3Y2JEaVRoM3FNZkNTd0JFdDFxTURvNm1sLzg0aGZNbWpXTE5tM2F1TldzaUtkYXRHakJRdzg5Ukd4c0xCa1pHWlNWbGJuVmRBUGdmdUJ6NEN1M0dnMDA0ZHlqbndSTXc4V2JOaWtwS2N5ZVBadTBOTTBDay9DMWVmTm14bzRkNi9iWWZTbjJkb1d2dWRsb29BalhIdjB2Z04vaTRqclhqenp5Q0I5ODhBRWRPblJ3cTBtUmdOU3FWU3NlZXVnaGpoOC96dGF0VzkxcU5nSzRIYnR6KzRsYmpRYUtjT3ZSKzdBRC9sbTNHbXpjdURIVHBrM2p2dnUwTElmSTVkNS8vMzBlZWVRUmNuSnkzR3oyTmVBcDdLbVlZU0djZ3Q0SC9BRjQwcTBHQnc4ZXpGdHZ2VVhyMXEzZGFsSWs2Qnc3ZG95SEhucUlwVXVYdXRuc0c4QVQyTXVOaDd4d0dicUp3bDdIZXBJYmpVVkdSdktyWC8ySzlQUjBHalpzNkVhVElrR3JmdjM2M0gvLy9VUkhSN05telJxM3BtSDJ4WjZDK1NGaDBMTVBoeDU5RFBBT2NMY2JqU1VrSlBET08rOHdiTmd3TjVvVENTbXJWNi9tdnZ2dTQvang0MjQxdVJDNEIzdkprNUFWNmtFZkM4ekIzdmJQY2IxNzkyYmV2SG1rcEtTNDBaeElTRHA0OENDalI0L21zODgrYzZ2SnBkZ2R3WHkzR25SYktPK3VIb2Y5UDlDVmtKODRjU0xyMTY5WHlJdjRxVTJiTm56eXlTZE1tRERCclNaSFlQZnM0OXhxMEcyaEd2UXh3RnpnVnFjYmlvMk5aZXJVcWJ6NTVwdlVxVlBINmVaRXdrSmNYQngvK2N0ZlNFOVBKeVlteG8wbUJ3TUxzRWNCUWs0b0R0MUVZUzlPOWtPbkcycldyQmtmZlBBQk45OThzOU5OaVlTdDlldlg4NE1mL0lBVEowNjQwZHg3MkZzVWxyclJtRnRDTGVnanNHZlhqSFc2b1k0ZE83Smt5Ukk2ZGVya2RGTWlZVy92M3IzY2NjY2Q3Tnk1MDQzbTNnWWVKSVNtWG9iUzBJMFArMEVJeDBNK0xTMk5EUnMyS09SRlhOSytmWHZXcjEvUGQ3LzdYVGVhR3dmTUlJUTZ3cUUwai81L3NOZXljTlE5OTl6RGdnVUxORDlleEdWeGNYSGNmLy85Wkdkbms1V1Y1WFJ6dllIR3dES25HM0pEcUFUOUw0QVhuVzdrcHovOUthKy8vanJSMGRwMFhzUUxVVkZSM0hYWFhSUVhGNU9Sa2VGMGN4VTMzLzdoZEVOT0M0V2cveEh3LzV4c0lDb3FpcGt6Wi9Mc3M4L2k4NFhNcHptUm9PVHorUmc4ZURCSlNVa3NXYkxFNlNkcHY0ZTlwbjFRcjJjZjdLazFBdnNSWnNlV0dvNkppZUd2Zi8wcm8wZVBkcW9KRWFtbER6LzhrREZqeGxCWTZPaURyYVhBWGRoejdZTlNNQWQ5SCt5UFZQV2RhaUEyTnBaMzMzMlhPKys4MDZrbVJNUlBTNWN1NWU2Nzd5WS8zOUVIVzNPQjcyQnZZQkowZ2pYb1d3TWJjWEQ3djNyMTZyRmd3UUtHREJuaVZCTWlZc2lhTldzWU9YSWt1Ym01VGpiek5mYTQvVUVuRzNGQ01BWjlReUFEZTY5WFJ6UnUzSmdsUzViUXYzOS9wNW9RRWNNMmJkckVpQkVqbkY3YmZnY3dnQ0RiY0R6WTV0RkhZeis1NWxqSXg4Zkg4L0hISHl2a1JZSk12Mzc5V0w1OE9VMmJObld5bWU3WVQ5Njd0Z1dwQ2NFVzlOT0JvVTRWYjlxMEtXdldyS0ZmdjM1T05TRWlEdXJkdXplclY2OTJPdXlIQTY4NzJZQnB3UlQwVHdFVG5TcmVxRkVqbGk1ZFN2ZnUzWjFxUWtSYzBMMTdkNVl2WDA1OGZMeVR6VHlDdlVOVlVBaVdNZnIrMkJ2Nk9yS01YZDI2ZFZtMmJCa0RCdzUwb3J5SWVHRGp4bzBNR3piTXlSdTB4Y0FnWUsxVERaZ1NERUhmSFB0aEJVYzJYbzJMaTJQeDRzWGNlcXZqS3hxTGlNdFdyVnJGSFhmY1FVRkJnVk5OSE1YZWx2QnJweG93SWRDSGJxS3hkNGh5Sk9Tam82T1pPM2V1UWw0a1JBMGFOSWdQUHZpQTJGakhscGx2Z2IzM1JVQ3ZpeExvU3lCTUJjWTRVVGd5TXBMWnMyZHoxMTEzT1ZGZVJBSkVodzRkdU82NjY1Zy9mejVsWlk2c1BOd0dxQWQ4N0VSeEV3STU2TWZpNEJvMmI3NzVKZzg4OElCVDVVVWtnSFRyMW8yV0xWdXljS0ZqcXhqMEIzWml6N01QT0lFYTlEMkJEM0RvNDlEUGZ2WXpubjMyV1NkS2kwaUE2dHUzTDBWRlJheGQ2OWk5MDl1dzE5NXlaU3VzbWdqRW03RjFnRTNBOVU0VXYvZmVlL25iMy82bVZTaEZ3cEJsV1l3ZlA1N1pzMmM3MWNRWHdBMkFvd3Z2MUZRZzl1aGZCVzUzb3ZEQWdRT1pQMzgrVVZGQjlWQ2JpQmppOC9rWU9YSWs2OWF0SXpzNzI0a21tbUl2MDdMVWllSzFGV2pkMmhIQVlodzRyNjVkdTdKdTNUcW5INklRa1NCdzZ0UXAwdExTMkxWcmx4UGxMZUQ3d0NJbml0ZEdJQVY5TXlBTGU5NjhVWW1KaVd6WXNJR09IVHVhTGkwaVFXcmZ2bjNjZlBQTkhEOSszSW55SjdEdk5SNTFvbmhOQmNvOGVoL3dGZzZFZkd4c0xBc1hMbFRJaThnbFVsSlNtRDkvUGpFeGpqeHczeFNZU1lCMHBnTmxqUDVwNEVrbkNrK2JOazBiaDRoSWxkcTJiVXRpWWlLTEZ5OTJvbnhuN0o3OUppZUsxMFFnQkgzRnNwL0dwMUtPR3plT2wxOSsyWFJaRVFraC9mcjE0K0RCZzJ6ZHV0V0o4b093cDF3Nk1qNVVYVjUvcklqRy9tbVhhcnJ3RFRmY1FFWkdCblhxMURGZFdrUkNUSDUrUGdNR0RIQXE3TGNDTndJbFRoU3ZEcS9INkovSGdaQ1BqNDluenB3NUNua1JxWmE0dURqZWYvOTlFaE1UblNqZkczak9pY0xWNVdXUHZqT1FpZjJBbERFUkVSRXNXYktFNGNPSG15d3JJbUZneFlvVjNIYmJiWlNXbHBvdVhRajB3bDRtd1hWZWpkRkhBUE9CRHFZTC8rcFh2K0xCQng4MFhWWkV3a0Q3OXUySmlJaGc5ZXJWcGt0SFlkK1BuR1c2Y0hWNDFhTi9BZ2UyNGhvNmRDZ2ZmZlNSbGpjUWtWb3JLeXRqMkxCaHJGeTUwb255azRBM25TaDhOVjRrWWl2c0ZkNGFteXlhbUpoSVptWW1yVnExTWxsV1JNTFE0Y09IU1UxTkpTY254M1RwczlnOSs4T21DMStORnpkalg4Tnd5QU84L3ZyckNua1JNYUoxNjliTW1ESERpZEtOZ044N1VmaHEzQjZqSHdQOHpIVFJ4eDU3ak9lZmY5NTBXUkVKWTkyNmRYTnFmbjEzN0lrb3J0MllkWFBvcGo2d0Mzdm94cGlPSFR1eWRldFc2dGV2YjdLc2lBZ1hMbHlnVDU4KzdONjkyM1RwUTBCWDRJTHB3bFZ4YytqbVJReUhmSFIwTkgvOTYxOFY4aUxpaUhyMTZ2SE9PKzhRSFczOHdmMGs0TWVtaTE2SlcwTTN5Y0JzREM5ejhQTExMM1BmZmZlWkxDa2ljb21LZTM4T1RMbThFWHU2NVRuVGhTL24xdEROWEdDMHlZS3BxYWxzMnJUSmlaKzBJaUtYS0NrcDRjWWJiM1JpdlA2dmdPT2JWN3NSOUFPQURKTnRSVVZGc1hIalJ2cjI3V3VxcElqSVZXM2F0SW4rL2Z1YmZtcldBcjRET0xhUkxUZy9kQk1CekFOYW15ejYzSFBQTVg3OGVKTWxSVVN1cW5YcjFwdzVjNGFOR3plYUxPdkRYaHBoSm5ib084THBIdjBrd09oazFKU1VGTFp0MjBhOWV2Vk1saFVSdWFhOHZEeDY5T2pCM3IxN1RaZCtFSHZ6SlVjNE9ldW1JV0IwTVhpZno4Zk1tVE1WOGlMaWlicDE2ekp0MmpRblN2OEtld3E2STV3TSttY3h2RFhnd3c4L3pLQkJnMHlXRkJHcGtXSERoakZ1M0RqVFpWdGg3N1RuQ0tlR2J1S0J2ZGlQK3hyUnJGa3pkdTdjU1pNbVRVeVZGQkdwbFpNblQ5SzFhMWZUYStHY0J0b0RaMHdXQmVkdXh2NE1HR0t5NE5TcFV4a3dZSURKa2lJaXRWSzNibDNxMWF2SGtpVkxUSmFOQTRxQVQwd1dCV2Q2OUluWXZma0dwZ3IyNnRXTHpaczNFeGtaQ0Z2Y2lvaEFhV2twdlh2M1p0dTJiU2JMbnNmdTFaOHdXZFNKTWZvWE1SanlZUGZtRmZJaUVrZ2lJeU9aT25XcTZiTDFzZTl2R21XNlI5OFMrQXFvYTZyZzZOR2ptVHQzcnFseUlpSkczWG5ublh6NDRZY21TMTdBM24zdm1LbUNwb1ArVmVCSlU4VmlZMlBadm4wN0hUdDJORlZTUk1Tb1BYdjIwTDE3ZHdvTEMwMlcvUjBHRnowek9YVFRDbmpZWUQxKy9PTWZLK1JGSktCMTZOQ0J5Wk1ubXk3N0l3eXVLR0N5Ui84S1lPeGYyNkpGQzNidjNrMkRCa2FIKzBWRWpEdDM3aHlkT25YaStQSGpKc3NhNjlXYjZ0RTNBU1lhcWdYQWl5KytxSkFYa2FEUXNHRkRKM2E1ZXdSRDI2NmE2dEcvQlB6U1VDMWF0V3JGVjE5OVJWeGNuS21TSWlLT0tpZ29vR1BIamh3K2JIVGY3LzhBZnVOdkVSTTkrbGdNM29BRitNLy8vRStGdklnRWxUcDE2dkRDQ3krWUx2czBFT052RVJNOStvbkFtd2JxQU5DdVhUdDI3OTVOVEl6Zi96WVJFVmNWRlJYUnBVc1hzck96VFpZZEQ3enRUd0VUUFhxakMvRk1tVEpGSVM4aVFTa21Kb1lYWDN6UmRObWY0R2VuM044ZS9RakEyR0lQblRwMTRvc3Z2aUFxS3NwVVNSRVJWeFVYRjlPMWExZlRhOVlQQTViWDlzWCtyaXN3SFh0ZEJpTmVmZlZWVWxOVFRaVVRFWEZkWkdRa2pSbzE0b01QUGpCWnRoa3d1N1l2OXFkSDN3UEk4dVAxbCtqUW9RTzdkdTNTbWpZaUV2UktTa3JvMkxFaisvZnZOMVhTd3M3Y0hiVjVzVDlqOUkvNThkcHZlZWFaWnhUeUloSVNvcUtpZVBwcG83Y3ZmZGp6Nm12OTR0cUlBdzVqUHlqbHQvajRlUGJ2MzAvOStvN3RwQ1VpNHFyYzNGemF0bTNMbVRQRzloRTVoYjBzUWtGTlgxamJIdjA5R0FwNWdDZWVlRUloTHlJaHBVR0RCanoybU5HQmozamdydHE4c0xZOStnemdsbHErOWhLeHNiSHMyN2VQbGkxYm1pZ25JaEl3dnY3NmExSlNVaWdxS2pKVmNqVlE0NDJ6YTlPajd3SVkyOU52N05peENua1JDVW10V3JYaS92dnZOMW55ZTBDbm1yNm9Oa0gvS0FaWHZUUjh3MEpFSktBODk5eHorSHpHSXROSExaYURyMm5ReHdMamF0cklsUXdiTm95ZVBYdWFLaWNpRW5DdXYvNTZoZ3daWXJMa0JDQzZKaStvYWREL0FHaGF3OWRjMGVPUFAyNnFsSWhJd0hyMDBVZE5sbXNCakt6SkMycjZlV0l4Y0hzTlgxT2w1czJiYy9EZ1FhS2phL1NEU1VRazZCUVhGOU8yYlZ1T0hqMXFxdVFDYWpBRHB5WTkraWFBc2M4ZkV5ZE9WTWlMU0ZpSWpvNW0zRGhqbzk1Z3J6UFdxTHJmWEpPZy95RUcxa1VHOFBsOFRKeG9kRU1xRVpHQU5tblNKSk0zWldPQjcxZjNtMnNTOUdOcWZpNVZHelJva0RiOUZwR3cwcmx6WndZT0hHaXk1TDNWL2NicUJuMGl0WmlrZnlXUFBGTHJKUnRFUklLVzRld2JodjIwN0RWVjkzUEVZOWhMRXZzdElTR0J3NGNQRXhzYmE2S2NpRWpRS0Nnb29IWHIxcHc2ZGNwVXlZbkFuNi8xVGRYdDBkL2ozN2w4NDRFSEhsRElpMGhZcWxPbkR2ZmRkNS9Ka3RVYXZxbE8wRGNGdnV2ZnVYekQ4RDlTUkNTbzNIdHZ0WWZXcTJNdzlxWWtWMVdkb1pzbmdOZjlQaDJnYmR1MlpHZG5tN3p6Yk13VFR6ekJvVU9IWEczenB6LzlLVGZkZEpPcmJZcDQ0ZE5QUCtYbGwxOTJ0YzJrcENTbVRadm1hcHZWVVZaV1JwczJiZmo2NjY5TmxYd1VtSEcxYjZqTzVxeWp6SndMakJrekppQkRIbURWcWxYczNyM2IxVFlmZnJqR1MxYUlCS1VqUjQ2d2FORWlWOXZzM0xtenErMVZWMFJFQktOSGorWVBmL2lEcVpJanVVYlFYMnZvcGc0R2gyM0dqREUyUTFORUpHZ1p6c0xCMlBQcXIraGFRZjg5b0s2Sk0wbEpTZUdHRzI0d1VVcEVKS2lscGFYUnJsMDdVK1hxY1kzOVFhNFY5TGVaT3BOQUhyWVJFWEdUeitmajdydnZObG55cWxsOXJURjZvMEVmYkpvM2IyNXNLdWpSbzBkTjdqSWpFdlJpWW1KbzBhS0ZrVnFGaFlVY08zYk1TQzIzakJremh0Lzk3bmVteXQwRy9PUktmM20xb0UvQjNrM0tiKzNhdGFOUG56NG1Tcm1xVWFOR05HalF3RWl0bkp3Y0JiMUlKZEhSMFRSdGFtYlY4OXpjM0tBTCtodHZ2SkdrcENSVHMvMnVCOW9BQjZ2Nnk2c04zWXd3MFRyQWlCSEdTb21JaEFTZno4Znc0Y05ObHJ6aUNNelZndDdZc0kyQ1hrVGsyd3huWTQyRFBnYTQxVVRMTVRFeERCcGtiRDAwRVpHUU1XVElFSlA3Y2d6aENsc01YaW5vYndEcW0yaDU0TUNCMUs5dnBKU0lTRWhwMUtnUi9mdjNOMVd1SWRDcnFyKzRVdEFQTU5YeWJiY1pHd0VTRVFrNWhqT3l5dXgyUE9nMVBpOGljbVdHTTdMSzdLNXFlcVVQTVBKWklpa3BpZTdkdTVzb0ZaSU9IVHJFdi83MUw2OVBROFJ4Ymk4WUdFeFNVMU5wMWFxVnFVWE9xdHpDcXFxZzcwZzFscjJzam1IRGhwa29FN0tlZXVvcHIwOUJSRHptOC9rWU1tUUlzMmJOTWxHdU9kQWUyRnY1RDZzYXVybnFtZ2sxY2NzdHhrcUppSVFzdzFuNXJlR2Jxb0xlMlBqOGdBSEdTb21JaEN6RFdlbGUwQ2NtSnRLcFV5Y1RwVVJFUWxxM2J0MklqNi9XUHQvVjhhMlBCNWVQMGNkamFIMmJ0TFEwclZaWlNVUkVCSkdSa1Y2ZmhrakFpSWlvN3BiVm9jL244OUcvZjM4V0wxNXNvbHczb0Fsd3V1SVBMZy82RzZqZTlvTFhwUEg1U3dYcWJqY2lFaGdHREJoZ0t1Z2pnRDdBeXNwL1VGa1BFNjJBM2FNWEVaSHFNVHhPZjBtV094TDBzYkd4OU8zYjEwUXBFWkd3MEs5ZlAySmlZa3lWY3o3b2UvZnVUWjA2ZFV5VUVoRUpDM0Z4Y2ZUcVZlVlNOYlhScy9KdktnZDlGSENkaVJaNjkrNXRvb3lJU0ZneEdQVGRnWXV6UHlvSGZSZkFTRGU4Unc5alEvMGlJbUhEWUhiR0FSMHFmbE01Nkh0KyszdHJwMmRQWTZWRVJNS0c0ZXk4V0t4eTBCdjVVZUx6K2RTakZ4R3BoWjQ5ZTVwOC91aGlFQnNQK3VUa1pCbzJiR2lpbEloSVdHbmN1REZKU1VtbXlsWFpvKzltb3JKNjh5SWl0V2N3UXk5bWVrWFFSd0p0VFZST1RVMDFVVVpFSkN3WkhLZHZSM25HVndSOWE2NndxV3hOcVVjdklsSjdCak8wRHRBQ3ZnbjZGRk9WdGFhTGlFanRkZWxpWkYzSkNzbndUZEFuRzZ1YWJLeVVpRWpZTVp5aEtXQzRSeDhmSDAralJvMU1sQklSQ1VzSkNRa21aeTVlRXZUdFRGUlViMTVFeEg4R3N6UVpEUGZvVTFLTURmV0xpSVF0ZzBGL1NZL2VTRlgxNkVWRS9HZXcwNXdNZHRCSFlVK3Y5TCtpZ2w1RXhHOEdnNzR0RUJrQkpQTHRMUVZyUlVNM0lpTCtNOWhwamdMaUk3QTNCRGVpYlZzakQ5ZUtpSVExdzZNakNSRkFVMVBWbWpWclpxcVVpRWpZYXRyVVdDd0RKRVlBQ1NZcStYdys0dU9OZlRnUUVRbGJpWW1KSnNzbFZJelIrNjFSbzBaRVJ4dFpMa2RFSkt6RnhNVFFvRUVEVStYTTllZ1RFb3lVRVJFUmpHWnFnckdnTi94UlEwUWtyQm5NVkhORE4rclJpNGlZWXpCVHpRM2RxRWN2SW1LTzZSNjlrZVVtTmVOR1JNUWNnejM2eGhGQXJJbEtXcDVZUk1RY2c1a2FheXpvWTJPTmxCRVJFZXdwbHFaS1JRQkdxaGs4S1JHUnNHZXc4NndldlloSUlESWQ5T3JSaTRnRUdBM2RpSWlFT0EzZGlJaUVPUFhvUlVSQ25NYm9SVVJDbk9tZ0Z4R1JFQllCRkprb1ZGUmtwSXlJaUFDRmhZWEdTaW5vUlVRQ2tPbWdOMUxONEVtSmlJUTlnNTNuSXZYb1JVUUNrSVp1UkVSQ25NR2dMOUxRalloSUFETFllVmFQWGtRa0VPbG1ySWhJaUROOU05WklRcDg5ZTlaRUdSRVJ3V2ltRmtZQVoweFV5c25KTVZGR1JFU0FFeWRPbUNwMU9nSTRhYUxTeVpOR3lvaUlDRVk3enljakFDUFZGUFFpSXVZWXpOUWNZMEd2b1JzUkVYTU1abXFPaG01RVJBSlFRUGJvejUwN3A3bjBJaUlHRkJRVWNPSENCVlBsVGhycjBRT2NPblhLVkNrUmtiQmxlQ2pjWEk4ZTRQang0NlpLaVlpRUxZTlRLOEYwMEI4NGNNQlVLUkdSc0xWLy8zNlQ1UzVPcnl3eFVXM2Z2bjBteW9pSWhMWHM3R3hUcFlvcGYyQ3FCRGhzb3FMaG4wSWlJbUhKWUtmNUlGQmFzVGw0dG9tSzZ0R0xpUGpQWUpidUEzdHo4SXUvOFpmQmp4c2lJbUhMWUpabXd6ZEJiNlNxZ2w1RXhIOEdzL1NTSHIyUnFxZE9uZEp5eFNJaWZzakp5ZUhjdVhPbXlwa2Z1Z0gxNmtWRS9HSDRYbWMyR083UkEremN1ZE5VS1JHUnNMTnIxeTZUNVM3cDBSL0cwTjZ4MjdadE0xRkdSQ1FzR2N6UUF1QW9mQlAwcFlDUngxcXpzckpNbEJFUkNVc0dnejRic09DYm9BZjR3a1JsOWVoRlJHb3ZNelBUVktrZEZiK29IUFJHdXVMNzkrL256QmtqMjlDS2lJU1ZVNmRPY2Zpd2tZVUtBQzcydWlPcStrTi9XSmJGOXUzYlRaUVNFUWtyaGtkRW5BdDYwRGk5aUVodEdNN09pOFVxQi8xdUlOOUVkWTNUaTRqVW5NSHN2QURzcmZoTjVhQXZ4ZEFOMmM4Ly85eEVHUkdSc0dMNFJteFp4VzhpTHZ0TEk1OGJ0bXpaUW42K2tROEhJaUpoSVQ4LzMyUW4rWklzdnp6b2pYeHVLQ29xNHAvLy9LZUpVaUlpWWVIVFR6K2xxTWpJYzZ0d1daWTdFdlFBNjlhdE0xVktSQ1RrR2M3TVMzcjBVWmY5NVJic0o2bDgvcmFpb0wvVTd0Mjd5Y3ZMOC9vMFJBSkczYnAxNmR5NXM5ZW5FVERXcjE5dnFsUVpjTWtZME9WQmZ3cjRGM0NkdnkydFg3OGV5N0x3K2Z6K21SRVN5c3JLS0MwdDlmbzBSQUpHV1ZuWnRiOHBURmlXeGNhTkcwMlYydzVjOHRUcTVVTTNBRWE2NGprNU9hWlhZUk1SQ1VrN2R1emcxS2xUcHNwOUs4TWRDM3JROEkySVNIVVl6a29GdlloSW9ER2NsZDhhN0w5OGpCN2dLK3cxakZ2NDI5cnk1Y3MxVG44VnI3NzZLb01IRC9iNk5FUWN0M0xsU3A1NjZpbXZUeU1nV1piRmloVXJUSlg3bWlwMkRLd3E2QUUyQUhmNTIrS2hRNGZZdm4wN1BYcjA4TGRVU0VwS1NxSmJ0MjVlbjRhSTQzUy83c28rLy94empodzVZcXJjMnFyK3NLcWhHekE0ZkxOczJUSlRwVVJFUXM3U3BVdE5scXN5dXgwUGVzUC9DQkdSa09KbDBHOEJ6aHRwZGQwNmNuTnpUWlFTRVFrcFo4NmNNVGwvL2l4UTVhcG9Wd3I2SW1DVmlaYUxpb3BZYmRKNUlBQUFHQ2hKUkVGVXVYS2xpVklpSWlGbCtmTGxsSlNVbUNxM0FxaXkySldDSHNEWTRMckc2VVZFdnMxd05sNngyTldDM3RqQTBkS2xTN0VzeTFRNUVaR2daMWtXSDMzMGtjbVNWd3o2SzAydkJNZ0dkZ0pkL1czOXdJRURiTjY4bVg3OSt2bGJ5bFZuejU2bG9LREFTSzNpNG1JamRVUkNSWEZ4TVNkT25EQlNxN0N3MEVnZE4yM1lzTUgwUnVDSHJ2U1hWd3Q2c0g5QytCMzBBSFBuemcyNm9EOTI3SmpYcHlBU3NvcUtpamh3NElEWHArR1pPWFBtbUN4MzFSR1lxdzNkWFBQRk5mSDN2Lzlkd3pjaUl0Z3JkNzczM25zbVMxNTFzUDlhUWI4R01MS0krc0dEQi9uMDAwOU5sQklSQ1dwcjE2NDFPV3h6Z1NyV3Q2bnNXa0ZmQUh4aTZtd01mMVFSRVFsS2hyTndCWERWbXhUWEdxTUhXQWpjYnVKczVzNmR5MjkvKzFzaUlxNzE4OFY5Z3dZTmNuMjNtNVl0VzdyYW5vaFhXclpzeWNpUkkxMXRNeWtweWRYMnFxdTB0SlI1OCthWkxMbm9XdDlRbldVbEU0RWpWTytId2pXdFhidVdBUU1HbUNnbEloSjBWcTllemFCQmcweVZLd1phQWpsWCs2YnFkSzFQQXF0Tm5CSEF1KysrYTZxVWlFalFNWnlCSzdoR3lFUDFOd0dmQk16dzYzVEtKU1FrY09qUUllclVxV09pbkloSTBNalB6NmQxNjlhY1BuM2FWTWtIZ2JldTlVM1ZIU3lmaDczK2pkOXljbkpZc0dDQmlWSWlJa0ZsN3R5NUprTytDUGl3T3Q5WTNhQS9EUmhibVd6R0RDTWZEa1JFZ29yaDdGdUduYzNYVkpQcEw4Ym1BNjFldlpvdnYvelNWRGtSa1lDM2E5Y3UwM3ZEVmp1VGF4TDBDN2pHWE0zcXNpeUxQLzNwVHlaS2lZZ0VoUmt6WnBoY0hhQUFlK3A3dGRSMDErNkZnSkhKc00yYk4rZmd3WU5FUjBlYktDY2lFckNLaW9wbzA2WU54NDhmTjFWeVBuQjNkYis1cGs4dXphcmg5MS9Sc1dQSFdMVG9tdlA4UlVTQzNvSUZDMHlHUE1EYk5mbm1tZ2I5QjRDeHM1MCtmYnFwVWlJaUFldU5OOTR3V2U0b3NMZ21MNmhwMEJkaHNGZi84Y2NmazVsWjVSYUhJaUloSVNzcmkxV3JqT3pNV3VIUDJFL0VWbHR0RnAyWkFSaTdvekIxNmxSVHBVUkVBczV2ZnZNYmt6ZGhMYURHTTFscWVqTzJ3aitBNzlUeXRaZUlqbzVtNzk2OUFic0FrWWhJYlIwK2ZKajI3ZHRUVkdUa2VWT0FWY0RnbXI2b3RzdElHcHYxWDF4Y3pHdXZ2V2FxbkloSXdKZzZkYXJKa0lkYVptOXRlL1IxZ01OQWZDMWZmNGttVFpwdzRNQUI2dGV2YjZLY2lJam5jbk56YWRPbURXZlBualZWTWdkSXdwNURYeU8xN2RFWEFMTnIrZHB2T1gzNk5HKysrYWFwY2lJaW5rdFBUemNaOG1CUGhLbHh5RVB0ZS9RQTNiRjNIdmVueGtYSnljbDgrZVdYUkVVWldmWmVSTVF6eGNYRmRPelkwZVRtNXhad1BmQkZiVjdzejFaUE80RGxmcnorRXRuWjJienp6anVteW9tSWVPYnR0OTgyR2ZKZ0wyQldxNUFILzN2anc0Q1AvS3h4VVhKeU1ydDI3U0ltSnNaVVNSRVJWeFVYRjlPMWExZjI3dDFyc3V3US9GaEIyTi9OV3o4R1B2ZXp4a1haMmRuTW1tWHNlU3dSRWRlOStlYWJwa00rQzN0YVphMlpHRitmQVB6RlFCMEEyclp0eSs3ZHU0bU5qVFZWVWtURUZZV0ZoWFRxMUltREJ3K2FMRHNXOEd0YzI5OGVQZVVuWU94ZmRlREFBYzNBRVpHZ2xKNmVianJrRHdGei9TMWlaTVlNOER6dzM0WnEwYkpsUy9iczJVTmNYSnlwa2lJaWppb29LS0JqeDQ0Y1BuellaTmtmQTcvenQ0aUpIajNBTk9DY29Wb2NPWEtFOVBSMFUrVkVSQnozeHovKzBYVElud09NREcrWTZ0RURUQVdlTmxXc1diTm1mUG5sbHpSczJOQlVTUkVSUjV3OWU1Wk9uVHB4NHNRSmsyVi9BL3lIaVVLUkpvcVV5d0orQkJqWk11ckNoUXVVbFpVeGRPaFFFK1ZFUkJ6ejBrc3ZzWEpscldjL1ZpVWYrRDlBcm9saUpudjBBSzhBazAwVmk0bUpZZnYyN1hUcTFNbFVTUkVSbzc3NjZpdXV2LzU2Q2d1TmJLbGR3Vmh2SHN5TjBWZjROWkJucWxoUlVSSC84Ui9HL3EwaUlzWTkvZlRUcGtQK1BQQmJrd1ZOQi8xUjRIV1RCUmNzV01ESEgzOXNzcVNJaUJFclZxeGd5WklscHN1K2dzRXRXOEg4MEExQUlyQVhhR0NxNEhYWFhVZG1acVlXUEJPUmdGRlNVa0t2WHIzWXNXT0h5YkpuZ2ZiQUtaTkZUZmZvQVU0Q3I1b3MrTVVYWHpCamhyRzlUa1JFL1BiSFAvN1JkTWdEL0I3RElRL085T2dCbW1EMzZodWJLcGlZbU1qT25UdEpTRWd3VlZKRXBGYU9IejlPMTY1ZE9YMzZ0TW15cDdCNzgwWVhzUWRuZXZRQXA3Ri9NaGx6OHVSSm5udnVPWk1sUlVScTVabG5uakVkOG1EZmdEVWU4dUJjang3c01mcmRRQXRUQlgwK0h4OTk5SkhtMW91SVo1WXNXY0lkZDl4aHV1eGhvQXR3d1hSaGNEYm9BUjRDL21TeVlISnlNdHUyYmRQK3NpTGl1Z3NYTHRDalJ3LzI3ZHRudXZRNERHN1Blam1UVDhaV0pRdTRIV2h0cXVDWk0yY29MaTVtMkxCaHBrcUtpRlRMVDM3eUV6NzZ5TmhlU3hVMkF2OXV1bWhsVHZmb0Fmb0Q2MHkyRlJrWnljYU5HN25oaGh0TWxSUVJ1YXJQUHZ1TXRMUTBTa3RMVFphMXNEUHlVNU5GTCtmVXpkaktOZ0J6VEJZc0xTM2w0WWNmcHJpNDJHUlpFWkVxbFpTVThOaGpqNWtPZVlDM2NUamt3Zm1obXdxZkFZOWphTUV6Z0dQSGpoRVRFOE4zdnZNZFV5VkZSS3IwaTEvOGdyLy8vZStteTE0QTdzTFF3bVZYNDhiUVRZV2ZBejh6V1RBcUtvcTFhOWR5MDAwM21Td3JJbkxSNXMyYlNVdExjMklFNGFmQUwwMFhyWXFiUVI4SDdBVGFtaXphb1VNSHRtN2RTb01HeGxaY0VCRUI0UHo1OC9UdDI1ZmR1M2ViTG4wUTZJckJSU0N2eHEyaEc0QVM3UDBQeDVnc2V2cjBhVTZjT01IM3YvOTlrMlZGUkhqMDBVZFp0V3FWRTZVbkFOdWRLRndWTjN2MEZlWmpqMHNaOWU2Nzd6Sm1qTkdmSVNJU3h1Yk5tOGZvMGFPZEtQMHVjSjhUaGEvRWk2QnZDZXpBWGcvSG1DWk5tdkQ1NTUvVHRxM1JrU0VSQ1VPSERoMGlOVFdWVTZlTXJ5OTJGcmdPK05wMDRhdHhZM3JsNVk0QUw1b3VldnIwYWNhUEgwOVpXWm5wMGlJU1Jzckt5cGd3WVlJVElRL3dEQzZIUExnN1JsL1pGdUI3UUxMSm92djM3OWVVU3hIeHk4OS8vblArL09jL08xRjZGZkNzRTRXdnhZdWhtd3FkZ0V6czJUakdSRVJFc0dqUklrYU1HR0d5cklpRWdlWExsek5peEFnbkhvektCM29DWDVrdVhCMWVETjFVK0JKNDJYVFJzckl5eG80ZHk5NjllMDJYRnBFUWxwMmR6ZjMzMys5RXlBUDhGeDZGUEhqYm93ZjdTZG5QZ0Y2bUMvZnAwNGUxYTljU0YyZjBBNE9JaEtDOHZEelMwdExJek14MG92d1c0Q2JzS2VhZThMSkhEMUFNak1YK1dHUFVsaTFiZVBUUlIwMlhGWkVROUcvLzltOU9oWHdCOENBZWhqeDRkek8yc2hQQU9jRDRvSHBXVmhZdFdyVFFLcGNpY2tXdnZ2b3F2LzcxcjUwcVB4bFk3RlR4NnZKNjZLYUNEMWlFdlhhOVVURXhNYXhldlpxMHREVFRwVVVreUsxZHU1WkJnd1k1dFJMdVF1Qk83S1dJUFJVb1FRL1FGSHVqRW1OYkQxWklURXhrL2ZyMWRPclV5WFJwRVFsU2UvZnVwWC8vL2h3L2Z0eUo4c2V4WjlrY2M2SjRUWGs5UmwvWkNleXRCNDMvOUR0NThpUWpSb3pneElrVHBrdUxTQkRLeWNsaHhJZ1JUb1c4QlV3a1FFSWVBaXZvQVpZQnJ6dFJlTStlUGR4OTk5MFVGaFk2VVY1RWdrUkJRUUYzM25tbkV5dFNWdmdEQVRBdVgxbWdCVDNBYzhBMkp3cG5aR1F3ZnZ4NExNdnpJVE1SOFlCbFdVeWFOSWwxNjlZNTFjUU9IRmppeFYrQk1Pdm1jaVZBQnZZeW5qR21pKy9Zc1lQaTRtSUdEeDVzdXJTSUJMZ1hYbmlCNmRPbk8xVStGeGlHdlo1WFFBbkVvQWY3UnNaZXdKRTFRak15TWtoS1NxSlBuejVPbEJlUkFEUjkrblJlZXVrbHA4cGJ3QVBBR3FjYThFZWdCajNZaS9JM3d0NGgzYmdsUzViUXVYTm5yci8rZWlmS2kwZ0FtVDkvUGhNblRuUnlkZHZmQXE4NFZkeGZnVFM5c2lwUndBcmd1MDRVajQ2T1p2NzgrWXdjT2RLSjhpSVNBRDc2NkNQdXZQTk9KeWRpck1ZZXN2SDA2ZGVyQ2ZTZ0IyZ09iQWFTbkNnZUV4UERoeDkreVBEaHc1MG9MeUllV3JseUpTTkhqcVNnb01DcEpnNENOMkFQTndlc1lBaDZzQmNFK2djUTYwVHh1blhyc216Wk1nWU9IT2hFZVJIeHdNYU5HeGs2ZENqbno1OTNxb2xpNEZiQXNTazhwZ1RpOU1xcWZJcTlNNHNqOHZMeUdEVnFGUC84NXorZGFrSkVYSlNabWNudHQ5L3VaTWdEUEVrUWhEd0VUNCsrd2h2QUkwNFZiOXEwS2F0WHI2Wjc5KzVPTlNFaUR0dStmVHUzM25vckowK2VkTEtaNmNBVFRqWmdVckFGZlNTd0FIRHM3bW1USmsxWXRtd1pOOTU0bzFOTmlJaER0bXpad3ZEaHc1ME8rV1hBS0FMNDV1dmxnaTNvQVJwZ1AxQ1Y2bFFEalJvMVlzbVNKVnJ4VWlTSWZQYlpaNHdZTWNLcFRiMHJiQWR1QWM0NjJZaHB3VEpHWDFrdTluTEdCNTFxNE96WnN3d2JOb3pseTVjNzFZU0lHUFRKSjU4d1pNZ1FwMFArYSt6c0NhcVFoK0FNZW5EaFAvaUZDeGNZTldvVUN4WXNjS29KRVRGZzhlTEZqQmd4Z3R6Y1hDZWJjYnlENmFSZ0RYcXdQMExkaDRQalpJV0ZoWXdaTTRhNWMrYzYxWVNJK09IZGQ5L2xycnZ1Y25LZVBOZ1pjdy9neUY2RGJnamtKUkNxNHl2c2Rld2R1emxiVmxiRy9QbnphZG15SlgzNzluV3FHUkdwb2ZUMGRCNSsrR0ZLU2h5L0ovb1lFTlM5dldBUGVyQ2ZtdlVCMzNPcUFjdXlXTGh3SVVWRlJRd2FOQWlmTHhqdllZdUVCc3V5ZU9HRkYzanh4UmZkV0hMOFA0R3BUamZpdEZBSWVvQlBnTHJBQUNjYldidDJMZHUzYjJmVXFGRkVSMGM3MlpTSVZLR3dzSkFKRXlZNHVkUndaVk1CeDVhN2RGTW9kVTE5d0d1NDhCRER6VGZmekljZmZralRwazJkYmtwRXlwMDZkWXE3N3JxTE5XdGNXUW40ZGVEZjNHaklEYUVVOUdEL2UyWUFEenZkVUljT0hWaThlREZkdW5SeHVpbVJzTGRueng3dXVPTU9kdTNhNVVaemJ3TVBBbzZ0YWV5MllKNTFVeFVMZUJ5WTUzUkRlL2JzWWVEQWdVNXVTU1lpMkVPbU45OThzMXNoL3g3d0VDRVU4aEE2WS9TVmxRSHZBNzJCems0MmxKZVh4NnhaczRpTmplV1dXMjV4c2ltUnNQVEdHMjl3MzMzM09UMUh2c0xIMk5Nb2k5MW96RTJoTm5SVFdSeXdFSEJsYzlnSkV5WXdiZG8wNHVMaTNHaE9KS1RsNWVYeCtPT1A4L2JiYjd2VjVFcnM5V3Z5M1dyUVRhRWM5R0N2WC85MzRBZHVOTmFyVnkvbXpadEgrL2J0M1doT0pDUWRPSENBdSsrK204MmJON3ZWNUJMcy9hbERNdVFoOU1ib0wxY0kzSXM5N3VhNHp6Ly9uSDc5K3JGczJUSTNtaE1KT1V1WExxVlhyMTV1aHZ3SHdBOEo0WkNIMEJ5anYxd3BNQjlJeHNFVkx5dms1K2Z6dDcvOWpjaklTRzY1NVJZOVhDVlNEV1ZsWmZ6ODV6L25zY2NlSXovZnRjeDlDeGhMQ0k3Slh5NmNVc2lIL1FERVpMY2F2UFhXVzVrMWF4WkpTWTVzZHlzU0VnNGVQTWo0OGVQNTVKTlAzR3gyT3ZZOCtaQ2FYWE1sNGRDanIrd2pvQjdneWtMejJkblovT2xQZjZKZHUzYjA2TkhEalNaRmdzcThlZk80NDQ0NytOZS8vdVZtcy84RC9EdjJkT3l3RUc1QkQxQ3h5UHozM0dpc3NMQ1FlZlBtY2VqUUlRWU5Ha1JNVEl3YnpZb0V0TnpjWEI1Ly9IRmVldWtsTjRkcXdGNjc1bWR1TmhnSXdtbm81bklUc1QrK3ViWm9UWEp5TXJObnoyYkFBRWVYNUJFSmFKczJiV0xzMkxGOCtlV1hialpiZ2oxc084M05SZ05GT1Bib0syekZYdm55KzlqVE1CMTM1c3daM243N2JYdytILzM3OXljeU1wei84MHU0S1M0dTVwZS8vQ1VUSmt4d2VrL1h5NTNEbm1MOXJwdU5CcEp3N3RGWDZBRXNBdHE2Mm1pUEhzeVlNWU9iYnJySnpXWkZQTEYxNjFZbVRackVsaTFiM0c3NmErejlLcmE2M1hBZ0NmVjU5Tld4RGVnUHVQb08zTFp0RzJscGFUejIyR09jUDMvZXphWkZYSk9YbDhjTEw3eEF2Mzc5dkFqNWJjRE5oSG5JeTZYcVkvZnNMYmVQNU9Sa2E5bXlaWlpJS0ZteVpJblZybDA3MTYrbjh1TWpvS0dSWkpDUUV3VzhnVGR2VEd2Y3VISFdpUk1udkw0K1JmeHkvUGh4YSt6WXNWNEZ2SVY5d3pYS1FCNkVETjBOdkZRWjlrSm9SNERodVB6Zkp5c3JpNWt6WndKdzQ0MDM2bWF0QkpXU2toSm16cHpKNk5HajJiaHhveGVuVUFnOGh6MTlNaXdlaEJMLzlRV3k4YWhYMHFWTEYydng0c1ZlZDg1RXFtWEZpaFZXang0OXZPekZIOEllanhlcHNVUmdCZDY5ZWEwaFE0WllPM2JzOFBvNkZxblM3dDI3clh2dXVjZkxnTGVBZndBdC9MN2FKYXhGQWYrTi9WSFFremR5ZEhTME5YbnlaT3ZNbVROZVg5Y2lsbVZaVm01dXJqVmx5aFFyTmpiVzY1QlB4OFdISGlYMDNRdms0dUdidW1uVHB0Yi8vdS8vV25sNWVWNWY1eEttTGx5NFlQM21ONyt4RWhNVHZRNzRjOWhyeUlzWTF4M1lqcmR2Y0t0bHk1YldxNisrYWhVVUZIaDkzVXVZeU0vUHQ2Wk9uV3ExYU5IQzY0QzNnQ3lnbTUvWHNzaFYxY0VleWluRjR6ZDhtelp0cktsVHB5cnd4VEZGUlVWV2VucTZsWlNVNUhXNFc5akRwK2xBWGIrdVlKRWF1QjA0aXZkdmZxdDkrL2JXWC83eUY2dTR1TmpyWEpBUVVWUlVaTTJjT2RQTEI1NHVQNDRBdC9sMXhZclVVbFBnUTd5L0NDeXdoM1NtVEpsaW5UNTkydXVja0NCMTd0dzVhK3JVcVZiYnRtMDlmejlYT3BZQkxmMjRUa1dNR0ErY3gvc0x3Z0tzQmcwYVdKTW5UN1lPSERqZ2RXNUlrRGh5NUlnMVpjb1VxMG1USnA2L2Z5c2QrY0RUYVBGRkNTRFhZUytNNXZYRmNmR0lpWW14Smt5WVlHVmxaWG1kSXhLZ3RtN2RhajN3d0FOV2RIUzA1Ky9YeTQ3TlFOZGFYNDBpRG9vQ1hnRHk4UDVDdVhqNGZENXI2TkNoMW52dnZXY1ZGUlY1blMzaXNjTENRbXZPbkRuVzRNR0RQWDl2Vm5GY0FINkMxcXFSSU5BZWU4dENyeSthYngxTm1qU3hIbjMwVVd2YnRtMWU1NDI0Yk5ldVhkYnp6ejl2Tld2V3pQUDM0UldPZndCZGFuWEZpWGpFaHoxMmZ4THZMNkFxajc1OSsxcnA2ZW5XaFFzWHZNNGdjVWhCUVlFMVo4NGNhOGlRSVpiUDUvUDhQWGVGNHpUd0tCcUxseURXRW5nUDd5K21LeDVObWpTeGZ2U2pIMW4vK01jL3JOTFNVcSt6U2Z4VVdscHFyVjY5Mm5yODhjZXR4bzBiZS83K3VzYnhkNkI1amE4cWtRRDFBK0FBM2w5WVZ6MWF0V3BsVFo0ODJWcTdkcTFWVmxibWRXWkpOWldXbGxvWkdSbldrMDgrYWJWczJkTHo5MUUxam4zQXFCcGVReUpCSVE1NEhudWREcTh2dEdzZVNVbEoxdVRKazYyTWpBeUZmb0Rhdm4yN05XWEtGS3Q5Ky9hZXYxK3FlVndBL3F2OFdoQ1hhRXpNRzYyQlh3TVBFQ1QvRDVvMWE4Ync0Y01aTldvVVE0Y09wWEhqeGw2ZlVsaTZjT0VDcTFhdFl0R2lSU3hkdXBTREJ3OTZmVXJWWldFUFlUNkgvY2xXWEJRVUlSUEMrZ0ZUZ1RTdlQ2UW1JaU1qNmRXckZ5TkhqbVRVcUZIMDZkTUhuMDl2SmFmczJMR0RSWXNXc1dMRkN0YXNXVU5SVVpIWHAxUlRtNEYvQjlaNWZTTGhTbGVuOXlLQWNkZzkvS0I4ekx0bHk1WU1IVHFVVzI2NWhiUzBOSzY3N2pvRmZ5MlZsWlh4eFJkZnNHN2RPdGF0VzhmeTVjczVldlNvMTZkVlc0ZUJGNEhaMkQxNjhZaXV4c0JSSDd2WDh5elF4T056OFV0OGZEejkrL2Rud0lBQkRCZ3dnSDc5K2hFWHB5SFpxdVRsNWJGcDA2YUx3YjVod3daT256N3Q5V241NnhUd3Y4QXIyR1B5NGpFRmZlQnBERHlESGZvTlBUNFhJNktqbytuVHB3K3BxYW4wN05tVEhqMTYwTE5uejdBYjV6OTkralJaV1ZsczI3YU5yS3dzTWpNejJicDFLOFhGeFY2Zm1pbG5zWWNpZjEvK2F3a1FDdnJBbFlCOTQrb3BvSjdINStLSXRtM2JjdjMxMTlPelowOTY5dXhKNTg2ZFNVbEpJVDQrM3V0VDgwdE9UZzc3OXUxajkrN2RaR1ZsWFF6M1E0Y09lWDFxVGprUHZBcjhGcnMzTHdGR1FSLzRtbUd2bi9NNFlUSWxyV0hEaGlRbko1T1Nrbkx4YTBwS0N1M2F0YU5wMDZZa0pDUVFHeHZyeWJrVkZoYVNrNVBEaVJNbnlNN09KanM3bTMzNzlyRnYzNzZMdjg3TnpmWGszRHlRQjB3RC9oOXd3dU56a2F0UTBBZVBWdGpqOTQ4UUlrTTYvcWhmdno0SkNRazBiZHFVeE1SRUVoSVNTRWhJb0g3OStqUnNhUC9ucVZ1MzdzVWZDRTJhMkxjOUtuNWZXRmdJY0hFOHZMQ3drTHk4UEFET25UdkgrZlBueWNuSklTY25oNU1uVDNMaXhBbHljbkk0Zi82OHEvL09BSFVPZUFQNEhmYUdJQ0ppV0FQc05icjM0LzNETHpyQzZ6aUMvYkJUVUU4V0VBa20wY0E5d0tkNEh3QTZRdnY0SEh1QnZtaEV4RE8zQUF1eE4wLzJPaFIwaE02eEZuczlHZzN4aWdTUTY3Q250K1hnZlVqb0NNN2pKUGIweU9zUWtZQVdpejJzc3h6MThuVlU3OWlNdlNaOFhVUWs2SFRFdm9FVzhFc2s2M0Q5T0FMOE4vWjdSRVJDUURUd1ErQjlJQi92UTBhSE4wYytNQjk3ZndUdHl5b1N3dXBpRCswc0JBcnhQbngwT0h1VVlBL2pqVWZQWUlpRXBTYkFROEF5b0JqdlEwbUhtYU1JV0FJOGlMMStrb1F4VFp1U3loS3doM2RHQVlNSTBUVjJRdGg1WUNXd0NIdDRSdXZPQ0tDZ2x5dUxBbTRHUmdKRGdEN28vUktJOWdJcnNNUDlZK3loT0pGTDZNS1Y2bW9PRE1jTy9xRm9PTUFyRjRBTjJNSCtQdHFXVDZwQlFTKzFFWVhkdzA4REJwUWZRYms3VmhENEduc0x2blhBZW1BcjlzMVZrV3BUMElzcHJiQUQvNWJ5cjcyeHQwbVVtdG1MSGVwcnk3OStnWDF6VmFUV0ZQVGlsTWJZdmY0ZTVVY3E5bVAxZXZMU2xnZnNBTEtBYmVYSEZ1Q01seWNsb1VsQkwyNktCTnBqaDM3RkQ0RHJnR1RzWlJ0Q1VTR1FqZDB6cndqMFRHQVA5dklVSW81VDBFdWdhSUw5UStEeW94V1FRdUR1cmxXTXZSRFkxOWpETHBjZis0RlN6ODVPQkFXOUJJY0lJQkY3bnYvbFI5UHlyNG5ZOC80clpnUFY0WnNmRG8zS2EwUUQ5Y3YvN0R4MlNKZnh6VWJXK1VCQithL1BsSDlQVHZseG90S3ZjN0REdmVMWDZwbExRUHYvRlNINSsrU1M5TVlBQUFBQVNVVk9SSzVDWUlJPSc7IiwiLyoqXHJcbiAqIE1hcHMgaXMgdGhlIHNldCBvZiB0aGUgbWFwIGZ1bmN0aW9uc1xyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXBzXHJcbiAqIEBwcm9wZXJ0eSB7W2lkOiBzdHJpbmddOiBOb2RlfSBub2RlTWFwIC0gbWFwIGlkIHRvIFtOb2RlXXtAbGluayBOb2RlfSAtIFJldHVybnMgTm9kZSBieSBpZCBhbmQgKG9wdGlvbmFsKSByb2xlLlxyXG4gKiBAcHJvcGVydHkge1tpZDogc3RyaW5nXTogTGlua30gbGlua01hcCAtIG1hcCBpZCB0byAgW0xpbmtde0BsaW5rIExpbmt9IC0gUmV0dXJucyBMaW5rIGJ5IGlkIGFuZCAob3B0aW9uYWwpIHJvbGUuXHJcbiAqIEBwcm9wZXJ0eSB7W2lkOiBzdHJpbmddOiBMaW5rfSBzb3VyY2VNYXAgLSBtYXAgaWQgdG8gIFtMaW5rXXtAbGluayBMaW5rfVtdIC0gUmV0dXJucyBhbGwgaW5jb21pbmcgbGlua3MgZm9yIHRoZSBub2RlIHdpdGggc3BlY2lmaWVkIGlkIChmaWx0ZXJzIGJ5IHJvbGUpLlxyXG4gKiBAcHJvcGVydHkge1tpZDogc3RyaW5nXTogTGlua30gdGFyZ2V0TWFwIC0gbWFwIGlkIHRvICBbTGlua117QGxpbmsgTGlua31bXSAtIFJldHVybnMgYWxsIG91dGdvaW5nIGxpbmtzIGZvciB0aGUgbm9kZSB3aXRoIHNwZWNpZmllZCBpZCAoZmlsdGVycyBieSByb2xlKS5cclxuKi9cclxuXHJcbi8qKlxyXG4gKiBFbmQgZWxlbWVudHMgb2YgdGhlIGdyYXBoLCB3aGljaCB3ZXJlIGNyZWF0ZWQgZnJvbSB7QGxpbmsgU2VydmVyRGF0YX0uXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdyYXBoRGF0YVxyXG4gKiBAcHJvcGVydHkge0xpbmtbXX0gbGlua3MgLSBMaXN0IG9mIExpbmtzIG9mIHRoZSBncmFwaFxyXG4gKiBAcHJvcGVydHkge05vZGVbXX0gbm9kZXMgLSBMaXN0IG9mIE5vZGVzIG9mIHRoZSBncmFwaFxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIERhdGFDb250YWluZXIgLSBhbiBvYmplY3Qgd2hpY2ggaXMgYSBkYXRhIG1vZGVsIG9mIHRoZSBMaW5lZ2VHcmFtLiBJdCBzdG9yZXMgYW5kIG9yZ2luaXplc1xyXG4gKiBkYXRhIGZvciB0aGUgdmlld3MgYW5kIGFsc28gcHJvdmlkZXMgc2V0IG9mIG1hcHMgKGRpY3Rpb25hcmllcykgZm9yIGxpbmtzIGFuZCBub2RlcyBvZiB0aGUgZ3JhcGguXHJcbiAqIFlvdSBjYW4gZ2V0IHRoaXMgbW9kZWwgdXNpbmcgYSBMaW5lYUdyYW0gbWV0aG9kIHdoaWNoIGlzIGNhbGxlZCAnZ2V0R3JhcGhNb2RlbCcuXHJcbiAqIERhdGFDb250YWluZXIgaW1wbGVtZW50cyBzZXBhcmF0aW9uIGFuZCBmaWx0cmF0aW9uIG1lY2hhbmlzbXMsIGluIG90aGVyIHdvcmRzLFxyXG4gKiB5b3UgY2FuIHJldHVybiBkaWZmZXJlbnQgZGF0YSBmb3IgZGlmZmVyZW50IHJvbGVzLlxyXG4gKiBAY2xhc3NcclxuICogQHBhcmFtIHtHcmFwaERhdGF9IGRhdGEgLSBSYXcgZGF0YSAtIG1vZGVscyBmb3IgbGlua3MgYW5kIG5vZGVzIG9mIHRoZSBncmFwaC5cclxuICogQHBhcmFtIHtQYXJhbWV0ZXJzfSBwYXJhbWV0ZXJzIC0gUGFyYW1ldGVycyBzZXRcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7TWFwc30gbWFwcyAtIFNldCBvZiB0aGUgbWFwIGZ1bmN0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIERhdGFDb250YWluZXIgKGRhdGEsIHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIGlmICghZGF0YSkgZGF0YSA9IHt9O1xyXG4gICAgaWYgKCFkYXRhLm5vZGVzKSBkYXRhLm5vZGVzID0gW107XHJcbiAgICBpZiAoIWRhdGEubGlua3MpIGRhdGEubGlua3MgPSBbXTtcclxuXHJcbiAgICBzZWxmLm5vZGVzID0gZGF0YS5ub2RlcztcclxuICAgIHNlbGYubGlua3MgPSBkYXRhLmxpbmtzO1xyXG4gICAgc2VsZi5tYXBzID0geyBzb3VyY2VNYXA6IHt9LCB0YXJnZXRNYXA6IHt9LCBub2RlTWFwOiB7fSwgbGlua01hcDoge30sIGlkTWFwOiB7fSB9O1xyXG4gICAgc2VsZi56b25lcyA9IFtdO1xyXG4gICAgXHJcbiAgICBjb25zdCBfem9uZVNpemUgPSBwYXJhbWV0ZXJzLmRhdGFab25lU2l6ZTtcclxuICAgIGNvbnN0IF9lbGVtZW50U2l6ZSA9IHBhcmFtZXRlcnMuZWxlbWVudFNpemU7XHJcbiAgICBjb25zdCBfem9uZXNJbkdyb3VwID0gcGFyYW1ldGVycy56b25lc0luR3JvdXA7XHJcblxyXG4gICAgLy8gSWYgc29tZSBub2RlIGRvbnQgaGl0IGFueSByZWFsIHpvbmUgaXQgd2lsbCBoaXQgdGhpcyBvbmUuXHJcbiAgICBjb25zdCBfZmFrZVpvbmUgPSBuZXcgTm9kZXNab25lKG51bGwsIHtcclxuICAgICAgICB4OiAwLFxyXG4gICAgICAgIHk6IDAsXHJcbiAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgaGVpZ2h0OiAwLFxyXG4gICAgICAgIGVsZW1lbnRTaXplOiAwLFxyXG4gICAgICAgIGZha2Vab25lOiB0cnVlLFxyXG4gICAgfSk7XHJcbiAgICBpZiAoX2VsZW1lbnRTaXplLndpZHRoID49IF96b25lU2l6ZS53aWR0aCB8fCBfZWxlbWVudFNpemUuaGVpZ2h0ID49IF96b25lU2l6ZS5oZWlnaHQpIHtcclxuICAgICAgICBfem9uZVNpemUud2lkdGggPSBfZWxlbWVudFNpemUud2lkdGggKiAyMDtcclxuICAgICAgICBfem9uZVNpemUuaGVpZ2h0ID0gX2VsZW1lbnRTaXplLmhlaWdodCAqIDIwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBub2RlcyBhbmQgbGlua3Mgd2hpY2ggYXJlIGxpZSBuZWFyIHRoZSBwb2ludFxyXG4gICAgICogQHBhcmFtIHtQb2ludFtdfSBwb2ludHMgLSBBcnJheSBvZiBwb2ludHNcclxuICAgICAqIEByZXR1cm4ge0dyYXBoRGF0YX0gLSBOb2RlcyBhbmQgTGlua3NcclxuICAgICAqIEBtZW1iZXJvZiBEYXRhQ29udGFpbmVyXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRFbGVtZW50c05lYXJUaGVQb2ludHMgPSBmdW5jdGlvbiAocG9pbnRzKSB7XHJcbiAgICAgICAgY29uc3Qgc3VpdGFibGVab25lcyA9IF96b25lc0ZvclBvaW50cyAocG9pbnRzKTtcclxuICAgICAgICBjb25zdCByZXN1bHROb2RlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdExpbmtzID0gW107XHJcblxyXG4gICAgICAgIHN1aXRhYmxlWm9uZXMuZm9yRWFjaCh6ID0+IHtcclxuICAgICAgICAgICAgei5yZWxhdGVkTm9kZXMuZm9yRWFjaChuID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHROb2Rlcy5pbmRleE9mKG4pID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE5vZGVzLnB1c2gobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB6Lm5vZGVzLmZvckVhY2gobiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Tm9kZXMuaW5kZXhPZihuKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHROb2Rlcy5wdXNoKG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgei5saW5rcy5mb3JFYWNoKGwgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdExpbmtzLmluZGV4T2YobCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0TGlua3MucHVzaChsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5vZGVzOiByZXN1bHROb2RlcyxcclxuICAgICAgICAgICAgbGlua3M6IHJlc3VsdExpbmtzLFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVjdGFuZ2xlXHJcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBSZWN0YW5nbGVcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IC0gUG9zaXRpb24gYnkgeCBheGlzXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geSAtIFBvc2l0aW9uIGJ5IHkgYXhpc1xyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBub2RlcyBhbmQgbGlua3Mgd2hpY2ggYXJlIGxpZSBpbnRvIHRoZSByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gSGl0IHJlY3RhbmdsZVxyXG4gICAgICogQHJldHVybiB7R3JhcGhEYXRhfSAtIE5vZGVzIGFuZCBMaW5rc1xyXG4gICAgICogQG1lbWJlcm9mIERhdGFDb250YWluZXJcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmdldEVsZW1lbnRzRm9yUmVjdGFuZ2xlID0gZnVuY3Rpb24gKHJlY3QpIHtcclxuXHJcbiAgICAgICAgaWYgKCFyZWN0KSByZXR1cm4geyBub2RlczogW10sIGxpbmtzOiBbXSB9O1xyXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xyXG4gICAgICAgIGlmIChyZWN0LndpZHRoIDw9IF96b25lU2l6ZS53aWR0aCAmJiByZWN0LmhlaWdodCA8PSBfem9uZVNpemUuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHsgeDogcmVjdC54LCAgICAgICAgICAgICAgeTogcmVjdC55fSk7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHsgeDogcmVjdC54ICsgcmVjdC53aWR0aCwgeTogcmVjdC55IH0pO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh7IHg6IHJlY3QueCwgICAgICAgICAgICAgIHk6IHJlY3QueSArIHJlY3QuaGVpZ2h0IH0pO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh7IHg6IHJlY3QueCArIHJlY3Qud2lkdGgsIHk6IHJlY3QueSArIHJlY3QuaGVpZ2h0IH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHggPSByZWN0LnggOzsgeCArPSBfem9uZVNpemUud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSByZWN0LnkgOzsgeSArPSBfem9uZVNpemUuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBNYXRoLm1pbih4LCByZWN0LnggKyByZWN0LndpZHRoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogTWF0aC5taW4oeSwgcmVjdC55ICsgcmVjdC5oZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPj0gcmVjdC55ICsgcmVjdC5oZWlnaHQpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHggPj0gcmVjdC54ICsgcmVjdC53aWR0aCkgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0RWxlbWVudHNOZWFyVGhlUG9pbnRzKHBvaW50cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBub2RlcyByZWxhdGVkIHdpdGggdGhlIHRhcmdldCBub2RlXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSB0YXJnZXQgbm9kZVxyXG4gICAgICogQHJldHVybiB7Tm9kZVtdfVxyXG4gICAgICogQG1lbWJlcm9mIERhdGFDb250YWluZXJcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmdldFJlbGF0ZWROb2RlcyA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gW107XHJcbiAgICAgICAgaWYgKHNlbGYubWFwcy50YXJnZXRNYXBbbm9kZS5pZF0pIHtcclxuICAgICAgICAgICAgc2VsZi5tYXBzLnRhcmdldE1hcFtub2RlLmlkXVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2gobCA9PiBuZWlnaGJvcnMucHVzaChzZWxmLm1hcHMubm9kZU1hcFtsLm1vZGVsLnRhcmdldF0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNlbGYubWFwcy5zb3VyY2VNYXBbbm9kZS5pZF0pIHtcclxuICAgICAgICAgICAgc2VsZi5tYXBzLnNvdXJjZU1hcFtub2RlLmlkXVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2gobCA9PiBuZWlnaGJvcnMucHVzaChzZWxmLm1hcHMubm9kZU1hcFtsLm1vZGVsLnNvdXJjZV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5laWdoYm9ycztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoZXMgY29udGFpbmVyLiBJdCBtZWFucyB0aGF0IGFsbCBtYXBzIHdpbGxcclxuICAgICAqIGJlIHVwZGF0ZWQgYW5kIG5vZGVzIGluIHRoZSBjb250YWluZXIgd2lsbCBiZSBvcmdhbml6ZWQuXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUYXJnZXQgbm9kZSAob3B0aW9uYWwpXHJcbiAgICAgKiBAbWVtYmVyb2YgRGF0YUNvbnRhaW5lclxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYucmVmcmVzaCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XHJcbiAgICAgICAgaWYgKG5ld0RhdGEpIHtcclxuICAgICAgICAgICAgaWYgKG5ld0RhdGEubm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYubm9kZXMgPSBuZXdEYXRhLm5vZGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXdEYXRhLmxpbmtzKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmxpbmtzID0gbmV3RGF0YS5saW5rcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfcmVmcmVzaE1hcHMoKTtcclxuICAgICAgICBfcmVmcmVzaEdyaWQoKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgbm9kZSBmcm9tIG9uZSB6b25lIHRvIGFub3RoZXIuXHJcbiAgICAgKiBXZSBhcmUgdXNpbmcgaXQgd2hlbiBub2RlIGlzIGRyYWdnZWQgdG8gc29tZXdoZXJlIG9uIHRoZSBwYXBlclxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gdGFyZ2V0IG5vZGVcclxuICAgICAqIEBwYXJhbSB7UG9pbnR9IG9sZFBvcyAtIHByZXZpb3VzIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZVxyXG4gICAgICogQG1lbWJlcm9mIERhdGFDb250YWluZXJcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnVwZGF0ZVpvbmVzRm9yTm9kZSA9IGZ1bmN0aW9uIChub2RlLCBvbGRQb3MpIHtcclxuICAgICAgICBjb25zdCBjdXJQb3MgPSBub2RlLm1vZGVsLnBvc2l0aW9uO1xyXG4gICAgICAgIGNvbnN0IG9sZFpvbmVzID0gX3pvbmVzRm9yUG9pbnRzIChbb2xkUG9zXSk7XHJcblxyXG4gICAgICAgIG9sZFpvbmVzLmZvckVhY2goem9uZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld05vZGVzID0gem9uZS5ub2Rlcy5maWx0ZXIobiA9PiBuICE9PSBub2RlKTtcclxuICAgICAgICAgICAgX2NsZWFyWm9uZSh6b25lKTtcclxuICAgICAgICAgICAgX2ZpbGxab25lICh6b25lLCBuZXdOb2Rlcyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IG5ld1pvbmVzID0gX3pvbmVzRm9yUG9pbnRzIChbY3VyUG9zXSk7XHJcbiAgICAgICAgaWYgKG5ld1pvbmVzKSB7XHJcbiAgICAgICAgICAgIG5ld1pvbmVzLmZvckVhY2goeiA9PiB7XHJcbiAgICAgICAgICAgICAgICBfZmlsbFpvbmUgKHosIFtub2RlXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9maWxsWm9uZSAoX2Zha2Vab25lLCBbbm9kZV0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCB6b25lcyB3aGljaCBjb250YWluIG9idGFpbmVkIHBvaW50cy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50W119IHBvaW50c1xyXG4gICAgICogQHJldHVybiB7Tm9kZXNab25lW119XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3pvbmVzRm9yUG9pbnRzIChwb2ludHMpIHtcclxuICAgICAgICBwb2ludHMgPSBwb2ludHMgfHwgW107XHJcbiAgICAgICAgY29uc3Qgc3VpdGFibGVab25lcyA9IFtdO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWN1cnNpb24gKHAsIHpvbmVzKSB7XHJcbiAgICAgICAgICAgIHpvbmVzLmZvckVhY2goeiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoei5oaXRUZXN0KHApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHogaW5zdGFuY2VvZiBHcm91cE9mWm9uZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzaW9uKHAsIHouem9uZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3VpdGFibGVab25lcy5pbmRleE9mKHopID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWl0YWJsZVpvbmVzLnB1c2goeik7IFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvaW50cy5mb3JFYWNoKHAgPT4ge1xyXG4gICAgICAgICAgICByZWN1cnNpb24gKHAsIHNlbGYuem9uZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1aXRhYmxlWm9uZXMucHVzaChfZmFrZVpvbmUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBzdWl0YWJsZVpvbmVzO1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB6b25lcyB0cmVlLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfcmVmcmVzaEdyaWQgKCkge1xyXG4gICAgICAgIGxldCBtaW5YID0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBtaW5ZID0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBtYXhYID0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBtYXhZID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBzZWxmLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IG5vZGUubW9kZWwucG9zaXRpb247XHJcbiAgICAgICAgICAgIG1pblggPSAobWluWCA9PT0gdW5kZWZpbmVkID8gcG9zLnggOiBNYXRoLm1pbihtaW5YLCBwb3MueCkpO1xyXG4gICAgICAgICAgICBtaW5ZID0gKG1pblkgPT09IHVuZGVmaW5lZCA/IHBvcy55IDogTWF0aC5taW4obWluWSwgcG9zLnkpKTtcclxuICAgICAgICAgICAgbWF4WCA9IChtYXhYID09PSB1bmRlZmluZWQgPyBwb3MueCA6IE1hdGgubWF4KG1heFgsIHBvcy54KSk7XHJcbiAgICAgICAgICAgIG1heFkgPSAobWF4WSA9PT0gdW5kZWZpbmVkID8gcG9zLnkgOiBNYXRoLm1heChtYXhZLCBwb3MueSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgem9uZXMgPSBbXTtcclxuICAgICAgICBsZXQgbm9kZXMgPSBbXS5jb25jYXQoc2VsZi5ub2Rlcyk7XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IG1pblgsIGkgPSAwOyB4IDw9IG1heFg7IHggKz0gKF96b25lU2l6ZS53aWR0aCAtIF9lbGVtZW50U2l6ZS53aWR0aCksIGkrKykge1xyXG4gICAgICAgICAgICB6b25lc1tpXSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gbWluWSwgaiA9IDA7IHkgPD0gbWF4WTsgeSArPSAoX3pvbmVTaXplLmhlaWdodCAtIF9lbGVtZW50U2l6ZS5oZWlnaHQpLCBqKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1pvbmUgPSBuZXcgTm9kZXNab25lKG51bGwsIHtcclxuICAgICAgICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IF96b25lU2l6ZS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IF96b25lU2l6ZS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNpemU6IF9lbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbm9kZXMgPSBfZmlsbFpvbmUgKG5ld1pvbmUsIG5vZGVzKTtcclxuICAgICAgICAgICAgICAgIHpvbmVzW2ldW2pdID0gbmV3Wm9uZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZWxmLnpvbmVzID0gX2dyb3VwWm9uZXMoem9uZXMpO1xyXG4gICAgICAgIHNlbGYuem9uZXMucHVzaChfZmFrZVpvbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR3JvdXBzIHpvbmVzIGJ5IGdyb3VwcyBvZiAoYnkgZGVmYXVsdCkgZm91ci5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge05vZGVab25lW119IHpvbmVzXHJcbiAgICAgKiBAcmV0dXJuIHtOb2RlWm9uZVtdIHwgR3JvdXBPZlpvbmVzfVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9ncm91cFpvbmVzICh6b25lcykge1xyXG4gICAgICAgIGNvbnN0IE1BWF9ERUVQID0gMTAwMDtcclxuICAgICAgICBjb25zdCBzaWRlID0gTWF0aC5zcXJ0KF96b25lc0luR3JvdXApOyAvLyBsZW5ndGggb2Ygc2lkZSBvZiBncm91cFxyXG4gICAgICAgIGxldCBuZXdab25lcztcclxuICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IE1BWF9ERUVQICYmIHpvbmVzLmxlbmd0aCAhPT0gMTsgbisrKSB7IC8vIGl0ZXJhdGlvbnNcclxuICAgICAgICAgICAgbmV3Wm9uZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG5pID0gMDsgaSA8IHpvbmVzLmxlbmd0aDsgaSArPSBzaWRlLCBuaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdab25lc1tuaV0gPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBuaiA9IDA7IGogPCB6b25lc1tpXS5sZW5ndGg7IGogKz0gc2lkZSwgbmorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHpvbmVzT2ZHcm91cCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHpvbmVzT2ZHcm91cC5wdXNoKHpvbmVzW2ldW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoem9uZXNbaSArIDFdICYmIHpvbmVzW2kgKyAxXVtqXSkgem9uZXNPZkdyb3VwLnB1c2goem9uZXNbaSArIDFdW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoem9uZXNbaV0gJiYgem9uZXNbaV1baiArIDFdKSB6b25lc09mR3JvdXAucHVzaCh6b25lc1tpXVtqICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh6b25lc1tpICsgMV0gJiYgem9uZXNbaSArIDFdW2ogKyAxXSkgem9uZXNPZkdyb3VwLnB1c2goem9uZXNbaSArIDFdW2ogKyAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Wm9uZXNbbmldW25qXSA9IG5ldyBHcm91cE9mWm9uZXMoem9uZXNPZkdyb3VwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB6b25lcyA9IG5ld1pvbmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV3Wm9uZXMpIHpvbmVzID0gbmV3Wm9uZXM7XHJcbiAgICAgICAgcmV0dXJuIHpvbmVzWzBdIHx8IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHV0cyBub2RlcyBhbmQgbGlua3MgaW50byB6b25lLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Tm9kZVpvbmV9IHpvbmVcclxuICAgICAqIEBwYXJhbSB7Tm9kZVtdfSBub2Rlc1xyXG4gICAgICogQHJldHVybiB7Tm9kZVtdfVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9maWxsWm9uZSAoem9uZSwgbm9kZXMpIHtcclxuICAgICAgICBjb25zdCBub3RGaXRlZE5vZGVzID0gW107IC8vIGluZGV4ZXMgdG8gcmVtb3ZlIHRoZSBjYXRjaGVkIG5vZGVzIGZyb20gdGhlIGxpc3RcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh6b25lLm5vZGVIaXRUZXN0KG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICB6b25lLm5vZGVzLnB1c2gobm9kZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5nZXRSZWxhdGVkTm9kZXMobm9kZSkuZm9yRWFjaChuID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoem9uZS5yZWxhdGVkTm9kZXMuaW5kZXhPZihuKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgem9uZS5yZWxhdGVkTm9kZXMucHVzaChuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tYXBzLnNvdXJjZU1hcFtub2RlLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWFwcy5zb3VyY2VNYXBbbm9kZS5pZF0uZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgem9uZS5saW5rcy5wdXNoKGxpbmspO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubWFwcy50YXJnZXRNYXBbbm9kZS5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLm1hcHMudGFyZ2V0TWFwW25vZGUuaWRdLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvbmUubGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vdEZpdGVkTm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBub3RGaXRlZE5vZGVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIgem9uZSAtIHJlbW92ZSBhbGwgZGF0YSBmcm9tIHRoZSB6b25lLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Tm9kZVpvbmV9IHpvbmVcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfY2xlYXJab25lICh6b25lKSB7XHJcbiAgICAgICAgem9uZS5yZWxhdGVkTm9kZXMgPSBbXTtcclxuICAgICAgICB6b25lLm5vZGVzID0gW107XHJcbiAgICAgICAgem9uZS5saW5rcyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBtYXAgZm9yIG5vZGVzXHJcbiAgICAgKiBhbmQgdXBkYXRlcyBhc3BlY3QgcmVsYXRpb25zIGJldHdlZW4gbm9kZXNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyBub2RlTWFwXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZU5vZGVNYXBzICgpIHtcclxuICAgICAgICBjb25zdCBub2RlTWFwID0ge307XHJcbiAgICAgICAgY29uc3QgaWRNYXAgPSB7fTtcclxuICAgICAgICBzZWxmLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIG5vZGVNYXBbbm9kZS5pZF0gPSBub2RlO1xyXG4gICAgICAgICAgICBub2RlTWFwW25vZGUubW9kZWwuaWRdID0gbm9kZS5pZDtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbm9kZU1hcDogbm9kZU1hcCxcclxuICAgICAgICAgICAgaWRNYXA6IGlkTWFwLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG1hcHMgZm9yIGxpbmtzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlTWFwXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaWRNYXBcclxuICAgICAqIEByZXR1cm5zIHtsaW5rTWFwLCBpZE1hcH1cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfY3JlYXRlTGlua01hcHMgKG5vZGVNYXAsIGlkTWFwKSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlTWFwID0ge307XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0TWFwID0ge307XHJcbiAgICAgICAgY29uc3QgbGlua01hcCA9IHt9O1xyXG5cclxuICAgICAgICBzZWxmLmxpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIGxpbmtNYXBbbGluay5pZF0gPSBsaW5rO1xyXG4gICAgICAgICAgICBpZE1hcFtsaW5rLm1vZGVsLmlkXSA9IGxpbmsuaWQ7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBub2RlTWFwW2xpbmsubW9kZWwuc291cmNlXTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gbm9kZU1hcFtsaW5rLm1vZGVsLnRhcmdldF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIXNvdXJjZU1hcFt0YXJnZXQuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBbdGFyZ2V0LmlkXSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNvdXJjZU1hcFt0YXJnZXQuaWRdLnB1c2gobGluayk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRhcmdldE1hcFtzb3VyY2UuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRNYXBbc291cmNlLmlkXSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhcmdldE1hcFtzb3VyY2UuaWRdLnB1c2gobGluayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGlua01hcDogbGlua01hcCxcclxuICAgICAgICAgICAgc291cmNlTWFwOiBzb3VyY2VNYXAsXHJcbiAgICAgICAgICAgIHRhcmdldE1hcDogdGFyZ2V0TWFwLFxyXG4gICAgICAgICAgICBpZE1hcDogaWRNYXAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgbWFwcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3JlZnJlc2hNYXBzICgpIHtcclxuICAgICAgICBjb25zdCB7IG5vZGVNYXAsIGlkTWFwIH0gPSBfY3JlYXRlTm9kZU1hcHMoKTtcclxuICAgICAgICBjb25zdCBsaW5rTWFwcyA9IF9jcmVhdGVMaW5rTWFwcyhub2RlTWFwLCBpZE1hcCk7XHJcblxyXG4gICAgICAgIHNlbGYubWFwcyA9IHtcclxuICAgICAgICAgICAgc291cmNlTWFwOiBsaW5rTWFwcy5zb3VyY2VNYXAsXHJcbiAgICAgICAgICAgIHRhcmdldE1hcDogbGlua01hcHMudGFyZ2V0TWFwLFxyXG4gICAgICAgICAgICBub2RlTWFwOiBub2RlTWFwLFxyXG4gICAgICAgICAgICBpZE1hcDogbGlua01hcHMuaWRNYXAsXHJcbiAgICAgICAgICAgIGxpbmtNYXA6IGxpbmtNYXBzLmxpbmtNYXAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmLnJlZnJlc2goKTtcclxufVxyXG5leHBvcnQgZGVmYXVsdCBEYXRhQ29udGFpbmVyO1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIE9iamVjdCB0aGF0IGlzIHRoZSBsZWFmIG9mIHRoZSB6b25lcyB0cmVlXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0ge05vZGVab25lW119IHpvbmVzIC0gQXJyYXkgb2Ygem9ubmVzIGZvciBjb250YWluaW5nXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZVpvbmVbXX0gem9uZXMgLSBBcnJheSBvZiB6b25uZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBHcm91cE9mWm9uZXMgKHpvbmVzKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICBzZWxmLm1vZGVsID0ge307XHJcbiAgICBzZWxmLnpvbmVzID0gem9uZXM7XHJcblxyXG4gICAgX2NhbGN1bGF0ZUJvdW5kcygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIENhbGN1bGF0ZXMgYm91bmRzIG9mIHRoZSB0b3RhbCBhcmVhIG9mIGNvbnRhaW5lZCB6b25lcy4gXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NhbGN1bGF0ZUJvdW5kcyAoKSB7XHJcbiAgICAgICAgbGV0IG1pblggPSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIG1pblkgPSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIG1heFggPSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIG1heFkgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHNlbGYuem9uZXMuZm9yRWFjaCh6b25lID0+IHtcclxuICAgICAgICAgICAgbWluWCA9IChtaW5YID09PSB1bmRlZmluZWQgPyB6b25lLm1vZGVsLnggOiBNYXRoLm1pbihtaW5YLCB6b25lLm1vZGVsLngpKTtcclxuICAgICAgICAgICAgbWluWSA9IChtaW5ZID09PSB1bmRlZmluZWQgPyB6b25lLm1vZGVsLnkgOiBNYXRoLm1pbihtaW5ZLCB6b25lLm1vZGVsLnkpKTtcclxuICAgICAgICAgICAgbWF4WCA9IChtYXhYID09PSB1bmRlZmluZWQgPyB6b25lLm1vZGVsLnggKyB6b25lLm1vZGVsLndpZHRoIDogTWF0aC5tYXgobWF4WCwgem9uZS5tb2RlbC54ICsgem9uZS5tb2RlbC53aWR0aCkpO1xyXG4gICAgICAgICAgICBtYXhZID0gKG1heFkgPT09IHVuZGVmaW5lZCA/IHpvbmUubW9kZWwueSArIHpvbmUubW9kZWwuaGVpZ2h0IDogTWF0aC5tYXgobWF4WSwgem9uZS5tb2RlbC55ICsgem9uZS5tb2RlbC5oZWlnaHQpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzZWxmLm1vZGVsLnggPSBtaW5YO1xyXG4gICAgICAgIHNlbGYubW9kZWwueSA9IG1pblk7XHJcbiAgICAgICAgc2VsZi5tb2RlbC53aWR0aCA9IG1heFggLSBtaW5YO1xyXG4gICAgICAgIHNlbGYubW9kZWwuaGVpZ2h0ID0gbWF4WSAtIG1pblk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB1cyB3aGV0aGVyIGEgcG9pbnQgZmFsbCBpbnRvIHRoaXMgZ3JvdXAgb2Ygem9uZXMgb3Igbm8uXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIFRlc3RlZCBwb2ludFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAbWVtYmVyb2YgR3JvdXBPZlpvbmVzXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5oaXRUZXN0ID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgcG9pbnQueCA+PSBzZWxmLm1vZGVsLnggJiZcclxuICAgICAgICAgICAgcG9pbnQueCA8PSBzZWxmLm1vZGVsLnggKyBzZWxmLm1vZGVsLndpZHRoICYmXHJcbiAgICAgICAgICAgIHBvaW50LnkgPj0gc2VsZi5tb2RlbC55ICYmXHJcbiAgICAgICAgICAgIHBvaW50LnkgPD0gc2VsZi5tb2RlbC55ICsgc2VsZi5tb2RlbC5oZWlnaHRcclxuICAgICAgICApO1xyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIE9wdGlvbnMgb2YgYSBOb2RlWm9uZVxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBOb2RlWm9uZU9wdGlvbnNcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSBQb3NpdGlvbiBieSB4IGF4aXNcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgLSBQb3NpdGlvbiBieSB5IGF4aXNcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcclxuICogQHByb3BlcnR5IHtFbGVtZW50U2l6ZX0gZWxlbWVudFNpemUgLSBTaXplIG9mIGVsZW1lbnRzIG9mIHRoZSBncmFwaFxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGZha2Vab25lIC0gSXMgaXQgZmFrZSB6b25lIChhYnN0cmFjdCBvciBkb24ndCBoYXMgcG9zaXRpb24pXHJcbiovXHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogT2JqZWN0IHRoYXQgaXMgdGhlIGxlYWYgb2YgdGhlIHRyZWUgb2Ygem9uZXNcclxuICogQGNsYXNzXHJcbiAqIEBwYXJhbSB7Tm9kZVtdfSBub2RlcyAtIE5vZGVzIG9mIHRoZSB6b25lIChjYW4gYmUgdW5kZWZpbmVkKVxyXG4gKiBAcGFyYW0ge05vZGVab25lT3B0aW9uc30gcGFyYW1ldGVycyAtIFByb3BlcnRpZXMgc2V0XHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge05vZGVab25lT3B0aW9uc30gbW9kZWwgLSBQcm9wZXJ0aWVzIHNldFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE5vZGVzWm9uZSAobm9kZXMsIHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHNlbGYubW9kZWwgPSBwYXJhbWV0ZXJzO1xyXG4gICAgc2VsZi5ub2RlcyA9IG5vZGVzIHx8IFtdO1xyXG4gICAgc2VsZi5yZWxhdGVkTm9kZXMgPSBbXTtcclxuICAgIHNlbGYubGlua3MgPSBbXTtcclxuXHJcbiAgICBjb25zdCBfZWxlbWVudFNpemUgPSBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdXMgd2hldGhlciBhIE5vZGUgZmFsbCBpbnRvIHRoZSB6b25lIG9yIG5vLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGVzdGVkIG5vZGVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQG1lbWJlcm9mIE5vZGVzWm9uZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYubm9kZUhpdFRlc3QgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIGlmIChzZWxmLm1vZGVsLmZha2Vab25lKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBjb25zdCBub2RlUG9zaXRpb24gPSBub2RlLm1vZGVsLnBvc2l0aW9uO1xyXG5cclxuICAgICAgICBjb25zdCBwMSA9IG5vZGVQb3NpdGlvbjtcclxuICAgICAgICBjb25zdCBwMiA9IHsgeDogbm9kZVBvc2l0aW9uLnggKyBfZWxlbWVudFNpemUud2lkdGgsIHk6IG5vZGVQb3NpdGlvbi55IH07XHJcbiAgICAgICAgY29uc3QgcDMgPSB7IHg6IG5vZGVQb3NpdGlvbi54LCB5OiBub2RlUG9zaXRpb24ueSArIF9lbGVtZW50U2l6ZS5oZWlnaHQgfTtcclxuICAgICAgICBjb25zdCBwNCA9IHsgeDogbm9kZVBvc2l0aW9uLnggKyBfZWxlbWVudFNpemUud2lkdGgsIHk6IG5vZGVQb3NpdGlvbi55ICsgX2VsZW1lbnRTaXplLmhlaWdodCB9O1xyXG5cclxuICAgICAgICByZXR1cm4gKHNlbGYuaGl0VGVzdChwMSkpICYmXHJcbiAgICAgICAgICAgICAgIChzZWxmLmhpdFRlc3QocDIpKSAmJlxyXG4gICAgICAgICAgICAgICAoc2VsZi5oaXRUZXN0KHAzKSkgJiZcclxuICAgICAgICAgICAgICAgKHNlbGYuaGl0VGVzdChwNCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHVzIHdoZXRoZXIgYSBwb2ludCBmYWxsIGludG8gdGhlIHpvbmUgb3Igbm8uXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIFRlc3RlZCBwb2ludFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAbWVtYmVyb2YgTm9kZXNab25lXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5oaXRUZXN0ID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgc2VsZi5tb2RlbC5mYWtlWm9uZSB8fFxyXG4gICAgICAgICAgICBwb2ludC54ID49IHNlbGYubW9kZWwueCAmJlxyXG4gICAgICAgICAgICBwb2ludC54IDw9IHNlbGYubW9kZWwueCArIHNlbGYubW9kZWwud2lkdGggJiZcclxuICAgICAgICAgICAgcG9pbnQueSA+PSBzZWxmLm1vZGVsLnkgJiZcclxuICAgICAgICAgICAgcG9pbnQueSA8PSBzZWxmLm1vZGVsLnkgKyBzZWxmLm1vZGVsLmhlaWdodFxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG59IiwiZXhwb3J0IGNvbnN0IExHX0dST1VQX1RZUEVfSUQgPSAndHEtbGctZ3JvdXAnO1xyXG5cclxuZXhwb3J0IGNvbnN0IE5PREVfTU9ERUxfRklFTERTID0gW1xyXG4gICAgJ2lkJyxcclxuICAgICdsYWJlbCcsXHJcbiAgICAndmlld0ZyYW1lJyxcclxuICAgICd0eXBlSWQnLFxyXG4gICAgJ3Jlc291cmNlJyxcclxuICAgICdyZXNvdXJjZVR5cGUnLFxyXG4gICAgJ3Bvc2l0aW9uJyxcclxuICAgICdkZWZhdWx0UG9zaXRpb24nLFxyXG4gICAgJ2RhdGEnLFxyXG4gICAgJ29mZnNldCdcclxuXTtcclxuXHJcbmV4cG9ydCBjb25zdCBMSU5LX01PREVMX0ZJRUxEUyA9IFtcclxuICAgICdpZCcsXHJcbiAgICAnc291cmNlJyxcclxuICAgICd0YXJnZXQnLFxyXG4gICAgJ2xpbmtUeXBlJyxcclxuICAgICdncm91cCcsXHJcbiAgICAnZGF0YScsXHJcbl07XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICpcclxuICogVGhlIGZ1bmN0aW9uIGZpbHRlcnMgdGhlIGRhdGEsIHNldHMgYXV0aG9yaXRpZXMgYW5kIGNvbGxhcHNlcyBsaW5rcy5cclxuICogQHBhcmFtIHtcclxuICogIG5vZGVzOiBOb2RlTW9kZWxbXSxcclxuICogIGxpbmtzOiBMaW5rTW9kZWxbXVxyXG4gKiB9IGRhdGFcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzRGF0YSAoZGF0YSkge1xyXG4gICAgaWYgKCFkYXRhIHx8ICFkYXRhLm5vZGVzKSByZXR1cm47XHJcbiAgICBkYXRhLmxpbmtzID0gZGF0YS5saW5rcyB8fCBbXTtcclxuXHJcbiAgICBjb25zdCBub2RlTWFwID0ge307XHJcblxyXG4gICAgZGF0YS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgIG5vZGVNYXBbbm9kZS5pZF0gPSBub2RlO1xyXG4gICAgICAgIG5vZGUucG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICAvLyBleHRyYWN0aW5nIGFkZGl0aW9uYWwgZGF0YVxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSB7fTtcclxuICAgICAgICBPYmplY3Qua2V5cyhub2RlKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdFBlcm1hbmVudEZpZWxkID0gTk9ERV9NT0RFTF9GSUVMRFMuaW5kZXhPZihrZXkpID09PSAtMTtcclxuICAgICAgICAgICAgaWYgKG5vdFBlcm1hbmVudEZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSBub2RlW2tleV07XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbm9kZS5kYXRhID0gZGF0YTtcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICBjb25zdCBkZXN0aW5hdGlvbk1hcCA9IHt9O1xyXG4gICAgZGF0YS5saW5rcy5mb3JFYWNoKHJhd0xpbmsgPT4ge1xyXG4gICAgICAgIGlmIChub2RlTWFwW3Jhd0xpbmsuc291cmNlXSAmJiBub2RlTWFwW3Jhd0xpbmsudGFyZ2V0XSkge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rQ2FjaGVJZCA9IGdldENhY2hlSWQocmF3TGluayk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVzdGluYXRpb25NYXBbbGlua0NhY2hlSWRdKSB7XHJcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbk1hcFtsaW5rQ2FjaGVJZF0gPSBncm91cChkZXN0aW5hdGlvbk1hcFtsaW5rQ2FjaGVJZF0sIHJhd0xpbmspO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25NYXBbbGlua0NhY2hlSWRdID0gcmF3TGluaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghbm9kZU1hcFtyYXdMaW5rLnNvdXJjZV0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignU291cmNlIG5vdCBmb3VuZCEgVGhlIGxpbmsgZnJvbSAnICsgcmF3TGluay5zb3VyY2UgKyAnIHRvICcgKyByYXdMaW5rLnRhcmdldCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RhcmdldCBub3QgZm91bmQhIFRoZSBsaW5rIGZyb20gJyArIHJhd0xpbmsuc291cmNlICsgJyB0byAnICsgcmF3TGluay50YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgc291cmNlTWFwID0ge307XHJcbiAgICBjb25zdCB0YXJnZXRNYXAgPSB7fTtcclxuICAgIGNvbnN0IGxpbmtzID0gT2JqZWN0LmtleXMoZGVzdGluYXRpb25NYXApLm1hcChjYWNoZUlkID0+IHtcclxuICAgICAgICBjb25zdCBsaW5rID0gZGVzdGluYXRpb25NYXBbY2FjaGVJZF07XHJcbiAgICAgICAgT2JqZWN0LmtleXMobGluaykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBub3RQZXJtYW5lbnRGaWVsZCA9IExJTktfTU9ERUxfRklFTERTLmluZGV4T2Yoa2V5KSA9PT0gLTE7XHJcbiAgICAgICAgICAgIGlmIChub3RQZXJtYW5lbnRGaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgZGF0YVtrZXldID0gbGlua1trZXldO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGxpbmtba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICghc291cmNlTWFwW2xpbmsudGFyZ2V0XSkgc291cmNlTWFwW2xpbmsudGFyZ2V0XSA9IFtdO1xyXG4gICAgICAgIHNvdXJjZU1hcFtsaW5rLnRhcmdldF0ucHVzaChsaW5rKTtcclxuXHJcbiAgICAgICAgaWYgKCF0YXJnZXRNYXBbbGluay5zb3VyY2VdKSB0YXJnZXRNYXBbbGluay5zb3VyY2VdID0gW107XHJcbiAgICAgICAgdGFyZ2V0TWFwW2xpbmsuc291cmNlXS5wdXNoKGxpbmspO1xyXG5cclxuICAgICAgICByZXR1cm4gbGluaztcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9kZXM6IE9iamVjdC5rZXlzKG5vZGVNYXApLm1hcChrZXkgPT4gbm9kZU1hcFtrZXldKSxcclxuICAgICAgICBsaW5rczogbGlua3MsXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldENhY2hlSWQgKGxpbmspIHtcclxuICAgICAgICByZXR1cm4gYHNvdXJjZTooJHtsaW5rLnNvdXJjZX0pfiN+dGFyZ2V0Oigke2xpbmsudGFyZ2V0fSlgO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdyb3VwIChleGlzdGVkTGluaywgbmV3TGluaykge1xyXG4gICAgICAgIGNvbnN0IGdyb3VwID0gZXhpc3RlZExpbmsuZ3JvdXAgPyBleGlzdGVkTGluayA6IHtcclxuICAgICAgICAgICAgaWQ6IGdldENhY2hlSWQoZXhpc3RlZExpbmspLFxyXG4gICAgICAgICAgICBzb3VyY2U6IGV4aXN0ZWRMaW5rLnNvdXJjZSxcclxuICAgICAgICAgICAgdGFyZ2V0OiBleGlzdGVkTGluay50YXJnZXQsXHJcbiAgICAgICAgICAgIGxpbmtUeXBlOiBMR19HUk9VUF9UWVBFX0lELCAvLyBleGlzdGVkTGluay5saW5rVHlwZSxcclxuICAgICAgICAgICAgZ3JvdXA6IFtleGlzdGVkTGlua10sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBncm91cC5ncm91cC5wdXNoKG5ld0xpbmspO1xyXG4gICAgICAgIC8vIGV4dHJhY3RpbmcgYWRkaXRpb25hbCBkYXRhXHJcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IHByb2Nlc3NEYXRhO1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbiBmaWx0ZXJzIHRoZSBkYXRhLCBzZXRzIGF1dGhvcml0aWVzIGFuZCBjb2xsYXBzZXMgbGlua3MuXHJcbiAqIEBwYXJhbSB7XHJcbiAqICBub2RlczogTm9kZU1vZGVsW10sXHJcbiAqICBsaW5rczogTGlua01vZGVsW11cclxuICogfSBkYXRhXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXNwZWN0UmVsYXRpb25zIChub2Rlcykge1xyXG4gICAgY29uc3QgYXNwZWN0TWFwID0ge307XHJcbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgIC8vIGNvbWJpbmUgbm9kZXMgd2l0aCB0aGUgc2FtZSBpZFxyXG4gICAgICAgIGNvbnN0IGNsZWFySWQgPSBub2RlLm1vZGVsLnJlc291cmNlO1xyXG4gICAgICAgIGlmIChjbGVhcklkKSB7XHJcbiAgICAgICAgICAgIGlmICghYXNwZWN0TWFwW2NsZWFySWRdKSB7XHJcbiAgICAgICAgICAgICAgICBhc3BlY3RNYXBbY2xlYXJJZF0gPSBbbm9kZV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhc3BlY3RNYXBbY2xlYXJJZF0ucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmtleXMoYXNwZWN0TWFwKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaWYgKGFzcGVjdE1hcFtrZXldLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgYXNwZWN0TWFwW2tleV0uZm9yRWFjaChuID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYXNwZWN0TWFwW2tleV0uaW5kZXhPZihuKTtcclxuICAgICAgICAgICAgICAgIG4uYXNwZWN0cyA9IGFzcGVjdE1hcFtrZXldLnNsaWNlKDAsIGluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoYXNwZWN0TWFwW2tleV0uc2xpY2UoaW5kZXggKyAxLCBhc3BlY3RNYXBba2V5XS5sZW5ndGgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIERlZmF1bHREYXRhUHJvdmlkZXIocGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICBpZiAoIXBhcmFtZXRlcnMpIHBhcmFtZXRlcnMgPSB7fTtcclxuXHJcbiAgICBjb25zdCBfc2VydmVyVVJMID0gcGFyYW1ldGVycy5zZXJ2ZXJVUkwgfHwgJy9hcGkvdGJsL3N3cCc7XHJcbiAgICBjb25zdCBfZGVmYXVsdExpbmVhZ2VHcmFtVmlld0NsYXNzID0gcGFyYW1ldGVycy5sZ1ZpZXdDbGFzcyB8fCAnaHR0cDovL2VkZy50b3BicmFpZC5zb2x1dGlvbnMvbW9kZWwvQnVpbGRKU09OZm9yTGluZWFnZU1vZGVsTGluZWFnZUdyYW0nO1xyXG4gICAgY29uc3QgX3ZmVmlld0NsYXNzID0gcGFyYW1ldGVycy52ZlZpZXdDbGFzcyB8fCAnZWRnOmdldFZpZXdGcmFtZXNGb3JSZXNvdXJjZSc7XHJcbiAgICBjb25zdCBfZG1WaWV3Q2xhc3MgPSBwYXJhbWV0ZXJzLmRtVmlld0NsYXNzIHx8ICdlZGc6RGVyaXZhdGlvbk1hcERhdGFTZXJ2aWNlJztcclxuICAgIGNvbnN0IF92Y1ZpZXdDbGFzcyA9IHBhcmFtZXRlcnMudmNWaWV3Q2xhc3MgfHwgJ2VkZzpnZXRMaW5lYWdlR3JhbURhdGFQcm92aWRlcic7XHJcblxyXG4gICAgY29uc3QgX2dyYXBoID0gcGFyYW1ldGVycy5ncmFwaCB8fCAndW5kZWZpbmVkJztcclxuICAgIGNvbnN0IF9jb25maWdHcmFwaCA9IHBhcmFtZXRlcnMuY29uZmlnR3JhcGggfHwgJ2h0dHA6Ly9lZGcudG9wYnJhaWRsaXZlLm9yZy8xLjAvY29uZmlnL2RpYWdyYW1zJztcclxuICAgIGNvbnN0IF9iYXNlID0gcGFyYW1ldGVycy5iYXNlIHx8ICd1bmRlZmluZWQnO1xyXG5cclxuICAgIGNvbnN0IF9yZWFjaCA9IHBhcmFtZXRlcnMucmVhY2g7XHJcbiAgICBjb25zdCBfcmFuZ2UgPSBwYXJhbWV0ZXJzLnJhbmdlO1xyXG4gICAgY29uc3QgX2JyZWFkdGggPSBwYXJhbWV0ZXJzLmJyZWFkdGg7XHJcbiAgICBjb25zdCBfZGVwdGggPSBwYXJhbWV0ZXJzLmRlcHRoO1xyXG5cclxuICAgIHNlbGYuZmV0Y2hEYXRhID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX2V4ZWN1dFF1ZXJ5KGdldEZldGNoRGF0YVVybChcclxuICAgICAgICAgICAgb3B0aW9ucy50YXJnZXROb2RlSWQsXHJcbiAgICAgICAgICAgIG9wdGlvbnMudmlld0ZyYW1lLFxyXG4gICAgICAgICAgICBvcHRpb25zLmxpbmVhZ2VHcmFtVmlld0NsYXNzLFxyXG4gICAgICAgICAgICBvcHRpb25zLmRpYWdyYW1UeXBlLFxyXG4gICAgICAgICAgICAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnb2Zmc2V0JykgPyBvcHRpb25zLm9mZnNldCA6IG51bGwpXHJcbiAgICAgICAgKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0Vmlld0ZyYW1lcyA9IGZ1bmN0aW9uIChyZXNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiBfZXhlY3V0UXVlcnkoZ2V0Vmlld0ZyYW1lc1VybChyZXNvdXJjZSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldFZpZXdDbGFzc0ZvclJlc291cmNlID0gZnVuY3Rpb24gKHJlc291cmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIF9leGVjdXRRdWVyeShnZXRWaWV3Q2xhc3NVcmwocmVzb3VyY2UpKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5yZWxhdGlvbkluZm8gPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gX2V4ZWN1dFF1ZXJ5KGdldERlcml2YXRpb25EYXRhVXJsKFxyXG4gICAgICAgICAgICByZWxhdGlvbi5zb3VyY2UucmVzb3VyY2UsXHJcbiAgICAgICAgICAgIHJlbGF0aW9uLnRhcmdldC5yZXNvdXJjZSxcclxuICAgICAgICAgICAgcmVsYXRpb24ubGlua1R5cGVcclxuICAgICAgICApKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Vmlld0ZyYW1lc1VybCAocmVzb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gX3NlcnZlclVSTCArICc/JyArXHJcbiAgICAgICAgICAgICdfdmlld0NsYXNzPScgKyBfdmZWaWV3Q2xhc3MgKyAnJicgK1xyXG4gICAgICAgICAgICAnZ3JhcGg9JyArIF9ncmFwaCArICcmJyArXHJcbiAgICAgICAgICAgICdyZXNvdXJjZT0nICsgcmVzb3VyY2UgKyAnJicgK1xyXG4gICAgICAgICAgICAnY29uZmlnR3JhcGg9JyArIF9jb25maWdHcmFwaCArICcmJyArXHJcbiAgICAgICAgICAgICdfYmFzZT0nICsgX2Jhc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Vmlld0NsYXNzVXJsIChyZXNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiBfc2VydmVyVVJMICsgJz8nICtcclxuICAgICAgICAgICAgJ192aWV3Q2xhc3M9JyArIF92Y1ZpZXdDbGFzcyArICcmJyArXHJcbiAgICAgICAgICAgICdncmFwaD0nICsgX2dyYXBoICsgJyYnICtcclxuICAgICAgICAgICAgJ3Jlc291cmNlPScgKyByZXNvdXJjZSArICcmJyArXHJcbiAgICAgICAgICAgICdjb25maWdHcmFwaD0nICsgX2NvbmZpZ0dyYXBoICsgJyYnICtcclxuICAgICAgICAgICAgJ19iYXNlPScgKyBfYmFzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRGZXRjaERhdGFVcmwgKGZvY3VzTm9kZSwgdmlld0ZyYW1lLCBsaW5lYWdlR3JhbVZpZXdDbGFzcywgZGlhZ3JhbVR5cGUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciBkYXRhVXJsID0gX3NlcnZlclVSTCArICc/JyArXHJcbiAgICAgICAgICAgICdfdmlld0NsYXNzPScgKyAobGluZWFnZUdyYW1WaWV3Q2xhc3MgfHwgX2RlZmF1bHRMaW5lYWdlR3JhbVZpZXdDbGFzcykgKyAnJicgK1xyXG4gICAgICAgICAgICAnZ3JhcGg9JyArIF9ncmFwaCArICcmJyArXHJcbiAgICAgICAgICAgICdmb2N1c05vZGU9JyArIGVuY29kZVVSSUNvbXBvbmVudChmb2N1c05vZGUpICsgJyYnICtcclxuICAgICAgICAgICAgJ19iYXNlPScgKyBfYmFzZTtcclxuXHJcbiAgICAgICAgaWYgKHZpZXdGcmFtZSkge1xyXG4gICAgICAgICAgICBkYXRhVXJsICs9ICcmdmlld0ZyYW1lPScgKyB2aWV3RnJhbWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIGRhdGFVcmwgKz0gJyZvZmZzZXQ9JyArIG9mZnNldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChfcmVhY2gpIHtcclxuICAgICAgICAgICAgZGF0YVVybCArPSAnJnJlYWNoPScgKyBfcmVhY2g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoX3JhbmdlKSB7XHJcbiAgICAgICAgICAgIGRhdGFVcmwgKz0gJyZyYW5nZT0nICsgX3JhbmdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKF9icmVhZHRoKSB7XHJcbiAgICAgICAgICAgIGRhdGFVcmwgKz0gJyZicmVhZHRoPScgKyBfYnJlYWR0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChfZGVwdGgpIHtcclxuICAgICAgICAgICAgZGF0YVVybCArPSAnJmRlcHRoPScgKyBfZGVwdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGlhZ3JhbVR5cGUpIHtcclxuICAgICAgICAgICAgZGF0YVVybCArPSAnJmRpYWdyYW1UeXBlPScgKyBkaWFncmFtVHlwZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhVXJsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9leGVjdXRRdWVyeSAodXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZldGNoKHVybCwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcclxuICAgICAgICAgICAgbW9kZTogJ2NvcnMnLFxyXG4gICAgICAgICAgICBjYWNoZTogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvdHVydGxlJyxcclxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vc3BhcnFsLXF1ZXJ5JyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7IC8vIEFsc28gcG9zc2libGUgdG8gdXNlOiByZXNwb25zZS50ZXh0KCk7IC8vcmVzcG9uc2UudHlwZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcclxuICAgICAgICAgICAgICAgIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldERlcml2YXRpb25EYXRhVXJsIChsZWZ0Tm9kZSwgcmlnaHROb2RlLCBsaW5rVHlwZSkge1xyXG4gICAgICAgIGxldCBkYXRhVVJMID0gX3NlcnZlclVSTCArICc/JyArXHJcbiAgICAgICAgICAgICdfYmFzZT0nICsgX2Jhc2UgKyAnJicgK1xyXG4gICAgICAgICAgICAnX3ZpZXdDbGFzcz0nICsgX2RtVmlld0NsYXNzICsgJyYnICtcclxuICAgICAgICAgICAgJ2xlZnROb2RlPScgKyBsZWZ0Tm9kZSArICcmJyArXHJcbiAgICAgICAgICAgICdyaWdodE5vZGU9JyArIHJpZ2h0Tm9kZTtcclxuXHJcbiAgICAgICAgICAgIGlmKGxpbmtUeXBlKXtcclxuICAgICAgICAgICAgICBkYXRhVVJMICs9ICcmbGlua1R5cGU9JyArIGxpbmtUeXBlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YVVSTDtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZGVmYXVsdCBEZWZhdWx0RGF0YVByb3ZpZGVyO1xyXG4iLCJpbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCAqIGFzIGltYWdlcyBmcm9tICcuL2Jhc2U2NEltYWdlcyc7XHJcblxyXG5leHBvcnQgY29uc3QgRkVFRF9QSVBFX1RZUEUgPSAnZmVlZHBpcGUnO1xyXG5cclxuZXhwb3J0IGNvbnN0IExHX0dST1VQX1RZUEVfSUQgPSAndHEtbGctZ3JvdXAnO1xyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfREVSSVZBVElPTl9NQVBfTElOS19TVFlMRSA9IHtcclxuICAgIGNzc0NsYXNzOiAnZGVyaXZhdGlvbi1saW5rJyxcclxuICAgIGxpbmVUeXBlOiAnc29saWQnLCAvLyAnZGFzaGVkJ1xyXG4gICAgY29sb3I6ICdibGFjaycsXHJcbiAgICB0ZXh0Q29sb3I6ICdibGFjaycsXHJcbiAgICB0ZXh0QmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLCBcclxuICAgIHRoaWNrbmVzczogMixcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0xJTktfU1RZTEUgPSB7XHJcbiAgICBjc3NDbGFzczogJ2xpbmVhZ2UtZ3JhbS1saW5rJyxcclxuICAgIGxpbmVUeXBlOiAnc29saWQnLCAvLyAnZGFzaGVkJ1xyXG4gICAgY29sb3I6ICcjM2M0MjYwJyxcclxuICAgIHRvb2xCdXR0b246IHtcclxuICAgICAgICBpbWFnZTogaW1hZ2VzLkxJTktfT1BUSU9OUyxcclxuICAgICAgICB3aWR0aDogMzAsXHJcbiAgICAgICAgaGVpZ2h0OiAzMCxcclxuICAgICAgICBhbHdheXNWaXNpYmxlOiBmYWxzZSxcclxuICAgIH0sXHJcbiAgICB0aGlja25lc3M6IDIsXHJcbiAgICBoYXNBcnJvdzogdHJ1ZSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0dST1VQX0xJTktfU1RZTEUgPSB7XHJcbiAgICBjc3NDbGFzczogJ2xpbmVhZ2UtZ3JhbS1saW5rcy1ncm91cCcsXHJcbiAgICBsaW5lVHlwZTogJ3NvbGlkJywgLy8gJ2Rhc2hlZCdcclxuICAgIGNvbG9yOiAnIzNjNDI2MCcsXHJcbiAgICB0aGlja25lc3M6IDIsXHJcbiAgICBoYXNBcnJvdzogdHJ1ZSxcclxuICAgIHRvb2xCdXR0b246IHtcclxuICAgICAgICBhbHdheXNWaXNpYmxlOiB0cnVlLFxyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEZFRURfUElQRV9MSU5LX1NUWUxFID0ge1xyXG4gICAgY3NzQ2xhc3M6ICdsaW5lYWdlLWdyYW0tZmVlZC1waXBlLWxpbmsnLFxyXG4gICAgbGluZVR5cGU6ICdzb2xpZCcsIC8vICdkYXNoZWQnXHJcbiAgICBjb2xvcjogJyMzYzQyNjAnLFxyXG4gICAgdG9vbEJ1dHRvbjoge1xyXG4gICAgICAgIGltYWdlOiBpbWFnZXMuRkVFRF9QSVBFLFxyXG4gICAgICAgIHdpZHRoOiAzMCxcclxuICAgICAgICBoZWlnaHQ6IDMwLFxyXG4gICAgICAgIGFsd2F5c1Zpc2libGU6IHRydWUsXHJcbiAgICB9LFxyXG4gICAgdGhpY2tuZXNzOiAzLFxyXG4gICAgaGFzQXJyb3c6IHRydWUsXHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gUmVzb3VyY2VQcm92aWRlciAoX3BhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHNlbGYuZ2V0TGlua1N0eWxlID0gX2dldExpbmtTdHlsZTtcclxuICAgIHNlbGYuZ2V0SW1hZ2UgPSBfZ2V0SW1hZ2U7XHJcbiAgICBzZWxmLmdldENvbG9yID0gX2dldENvbG9yO1xyXG4gICAgc2VsZi5nZXRJY29uID0gX2dldEljb247XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldENvbG9yICh0eXBlKSB7XHJcbiAgICAgICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnd2hpdGUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9wYXJhbWV0ZXJzLmNvbG9yc1snZGVmYXVsdCddO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcGFyYW1ldGVycy5jb2xvcnNbdHlwZV0gfHwgX3BhcmFtZXRlcnMuY29sb3JzWydkZWZhdWx0J107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9nZXRJbWFnZSAodHlwZSkge1xyXG4gICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2VzLlVOS05PV19JTUFHRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfcGFyYW1ldGVycy5pbWFnZXNbdHlwZV0gJiYgdHlwZSA9PT0gJ2xpbmstb3B0aW9ucycgfHwgdHlwZSA9PT0gJ2RlZmF1bHQtbGluay1vcHRpb25zJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2VzLkxJTktfT1BUSU9OUztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfcGFyYW1ldGVycy5pbWFnZXNbdHlwZV0gJiYgdHlwZSA9PT0gJ2ZlZWQtcGlwZScgfHwgdHlwZSA9PT0gJ2RlZmF1bHQtZmVlZC1waXBlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2VzLkZFRURfUElQRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9wYXJhbWV0ZXJzLnJlc291cmNlUGF0aCArIChcclxuICAgICAgICAgICAgX3BhcmFtZXRlcnMuaW1hZ2VzW3R5cGVdIHx8XHJcbiAgICAgICAgICAgIF9wYXJhbWV0ZXJzLmltYWdlc1sndW5rbm93biddIHx8XHJcbiAgICAgICAgICAgIGltYWdlcy5VTktOT1dfSU1BR0VcclxuICAgICAgICApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0TGlua1N0eWxlICh0eXBlKSB7XHJcbiAgICAgICAgY29uc3QgbGlua1N0eWxlcyA9IF9wYXJhbWV0ZXJzLmxpbmtTdHlsZXM7XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdFN0eWxlID0gXy5jbG9uZURlZXAobGlua1N0eWxlc1snZGVmYXVsdC1saW5rLXN0eWxlJ10gfHwgREVGQVVMVF9MSU5LX1NUWUxFKTtcclxuXHJcbiAgICAgICAgbGV0IGxpbmtTdHlsZTtcclxuICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgbGlua1N0eWxlID0gZGVmYXVsdFN0eWxlIHx8IGRlZmF1bHRTdHlsZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobGlua1N0eWxlc1t0eXBlXSkge1xyXG4gICAgICAgICAgICAgICAgbGlua1N0eWxlID0gbGlua1N0eWxlc1t0eXBlXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxpbmtTdHlsZSA9IGRlZmF1bHRTdHlsZSB8fCBkZWZhdWx0U3R5bGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF8ubWVyZ2UoZGVmYXVsdFN0eWxlLCBsaW5rU3R5bGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9nZXRJY29uICh0eXBlKSB7XHJcbiAgICAgICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBfcGFyYW1ldGVycy5pY29uc1t0eXBlXTtcclxuXHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFRRR3JhbVVJIGZyb20gJ3Zpc3VhbGl6YXRpb25zLWxpYnJhcnknO1xyXG5pbXBvcnQgeyBWaWV3RnJhbWVCdXR0b25zIH0gZnJvbSAnLi92aWV3RnJhbWVCdXR0b25zJztcclxuaW1wb3J0IE1hcCBmcm9tICcuL21hcCc7XHJcbmltcG9ydCBJbmZvUGFuZWwgZnJvbSAnLi9pbmZvUGFuZWwnO1xyXG5pbXBvcnQgT3B0aW9uc1BhbmVsIGZyb20gJy4vb3B0aW9uc1BhbmVsJztcclxuXHJcbi8qKlxyXG4gKiBQYXJhbWV0ZXJzIHNldCBmb3IgYSB7QGxpbmsgVG9vbGJhcn0uXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlZmF1bHRVSU9wdGlvbnNcclxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudCB8IFN0cmluZ30gYmFzZUVsZW1lbnQgLSBSb290IEhUTUxFbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIExlZ2VuZERlc2NyaXB0b3I+fSBsZWdlbmRzXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuZWlnaGJvckdyYW1WaWV3Q2xhc3NcclxuICovXHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtEZWZhdWx0VUlPcHRpb25zfSBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gRGVmYXVsdFVJIChvcHRpb25zKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIC8vIEluaXRpYWxpemF0aW9uXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBjb25zdCBfbGluZWFnZUdyYW0gPSBvcHRpb25zLmxpbmVhZ2VHcmFtO1xyXG4gICAgY29uc3QgbWFya3VwID0gYFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0cS1sZy1kZWZhdWx0LXVzZXItdWlcIj5cclxuICAgICAgICAgICAgPGRpdiBpZD1cInRxTGdUb29sYmFyXCI+PC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgaWQ9XCJ0cUxnTWluaU1hcFwiPjwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGlkPVwidHFMZ0luZm9QYW5lbFwiPjwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGlkPVwidHFMZ09wdGlvbnNQYW5lbFwiPjwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGlkPVwidHFMZ1NlYXJjaFBhbmVsXCI+PC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgO1xyXG5cclxuICAgIGxldCBfZWw7XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYmFzZUVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgX2VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5iYXNlRWxlbWVudCk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmJhc2VFbGVtZW50ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIF9lbCA9IG9wdGlvbnMuYmFzZUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoIV9lbCkgcmV0dXJuO1xyXG4gICAgX2VsLmlubmVySFRNTCA9IG1hcmt1cDtcclxuXHJcbiAgICBjb25zdCB0cUxnVG9vbGJhciA9IF9lbC5xdWVyeVNlbGVjdG9yKCcjdHFMZ1Rvb2xiYXInKTtcclxuICAgIGNvbnN0IHRxTGdNaW5pTWFwID0gX2VsLnF1ZXJ5U2VsZWN0b3IoJyN0cUxnTWluaU1hcCcpO1xyXG4gICAgY29uc3QgdHFMZ0luZm9QYW5lbCA9IF9lbC5xdWVyeVNlbGVjdG9yKCcjdHFMZ0luZm9QYW5lbCcpO1xyXG4gICAgY29uc3QgdHFMZ09wdGlvbnNQYW5lbCA9IF9lbC5xdWVyeVNlbGVjdG9yKCcjdHFMZ09wdGlvbnNQYW5lbCcpO1xyXG4gICAgY29uc3QgdHFMZ1NlYXJjaFBhbmVsID0gX2VsLnF1ZXJ5U2VsZWN0b3IoJyN0cUxnU2VhcmNoUGFuZWwnKTtcclxuXHJcbiAgICBsZXQgX3pvb21pbmcgPSBfbGluZWFnZUdyYW0uem9vbSgpO1xyXG4gICAgbGV0IF9leHBhbmRBbGwgPSB0cnVlO1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGNvbnN0IF9jb2xvcmVkQnV0dG9ucyA9IG5ldyBWaWV3RnJhbWVCdXR0b25zKHtcclxuICAgICAgICBsaW5lYWdlR3JhbTogX2xpbmVhZ2VHcmFtXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IF9zd2l0Y2hlciA9IG5ldyBUUUdyYW1VSS5Td2l0Y2hlcih7XHJcbiAgICAgICAgc3RhdGVzOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlkOiAnbGluZWFnZURpYWdyYW0nLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdMaW5lYWdlIGRpYWdyYW0gdmlldycsXHJcbiAgICAgICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1tb2RhbC13aW5kb3cnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZDogJ2JpcmRFeWUnLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdCaXJkIGV5ZSB2aWV3JyxcclxuICAgICAgICAgICAgICAgIGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLWV5ZS1vcGVuJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIHZlcnRpY2FsT3JpZW50YXRpb246IHRydWUsXHJcbiAgICB9KTtcclxuXHJcbiAgICBfc3dpdGNoZXIub24oJ3N0YXRlLWNoYW5nZWQnLCB0YWJJZCA9PiB7XHJcbiAgICAgICAgX2xpbmVhZ2VHcmFtLnNldEN1cnJlbnRWaWV3KHRhYklkKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IF90b29sYmFyID0gbmV3IFRRR3JhbVVJLlRvb2xiYXIoe1xyXG4gICAgICAgIGJhc2VFbGVtZW50OiB0cUxnVG9vbGJhcixcclxuICAgICAgICB0b29sczogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZDogJ3RxTGdTZWFyY2gnLFxyXG4gICAgICAgICAgICAgICAgaWNvbjogJ2dseXBoaWNvbiBnbHlwaGljb24tc2VhcmNoJyxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnU2VhcmNoJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWQ6ICd0cUxnWm9vbUluJyxcclxuICAgICAgICAgICAgICAgIGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLXpvb20taW4nLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdab29tIGluJyxcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3pvb21pbmcgPSBfbGluZWFnZUdyYW0uem9vbUluKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Rvb2xiYXIucm9vdEh0bWwucXVlcnlTZWxlY3RvcignI3RxTGdab29tSW4nKS5kaXNhYmxlZCA9IChfem9vbWluZy5jdXIgPT09IF96b29taW5nLm1heCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Rvb2xiYXIucm9vdEh0bWwucXVlcnlTZWxlY3RvcignI3RxTGdab29tT3V0JykuZGlzYWJsZWQgPSAoX3pvb21pbmcuY3VyID09PSBfem9vbWluZy5taW4pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWQ6ICd0cUxnWm9vbU91dCcsXHJcbiAgICAgICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi16b29tLW91dCcsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogJ1pvb20gb3V0JyxcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3pvb21pbmcgPSBfbGluZWFnZUdyYW0uem9vbU91dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cUxnWm9vbUluJykuZGlzYWJsZWQgPSAoX3pvb21pbmcuY3VyID09PSBfem9vbWluZy5tYXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cUxnWm9vbU91dCcpLmRpc2FibGVkID0gKF96b29taW5nLmN1ciA9PT0gX3pvb21pbmcubWluKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlkOiAndHFMZ1pvb21Ub0ZpdCcsXHJcbiAgICAgICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1mdWxsc2NyZWVuJyxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnWm9vbSB0byBmaXQnLFxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfem9vbWluZyA9IF9saW5lYWdlR3JhbS56b29tVG9GaXQoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlkOiAndHFMZ1Jlc2V0JyxcclxuICAgICAgICAgICAgICAgIGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLXJlZnJlc2gnLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdSZXNldCBsYXlvdXQnLFxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfbGluZWFnZUdyYW0ucmVzZXRMYXlvdXQoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlkOiAndHFMZ0dhdGhlcicsXHJcbiAgICAgICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1wdXNocGluJyxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnR2F0aGVyIHJlbGF0aXZlcycsXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9saW5lYWdlR3JhbS5jb21iaW5lKCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZDogJ2V4cGFuZEFsbCcsXHJcbiAgICAgICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1yZXNpemUtZnVsbCcsXHJcbiAgICAgICAgICAgICAgICBpY29uMjogJ2dseXBoaWNvbiBnbHlwaGljb24tcmVzaXplLXNtYWxsJyxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnRXhwYW5kIGFsbCBub2RlcycsXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfZXhwYW5kQWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW5lYWdlR3JhbS5leHBhbmRBbGxOb2RlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW5lYWdlR3JhbS5jb2xsYXBzZUFsbE5vZGVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF9leHBhbmRBbGwgPSAhX2V4cGFuZEFsbDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF9jb2xvcmVkQnV0dG9ucyxcclxuICAgICAgICAgICAgX3N3aXRjaGVyLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZDogJ2luZm9QYW5lbEJ0bicsXHJcbiAgICAgICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1pbmZvLXNpZ24nLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdJbmZvIHBhbmVsJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWQ6ICd0cUxnT3B0aW9uc0J1dHRvbicsXHJcbiAgICAgICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1tZW51LWhhbWJ1cmdlcicsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgIH0pO1xyXG4gICAgc2VsZi50b29sYmFyID0gX3Rvb2xiYXI7XHJcblxyXG4gICAgX2xpbmVhZ2VHcmFtLm9uKCdjdXJyZW50LXZpZXctY2hhbmdlZCcsICh2aWV3SWQpID0+IHtcclxuICAgICAgICBjb25zdCBkaXNhYmxlZCA9ICh2aWV3SWQgIT09ICdsaW5lYWdlRGlhZ3JhbScpO1xyXG4gICAgICAgIF9zd2l0Y2hlci5zZXRTdGF0ZSh2aWV3SWQpO1xyXG4gICAgICAgIF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyNleHBhbmRBbGwnKS5kaXNhYmxlZCA9IGRpc2FibGVkO1xyXG4gICAgICAgIF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cUxnUmVzZXQnKS5kaXNhYmxlZCA9IGRpc2FibGVkO1xyXG4gICAgICAgIF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cUxnWm9vbUluJykuZGlzYWJsZWQgPSBkaXNhYmxlZDtcclxuICAgICAgICBfdG9vbGJhci5yb290SHRtbC5xdWVyeVNlbGVjdG9yKCcjdHFMZ1pvb21PdXQnKS5kaXNhYmxlZCA9IGRpc2FibGVkO1xyXG4gICAgICAgIF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cUxnWm9vbVRvRml0JykuZGlzYWJsZWQgPSBkaXNhYmxlZDtcclxuICAgIH0pO1xyXG5cclxuICAgIG5ldyBUUUdyYW1VSS5TZWFyY2hQYW5lbCh7XHJcbiAgICAgICAgYmFzZUVsZW1lbnQ6IHRxTGdTZWFyY2hQYW5lbCxcclxuICAgICAgICB0cmlnZ2VyQnV0dG9uOiBfdG9vbGJhci5yb290SHRtbC5xdWVyeVNlbGVjdG9yKCcjdHFMZ1NlYXJjaCcpLFxyXG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcbiAgICB9KTtcclxuXHJcbiAgICBuZXcgSW5mb1BhbmVsKHtcclxuICAgICAgICBiYXNlRWxlbWVudDogdHFMZ0luZm9QYW5lbCxcclxuICAgICAgICBhY3RpdmU6IGZhbHNlLFxyXG4gICAgICAgIHRyaWdnZXJCdXR0b246IF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyNpbmZvUGFuZWxCdG4nKSxcclxuICAgICAgICBsaW5lYWdlR3JhbTogX2xpbmVhZ2VHcmFtXHJcbiAgICB9KTtcclxuXHJcbiAgICBuZXcgT3B0aW9uc1BhbmVsKHtcclxuICAgICAgICBsaW5lYWdlR3JhbTogX2xpbmVhZ2VHcmFtLFxyXG4gICAgICAgIGJhc2VFbGVtZW50OiB0cUxnT3B0aW9uc1BhbmVsLFxyXG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgdHJpZ2dlckJ1dHRvbjogX3Rvb2xiYXIucm9vdEh0bWwucXVlcnlTZWxlY3RvcignI3RxTGdPcHRpb25zQnV0dG9uJyksXHJcbiAgICAgICAgbGVnZW5kczogb3B0aW9ucy5sZWdlbmRzLFxyXG4gICAgICAgIG9uUHJlc3NIZWxwOiBvcHRpb25zLm9uUHJlc3NIZWxwLFxyXG4gICAgfSk7XHJcblxyXG4gICAgbmV3IE1hcCh7XHJcbiAgICAgICAgYmFzZUVsZW1lbnQ6IHRxTGdNaW5pTWFwLFxyXG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgbGluZWFnZUdyYW06IF9saW5lYWdlR3JhbSxcclxuICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgICAgICB4OiAnY2FsYygxMDAlIC0gMjY1cHgpJyxcclxuICAgICAgICAgICAgeTogJ2NhbGMoMTAwJSAtIDI2NXB4KScsXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IERlZmF1bHRVSTtcclxuIiwiaW1wb3J0IFRRR3JhbVVJIGZyb20gJ3Zpc3VhbGl6YXRpb25zLWxpYnJhcnknO1xyXG5pbXBvcnQgeyBETUluZm9QYW5lbCB9IGZyb20gJy4vZG1JbmZvUGFuZWwnO1xyXG5cclxuLyoqXHJcbiAqIFBhcmFtZXRlcnMgc2V0IGZvciBhIHtAbGluayBUb29sYmFyfS5cclxuICogQHR5cGVkZWYge09iamVjdH0gRGVmYXVsdFVJT3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50IHwgU3RyaW5nfSBiYXNlRWxlbWVudCAtIFJvb3QgSFRNTEVsZW1lbnRcclxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgTGVnZW5kRGVzY3JpcHRvcj59IGxlZ2VuZHNcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5laWdoYm9yR3JhbVZpZXdDbGFzc1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0RlZmF1bHRVSU9wdGlvbnN9IG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBETURlZmF1bHRVSSAob3B0aW9ucykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICBjb25zdCBfZGVyaXZhdGlvbk1hcCA9IG9wdGlvbnMuZGVyaXZhdGlvbk1hcDtcclxuICAgIGNvbnN0IF9iYXNlID0gX2NyZWF0ZUJhc2UoXHJcbiAgICAgICAgX2dldEh0bWxFbGVtZW50KG9wdGlvbnMuYmFzZUVsZW1lbnQpLFxyXG4gICAgICAgIF9nZXRIdG1sRWxlbWVudChvcHRpb25zLmluZm9QYW5lbCksXHJcbiAgICApO1xyXG4gICAgbGV0IF9leHBhbmRBbGwgPSB0cnVlO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemF0aW9uXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGxldCBiYXNlVG9vbHMgPSBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ3RxRE1TZWFyY2gnLFxyXG4gICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1zZWFyY2gnLFxyXG4gICAgICAgICAgICBsYWJlbDogJ1NlYXJjaCcsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiBfb3BlbkNsb3NlU2VhcmNoUGFuZWwsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAndHFETUV4cG9ydFNWRycsXHJcbiAgICAgICAgICAgIGljb246ICd0b29sLWJhci1zdmctaWNvbicsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnRXhwb3J0IHRvIFNWRycsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBfZGVyaXZhdGlvbk1hcC5leHBvcnRUb1N2ZygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ3RxRE1FeHBvcnRQTkcnLFxyXG4gICAgICAgICAgICBpY29uOiAndG9vbC1iYXItcG5nLWljb24nLFxyXG4gICAgICAgICAgICBsYWJlbDogJ0V4cG9ydCB0byBQTkcnLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgX2Rlcml2YXRpb25NYXAuZXhwb3J0VG9QbmcoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICd0cVByaW50JyxcclxuICAgICAgICAgICAgaWNvbjogJ2dseXBoaWNvbiBnbHlwaGljb24tcHJpbnQnLFxyXG4gICAgICAgICAgICBsYWJlbDogJ1ByaW50JyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIF9kZXJpdmF0aW9uTWFwLnByaW50KCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAndHFETVpvb21JbicsXHJcbiAgICAgICAgICAgIGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLXpvb20taW4nLFxyXG4gICAgICAgICAgICBsYWJlbDogJ1pvb20gaW4nLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgX2Rlcml2YXRpb25NYXAuem9vbUluKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAndHFETVpvb21PdXQnLFxyXG4gICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi16b29tLW91dCcsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnWm9vbSBvdXQnLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgX2Rlcml2YXRpb25NYXAuem9vbU91dCgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ3RxRE1ab29tVG9GaXQnLFxyXG4gICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1mdWxsc2NyZWVuJyxcclxuICAgICAgICAgICAgbGFiZWw6ICdab29tIHRvIGZpdCcsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBfZGVyaXZhdGlvbk1hcC56b29tVG9GaXQoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdpbmZvUGFuZWxCdG4nLFxyXG4gICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1pbmZvLXNpZ24nLFxyXG4gICAgICAgICAgICBsYWJlbDogJ09wZW4gSW5mbyBwYW5lbCcsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAnZXhwYW5kQWxsJyxcclxuICAgICAgICAgICAgaWNvbjogJ2dseXBoaWNvbiBnbHlwaGljb24tcmVzaXplLWZ1bGwnLFxyXG4gICAgICAgICAgICBpY29uMjogJ2dseXBoaWNvbiBnbHlwaGljb24tcmVzaXplLXNtYWxsJyxcclxuICAgICAgICAgICAgbGFiZWw6ICdFeHBhbmQgYWxsJyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfZXhwYW5kQWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2Rlcml2YXRpb25NYXAuZXhwYW5kQWxsRWxlbWVudHMoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2Rlcml2YXRpb25NYXAuY29sbGFwc2VBbGxFbGVtZW50cygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX2V4cGFuZEFsbCA9ICFfZXhwYW5kQWxsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICBdO1xyXG5cclxuICAgIGlmIChvcHRpb25zLnRvb2xzKSB7XHJcbiAgICAgICAgb3B0aW9ucy50b29scy5mb3JFYWNoKCh0b29sKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0b29sLnBvc2l0aW9uIDwgYmFzZVRvb2xzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgYmFzZVRvb2xzLnNwbGljZSh0b29sLnBvc2l0aW9uLCAwLCB0b29sKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJhc2VUb29scy5wdXNoKHRvb2wpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZi50b29sYmFyID0gbmV3IFRRR3JhbVVJLlRvb2xiYXIoe1xyXG4gICAgICAgIGJhc2VFbGVtZW50OiBfYmFzZS50b29sYmFyLFxyXG4gICAgICAgIHRvb2xzOiBiYXNlVG9vbHNcclxuICAgIH0pO1xyXG5cclxuICAgIHNlbGYuaW5mb1BhbmVsID0gbmV3IERNSW5mb1BhbmVsKHtcclxuICAgICAgICBiYXNlRWxlbWVudDogX2Jhc2UuaW5mb1BhbmVsLFxyXG4gICAgICAgIHRyaWdnZXJCdXR0b246IHNlbGYudG9vbGJhci5yb290SHRtbC5xdWVyeVNlbGVjdG9yKCcjaW5mb1BhbmVsQnRuJylcclxuICAgIH0pO1xyXG5cclxuICAgIHNlbGYuaW5mb1BhbmVsLm9uKCdzaXplLWNoYW5nZWQnLCAoKSA9PiBfZGVyaXZhdGlvbk1hcC5yZXNldEZvY3VzKCkpO1xyXG5cclxuICAgIHNlbGYuaW5mb1BhbmVsLm9uKCdlbGVtZW50LWNsaWNrJywgZWxlbWVudElkID0+IHtcclxuICAgICAgICBfZGVyaXZhdGlvbk1hcC5zZXRTZWxlY3RlZEVsZW1lbnQoZWxlbWVudElkKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBsZXQgc2VhcmNoUGFuZVZpc2libGUgPSBmYWxzZTtcclxuICAgIGxldCBkZWJvdW5jZSA9IGZhbHNlO1xyXG4gICAgY29uc3Qgc2VhcmNoQnV0dG9uID0gc2VsZi50b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cURNU2VhcmNoJyk7XHJcbiAgICBjb25zdCBzZWFyY2hJbnB1dCA9IF9iYXNlLnNlYXJjaFBhbmVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XHJcbiAgICBzZWFyY2hJbnB1dC5vbmtleXVwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChkZWJvdW5jZSkgY2xlYXJUaW1lb3V0KGRlYm91bmNlKTtcclxuXHJcbiAgICAgICAgZGVib3VuY2UgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VhcmNoS2V5ID0gc2VhcmNoSW5wdXQudmFsdWU7XHJcbiAgICAgICAgICAgIF9kZXJpdmF0aW9uTWFwLnNldFNlYXJjaEtleShzZWFyY2hLZXkpO1xyXG4gICAgICAgIH0sIDMwMCk7XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gX29wZW5DbG9zZVNlYXJjaFBhbmVsICgpIHtcclxuICAgICAgICBpZiAoc2VhcmNoUGFuZVZpc2libGUpIHtcclxuICAgICAgICAgICAgX2Rlcml2YXRpb25NYXAuc2V0U2VhcmNoS2V5KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIF9iYXNlLnNlYXJjaFBhbmVsLmNsYXNzTGlzdC5hZGQoJ3RxLWRtLWhpZGRlbicpO1xyXG4gICAgICAgICAgICBzZWFyY2hCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgndHEtdWktc2VsZWN0ZWQnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfZGVyaXZhdGlvbk1hcC5zZXRTZWFyY2hLZXkoc2VhcmNoSW5wdXQudmFsdWUpO1xyXG4gICAgICAgICAgICBfYmFzZS5zZWFyY2hQYW5lbC5jbGFzc0xpc3QucmVtb3ZlKCd0cS1kbS1oaWRkZW4nKTtcclxuICAgICAgICAgICAgc2VhcmNoQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3RxLXVpLXNlbGVjdGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlYXJjaFBhbmVWaXNpYmxlID0gIXNlYXJjaFBhbmVWaXNpYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9nZXRIdG1sRWxlbWVudCAoYmFzZUVsZW1lbnQpIHtcclxuICAgICAgICBsZXQgYmFzZUh0bWw7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiYXNlRWxlbWVudCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgYmFzZUh0bWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChiYXNlRWxlbWVudCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYmFzZUVsZW1lbnQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGJhc2VIdG1sID0gYmFzZUVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYmFzZUh0bWwpIHRocm93IG5ldyBFcnJvcignQmFzZSBlbGVtZW50IGlzIG5vdCBmb3VuZCEnKTtcclxuICAgICAgICByZXR1cm4gYmFzZUh0bWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGh0bWwgbWFya3VwLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGh0bWxOb2RlIC0gUm9vdCBub2RlIGZvciBtYXJrdXBcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywgSFRNTEVsZW1lbnQ+fSAtIE1hcCBvZiBodG1sIGVsZW1lbnRzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jcmVhdGVCYXNlIChodG1sTm9kZSwgaW5mb1BhbmVsKSB7XHJcbiAgICAgICAgaHRtbE5vZGUuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgaHRtbE5vZGUudGFiSW5kZXggPSAxO1xyXG5cclxuICAgICAgICBjb25zdCB0b29sYmFyQmFzZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgICAgIHRvb2xiYXJCYXNlLmNsYXNzTmFtZSA9ICd0cS1kZXJpdmF0aW9uLW1hcF9fdG9vbGJhcic7XHJcbiAgICAgICAgdG9vbGJhckJhc2UuaWQgPSAndHEtZGVyaXZhdGlvbi1tYXAtdG9vbGJhcic7XHJcbiAgICAgICAgaHRtbE5vZGUuYXBwZW5kQ2hpbGQodG9vbGJhckJhc2UpO1xyXG5cclxuICAgICAgICBjb25zdCBzZWFyY2hQYW5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgICAgIHNlYXJjaFBhbmVsLmNsYXNzTmFtZSA9ICd0cS1kZXJpdmF0aW9uLW1hcF9zZWFyY2gtcGFuZSB0cS1kbS1oaWRkZW4nO1xyXG4gICAgICAgIHNlYXJjaFBhbmVsLmlubmVySFRNTCA9IGBcclxuICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICBpZD1cInRxLWRtLXNlYXJjaC1wYW5lXCJcclxuICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgIGNsYXNzPVwidHEtZGVyaXZhdGlvbi1tYXBfc2VhcmNoLXBhbmVfX2lucHV0XCI+XHJcbiAgICAgICAgICAgIDwvaW5wdXQ+XHJcbiAgICAgICAgYDtcclxuICAgICAgICBodG1sTm9kZS5hcHBlbmRDaGlsZChzZWFyY2hQYW5lbCk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNlYXJjaFBhbmVsOiBzZWFyY2hQYW5lbCxcclxuICAgICAgICAgICAgcm9vdEh0bWw6IGh0bWxOb2RlLFxyXG4gICAgICAgICAgICBpbmZvUGFuZWw6IGluZm9QYW5lbCxcclxuICAgICAgICAgICAgdG9vbGJhcjogdG9vbGJhckJhc2UsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZGVmYXVsdCBETURlZmF1bHRVSTtcclxuIiwiaW1wb3J0IFN1YnNjcmliYWJsZSBmcm9tICcuLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZSc7XG5pbXBvcnQgeyBMaW5rLCBOb2RlIH0gZnJvbSAnLi4vam9pbnRWaWV3cy9kZXJpdmF0aW9uTWFwL21hcEVsZW1lbnRzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogVGhlIGRhdGEgbW9kZWwgZm9yIGEge0BsaW5rIERNSW5mb1BhbmVsfSBvYmplY3QuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBETUluZm9QYW5lbE1vZGVsXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gYmFzZUVsZW1lbnQgLSBSb290IGZvciB0aGlzIHBhbmVsXG4gKiBAcHJvcGVydHkge0xpbmVhZ2VHcmFtfSBkZXJpdmF0aW9uTWFwIC0gRGVyaXZhdGlvbk1hcCBvYmplY3QuXG4gKi9cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0RNSW5mb1BhbmVsTW9kZWx9IC0gRGF0YSBtb2RlbC5cbiAqIEBmaXJlcyBzaXplLWNoYW5nZWRcbiAqIEBmaXJlcyBlbGVtZW50LWNsaWNrIChpZDpzdHJpbmcpXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIERNSW5mb1BhbmVsIChwYXJhbWV0ZXJzKSB7XG4gICAgU3Vic2NyaWJhYmxlLmFwcGx5KHRoaXMpOyAgIC8vIG1ha2UgdGhpcyBjbGFzcyBTdWJzY3JpYmFibGVcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGlmICghcGFyYW1ldGVycykgcGFyYW1ldGVycyA9IHt9O1xuXG4gICAgbGV0IF9zZWxlY3RlZEVsZW1lbnQgPSBwYXJhbWV0ZXJzLnNlbGVjdGVkRWxlbWVudDtcbiAgICBsZXQgX3dpZHRoID0gMjUwO1xuICAgIGxldCBfaGlkZGVuID0gdHJ1ZTtcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBzZWxmLnJvb3RIdG1sID0gX2dldEVsZW1lbnQocGFyYW1ldGVycy5iYXNlRWxlbWVudCk7XG5cbiAgICBjb25zdCBfY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgX2NvbnRhaW5lci5jbGFzc05hbWUgPSAndHEtbGctZG0tcHJvcGVydHktcGFuZS1jb250YWluZXInO1xuICAgIHNlbGYucm9vdEh0bWwuYXBwZW5kQ2hpbGQoX2NvbnRhaW5lcik7XG5cbiAgICBjb25zdCBfdHJpZ2dlckJ1dHRvbiA9IHBhcmFtZXRlcnMudHJpZ2dlckJ1dHRvbjtcbiAgICBfdHJpZ2dlckJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAoX2hpZGRlbikge1xuICAgICAgICAgICAgX3Nob3coKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBjb25zdCBfc2xpZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgX3NsaWRlci5jbGFzc05hbWUgPSAndHEtbGctZG0tc2xpZGVyJztcbiAgICBfc2xpZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChldmVudCkgPT4geyBfb25Nb3VzZWRvd24oZXZlbnQpOyB9KTtcbiAgICBfY29udGFpbmVyLmFwcGVuZENoaWxkKF9zbGlkZXIpO1xuXG4gICAgY29uc3QgX2Nsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgX2Nsb3NlQnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnQ2xvc2UgaW5mbyBwYW5lbCcpO1xuICAgIF9jbG9zZUJ1dHRvbi5jbGFzc05hbWUgPSAndHEtbGctZG0taGlkZS1idXR0b24nO1xuICAgIF9jbG9zZUJ1dHRvbi5vbmNsaWNrID0gKCkgPT4geyBfaGlkZSgpOyB9O1xuICAgIF9jb250YWluZXIuYXBwZW5kQ2hpbGQoX2Nsb3NlQnV0dG9uKTtcblxuICAgIHNlbGYuYm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgIF9jb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi5ib2R5KTtcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBzZWxmLmlkID0gJ2Rlcml2YXRpb25NYXBJbmZvUGFuZWwnO1xuICAgIHNlbGYucmVkcmF3ID0gX3JlZHJhdztcbiAgICBzZWxmLnNldFNlbGVjdGVkRWxlbWVudCA9IF9zZXRTZWxlY3RlZEVsZW1lbnQ7XG4gICAgc2VsZi5zaG93ID0gX3Nob3c7XG4gICAgc2VsZi5oaWRkZSA9IF9oaWRlO1xuICAgIC8vIHdpZHRoOiAyNTBweDtcblxuICAgIF9yZWRyYXcoKTtcblxuICAgIGZ1bmN0aW9uIF9yZWRyYXcgKCkge1xuICAgICAgICBpZiAoX2hpZGRlbikgcmV0dXJuO1xuICAgICAgICBsZXQgbWFya3VwO1xuICAgICAgICBpZiAoX3NlbGVjdGVkRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKF9zZWxlY3RlZEVsZW1lbnQgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgICAgICAgbWFya3VwID0gX2dldE5vZGVJbmZvKF9zZWxlY3RlZEVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfc2VsZWN0ZWRFbGVtZW50IGluc3RhbmNlb2YgTGluaykge1xuICAgICAgICAgICAgICAgIG1hcmt1cCA9IF9nZXRMaW5rSW5mbyhfc2VsZWN0ZWRFbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFya3VwID0gYFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtbGctZG0tcHJvcGVydHktcGFuZSB0cS1sZy1kbS1lbXB0eVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5Vbmtub3duIHR5cGUgb2YgZWxlbWVudDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFya3VwID0gYFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS1sZy1kbS1wcm9wZXJ0eS1wYW5lIHRxLWxnLWRtLWVtcHR5XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXY+U2VsZWN0IGEgZGlhZ3JhbSBlbGVtZW50PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICBgO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuYm9keS5zdHlsZS53aWR0aCA9IGAke193aWR0aH1weGA7XG4gICAgICAgIHNlbGYuYm9keS5pbm5lckhUTUwgPSBtYXJrdXA7XG5cbiAgICAgICAgaWYgKF9zZWxlY3RlZEVsZW1lbnQgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNlbGYuYm9keS5xdWVyeVNlbGVjdG9yQWxsKCcudHEtbGctZG0tY2hpbGQtYnV0dG9uJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baV0ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdlbGVtZW50LWNsaWNrJywgdGhpcy5pZCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKF9zZWxlY3RlZEVsZW1lbnQgaW5zdGFuY2VvZiBMaW5rKSB7XG4gICAgICAgICAgICBzZWxmLmJvZHkucXVlcnlTZWxlY3RvcignLnRxLWxnLWRtLXNvdXJjZS1idXR0b24nKS5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignZWxlbWVudC1jbGljaycsIHRoaXMuaWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYuYm9keS5xdWVyeVNlbGVjdG9yKCcudHEtbGctZG0tdGFyZ2V0LWJ1dHRvbicpLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdlbGVtZW50LWNsaWNrJywgdGhpcy5pZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8uLi5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9nZXROb2RlSW5mbyAobm9kZSkge1xuICAgICAgICBjb25zdCBjaGlscmVuID0gbm9kZS5jaGlsZHJlbi5tYXAoY2hpbGQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGA8ZGl2XG4gICAgICAgICAgICAgICAgaWQ9XCIke2NoaWxkLmlkfVwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCIke2NoaWxkLmxhYmVsfSgke2NoaWxkLmVuZHBvaW50SWR9KVwiXG4gICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwidHEtdWktcHJvcGVydHktYnV0dG9uIHRxLWxnLWRtLWNoaWxkLWJ1dHRvblwiPlxuICAgICAgICAgICAgICAgICR7Y2hpbGQubGFiZWx9XG4gICAgICAgICAgICA8L2Rpdj5gO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS1sZy1kbS1wcm9wZXJ0eS1wYW5lXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidHEtbGFiZWxcIj5JRDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPVwiJHtub2RlLmVuZHBvaW50SWR9XCJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCIke25vZGUuZW5kcG9pbnRJZH1cIiB0eXBlPVwidGV4dFwiICBjbGFzcz1cInRxLXVpLXByb3BlcnR5XCIgZGlzYWJsZWQ+XG4gICAgICAgICAgICAgICAgPC9pbnB1dD5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0cS1sYWJlbFwiPkRpYWdyYW0gSUQ8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cIiR7bm9kZS5pZH1cIlxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIiR7bm9kZS5pZH1cIlxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwidHEtdWktcHJvcGVydHlcIlxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD5cbiAgICAgICAgICAgICAgICA8L2lucHV0PlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInRxLWxhYmVsXCI+TGFiZWw8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB2YWx1ZT1cIiR7bm9kZS5sYWJlbH1cIiB0aXRsZT1cIiR7bm9kZS5sYWJlbH1cIiB0eXBlPVwidGV4dFwiIGNsYXNzPVwidHEtdWktcHJvcGVydHlcIiBkaXNhYmxlZD48L2lucHV0PlxuICAgICAgICAgICAgICAgICR7Y2hpbHJlbi5sZW5ndGggPiAwID8gJzxsYWJlbCBjbGFzcz1cInRxLWxhYmVsXCI+Q2hpbGRyZW48L2xhYmVsPicgOiAnJ31cbiAgICAgICAgICAgICAgICAke2NoaWxyZW59XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZ2V0TGlua0luZm8gKGxpbmspIHtcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS1sZy1kbS1wcm9wZXJ0eS1wYW5lXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidHEtbGFiZWxcIj5MYWJlbDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPGlucHV0IHZhbHVlPVwiJHtsaW5rLmxhYmVsfVwiIHRpdGxlPVwiJHtsaW5rLmxhYmVsfVwiIHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJ0cS11aS1wcm9wZXJ0eVwiIGRpc2FibGVkPjwvaW5wdXQ+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidHEtbGFiZWxcIj5Tb3VyY2U8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCIke2xpbmsuc291cmNlLmlkfVwiXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiJHtsaW5rLnNvdXJjZS5sYWJlbH0oJHtsaW5rLnNvdXJjZS5lbmRwb2ludElkfSlcIlxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwidHEtdWktcHJvcGVydHktYnV0dG9uIHRxLWxnLWRtLXNvdXJjZS1idXR0b25cIj5cbiAgICAgICAgICAgICAgICAgICAgJHtsaW5rLnNvdXJjZS5sYWJlbH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0cS1sYWJlbFwiPlRhcmdldDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cIiR7bGluay50YXJnZXQuaWR9XCJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCIke2xpbmsudGFyZ2V0LmxhYmVsfSgke2xpbmsudGFyZ2V0LmVuZHBvaW50SWR9KVwiXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJ0cS11aS1wcm9wZXJ0eS1idXR0b24gdHEtbGctZG0tdGFyZ2V0LWJ1dHRvblwiPlxuICAgICAgICAgICAgICAgICAgICAke2xpbmsudGFyZ2V0LmxhYmVsfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIGA7XG4gICAgfVxuXG4gICAgY29uc3QgU0VMRUNURURfQ0xBU1MgPSAndHEtdWktc2VsZWN0ZWQnO1xuICAgIGZ1bmN0aW9uIF9zaG93ICgpIHtcbiAgICAgICAgX2hpZGRlbiA9IGZhbHNlO1xuICAgICAgICBfY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBudWxsO1xuICAgICAgICBfdHJpZ2dlckJ1dHRvbi5jbGFzc0xpc3QuYWRkKFNFTEVDVEVEX0NMQVNTKTtcbiAgICAgICAgX3JlZHJhdygpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3NpemUtY2hhbmdlZCcpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaGlkZSAoKSB7XG4gICAgICAgIF9oaWRkZW4gPSB0cnVlO1xuICAgICAgICBfY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIF90cmlnZ2VyQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoU0VMRUNURURfQ0xBU1MpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3NpemUtY2hhbmdlZCcpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfb25Nb3VzZWRvd24gKGV2ZW50KSB7XG4gICAgICAgIGxldCBzdGFydFggPSAwO1xuICAgICAgICBjb25zdCBNSU5fV0lEVEggPSAxMDA7XG5cbiAgICAgICAgaWYgKGV2ZW50LnBhZ2VYKSBzdGFydFggPSBldmVudC5wYWdlWDtcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuY2xpZW50WCkgc3RhcnRYID0gZXZlbnQuY2xpZW50WDtcblxuICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfb25jaGFuZ2UpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfb25tb3VzZXVwKTtcblxuICAgICAgICBmdW5jdGlvbiBfb25jaGFuZ2UgKGV2ZW50KSB7XG4gICAgICAgICAgICBsZXQgZW5kWCA9IDA7XG5cbiAgICAgICAgICAgIGlmIChldmVudC5wYWdlWCkgZW5kWCA9IGV2ZW50LnBhZ2VYO1xuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuY2xpZW50WCkgZW5kWCA9IGV2ZW50LmNsaWVudFg7XG5cbiAgICAgICAgICAgIGNvbnN0IGRpZmZYID0gc3RhcnRYIC0gZW5kWDtcbiAgICAgICAgICAgIHN0YXJ0WCA9IGVuZFg7XG5cbiAgICAgICAgICAgIF93aWR0aCArPSBkaWZmWDtcbiAgICAgICAgICAgIF93aWR0aCA9IE1hdGgubWF4KE1JTl9XSURUSCwgX3dpZHRoKTtcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2l6ZS1jaGFuZ2VkJyk7XG4gICAgICAgICAgICBfcmVkcmF3KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfb25tb3VzZXVwIChldmVudCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX21vdXNlTW92ZSkge1xuICAgICAgICAgICAgICAgIF9vbmNoYW5nZShldmVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5fbW91c2VNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5Lm9ubW91c2Vtb3ZlID0gZG9jdW1lbnQuYm9keS5vbm1vdXNldXAgPSBudWxsO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfb25jaGFuZ2UpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX29ubW91c2V1cCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9zZXRTZWxlY3RlZEVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICAgICAgX3NlbGVjdGVkRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIF9yZWRyYXcoKTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBETUluZm9QYW5lbDtcblxuZnVuY3Rpb24gX2dldEVsZW1lbnQgKGVsKSB7XG4gICAgbGV0IGVsZW1lbnQ7XG4gICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZWxlbWVudCA9IGVsO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbiIsImltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IFRRR3JhbVVJIGZyb20gJ3Zpc3VhbGl6YXRpb25zLWxpYnJhcnknO1xyXG5pbXBvcnQgU3Vic2NyaWJhYmxlIGZyb20gJy4uL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlJztcclxuXHJcbi8qKlxyXG4gKiBUaGUgZGF0YSBtb2RlbCBmb3IgYSB7QGxpbmsgSW5mb1BhbmVsfSBvYmplY3QuXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEluZm9QYW5lbE1vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBiYXNlRWxlbWVudCAtIFJvb3QgZm9yIHRoaXMgcGFuZWxcclxuICogQHByb3BlcnR5IHtMaW5lYWdlR3JhbX0gbGluZWFnZUdyYW0gLSBMaW5lYWdlR3JhbSBvYmplY3QuXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYWN0aXZlIC0gZmFsc2UgLSBjb2xsYXBzZWQsIHRydWUgLSBleHBhbmRlZFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gdHJpZ2dlckJ1dHRvblxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvblByZXNzRXh0ZXJuYWxcclxuICovXHJcblxyXG4vKipcclxuICogQ2xhc3Mgd2hpY2ggaXMgYSBzaW1wbGUgVUkgcGFuZWwuXHJcbiAqIFRoaXMgcGFuZWwgY2FuIHJlcHJlc2VudCBhbiBpbmZvcm1hdGlvbiBhYm91dCBzZWxlY3RlZCBlbGVtZW50XHJcbiAqIGFuZCBhbHNvLCBpdCBzdXBwb3J0cyBzaW1wbGUgbmF2aWdhdGlvbiBiZXR3ZWVuIGVsZW1lbnRzLlxyXG4gKiBAY2xhc3NcclxuICogQHBhcmFtIHtJbmZvUGFuZWxNb2RlbH0gb3B0aW9ucyAtIERhdGEgbW9kZWwuXHJcbiAqIEBmaXJlcyBzdGF0ZS1jaGFuZ2VkXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBJbmZvUGFuZWwgKG9wdGlvbnMpIHtcclxuICAgIFN1YnNjcmliYWJsZS5hcHBseSh0aGlzKTsgICAvLyBtYWtlIHRoaXMgY2xhc3MgU3Vic2NyaWJhYmxlXHJcblxyXG4gICAgY29uc3QgaW5mb1RlbXBsYXRlID0gbmV3IFRRR3JhbVVJLkluZm9QYW5lbCh7bGF1bmNoRXh0ZXJuYWw6b3B0aW9ucy5saW5lYWdlR3JhbS5sYXVuY2hFeHRlcm5hbH0pO1xyXG5cclxuICAgIGNvbnN0IF9saW5lYWdlR3JhbSA9IG9wdGlvbnMubGluZWFnZUdyYW07XHJcblxyXG4gICAgVFFHcmFtVUkuRmx5aW5nUGFuZWwuYXBwbHkodGhpcywgW3tcclxuICAgICAgICBiYXNlRWxlbWVudDogb3B0aW9ucy5iYXNlRWxlbWVudCxcclxuICAgICAgICBhY3RpdmU6IG9wdGlvbnMuYWN0aXZlLFxyXG4gICAgICAgIGhlYWRlcjogJ0luZm8gcGFuZWwnLFxyXG4gICAgICAgIHRyaWdnZXJCdXR0b246IG9wdGlvbnMudHJpZ2dlckJ1dHRvbixcclxuICAgICAgICBsYXVuY2hFeHRlcm5hbDogb3B0aW9ucy5vblByZXNzRXh0ZXJuYWwsXHJcbiAgICAgICAgZW1wdHlCb2R5OiBmYWxzZSxcclxuICAgICAgICBzaXplOiB7IHdpZHRoOiAnMzAwcHgnLCBoZWlnaHQ6ICc0NTBweCcgfSxcclxuICAgICAgICBib2R5OiBpbmZvVGVtcGxhdGUsXHJcbiAgICAgICAgcmVzaXphYmxlOiB0cnVlLFxyXG4gICAgfV0pO1xyXG5cclxuICAgIF9saW5lYWdlR3JhbS5vbignc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkJywgZnVuY3Rpb24gKGVsZW1lbnRNb2RlbCkge1xyXG4gICAgICAgIGNvbnN0IGdyYXBoTW9kZWwgPSBfbGluZWFnZUdyYW0uZ2V0R3JhcGhNb2RlbCgpO1xyXG4gICAgICAgIGNvbnN0IG5vZGVNYXAgPSBncmFwaE1vZGVsLm1hcHMubm9kZU1hcDtcclxuXHJcbiAgICAgICAgaWYgKGVsZW1lbnRNb2RlbCkge1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBub2RlTWFwW2VsZW1lbnRNb2RlbC5zb3VyY2VdO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBub2RlTWFwW2VsZW1lbnRNb2RlbC50YXJnZXRdO1xyXG5cclxuICAgICAgICAgICAgbGV0IGRhdGE7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50TW9kZWwubGlua1R5cGUgJiYgZWxlbWVudE1vZGVsLmdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0ge307XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50TW9kZWwuZ3JvdXAuZm9yRWFjaChlbCA9PiBkYXRhID0gXy5tZXJnZShkYXRhLCBlbC5kYXRhKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gXy5jbG9uZURlZXAoZWxlbWVudE1vZGVsLmRhdGEpIHx8IHt9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZWxlbWVudE1vZGVsLmxpbmtUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudE1vZGVsLmxpbmtUeXBlICYmICFlbGVtZW50TW9kZWwuZ3JvdXApIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhWydMaW5rIHR5cGUnXSA9IGVsZW1lbnRNb2RlbC5saW5rVHlwZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZU1hcCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRNb2RlbC5ncm91cC5mb3JFYWNoKGVsID0+IHR5cGVNYXBbZWwubGlua1R5cGVdID0gZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVzID0gT2JqZWN0LmtleXModHlwZU1hcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVsnTGluayB0eXBlJ10gPSBlbGVtZW50TW9kZWwubGlua1R5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbJ0dyb3VwZWQgdHlwZXMnXSA9IHR5cGVzLmpvaW4oJywgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVsnTGluayB0eXBlJ10gPSB0eXBlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVsnSURzJ10gPSBlbGVtZW50TW9kZWwuZ3JvdXAubWFwKGVsID0+IGVsLmlkKS5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZWxlbWVudE1vZGVsLm9mZnNldCkgZGF0YVsnT2Zmc2V0J10gPSBlbGVtZW50TW9kZWwub2Zmc2V0O1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudE1vZGVsLnZpZXdGcmFtZSkgZGF0YVsnVmlldyBmcmFtZSddID0gZWxlbWVudE1vZGVsLnZpZXdGcmFtZTtcclxuXHJcbiAgICAgICAgICAgIGluZm9UZW1wbGF0ZS5zZXRTZWxlY3RlZEVsZW1lbnQoe1xyXG4gICAgICAgICAgICAgICAgaWQ6IGVsZW1lbnRNb2RlbC5pZCxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBlbGVtZW50TW9kZWwubGFiZWwsXHJcbiAgICAgICAgICAgICAgICByZXNvdXJjZTogZWxlbWVudE1vZGVsLnJlc291cmNlLFxyXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VUeXBlOiBlbGVtZW50TW9kZWwucmVzb3VyY2VUeXBlLFxyXG4gICAgICAgICAgICAgICAgZGlhZ3JhbVR5cGU6IGVsZW1lbnRNb2RlbC5kaWFncmFtVHlwZSxcclxuICAgICAgICAgICAgICAgIHR5cGVzOiBlbGVtZW50TW9kZWwudHlwZUlkLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHNvdXJjZS5pZCxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogc291cmNlLmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgfSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0ID8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0YXJnZXQuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRhcmdldC5sYWJlbCxcclxuICAgICAgICAgICAgICAgIH0gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgcmVsYXRpb25zOiBfZ2V0UmVsYXRpb25zKGVsZW1lbnRNb2RlbCwgZ3JhcGhNb2RlbCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGluZm9UZW1wbGF0ZS5zZXRTZWxlY3RlZEVsZW1lbnQodW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpbmZvVGVtcGxhdGUub24oJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIGZ1bmN0aW9uIChlbGVtZW50SWQpIHtcclxuICAgICAgICBfbGluZWFnZUdyYW0uc2V0U2VsZWN0ZWRFbGVtZW50KGVsZW1lbnRJZCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0QXNwZWN0cyAoZWxlbWVudE1vZGVsLCBub2Rlcykge1xyXG4gICAgICAgIGNvbnN0IGFzcGVjdHMgPSBbXTtcclxuICAgICAgICBpZiAoZWxlbWVudE1vZGVsLnJlc291cmNlKSB7XHJcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5yZXNvdXJjZSA9PT0gZWxlbWVudE1vZGVsLnJlc291cmNlKSBhc3BlY3RzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFzcGVjdHMucHVzaChlbGVtZW50TW9kZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXNwZWN0cztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0UmVsYXRpb25zIChlbGVtZW50TW9kZWwsIGdyYXBoTW9kZWwpIHtcclxuICAgICAgICBjb25zdCBzb3VyY2VNYXAgPSBncmFwaE1vZGVsLm1hcHMuc291cmNlTWFwO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldE1hcCA9IGdyYXBoTW9kZWwubWFwcy50YXJnZXRNYXA7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IGdyYXBoTW9kZWwubWFwcy5ub2RlTWFwO1xyXG5cclxuICAgICAgICBjb25zdCBpZHMgPSBfZ2V0QXNwZWN0cyhlbGVtZW50TW9kZWwsIGdyYXBoTW9kZWwubm9kZXMpLm1hcChhID0+IGEuaWQpO1xyXG5cclxuICAgICAgICBsZXQgc291cmNlcyA9IFtdO1xyXG4gICAgICAgIGxldCB0YXJnZXRzID0gW107XHJcbiAgICAgICAgaWRzLmZvckVhY2goaWQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc291cmNlTWFwW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlcyA9IHNvdXJjZXMuY29uY2F0KHNvdXJjZU1hcFtpZF0ubWFwKGwgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwW2wuc291cmNlXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG5vZGUubGFiZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0TWFwW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KHRhcmdldE1hcFtpZF0ubWFwKGwgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwW2wudGFyZ2V0XTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG5vZGUubGFiZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoc291cmNlcyAmJiBzb3VyY2VzLmxlbmd0aCA+IDAgfHwgdGFyZ2V0cyAmJiB0YXJnZXRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGluY29taW5nczogc291cmNlcyxcclxuICAgICAgICAgICAgICAgIG91dGdvaW5nczogdGFyZ2V0cyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgSW5mb1BhbmVsO1xyXG4iLCJpbXBvcnQgVFFHcmFtVUkgZnJvbSAndmlzdWFsaXphdGlvbnMtbGlicmFyeSc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTWFwIChvcHRpb25zKSB7XHJcbiAgICBjb25zdCBtYXJrdXAgPSBgXHJcbiAgICAgICAgPGRpdiBpZD1cIm1hcEJ1dHRvblwiIGNsYXNzPVwidHEtbGctbWFwXCI+XHJcbiAgICAgICAgICAgIDxzcGFuIHRpdGxlPVwiTWluaSBtYXBcIiBjbGFzcz1cInRxLWxnLWNvbGxhcHNlLXBhbmVsX2JvZHlfX2xhYmVsIGdseXBoaWNvbiBnbHlwaGljb24tcGljdHVyZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGlkPVwiYmFzZUVsZW1lbnRGb3JNYXBcIj48L2Rpdj5cclxuICAgIGA7XHJcbiAgICBjb25zdCBfbGluZWFnZUdyYW0gPSBvcHRpb25zLmxpbmVhZ2VHcmFtO1xyXG5cclxuICAgIGxldCBfZWw7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmJhc2VFbGVtZW50ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIF9lbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMuYmFzZUVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5iYXNlRWxlbWVudCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBfZWwgPSBvcHRpb25zLmJhc2VFbGVtZW50O1xyXG4gICAgfVxyXG4gICAgaWYgKCFfZWwpIHJldHVybjtcclxuXHJcbiAgICBfZWwuaW5uZXJIVE1MID0gbWFya3VwO1xyXG5cclxuXHJcbiAgICBjb25zdCBtYXBGbHlpbmdQYW5lbCA9IG5ldyBUUUdyYW1VSS5GbHlpbmdQYW5lbCh7XHJcbiAgICAgICAgYmFzZUVsZW1lbnQ6IF9lbC5xdWVyeVNlbGVjdG9yKCcjYmFzZUVsZW1lbnRGb3JNYXAnKSxcclxuICAgICAgICBhY3RpdmU6IG9wdGlvbnMuYWN0aXZlLFxyXG4gICAgICAgIGhlYWRlcjogJ01hcCcsXHJcbiAgICAgICAgdHJpZ2dlckJ1dHRvbjogX2VsLnF1ZXJ5U2VsZWN0b3IoJyNtYXBCdXR0b24nKSxcclxuICAgICAgICBlbXB0eUJvZHk6IGZhbHNlLFxyXG4gICAgICAgIHNpemU6IHsgd2lkdGg6ICcyNTBweCcsIGhlaWdodDogJzI1MHB4J30sXHJcbiAgICAgICAgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb24sXHJcbiAgICAgICAgYm9keTogJycsXHJcbiAgICAgICAgcmVzaXphYmxlOiB0cnVlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgX2xpbmVhZ2VHcmFtLnNldFJvb3RIdG1sRm9yTWFwKG1hcEZseWluZ1BhbmVsLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJy50cS11aS1ib2R5X2NvbnRhaW5lcicpKTtcclxuICAgIFxyXG4gICAgbWFwRmx5aW5nUGFuZWwub24oJ3NpemUtY2hhbmdlZCcsICgpID0+IHtcclxuICAgICAgICBfbGluZWFnZUdyYW0ucmVmcmVzaCgnZ3JhcGhNYXAnKTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IE1hcDtcclxuIiwiaW1wb3J0IFN1YnNjcmliYWJsZSBmcm9tICcuLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZSc7XHJcbmltcG9ydCBUUUdyYW1VSSBmcm9tICd2aXN1YWxpemF0aW9ucy1saWJyYXJ5JztcclxuXHJcbi8qKlxyXG4gKiBUaGUgZGF0YSBtb2RlbCBmb3IgYSB7QGxpbmsgT3B0aW9uc1BhbmVsfSBvYmplY3QuXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNQYW5lbE1vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBiYXNlRWxlbWVudCAtIFJvb3QgZm9yIHRoaXMgcGFuZWxcclxuICogQHByb3BlcnR5IHtMaW5lYWdlR3JhbX0gbGluZWFnZUdyYW0gLSBMaW5lYWdlR3JhbSBvYmplY3QuXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYWN0aXZlIC0gZmFsc2UgLSBjb2xsYXBzZWQsIHRydWUgLSBleHBhbmRlZFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gdHJpZ2dlckJ1dHRvblxyXG4gKi9cclxuXHJcbi8qKiBcclxuICogQ2xhc3Mgd2hpY2ggaXMgYSBzaW1wbGUgVUkgcGFuZWwuXHJcbiAqIFRoaXMgcGFuZWwgY2FuIHJlcHJlc2VudCBhbiBpbmZvcm1hdGlvbiBhYm91dCBzZWxlY3RlZCBlbGVtZW50XHJcbiAqIGFuZCBhbHNvLCBpdCBzdXBwb3J0cyBzaW1wbGUgbmF2aWdhdGlvbiBiZXR3ZWVuIGVsZW1lbnRzLlxyXG4gKiBAY2xhc3NcclxuICogQHBhcmFtIHtPcHRpb25zUGFuZWxNb2RlbH0gb3B0aW9ucyAtIERhdGEgbW9kZWwuXHJcbiAqIEBmaXJlcyBzdGF0ZS1jaGFuZ2VkXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBPcHRpb25zUGFuZWwgKG9wdGlvbnMpIHtcclxuICAgIFN1YnNjcmliYWJsZS5hcHBseSh0aGlzKTsgICAvLyBtYWtlIHRoaXMgY2xhc3MgU3Vic2NyaWJhYmxlXHJcblxyXG4gICAgY29uc3QgbGVnZW5kcyA9IG9wdGlvbnMubGVnZW5kcyB8fCBbXTtcclxuICAgIGNvbnN0IF9saW5lYWdlR3JhbSA9IG9wdGlvbnMubGluZWFnZUdyYW07XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICBUUUdyYW1VSS5GbHlpbmdQYW5lbC5hcHBseSh0aGlzLCBbe1xyXG4gICAgICAgIGJhc2VFbGVtZW50OiBvcHRpb25zLmJhc2VFbGVtZW50LFxyXG4gICAgICAgIGFjdGl2ZTogb3B0aW9ucy5hY3RpdmUsXHJcbiAgICAgICAgaGVhZGVyOiAnT3B0aW9ucyBwYW5lbCcsXHJcbiAgICAgICAgdHJpZ2dlckJ1dHRvbjogb3B0aW9ucy50cmlnZ2VyQnV0dG9uLFxyXG4gICAgICAgIGVtcHR5Qm9keTogdHJ1ZSxcclxuICAgICAgICBzaXplOiB7XHJcbiAgICAgICAgICAgIHdpZHRoOiAnNDAwcHgnLFxyXG4gICAgICAgICAgICBoZWlnaHQ6ICc1MDBweCcsXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVCYWNrZ3JvdW5kOiB0cnVlLFxyXG4gICAgICAgIGJvZHk6IG5ldyBUUUdyYW1VSS5UYWJQYW5lbCh7XHJcbiAgICAgICAgICAgIHRhYnM6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogJ3RxVWlHZW5lcmFsJyxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ0dlbmVyYWwnLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImRpc3BsYXlHcm91cFwiIGNsYXNzPVwidHEtbGFiZWxcIj5EaXNwbGF5PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImRpc3BsYXlHcm91cFwiIGNsYXNzPVwidHEtdWktZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1ncm91cF9fc2VsZWN0LWxpbmVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGlkPVwidHFVaU9yaWVudGF0aW9uXCIgc2l6ZT1cIjFcIiBuYW1lPVwib3JpZW50YXRpb25cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImxlZnQtdG8tcmlnaHRcIj5sZWZ0IHRvIHJpZ2h0PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyaWdodC10by1sZWZ0XCI+cmlnaHQgdG8gbGVmdDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwidG9wLXRvLWJvdHRvbVwiPnRvcCB0byBib3R0b208L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImJvdHRvbS10by10b3BcIj5ib3R0b20gdG8gdG9wPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+IC0gR3JhcGggb3JpZW50YXRpb248L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1ncm91cF9fc2VsZWN0LWxpbmVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGlkPVwidHFVaVJvdXRpbmdcIiBzaXplPVwiMVwiIG5hbWU9XCJyb3V0aW5nXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJtZXRyb1wiPk1ldHJvPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJsZ3JvdXRlclwiPlJhaWxSb2FkPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJub3JtYWxcIj5Ob3JtYWw8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm1hbmhhdHRhblwiPk1hbmhhdHRhbjwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPiAtIExpbmsgcm91dGluZzwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWdyb3VwX19zZWxlY3QtbGluZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgaWQ9XCJ0cVVpTGF5b3V0XCIgc2l6ZT1cIjFcIiBuYW1lPVwibGF5b3V0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJzYW5rZXlcIj5TYW5rZXk8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImZsb3ctZGlyZWN0ZWRcIj5GbG93LWRpcmVjdGVkPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+IC0gTGF5b3V0IGFsZ29yaXRobTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWdyb3VwX19jaGVjay1ib3gtbGluZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPjxpbnB1dCBpZD1cInRxVWlFeHBhbmRDb2xsYXBzZVwiIHR5cGU9XCJjaGVja2JveFwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj5FeHBhbmQgbm9kZSBjb250YWluZXJzIHRvIHNob3cgZnVsbCB0ZXh0IGxhYmVsczwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWdyb3VwX19jaGVjay1ib3gtbGluZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPjxpbnB1dCBpZD1cInRxVWlDbGlwTm9kZXNcIiB0eXBlPVwiY2hlY2tib3hcIj48L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+Tm9kZXMgdHJpbW1pbmcgb24gYm9yZGVyczwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImV4cG9ydEdyb3VwXCIgY2xhc3M9XCJ0cS1sYWJlbFwiPkV4cG9ydCBhczwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJleHBvcnRHcm91cFwiIGNsYXNzPVwidHEtdWktZ3JvdXAgdHEtdWktZXhwb3J0LWdyb3VwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGlkPVwidHFVaUV4cG9ydFNWR1wiIHRpdGxlPVwiRXhwb3J0IGRpYWdyYW0gdG8gU1ZHXCIgY2xhc3M9XCJ0cS1idXR0b25cIj5TVkc8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gaWQ9XCJ0cVVpRXhwb3J0UE5HXCIgdGl0bGU9XCJFeHBvcnQgZGlhZ3JhbSB0byBQTkdcIiBjbGFzcz1cInRxLWJ1dHRvblwiPlBORzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBpZD1cInRxVWlQcmludFwiIHRpdGxlPVwiUHJpbnRcIiBjbGFzcz1cInRxLWJ1dHRvblwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1wcmludFwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImhvd1RvVXNlR3JvdXBcIiBjbGFzcz1cInRxLWxhYmVsXCI+SG93IHRvIHVzZTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJob3dUb1VzZUdyb3VwXCIgY2xhc3M9XCJ0cS11aS1ncm91cCB0cS11aS1vcHQtZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gaWQ9XCJ0cVVpSGVscEJ0blwiIHRpdGxlPVwiSGVscFwiIGNsYXNzPVwidHEtYnV0dG9uXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLWluZm8tc2lnblwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJ0cS1idXR0b25cIiB0aXRsZT1cIkRvY3VtZW50YXRpb25cIiBocmVmPVwiLi9kb2N1bWVudGF0aW9uL2luZGV4Lmh0bWxcIj5ET0M8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIGAsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiAndHFVaUxlZ2VuZHMnLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnTGVnZW5kcycsXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keTogbmV3IFRRR3JhbVVJLkxlZ2VuZHMoe2xlZ2VuZHM6IGxlZ2VuZHN9KSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KSxcclxuICAgIH1dKTtcclxuXHJcbiAgICAvLyBHZW5lcmFsXHJcblxyXG4gICAgY29uc3Qgc3ZnQnV0dG9uID0gc2VsZi5yb290SHRtbC5xdWVyeVNlbGVjdG9yKCcjdHFVaUV4cG9ydFNWRycpO1xyXG4gICAgY29uc3QgcG5nQnV0dG9uID0gc2VsZi5yb290SHRtbC5xdWVyeVNlbGVjdG9yKCcjdHFVaUV4cG9ydFBORycpO1xyXG4gICAgY29uc3QgcHJpbnRCdXR0b24gPSBzZWxmLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cVVpUHJpbnQnKTtcclxuICAgIGNvbnN0IGV4cGFuZENvbGxhcHNlID0gc2VsZi5yb290SHRtbC5xdWVyeVNlbGVjdG9yKCcjdHFVaUV4cGFuZENvbGxhcHNlJyk7XHJcbiAgICBjb25zdCBvcmllbnRhdGlvbiA9IHNlbGYucm9vdEh0bWwucXVlcnlTZWxlY3RvcignI3RxVWlPcmllbnRhdGlvbicpO1xyXG4gICAgY29uc3Qgcm91dGluZyA9IHNlbGYucm9vdEh0bWwucXVlcnlTZWxlY3RvcignI3RxVWlSb3V0aW5nJyk7XHJcbiAgICBjb25zdCBsYXlvdXQgPSBzZWxmLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cVVpTGF5b3V0Jyk7XHJcbiAgICBjb25zdCBjbGlwcGluZyA9IHNlbGYucm9vdEh0bWwucXVlcnlTZWxlY3RvcignI3RxVWlDbGlwTm9kZXMnKTtcclxuICAgIGNvbnN0IGhlbHBCdXR0b24gPSBzZWxmLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cVVpSGVscEJ0bicpO1xyXG5cclxuICAgIF9saW5lYWdlR3JhbS5vbignY3VycmVudC12aWV3LWNoYW5nZWQnLCBmdW5jdGlvbiAodmlld0lkKSB7XHJcbiAgICAgICAgc3ZnQnV0dG9uLmRpc2FibGVkID0gKHZpZXdJZCAhPT0gJ2xpbmVhZ2VEaWFncmFtJyk7XHJcbiAgICAgICAgZXhwYW5kQ29sbGFwc2UuZGlzYWJsZWQgPSAodmlld0lkICE9PSAnbGluZWFnZURpYWdyYW0nKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHN2Z0J1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9saW5lYWdlR3JhbS5leHBvcnQoe1xyXG4gICAgICAgICAgICB0eXBlOiAnc3ZnJyxcclxuICAgICAgICAgICAgdmlldzogJ2xpbmVhZ2VEaWFncmFtJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHBuZ0J1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9saW5lYWdlR3JhbS5leHBvcnQoe1xyXG4gICAgICAgICAgICB0eXBlOiAncG5nJyxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBwcmludEJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9saW5lYWdlR3JhbS5wcmludCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBhbmRDb2xsYXBzZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoZXhwYW5kQ29sbGFwc2UuY2hlY2tlZCkge1xyXG4gICAgICAgICAgICBfbGluZWFnZUdyYW0uZXhwYW5kQWxsTm9kZXMoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfbGluZWFnZUdyYW0uY29sbGFwc2VBbGxOb2RlcygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgb3JpZW50YXRpb24udmFsdWUgPSBfbGluZWFnZUdyYW0uZ2V0T3JpZW50YXRpb24oKTtcclxuICAgIG9yaWVudGF0aW9uLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9saW5lYWdlR3JhbS5zZXRPcmllbnRhdGlvbihvcmllbnRhdGlvbi52YWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICByb3V0aW5nLnZhbHVlID0gX2xpbmVhZ2VHcmFtLmdldFJvdXRpbmcoKTtcclxuICAgIHJvdXRpbmcub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2xpbmVhZ2VHcmFtLnNldFJvdXRpbmcocm91dGluZy52YWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGxheW91dC52YWx1ZSA9IF9saW5lYWdlR3JhbS5nZXRMYXlvdXRBbGdvcml0aG0oKTtcclxuICAgIGxheW91dC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfbGluZWFnZUdyYW0uc2V0TGF5b3V0QWxnb3JpdGhtKGxheW91dC52YWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGhlbHBCdXR0b24ub25jbGljayA9IG9wdGlvbnMub25QcmVzc0hlbHA7XHJcblxyXG4gICAgY2xpcHBpbmcuY2hlY2tlZCA9IF9saW5lYWdlR3JhbS5nZXRDbGlwcGluZygpO1xyXG4gICAgY2xpcHBpbmcub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2xpbmVhZ2VHcmFtLnNldENsaXBwaW5nKGNsaXBwaW5nLmNoZWNrZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBoZWxwQnV0dG9uLm9uY2xpY2sgPSBvcHRpb25zLm9uUHJlc3NIZWxwO1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IE9wdGlvbnNQYW5lbDsiLCJpbXBvcnQgKiBhcyBqb2ludCBmcm9tICdyYXBwaWQnO1xyXG5pbXBvcnQgU3Vic2NyaWJhYmxlIGZyb20gJy4uL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlJztcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBcclxuICogSHRtbC1VSSBlbGVtZW50IHdoaWNoIG1hbmFnZSBzaXplIG9mIHR3byBzcGxpdHRlZCB3aW5kb3dzLlxyXG4gKiBcclxuICogQ29uc3RydWN0b3IgcGFyYW1ldGVyczpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAcGFyYW0ge1xyXG4gKiAgdmlld0ZyYW1lQTogVmlld0ZyYW1lLFxyXG4gKiAgdmlld0ZyYW1lQjogVmlld0ZyYW1lLFxyXG4gKiB9IG1vZGVsXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gcGFyYW1ldGVycyBzZXRcclxuICogXHJcbiAqIFB1YmxpYyBwcm9wZXJ0aWVzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIGVsOiBIVE1MRUxlbWVudFxyXG4gKiBcclxuICogUHVibGljIG1ldGhvZHM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogb24gKGV2ZW50OiBzdHJpbmcsIGNhbGxiYWNrOiBmdW5jdGlvbik6IHZvaWRcclxuICogdW5zdWJzY3JpYmUgKGNhbGxiYWNrOiBmdW5jdGlvbik6IHZvaWRcclxuICogdHJpZ2dlciAoZXZlbnQ6IHN0cmluZywgcGFyYW1ldGVyczogYW55KTogdm9pZFxyXG4gKiBcclxuICogRXZlbnRzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBmaXJlcyBkaWZmKHsgZGlmZjogbnVtYmVyLCBsYXN0Q2hhbmdlOiBib29sZWFuIH0pXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU3BsaXR0ZXIgKG1vZGVsLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICAvLyBJbml0XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7ICAgLy8gbWFrZSB0aGlzIGNsYXNzIFN1YnNjcmliYWJsZVxyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgY29uc3QgX2dyYXBoT3JpZW50YXRpb24gPSBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICdsZWZ0LXRvLXJpZ2h0JyB8fCBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICdyaWdodC10by1sZWZ0JztcclxuICAgIGxldCBfdmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgc2VsZi5tb2RlbCA9IG1vZGVsO1xyXG4gICAgaWYgKHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ3JpZ2h0LXRvLWxlZnQnIHx8IHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnKSB7XHJcbiAgICAgICAgX3N3YXBWaWV3RnJhbWVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZi5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgc2VsZi5lbC5jbGFzc05hbWUgPSBfZ3JhcGhPcmllbnRhdGlvbiA/ICd0cV9saW5lYWdlX3VpX192aWV3LWZyYW1lLXNwbGl0dGVyJyA6ICd0cV9saW5lYWdlX3VpX192aWV3LWZyYW1lLXNwbGl0dGVyLXZlcnRpY2FsJztcclxuICAgIHNlbGYuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgX29ubW91c2Vkb3duKTtcclxuICAgIFxyXG4gICAgbGV0IHN0YXJ0ID0gMDtcclxuICAgIGZ1bmN0aW9uIF9vbm1vdXNlZG93biAoZXZlbnQpIHtcclxuICAgICAgICBldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcclxuICAgICAgICBzdGFydCA9IDA7XHJcbiAgICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChfZ3JhcGhPcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQucGFnZVgpIHN0YXJ0ID0gZXZlbnQucGFnZVg7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFgpIHN0YXJ0ID0gZXZlbnQuY2xpZW50WDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQucGFnZVkpIHN0YXJ0ID0gZXZlbnQucGFnZVk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFkpIHN0YXJ0ID0gZXZlbnQuY2xpZW50WTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX29uY2hhbmdlKTtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfb25tb3VzZXVwKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gX29uY2hhbmdlIChldmVudCwgb25Nb3VzZVVwKSB7XHJcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnQgfHwgd2luZG93LmV2ZW50O1xyXG4gICAgICAgICAgICBsZXQgZW5kID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChfZ3JhcGhPcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnBhZ2VYKSBlbmQgPSBldmVudC5wYWdlWDtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFgpIGVuZCA9IGV2ZW50LmNsaWVudFg7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQucGFnZVkpIGVuZCA9IGV2ZW50LnBhZ2VZO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuY2xpZW50WSkgZW5kID0gZXZlbnQuY2xpZW50WTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgICAgICAgICBzdGFydCA9IGVuZDtcclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdzcGxpdHRlci1wb3NpdGlvbi1jaGFuZ2VkJywgeyBkaWZmOiBfbGltaXREaWZmKGRpZmYpLCBsYXN0Q2hhbmdlOiBvbk1vdXNlVXAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBfb25tb3VzZXVwIChldmVudCkge1xyXG4gICAgICAgICAgICBfb25jaGFuZ2UoZXZlbnQsIHRydWUpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5Lm9ubW91c2Vtb3ZlID0gZG9jdW1lbnQuYm9keS5vbm1vdXNldXAgPSBudWxsO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF9vbmNoYW5nZSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF9vbm1vdXNldXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgc2VsZi51cGRhdGVOZWlnaGJvdXIgPSBmdW5jdGlvbiAobmV3TmVpZ2hib3VyKSB7XHJcbiAgICAgICAgaWYgKHNlbGYubW9kZWwudmlld0ZyYW1lQiAhPT0gbmV3TmVpZ2hib3VyKSB7XHJcbiAgICAgICAgICAgIHNlbGYubW9kZWwudmlld0ZyYW1lQiA9IG5ld05laWdoYm91cjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX3Zpc2libGUpIHtcclxuICAgICAgICAgICAgc2VsZi5lbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICBfdmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghX3Zpc2libGUpIHtcclxuICAgICAgICAgICAgc2VsZi5lbC5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICAgICAgICAgIF92aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9zd2FwVmlld0ZyYW1lcyAoKSB7XHJcbiAgICAgICAgY29uc3QgdGVtcCA9IG1vZGVsLnZpZXdGcmFtZUE7XHJcbiAgICAgICAgbW9kZWwudmlld0ZyYW1lQSA9IG1vZGVsLnZpZXdGcmFtZUI7XHJcbiAgICAgICAgbW9kZWwudmlld0ZyYW1lQiA9IHRlbXA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2xpbWl0RGlmZiAoZGlmZikge1xyXG4gICAgICAgIGlmIChkaWZmID09PSAwKSByZXR1cm47XHJcbiAgICAgICAgY29uc3QgdmZBID0gc2VsZi5tb2RlbC52aWV3RnJhbWVBO1xyXG4gICAgICAgIGNvbnN0IHZmQiA9IHNlbGYubW9kZWwudmlld0ZyYW1lQjtcclxuXHJcbiAgICAgICAgbGV0IHNpZGVBO1xyXG4gICAgICAgIGxldCBzaWRlQjtcclxuICAgICAgICBsZXQgbWluU2lkZVNob3VsZEJlO1xyXG5cclxuICAgICAgICBpZiAoX2dyYXBoT3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgc2lkZUEgPSB2ZkEuc2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgc2lkZUIgPSB2ZkIuc2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgbWluU2lkZVNob3VsZEJlID0gcGFyYW1ldGVycy5mcmFtZVBhZGRpbmcueCAqIDIgKyAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNpZGVBID0gdmZBLnNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICBzaWRlQiA9IHZmQi5zaXplLmhlaWdodDtcclxuICAgICAgICAgICAgbWluU2lkZVNob3VsZEJlID0gcGFyYW1ldGVycy5mcmFtZVBhZGRpbmcueSAqIDIgKyAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcmVzdWx0U2lkZUEgPSBzaWRlQSArIGRpZmY7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0U2lkZUIgPSBzaWRlQiAtIGRpZmY7XHJcblxyXG4gICAgICAgIGxldCBsaW1pdGF0aW9uQSA9IDA7XHJcbiAgICAgICAgbGV0IGxpbWl0YXRpb25CID0gMDtcclxuICAgICAgICBpZiAocmVzdWx0U2lkZUEgPCBtaW5TaWRlU2hvdWxkQmUgJiYgcmVzdWx0U2lkZUIgPCBtaW5TaWRlU2hvdWxkQmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdWx0U2lkZUEgPCBtaW5TaWRlU2hvdWxkQmUpIHtcclxuICAgICAgICAgICAgbGltaXRhdGlvbkEgPSAgbWluU2lkZVNob3VsZEJlIC0gcmVzdWx0U2lkZUE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHRTaWRlQiA8IG1pblNpZGVTaG91bGRCZSkge1xyXG4gICAgICAgICAgICBsaW1pdGF0aW9uQiA9ICByZXN1bHRTaWRlQiAtIG1pblNpZGVTaG91bGRCZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpbWl0YXRpb25BICE9PSAwIHx8IGxpbWl0YXRpb25CICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdERpZmYgPSBNYXRoLmFicyhsaW1pdGF0aW9uQSkgPiBNYXRoLmFicyhsaW1pdGF0aW9uQikgPyBkaWZmICsgbGltaXRhdGlvbkEgOiBkaWZmICsgbGltaXRhdGlvbkI7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFNpZGVBID0gc2lkZUEgKyByZXN1bHREaWZmO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRTaWRlQiA9IHNpZGVCIC0gcmVzdWx0RGlmZjtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdFNpZGVBIDwgbWluU2lkZVNob3VsZEJlIHx8IHJlc3VsdFNpZGVCIDwgbWluU2lkZVNob3VsZEJlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdERpZmY7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxufVxyXG5TcGxpdHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LnNoYXBlcy5iYXNpYy5SZWN0LnByb3RvdHlwZSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTcGxpdHRlcjsiLCIvKipcclxuICogQ29sb3JlZEJ1dHRvbk1vZGVsIC0gZGF0YSBtb2RlbCBmb3IgQ29sb3JlZEJ1dHRvbnMgaW4gdGhlIENvbG9yZWRCdXR0b25zTGlzdFxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb2xvcmVkQnV0dG9uTW9kZWxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gU3RyaW5nIGlkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYWJlbCAtIGFyZSB1c2VkIGZvciBpbXBsZW1lbnRpbmcgdG9vbHRpcCBhbmQgaWNvblxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYm9yZGVyQ29sb3IgLSBCb3JkZXIgY29sb3JcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJhY2tncm91bmRDb2xvciAtIEJhY2tncm91bmQgY29sb3JcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB3aWNoIHdpbGwgYmUgY29sbGVkIG9uIG1vdXNlIGNsaWNrIG9uIGJ1dHRvblxyXG4qL1xyXG5cclxubGV0IHVuaXF1ZUlkID0gMDtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyBpcyBhIGNvbGxlY3Rpb24gb2YgY29sb3JlZCBidXR0b25zLFxyXG4gKiB3aGljaCB1c2UgZmlyc3QgbGV0dGVycyBvZiB0aGUgbGFiZWwgYXMgYW4gaWNvbnMgZm9yIHRoZSBidXR0b25zLlxyXG4gKiAoSW5pdGlhbGx5IGl0IHdhcyBkZXZlbG9wZWQgYXMgYSBjb2xsZWN0aW9uIG9mIGNvbGxhcHNlZCB2aWV3RnJhbWVzIGZvciBMaW5lYWdlR3JhbSlcclxuICogQGNsYXNzXHJcbiAqIEBhdWdtZW50cyBUUVVJRWxlbWVudFxyXG4gKiBAcGFyYW0ge0xpbmVhZ2VHcmFtfSBsaW5lYWdlR3JhbVxyXG4gKiBcclxuICogQHByb3BlcnR5IHtDb2xvcmVkQnV0dG9uTW9kZWxbXX0gYnV0dG9ucyAtIGxpc3Qgb2YgYnV0dG9uIG1vZGVsc1xyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gVmlld0ZyYW1lQnV0dG9ucyAocGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICBpZiAoIXBhcmFtZXRlcnMpIHRocm93IEVycm9yKCdUaGUgYXJndW1lbnRzIHBhcmFtZXRlcnMgc2hvdWxkblxcJ3QgYmUgdW5kZWZpbmVkIScpO1xyXG4gICAgaWYgKCFwYXJhbWV0ZXJzLmxpbmVhZ2VHcmFtKSB0aHJvdyBFcnJvcignbGluZWFnZUdyYW0gZmllbGQgaXMgdW5kZWZpbmVkIScpO1xyXG5cclxuICAgIHNlbGYucm9vdEh0bWwgPSBfaW5pdFJvb3RFbGVtZW50KCk7XHJcbiAgICBzZWxmLmlkID0gcGFyYW1ldGVycy5saW5lYWdlR3JhbS5pZCB8fCAnY29sb3JlZEJ1dHRvbnMtJyArIHVuaXF1ZUlkKys7XHJcbiAgICBzZWxmLnJvb3RIdG1sLmlkID0gc2VsZi5pZDtcclxuICAgIFxyXG4gICAgbGV0IF9saW5lYWdlR3JhbSA9IHBhcmFtZXRlcnMubGluZWFnZUdyYW07XHJcbiAgICBsZXQgX3N0YXRlID0ge307XHJcbiAgICBsZXQgX2J1dHRvbnMgPSB7fTtcclxuICAgIGxldCBfb3ZlclZpZXdGcmFtZUJ1dHRvbjtcclxuXHJcbiAgICBfY3JlYXRlQnV0dG9ucygpO1xyXG5cclxuICAgIF9saW5lYWdlR3JhbS5vbigndmlldy1mcmFtZS1zdGF0ZS1jaGFuZ2VkJywgX3VwZGF0ZUJ1dHRvbnMpO1xyXG4gICAgX2xpbmVhZ2VHcmFtLm9uKCdoaXN0b3J5LXN0YXRlLWNoYW5nZWQnLCBfY3JlYXRlQnV0dG9ucyk7XHJcblxyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUJ1dHRvbnMgKCkge1xyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZXMgPSBfbGluZWFnZUdyYW0uZ2V0Vmlld0ZyYW1lcygpO1xyXG4gICAgICAgIGNvbnN0IG92ZXJWaWV3RnJhbWUgPSBfbGluZWFnZUdyYW0uZ2V0T3ZlclZpZXdGcmFtZSgpO1xyXG5cclxuICAgICAgICBfc3RhdGUgPSB7fTtcclxuICAgICAgICBfYnV0dG9ucyA9IHt9O1xyXG4gICAgICAgIHNlbGYucm9vdEh0bWwuaW5uZXJIVE1MID0gJyc7XHJcblxyXG4gICAgICAgIGlmIChvdmVyVmlld0ZyYW1lKSB7XHJcbiAgICAgICAgICAgIF9vdmVyVmlld0ZyYW1lQnV0dG9uID0gY3JlYXRlQnV0dG9uKG92ZXJWaWV3RnJhbWUpO1xyXG4gICAgICAgICAgICBfb3ZlclZpZXdGcmFtZUJ1dHRvbi5zdHlsZS5ib3JkZXJDb2xvciA9IG51bGw7XHJcbiAgICAgICAgICAgIF9vdmVyVmlld0ZyYW1lQnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG51bGw7XHJcbiAgICAgICAgICAgIF9vdmVyVmlld0ZyYW1lQnV0dG9uLnN0eWxlLmNvbG9yID0gbnVsbDtcclxuICAgICAgICAgICAgX292ZXJWaWV3RnJhbWVCdXR0b24uY2xhc3NMaXN0LmFkZCgndHEtdWktY29sb3JlZC1idXR0b25zLW92ZXJ2aWV3Jyk7XHJcbiAgICAgICAgICAgIHNlbGYucm9vdEh0bWwuYXBwZW5kQ2hpbGQoX292ZXJWaWV3RnJhbWVCdXR0b24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmlld0ZyYW1lcy5mb3JFYWNoKHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2aWV3RnJhbWUuaWQgIT09IG92ZXJWaWV3RnJhbWUuaWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGh0bWxCdXR0b24gPSBjcmVhdGVCdXR0b24odmlld0ZyYW1lKTtcclxuICAgICAgICAgICAgICAgIF9idXR0b25zW3ZpZXdGcmFtZS5pZF0gPSBodG1sQnV0dG9uO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5yb290SHRtbC5hcHBlbmRDaGlsZChodG1sQnV0dG9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfdXBkYXRlQnV0dG9ucygpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVCdXR0b24gKHZpZXdGcmFtZSkge1xyXG4gICAgICAgICAgICBjb25zdCBodG1sQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQlVUVE9OJyk7XHJcblxyXG4gICAgICAgICAgICBodG1sQnV0dG9uLmNsYXNzTmFtZSA9ICd0cS11aS10b29sYmFyX19idXR0b24gdHEtdWktY29sb3JlZC1idXR0b24nO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZpZXdGcmFtZS5pc092ZXJWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICBodG1sQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3RxLXVpLWNvbG9yZWQtYnV0dG9ucy1vdmVydmlldycpO1xyXG4gICAgICAgICAgICAgICAgaHRtbEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc3RhdGVbdmlld0ZyYW1lLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGluZWFnZUdyYW0uc2V0RnVsbFNjcmVlbk1vZGUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW5lYWdlR3JhbS5zZXRGdWxsU2NyZWVuTW9kZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaHRtbEJ1dHRvbi5pbm5lckhUTUwgPSBgPHNwYW4+JHtfZ2V0U2hvcnRMYWJlbCh2aWV3RnJhbWUubGFiZWwpfTwvc3Bhbj5gO1xyXG4gICAgICAgICAgICAgICAgaHRtbEJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB2aWV3RnJhbWUuYmFja2dyb3VuZENvbG9yIHx8ICd3aGl0ZSc7XHJcbiAgICAgICAgICAgICAgICBodG1sQnV0dG9uLnN0eWxlLmJvcmRlckNvbG9yID0gdmlld0ZyYW1lLmJvcmRlckNvbG9yIHx8ICdibGFjayc7XHJcbiAgICAgICAgICAgICAgICBodG1sQnV0dG9uLnN0eWxlLmNvbG9yID0gdmlld0ZyYW1lLmJvcmRlckNvbG9yIHx8ICdibGFjayc7XHJcbiAgICAgICAgICAgICAgICBodG1sQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zdGF0ZVt2aWV3RnJhbWUuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW5lYWdlR3JhbS5jb2xsYXBzZVZpZXdGcmFtZSh2aWV3RnJhbWUuaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW5lYWdlR3JhbS5leHBhbmRWaWV3RnJhbWUodmlld0ZyYW1lLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfc3RhdGVbdmlld0ZyYW1lLmlkXSA9IHZpZXdGcmFtZS5leHBhbmRlZDtcclxuICAgICAgICAgICAgcmV0dXJuIGh0bWxCdXR0b247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF91cGRhdGVCdXR0b25zICgpIHtcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWVzID0gX2xpbmVhZ2VHcmFtLmdldFZpZXdGcmFtZXMoKTtcclxuICAgICAgICBjb25zdCBvdmVyVmlld0ZyYW1lID0gX2xpbmVhZ2VHcmFtLmdldE92ZXJWaWV3RnJhbWUoKTtcclxuXHJcbiAgICAgICAgaWYgKG92ZXJWaWV3RnJhbWUpIHtcclxuICAgICAgICAgICAgX3N0YXRlW292ZXJWaWV3RnJhbWUuaWRdID0gb3ZlclZpZXdGcmFtZS5hY3RpdmU7XHJcbiAgICAgICAgICAgIF9vdmVyVmlld0ZyYW1lQnV0dG9uLmlubmVySFRNTCA9IGA8c3Bhbj4ke292ZXJWaWV3RnJhbWUuYWN0aXZlID8gJ0YnIDogJ08nfTwvc3Bhbj5gO1xyXG4gICAgICAgICAgICBpZiAob3ZlclZpZXdGcmFtZS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIF9vdmVyVmlld0ZyYW1lQnV0dG9uLnRpdGxlID0gJ1N3aXRjaCB0byBGcmFtZXMgbW9kZSc7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJvb3RIdG1sLmNsYXNzTGlzdC5hZGQoJ3RxLXVpLWNvbG9yZWQtYnV0dG9ucy1jb2xsYXBzZWQnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9vdmVyVmlld0ZyYW1lQnV0dG9uLnRpdGxlID0gJ1N3aXRjaCB0byBzaW5nbGUgZnJhbWUgbW9kZSc7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJvb3RIdG1sLmNsYXNzTGlzdC5yZW1vdmUoJ3RxLXVpLWNvbG9yZWQtYnV0dG9ucy1jb2xsYXBzZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmlld0ZyYW1lcy5mb3JFYWNoKHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2aWV3RnJhbWUuaWQgIT09IG92ZXJWaWV3RnJhbWUuaWQpIHtcclxuICAgICAgICAgICAgICAgIF9zdGF0ZVt2aWV3RnJhbWUuaWRdID0gdmlld0ZyYW1lLmV4cGFuZGVkO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlQnV0dG9uKHZpZXdGcmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQnV0dG9uICh2aWV3RnJhbWUpIHtcclxuICAgICAgICAgICAgY29uc3QgaHRtbEJ1dHRvbiA9IF9idXR0b25zW3ZpZXdGcmFtZS5pZF07XHJcbiAgICAgICAgICAgIGlmIChfc3RhdGVbdmlld0ZyYW1lLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgaHRtbEJ1dHRvbi50aXRsZSA9ICdDb2xsYXBzZSAnICsgdmlld0ZyYW1lLmxhYmVsO1xyXG4gICAgICAgICAgICAgICAgaHRtbEJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCd0cS11aS1zZWxlY3RlZCcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaHRtbEJ1dHRvbi50aXRsZSA9ICdFeHBhbmQgJyArIHZpZXdGcmFtZS5sYWJlbDtcclxuICAgICAgICAgICAgICAgIGh0bWxCdXR0b24uY2xhc3NMaXN0LmFkZCgndHEtdWktc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0U2hvcnRMYWJlbCAobGFiZWwpIHtcclxuICAgICAgICBpZiAoIWxhYmVsKSByZXR1cm47XHJcbiAgICAgICAgY29uc3Qgd29yZHMgPSBsYWJlbC5tYXRjaCgvW2EteidcXC1dKy9naSk7XHJcbiAgICAgICAgcmV0dXJuIHdvcmRzLmZpbHRlcih3ID0+ICh3LnRvTG93ZXJDYXNlKCkgIT09ICdhbmQnICYmIHcgIT09ICcmJykpLm1hcCh3ID0+IHdbMF0pLmpvaW4oJycpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9pbml0Um9vdEVsZW1lbnQgKCkge1xyXG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgICAgIGVsLmNsYXNzTmFtZSA9ICd0cS11aS1jb2xvcmVkLWJ1dHRvbnMtbGlzdCc7XHJcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgcmV0dXJuIGVsO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IFZpZXdGcmFtZUJ1dHRvbnM7IiwiaW1wb3J0IFN1YnNjcmliYWJsZSBmcm9tICcuLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZSc7XHJcbmltcG9ydCBTcGxpdHRlciBmcm9tICcuL3NwbGl0dGVyJztcclxuaW1wb3J0IHsgY2hlY2tQYWdpbmF0aW9uLCBjYWNoZUlkRm9yVmlld0ZyYW1lVUkgfSBmcm9tICcuLi91dGlscy9saW5lYWdlRGlhZ3JhbVV0aWxzJztcclxuaW1wb3J0IHsgYXJyYXlUb01hcCB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBcclxuICogTWFuYWdlcyB0aGUgbWFpbiB2aWV3IG9mIGFwcGxpY2F0aW9uIChWaWV3LTIpXHJcbiAqIFxyXG4gKiBDb25zdHJ1Y3RvciBwYXJhbWV0ZXJzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBwYXJhbSB7XHJcbiAqICByb290RWw6IEhUTUxFbGVtZW50XHJcbiAqICB2aWV3RnJhbWVzOiBBcnJheSBvZiBWaWV3RnJhbWVcclxuICogfSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gcGFyYW1ldGVycyBzZXRcclxuICogXHJcbiAqIFB1YmxpYyBtZXRob2RzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIHJlZnJlc2hTdGF0ZSAoKTogdm9pZFxyXG4gKiB1cGRhdGVWaWV3RnJhbWVzICh2aWV3RnJhbWVzOiBWaWV3RnJhbWVbXSk6IHZvaWRcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBvbiAoZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6IGZ1bmN0aW9uKTogdm9pZFxyXG4gKiB1bnN1YnNjcmliZSAoY2FsbGJhY2s6IGZ1bmN0aW9uKTogdm9pZFxyXG4gKiB0cmlnZ2VyIChldmVudDogc3RyaW5nLCBwYXJhbWV0ZXJzOiBhbnkpOiB2b2lkXHJcbiAqIFxyXG4gKiBFdmVudHM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQGZpcmVzIHZpZXctcG9ydC1wb3NpdGlvbi1jaGFuZ2VkIChWaWV3RnJhbWUpXHJcbiAqIEBmaXJlcyBzcGxpdHRlci1wb3NpdGlvbi1jaGFuZ2VkICh2ZjogVmlld0ZyYW1lLCBkaWZmOiB7IGRpZmY6IG51bWJlciwgbGFzdENoYW5nZTogYm9vbGVhbiB9KVxyXG4gKiBAZmlyZXMgdmlldy1mcmFtZS1jb2xsYXBzZWQgKFZpZXdGcmFtZSwgYm9vbGVhbilcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBWaWV3RnJhbWVzVUkgKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcclxuICAgIC8vIEluaXRcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7ICAgLy8gbWFrZSB0aGlzIGNsYXNzIFN1YnNjcmliYWJsZVxyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgY29uc3QgX3Jvb3QgPSBvcHRpb25zLnJvb3RFbDtcclxuXHJcbiAgICBsZXQgX29yaWVudGF0aW9uID0gcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uID09PSAncmlnaHQtdG8tbGVmdCcgfHwgcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uID09PSAnYm90dG9tLXRvLXRvcCc7XHJcbiAgICBsZXQgX2dyYXBoT3JpZW50YXRpb24gPSBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICdsZWZ0LXRvLXJpZ2h0JyB8fCBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICdyaWdodC10by1sZWZ0JztcclxuICAgIFxyXG4gICAgbGV0IF92aWV3TWFuYWdlciA9IG9wdGlvbnMudmlld01hbmFnZXI7XHJcbiAgICBsZXQgX3ZpZXdGcmFtZXMgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lcygpIHx8IFtdO1xyXG4gICAgbGV0IF92aWV3RnJhbWVzTWFwID0gYXJyYXlUb01hcChfdmlld0ZyYW1lcyk7XHJcbiAgICBsZXQgX3VpU2V0Rm9yVmlld0ZyYW1lcztcclxuICAgIGxldCBfYnV0dG9uczRTZXRzO1xyXG4gICAgbGV0IF9zcGxpdHRlcnM7XHJcbiAgICBsZXQgX3VpQm9keTtcclxuICAgIFxyXG4gICAgX2NyZWF0ZVVJKCk7XHJcbiAgICBcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZnJlc2hlcyBhIHN0YXRlIG9mIFVJLiAoQ2hhbmdlIGFycm93cyBzdGF0ZXMpXHJcbiAgICAgKi9cclxuICAgIHNlbGYucmVmcmVzaCA9IF9yZWZyZXNoO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG5ldyB2aWV3IG1hbmFnZXJcclxuICAgICAqIEBwYXJhbSB7QXJyYXkgb2YgVmlld0ZyYW1lfSB2aWV3RnJhbWVzXHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0Vmlld01hbmFnZXIgPSBmdW5jdGlvbiAodmlld01hbmFnZXIpIHtcclxuICAgICAgICBfdmlld01hbmFnZXIgPSB2aWV3TWFuYWdlcjtcclxuICAgICAgICBfdmlld0ZyYW1lcyA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCk7XHJcbiAgICAgICAgX2NyZWF0ZVVJKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgY2hhbmdlcyBvcmllbnRhdGlvbiBvZiB0aGUgZ3JhcGguXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZW50YXRpb24gLSBWYWx1ZXM6ICdsZWZ0LXRvLXJpZ2h0JywgJ3JpZ2h0LXRvLWxlZnQnLCAndG9wLXRvLWJvdHRvbScsICdib3R0b20tdG8tdG9wJ1xyXG4gICAgICogQG1lbWJlcm9mIFZpZXdGcmFtZXNVSVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLnNldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gKG9yaWVudGF0aW9uKSB7XHJcbiAgICAgICAgX29yaWVudGF0aW9uID0gb3JpZW50YXRpb24gPT09ICdyaWdodC10by1sZWZ0JyB8fCBvcmllbnRhdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnO1xyXG4gICAgICAgIF9ncmFwaE9yaWVudGF0aW9uID0gb3JpZW50YXRpb24gPT09ICdsZWZ0LXRvLXJpZ2h0JyB8fCBvcmllbnRhdGlvbiA9PT0gJ3JpZ2h0LXRvLWxlZnQnO1xyXG4gICAgICAgIF9jcmVhdGVVSSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZnJlc2hlcyBhIHN0YXRlIG9mIFVJLiAoQ2hhbmdlIGFycm93cyBzdGF0ZXMpXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9yZWZyZXNoICgpIHtcclxuICAgICAgICBfdXBkYXRlVmlld0ZyYW1lcygpO1xyXG4gICAgICAgIF9yZWZyZXNoVUkoKTtcclxuICAgICAgICBfdmlld0ZyYW1lcy5mb3JFYWNoKHZmID0+IHtcclxuICAgICAgICAgICAgaWYgKHZmLmN1c3RvbWVTaXplZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZmLnNpemUud2lkdGgpIF91aVNldEZvclZpZXdGcmFtZXNbdmYuaWRdLnN0eWxlLndpZHRoID0gdmYuc2l6ZS53aWR0aCArICdweCc7XHJcbiAgICAgICAgICAgICAgICBpZiAodmYuc2l6ZS5oZWlnaHQpIF91aVNldEZvclZpZXdGcmFtZXNbdmYuaWRdLnN0eWxlLmhlaWdodCA9IHZmLnNpemUuaGVpZ2h0ICsgJ3B4JztcclxuICAgICAgICAgICAgICAgIF91aVNldEZvclZpZXdGcmFtZXNbdmYuaWRdLnN0eWxlLmZsZXhHcm93ID0gMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF91aVNldEZvclZpZXdGcmFtZXNbdmYuaWRdLnN0eWxlLmZsZXhHcm93ID0gdmYuc3BhY2VTaGFyZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF91cGRhdGVWaWV3RnJhbWVzICgpIHtcclxuICAgICAgICBfdmlld0ZyYW1lcyA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCk7XHJcbiAgICAgICAgY29uc3QgdmZNYXAgPSBhcnJheVRvTWFwKF92aWV3RnJhbWVzKTtcclxuICAgICAgICBfc3BsaXR0ZXJzLmZvckVhY2goc3BsaXR0ZXIgPT4ge1xyXG4gICAgICAgICAgICBzcGxpdHRlci5tb2RlbC52aWV3RnJhbWVBID0gdmZNYXBbc3BsaXR0ZXIubW9kZWwudmlld0ZyYW1lQS5pZF07XHJcbiAgICAgICAgICAgIHNwbGl0dGVyLm1vZGVsLnZpZXdGcmFtZUIgPSB2Zk1hcFtzcGxpdHRlci5tb2RlbC52aWV3RnJhbWVCLmlkXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBfdmlld0ZyYW1lc01hcCA9IGFycmF5VG9NYXAoX3ZpZXdGcmFtZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBodG1sIG5hdmlnYXRlIGJ1dHRvbnMgZm9yIHRoZSB2aWV3cy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZVVJICgpIHtcclxuICAgICAgICBpZiAoIV9yb290KSByZXR1cm47XHJcbiAgICAgICAgZWxzZSBfcm9vdC5pbm5lckhUTUwgPSAnJztcclxuXHJcbiAgICAgICAgX3VpQm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgICAgIF91aUJvZHkuY2xhc3NOYW1lID0gJ3RxX2xpbmVhZ2VfdWknO1xyXG4gICAgICAgIF9yb290LmFwcGVuZENoaWxkKF91aUJvZHkpO1xyXG4gICAgICAgIF9zcGxpdHRlcnMgPSBbXTtcclxuXHJcbiAgICAgICAgX3VpQm9keS5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICBfdWlTZXRGb3JWaWV3RnJhbWVzID0ge307XHJcbiAgICAgICAgX2J1dHRvbnM0U2V0cyA9IHt9O1xyXG5cclxuICAgICAgICBjb25zdCBNT0RJRklFUiA9IDAuNTtcclxuXHJcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ3JpZ2h0LXRvLWxlZnQnKSB7XHJcbiAgICAgICAgICAgIF91aUJvZHkuc3R5bGUuZmxleERpcmVjdGlvbiA9ICdyb3ctcmV2ZXJzZSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICd0b3AtdG8tYm90dG9tJykge1xyXG4gICAgICAgICAgICBfdWlCb2R5LnN0eWxlLmZsZXhEaXJlY3Rpb24gPSAnY29sdW1uJztcclxuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnKSB7XHJcbiAgICAgICAgICAgIF91aUJvZHkuc3R5bGUuZmxleERpcmVjdGlvbiA9ICdjb2x1bW4tcmV2ZXJzZSc7XHJcbiAgICAgICAgfSBlbHNlIHsgLy8gaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICBfdWlCb2R5LnN0eWxlLmZsZXhEaXJlY3Rpb24gPSAncm93JztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF92aWV3RnJhbWVzLmZvckVhY2goKHZmLCBpbmRleCwgYXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZVVpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgICAgIHZpZXdGcmFtZVVpLmlkID0gY2FjaGVJZEZvclZpZXdGcmFtZVVJKHZmKTtcclxuICAgICAgICAgICAgaWYgKF9vcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lVWkuY2xhc3NOYW1lID0gJ3RxX2xpbmVhZ2VfdWlfdmlldy1mcmFtZV8nICsgcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lVWkuY2xhc3NOYW1lID0gJ3RxX2xpbmVhZ2VfdWlfdmlldy1mcmFtZV8nICsgcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodmYuY3VzdG9tZVNpemVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmYuc2l6ZS53aWR0aCkgdmlld0ZyYW1lVWkuc3R5bGUud2lkdGggPSB2Zi5zaXplLndpZHRoICsgJ3B4JztcclxuICAgICAgICAgICAgICAgIGlmICh2Zi5zaXplLmhlaWdodCkgdmlld0ZyYW1lVWkuc3R5bGUuaGVpZ2h0ID0gdmYuc2l6ZS5oZWlnaHQgKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lVWkuc3R5bGUuZmxleEdyb3cgPSAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lVWkuc3R5bGUuZmxleEdyb3cgPSB2Zi5zcGFjZVNoYXJlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF91aUJvZHkuYXBwZW5kQ2hpbGQodmlld0ZyYW1lVWkpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU1HJyk7XHJcbiAgICAgICAgICAgIHVwLmNsYXNzTmFtZSA9ICd0cV9saW5lYWdlX3VpX19idXR0b24gdHFfbGluZWFnZV91aV9fdXAtYnV0dG9uJztcclxuICAgICAgICAgICAgdXAub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZSA9IF92aWV3RnJhbWVzTWFwW3ZmLmlkXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1clBvcyA9IHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3LXBvcnQtcG9zaXRpb24tY2hhbmdlZCcsIHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogdmYuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlld1BvcnRQb3NpdGlvbjogeyB4OiBjdXJQb3MueCwgeTogY3VyUG9zLnkgLSB2aWV3RnJhbWUuc2l6ZS5oZWlnaHQgKiBNT0RJRklFUiB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZpZXdGcmFtZVVpLmFwcGVuZENoaWxkKHVwKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGRvd24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJTUcnKTtcclxuICAgICAgICAgICAgZG93bi5jbGFzc05hbWUgPSAndHFfbGluZWFnZV91aV9fYnV0dG9uIHRxX2xpbmVhZ2VfdWlfX2Rvd24tYnV0dG9uJztcclxuICAgICAgICAgICAgZG93bi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lID0gX3ZpZXdGcmFtZXNNYXBbdmYuaWRdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VyUG9zID0gdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3ZpZXctcG9ydC1wb3NpdGlvbi1jaGFuZ2VkJywge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiB2Zi5pZCxcclxuICAgICAgICAgICAgICAgICAgICB2aWV3UG9ydFBvc2l0aW9uOiB7IHg6IGN1clBvcy54LCB5OiBjdXJQb3MueSArIHZpZXdGcmFtZS5zaXplLmhlaWdodCAqIE1PRElGSUVSIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmlld0ZyYW1lVWkuYXBwZW5kQ2hpbGQoZG93bik7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU1HJyk7XHJcbiAgICAgICAgICAgIGxlZnQuY2xhc3NOYW1lID0gJ3RxX2xpbmVhZ2VfdWlfX2J1dHRvbiB0cV9saW5lYWdlX3VpX19sZWZ0LWJ1dHRvbic7XHJcbiAgICAgICAgICAgIGxlZnQub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZSA9IF92aWV3RnJhbWVzTWFwW3ZmLmlkXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1clBvcyA9IHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3LXBvcnQtcG9zaXRpb24tY2hhbmdlZCcsIHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogdmYuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlld1BvcnRQb3NpdGlvbjogeyB4OiBjdXJQb3MueCAtIHZpZXdGcmFtZS5zaXplLndpZHRoICogTU9ESUZJRVIsIHk6IGN1clBvcy55IH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmlld0ZyYW1lVWkuYXBwZW5kQ2hpbGQobGVmdCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0lNRycpO1xyXG4gICAgICAgICAgICByaWdodC5jbGFzc05hbWUgPSAndHFfbGluZWFnZV91aV9fYnV0dG9uIHRxX2xpbmVhZ2VfdWlfX3JpZ2h0LWJ1dHRvbic7XHJcbiAgICAgICAgICAgIHJpZ2h0Lm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3RnJhbWUgPSBfdmlld0ZyYW1lc01hcFt2Zi5pZF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJQb3MgPSB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcigndmlldy1wb3J0LXBvc2l0aW9uLWNoYW5nZWQnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHZmLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdQb3J0UG9zaXRpb246IHsgeDogY3VyUG9zLnggKyB2aWV3RnJhbWUuc2l6ZS53aWR0aCAqIE1PRElGSUVSLCB5OiBjdXJQb3MueSB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZpZXdGcmFtZVVpLmFwcGVuZENoaWxkKHJpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxhcHNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU1HJyk7XHJcbiAgICAgICAgICAgIGNvbGxhcHNlLmNsYXNzTmFtZSA9ICd0cV9saW5lYWdlX3VpX19idXR0b24gdHFfbGluZWFnZV91aV9fY29sbGFwc2UtYnV0dG9uJztcclxuICAgICAgICAgICAgY29sbGFwc2Uub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcigndmlldy1mcmFtZS1jb2xsYXBzZWQnLCB7IGlkOiB2Zi5pZCwgZXhwYW5kZWQ6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2aWV3RnJhbWVVaS5hcHBlbmRDaGlsZChjb2xsYXBzZSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBfYnV0dG9uczRTZXRzW3ZmLmlkXSA9IHtcclxuICAgICAgICAgICAgICAgIHVwOiB1cCxcclxuICAgICAgICAgICAgICAgIGRvd246IGRvd24sXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBhcnIubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3BsaXR0ZXIgPSBuZXcgU3BsaXR0ZXIoe1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdGcmFtZUE6IHZmLFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdGcmFtZUI6IGFycltpbmRleCArIDFdLFxyXG4gICAgICAgICAgICAgICAgfSwgcGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgICAgICBfc3BsaXR0ZXJzLnB1c2goc3BsaXR0ZXIpO1xyXG4gICAgICAgICAgICAgICAgX3VpQm9keS5hcHBlbmRDaGlsZChzcGxpdHRlci5lbCk7XHJcbiAgICAgICAgICAgICAgICBzcGxpdHRlci5vbignc3BsaXR0ZXItcG9zaXRpb24tY2hhbmdlZCcsIGZ1bmN0aW9uIChkaWZmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdzcGxpdHRlci1wb3NpdGlvbi1jaGFuZ2VkJywgW3NwbGl0dGVyLCBkaWZmXSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX3VpU2V0Rm9yVmlld0ZyYW1lc1t2Zi5pZF0gPSB2aWV3RnJhbWVVaTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX3JlZnJlc2hVSSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaCBuYXZpZ2F0aW9uIGJ1dHRvbnMuIEJ1dHRvbiBpc24ndCBhY3RpdmUgaWYgdGhlIHZpZXdQb3J0IGNhbid0IG1vdmUgYnkgdGhpcyBkaXJlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9yZWZyZXNoVUkgKCkge1xyXG4gICAgICAgIGlmICghX3Jvb3QpIHJldHVybjtcclxuICAgICAgICBfcmVmcmVzaFNwbGl0dGVyc1N0YXRlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgX3ZpZXdGcmFtZXMuZm9yRWFjaCh2ZiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gY2hlY2tQYWdpbmF0aW9uKHZmKTtcclxuXHJcbiAgICAgICAgICAgIF91aVNldEZvclZpZXdGcmFtZXNbdmYuaWRdLnN0eWxlLmRpc3BsYXkgPSB2Zi5hY3RpdmUgPyAnJyA6ICdub25lJztcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVwID0gX2J1dHRvbnM0U2V0c1t2Zi5pZF0udXA7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvd24gPSBfYnV0dG9uczRTZXRzW3ZmLmlkXS5kb3duO1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gX2J1dHRvbnM0U2V0c1t2Zi5pZF0ubGVmdDtcclxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBfYnV0dG9uczRTZXRzW3ZmLmlkXS5yaWdodDtcclxuXHJcbiAgICAgICAgICAgIHVwLnN0eWxlLmN1cnNvciA9IGNoZWNrLmNhbk1vdmVVcCA/ICdwb2ludGVyJyA6ICdub3QtYWxsb3dlZCc7XHJcbiAgICAgICAgICAgIGRvd24uc3R5bGUuY3Vyc29yID0gY2hlY2suY2FuTW92ZURvd24gPyAncG9pbnRlcicgOiAnbm90LWFsbG93ZWQnO1xyXG4gICAgICAgICAgICBsZWZ0LnN0eWxlLmN1cnNvciA9IGNoZWNrLmNhbk1vdmVMZWZ0ID8gJ3BvaW50ZXInIDogJ25vdC1hbGxvd2VkJztcclxuICAgICAgICAgICAgcmlnaHQuc3R5bGUuY3Vyc29yID0gY2hlY2suY2FuTW92ZVJpZ2h0ID8gJ3BvaW50ZXInIDogJ25vdC1hbGxvd2VkJztcclxuXHJcbiAgICAgICAgICAgIHVwLnN0eWxlLm9wYWNpdHkgPSBjaGVjay5jYW5Nb3ZlVXAgPyAnJyA6ICcwLjAzJztcclxuICAgICAgICAgICAgZG93bi5zdHlsZS5vcGFjaXR5ID0gY2hlY2suY2FuTW92ZURvd24gPyAnJyA6ICcwLjAzJztcclxuICAgICAgICAgICAgbGVmdC5zdHlsZS5vcGFjaXR5ID0gY2hlY2suY2FuTW92ZUxlZnQgPyAnJyA6ICcwLjAzJztcclxuICAgICAgICAgICAgcmlnaHQuc3R5bGUub3BhY2l0eSA9IGNoZWNrLmNhbk1vdmVSaWdodCA/ICcnIDogJzAuMDMnO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9yZWZyZXNoU3BsaXR0ZXJzU3RhdGUgKCkge1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUZyYW1lcyA9IF92aWV3RnJhbWVzLmZpbHRlcih2ZiA9PiB2Zi5hY3RpdmUpXHJcbiAgICAgICAgLnNvcnQoKGEsYikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwb3NBID0gYS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgcG9zQiA9IGIucG9zaXRpb247XHJcbiAgICAgICAgICAgIGlmIChfZ3JhcGhPcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc0EueCAtIHBvc0IueDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwb3NBLnkgLSBwb3NCLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBhY3RpdmVJZHMgPSBhY3RpdmVGcmFtZXMubWFwKHZmID0+IHZmLmlkKTtcclxuXHJcbiAgICAgICAgaWYgKF9vcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICBfc3BsaXR0ZXJzLmZvckVhY2goc3BsaXR0ZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlU3BsaXR0ZXIoc3BsaXR0ZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gX3NwbGl0dGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlU3BsaXR0ZXIoX3NwbGl0dGVyc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNwbGl0dGVyIChzcGxpdHRlcikge1xyXG4gICAgICAgICAgICBpZiAoc3BsaXR0ZXIubW9kZWwudmlld0ZyYW1lQS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5laWdoYm91ciA9IGdldE5laWdoYm91cihzcGxpdHRlci5tb2RlbC52aWV3RnJhbWVBLmlkKTtcclxuICAgICAgICAgICAgICAgIGlmICghbmVpZ2hib3VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BsaXR0ZXIuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzcGxpdHRlci51cGRhdGVOZWlnaGJvdXIobmVpZ2hib3VyKTtcclxuICAgICAgICAgICAgICAgICAgICBzcGxpdHRlci5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICB9ICBcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNwbGl0dGVyLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0TmVpZ2hib3VyICh2aWV3RnJhbWVJZCkge1xyXG4gICAgICAgICAgICBpZiAoIXZpZXdGcmFtZUlkKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhY3RpdmVJZHMuaW5kZXhPZih2aWV3RnJhbWVJZCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgYWN0aXZlSWRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY3RpdmVGcmFtZXNbaW5kZXggKyAxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IFZpZXdGcmFtZXNVSTtcclxuIiwiaW1wb3J0IHsgdW5pcXVlSWQsIGNsb25lLCBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBOb2RlLCBMaW5rLCBHcmFwaE5vZGUsIEdyYXBoTGluaywgR3JhcGhDcm9zc05vZGUsIEdyYXBoQ3Jvc3NMaW5rIH0gZnJvbSAnLi9tYXBFbGVtZW50cyc7XHJcbmltcG9ydCB7IFJlc291cmNlUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9kYXRhL3Jlc291cmNlUHJvdmlkZXInO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NEYXRhIChyYXdEYXRhLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCB0b3BOb2RlTW9kZWxzID0gcHJvY2Vzc05vZGVzKHJhd0RhdGEubm9kZXMsIHBhcmFtZXRlcnMpO1xyXG4gICAgY29uc3QgZGVyaXZhdGlvbk1hcE5vZGVzID0gY3JlYXRlRGlhZ3JhbU5vZGVzKHRvcE5vZGVNb2RlbHMsIHBhcmFtZXRlcnMpO1xyXG5cclxuICAgIGNvbnN0IG1hcExpbmtNb2RlbHMgPSBwcm9jZXNzTGlua3MocmF3RGF0YS5lZGdlcywgZGVyaXZhdGlvbk1hcE5vZGVzKTtcclxuICAgIC8vIENyZWF0ZSBmYWtlIGxpbmsgaWYgdGhlcmUgYXJlIG5vIGxpbmtzIGF0IGFsbCAoaXQgbWVhbnMgd2UgaGF2ZSBhIHByb2JsZW0gd2l0aCBhIGRhdGEpXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgaWYgKG1hcExpbmtNb2RlbHMubGVuZ3RoID09PSAwICYmIHRvcE5vZGVNb2RlbHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgY29uc3QgdG9wSWRzID0gdG9wTm9kZU1vZGVscy5tYXAodG0gPT4gdG0uaWQpO1xyXG4gICAgICAgIGNvbnN0IHRvcFZpZXdzID0gZGVyaXZhdGlvbk1hcE5vZGVzLmZpbHRlcihuID0+IHRvcElkcy5pbmRleE9mKG4uaWQpICE9PSAtMSk7XHJcbiAgICAgICAgbWFwTGlua01vZGVscy5wdXNoKHtcclxuICAgICAgICAgICAgc291cmNlOiB0b3BWaWV3c1swXSxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0b3BWaWV3c1sxXSxcclxuICAgICAgICAgICAgbGFiZWw6ICcnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGNvbnN0IGZpbmFsTGlua01vZGVscyA9IGdyb3VwTGlua3MobWFwTGlua01vZGVscywgcGFyYW1ldGVycyk7XHJcbiAgICBjb25zdCBkZXJpdmF0aW9uTWFwTGlua3MgPSBmaW5hbExpbmtNb2RlbHMubWFwKG1vZGVsID0+IG5ldyBMaW5rKG1vZGVsLCBwYXJhbWV0ZXJzKSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGVsZW1lbnRzOiBkZXJpdmF0aW9uTWFwTm9kZXMsXHJcbiAgICAgICAgbGlua3M6IGRlcml2YXRpb25NYXBMaW5rcyxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgcHJvY2Vzc0RhdGE7XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzTGlua3MgKHJhd0xpbmtzLCBkZXJpdmF0aW9uTWFwTm9kZXMpIHtcclxuICAgIGlmICghcmF3TGlua3MpIHJldHVybiBbXTtcclxuIFxyXG4gICAgY29uc3Qgbm9kZU1hcCA9IHt9O1xyXG4gICAgZGVyaXZhdGlvbk1hcE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgaWYgKG5vZGVNYXBbbm9kZS5lbmRwb2ludElkXSkge1xyXG4gICAgICAgICAgICBub2RlTWFwW25vZGUuZW5kcG9pbnRJZF0ucHVzaChub2RlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlTWFwW25vZGUuZW5kcG9pbnRJZF0gPSBbbm9kZV07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgZXhpc3RpbmdMaW5rcyA9IHt9O1xyXG4gICAgcmF3TGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAobm9kZU1hcFtsaW5rLnNvdXJjZV0gfHwgW10pLmZvckVhY2goc291cmNlID0+IHtcclxuICAgICAgICAgICAgKG5vZGVNYXBbbGluay50YXJnZXRdIHx8IFtdKS5mb3JFYWNoKHRhcmdldCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShleGlzdGluZ0xpbmtzW3NvdXJjZS5pZF0gJiYgZXhpc3RpbmdMaW5rc1tzb3VyY2UuaWRdW3RhcmdldC5pZF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxMaW5rID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBsaW5rLmxhYmVsIHx8IGdldExhYmVsRnJvbUlkKGxpbmsuaWQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlSWQ6IGxpbmsuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgW3NvdXJjZS5pZF0uY29uY2F0KHNvdXJjZS5vcmRlcmVkUG9zc2libGVJZHMpLmZvckVhY2goc291cmNlSWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGFyZ2V0LmlkXS5jb25jYXQodGFyZ2V0Lm9yZGVyZWRQb3NzaWJsZUlkcykuZm9yRWFjaCh0YXJnZXRJZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nTGlua3Nbc291cmNlSWRdKSBleGlzdGluZ0xpbmtzW3NvdXJjZUlkXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdMaW5rc1tzb3VyY2VJZF1bdGFyZ2V0SWRdID0gZmluYWxMaW5rO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBsaW5rcyA9IFtdO1xyXG4gICAgT2JqZWN0LmtleXMoZXhpc3RpbmdMaW5rcykuZm9yRWFjaChzb3VyY2VJZCA9PiB7XHJcbiAgICAgICAgT2JqZWN0LmtleXMoZXhpc3RpbmdMaW5rc1tzb3VyY2VJZF0pLmZvckVhY2godGFyZ2V0SWQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rID0gZXhpc3RpbmdMaW5rc1tzb3VyY2VJZF1bdGFyZ2V0SWRdO1xyXG4gICAgICAgICAgICBpZiAobGlua3MuaW5kZXhPZihsaW5rKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBsaW5rcztcclxufVxyXG5cclxuZnVuY3Rpb24gZ3JvdXBMaW5rcyAobGlua01vZGVscywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3QgZ3JvdXBzQnlTb3VyY2UgPSB7fTtcclxuICAgIGNvbnN0IGdyb3Vwc0J5VGFyZ2V0ID0ge307XHJcblxyXG4gICAgbGlua01vZGVscy5mb3JFYWNoKGxpbmtNb2RlbCA9PiB7XHJcbiAgICAgICAgY29uc3QgdHlwZUlkID0gbGlua01vZGVsLnR5cGVJZCB8fCBsaW5rTW9kZWwubGFiZWw7XHJcbiAgICAgICAgY29uc3Qgc291cmNlQ2FjaGVJZCA9IGNhY2hlRnVuY3Rpb24odHlwZUlkLCBsaW5rTW9kZWwuc291cmNlLmlkKTtcclxuICAgICAgICBpZiAoIWdyb3Vwc0J5U291cmNlW3NvdXJjZUNhY2hlSWRdKSB7XHJcbiAgICAgICAgICAgIGdyb3Vwc0J5U291cmNlW3NvdXJjZUNhY2hlSWRdID0gW107XHJcbiAgICAgICAgICAgIGdyb3Vwc0J5U291cmNlW3NvdXJjZUNhY2hlSWRdLnNvdXJjZSA9IGxpbmtNb2RlbC5zb3VyY2U7XHJcbiAgICAgICAgICAgIGdyb3Vwc0J5U291cmNlW3NvdXJjZUNhY2hlSWRdLmxhYmVsID0gbGlua01vZGVsLmxhYmVsO1xyXG4gICAgICAgICAgICBncm91cHNCeVNvdXJjZVtzb3VyY2VDYWNoZUlkXS50eXBlSWQgPSB0eXBlSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdyb3Vwc0J5U291cmNlW3NvdXJjZUNhY2hlSWRdLnB1c2gobGlua01vZGVsKTtcclxuXHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2FjaGVJZCA9IGNhY2hlRnVuY3Rpb24odHlwZUlkLCBsaW5rTW9kZWwudGFyZ2V0LmlkKTtcclxuICAgICAgICBpZiAoIWdyb3Vwc0J5VGFyZ2V0W3RhcmdldENhY2hlSWRdKSB7XHJcbiAgICAgICAgICAgIGdyb3Vwc0J5VGFyZ2V0W3RhcmdldENhY2hlSWRdID0gW107XHJcbiAgICAgICAgICAgIGdyb3Vwc0J5VGFyZ2V0W3RhcmdldENhY2hlSWRdLnRhcmdldCA9IGxpbmtNb2RlbC50YXJnZXQ7XHJcbiAgICAgICAgICAgIGdyb3Vwc0J5VGFyZ2V0W3RhcmdldENhY2hlSWRdLmxhYmVsID0gbGlua01vZGVsLmxhYmVsO1xyXG4gICAgICAgICAgICBncm91cHNCeVRhcmdldFt0YXJnZXRDYWNoZUlkXS50eXBlSWQgPSB0eXBlSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdyb3Vwc0J5VGFyZ2V0W3RhcmdldENhY2hlSWRdLnB1c2gobGlua01vZGVsKTtcclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5rZXlzKGdyb3Vwc0J5U291cmNlKS5mb3JFYWNoKGdyb3VwSWQgPT4ge1xyXG4gICAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBzQnlTb3VyY2VbZ3JvdXBJZF07XHJcbiAgICAgICAgY29uc3QgY3Jvc3NlZEVsZW1lbnRzID0gZ3JvdXAubGVuZ3RoID4gMSA/IGdyb3VwIDogW107XHJcbiAgICAgICAgY29uc3QgY3Jvc3NOb2RlID0gbmV3IEdyYXBoQ3Jvc3NOb2RlKHtjcm9zc2VkRWxlbWVudHM6IGNyb3NzZWRFbGVtZW50c30pO1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZUxpbmsgPSBuZXcgR3JhcGhMaW5rKHtcclxuICAgICAgICAgICAgc291cmNlOiBncm91cC5zb3VyY2UsXHJcbiAgICAgICAgICAgIHRhcmdldDogY3Jvc3NOb2RlLFxyXG4gICAgICAgICAgICBsYWJlbDogZ3JvdXAubGFiZWwsXHJcbiAgICAgICAgICAgIHR5cGVJZDogZ3JvdXAudHlwZUlkLFxyXG4gICAgICAgICAgICBjcm9zc2VkRWxlbWVudHM6IGNyb3NzZWRFbGVtZW50cyxcclxuICAgICAgICB9LCBwYXJhbWV0ZXJzKTtcclxuICAgICAgICBjcm9zc2VkRWxlbWVudHMuZm9yRWFjaChsaW5rTW9kZWwgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRMaW5rID0gbmV3IEdyYXBoQ3Jvc3NMaW5rKHtcclxuICAgICAgICAgICAgICAgIHR5cGVJZDogZ3JvdXAudHlwZUlkLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiBjcm9zc05vZGUsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGxpbmtNb2RlbC50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogJycsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsaW5rTW9kZWwuZ3JhcGhQcmltaXRpdmVzID0gW1xyXG4gICAgICAgICAgICAgICAgY3Jvc3NOb2RlLCBzb3VyY2VMaW5rLCB0YXJnZXRMaW5rLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBsaW5rTW9kZWwuZ3JvdXBlZEJ5ID0gJ3NvdXJjZSc7XHJcbiAgICAgICAgfSwgcGFyYW1ldGVycyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3Qua2V5cyhncm91cHNCeVRhcmdldCkuZm9yRWFjaChncm91cElkID0+IHtcclxuICAgICAgICBjb25zdCBncm91cCA9IGdyb3Vwc0J5VGFyZ2V0W2dyb3VwSWRdO1xyXG4gICAgICAgIGNvbnN0IGNyb3NzZWRFbGVtZW50cyA9IGdyb3VwLmxlbmd0aCA+IDEgPyBncm91cC5maWx0ZXIobGlua01vZGVsID0+ICFsaW5rTW9kZWwuZ3JhcGhQcmltaXRpdmVzKSA6IFtdO1xyXG4gICAgICAgIGNvbnN0IGNyb3NzTm9kZSA9IG5ldyBHcmFwaENyb3NzTm9kZSh7Y3Jvc3NlZEVsZW1lbnRzOiBjcm9zc2VkRWxlbWVudHN9KTtcclxuICAgICAgICBjb25zdCB0YXJnZXRMaW5rID0gbmV3IEdyYXBoQ3Jvc3NMaW5rKHtcclxuICAgICAgICAgICAgc291cmNlOiBjcm9zc05vZGUsXHJcbiAgICAgICAgICAgIHRhcmdldDogZ3JvdXAudGFyZ2V0LFxyXG4gICAgICAgICAgICBsYWJlbDogZ3JvdXAubGFiZWwsXHJcbiAgICAgICAgICAgIHR5cGVJZDogZ3JvdXAudHlwZUlkLFxyXG4gICAgICAgICAgICBjcm9zc2VkRWxlbWVudHM6IGNyb3NzZWRFbGVtZW50cyxcclxuICAgICAgICB9LCBwYXJhbWV0ZXJzKTtcclxuICAgICAgICBjcm9zc2VkRWxlbWVudHMuZm9yRWFjaChsaW5rTW9kZWwgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VMaW5rID0gbmV3IEdyYXBoTGluayh7XHJcbiAgICAgICAgICAgICAgICB0eXBlSWQ6IGdyb3VwLnR5cGVJZCxcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogbGlua01vZGVsLnNvdXJjZSxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogY3Jvc3NOb2RlLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICcnLFxyXG4gICAgICAgICAgICB9LCBwYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgbGlua01vZGVsLmdyYXBoUHJpbWl0aXZlcyA9IFtcclxuICAgICAgICAgICAgICAgIGNyb3NzTm9kZSwgc291cmNlTGluaywgdGFyZ2V0TGluayxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgbGlua01vZGVsLmdyb3VwZWRCeSA9ICd0YXJnZXQnO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGxpbmtNb2RlbHM7XHJcblxyXG4gICAgZnVuY3Rpb24gY2FjaGVGdW5jdGlvbiAobGFiZWwsIHRlcm1pbmFsSWQpIHtcclxuICAgICAgICByZXR1cm4gYCR7bGFiZWx9fiN0cURNTGluayN+JHt0ZXJtaW5hbElkfWA7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NOb2RlcyAocmF3Tm9kZXMsIHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHRvcE5vZGVzTWFwID0ge307XHJcbiAgICBjb25zdCBhbGxOb2Rlc01hcCA9IHt9O1xyXG4gICAgY29uc3QgcGFyZW50TWFwID0ge307XHJcbiAgICBjb25zdCByZXMgPSBuZXcgUmVzb3VyY2VQcm92aWRlcihwYXJhbWV0ZXJzKTtcclxuXHJcbiAgICByYXdOb2Rlcy5mb3JFYWNoKHJhd05vZGUgPT4ge1xyXG4gICAgICAgIGlmIChyYXdOb2RlLmlkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50TWFwW3Jhd05vZGUuaWRdO1xyXG4gICAgICAgICAgICBjb25zdCB0eXBlSWNvbiA9IHJlcy5nZXRJY29uKHJhd05vZGUudHlwZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gYWxsTm9kZXNNYXBbcmF3Tm9kZS5pZF0gfHwgY3JlYXRlTW9kZWwocmF3Tm9kZSwgY2hpbGRyZW4sIHR5cGVJY29uKTtcclxuICAgICAgICAgICAgYWxsTm9kZXNNYXBbcmF3Tm9kZS5pZF0gPSBtb2RlbDtcclxuICAgICAgICAgICAgZGVsZXRlIHBhcmVudE1hcFtyYXdOb2RlLmlkXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyYXdOb2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFsbE5vZGVzTWFwW3Jhd05vZGUucGFyZW50XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbE5vZGVzTWFwW3Jhd05vZGUucGFyZW50XS5jaGlsZHJlbi5wdXNoKG1vZGVsKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRNYXBbcmF3Tm9kZS5wYXJlbnRdKSBwYXJlbnRNYXBbcmF3Tm9kZS5wYXJlbnRdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50TWFwW3Jhd05vZGUucGFyZW50XS5wdXNoKG1vZGVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICghdG9wTm9kZXNNYXBbcmF3Tm9kZS5pZF0pIHtcclxuICAgICAgICAgICAgICAgIHRvcE5vZGVzTWFwW3Jhd05vZGUuaWRdID0gbW9kZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBQcm9jZXNzIG9ycGhhbiBub2Rlcy5cclxuICAgIC8vIFRoZXJlIHdlcmUgbGlua3MgdG8gdGhlbSBidXQgbm8gZGVmZW5pdGlvbnMuXHJcbiAgICBPYmplY3Qua2V5cyhwYXJlbnRNYXApLmZvckVhY2goaWQgPT4ge1xyXG4gICAgICAgIHRvcE5vZGVzTWFwW2lkXSA9IGNyZWF0ZU1vZGVsKHtcclxuICAgICAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgICAgICBsYWJlbDogZ2V0TGFiZWxGcm9tSWQoaWQpLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogcGFyZW50TWFwW2lkXSxcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHRvcE5vZGVzID0gT2JqZWN0LmtleXModG9wTm9kZXNNYXApLm1hcChrZXkgPT4gdG9wTm9kZXNNYXBba2V5XSk7XHJcblxyXG4gICAgLy8gcmVtb3ZlIGN5Y2xlc1xyXG4gICAgY29uc3QgcHJvY2Vzc2VkTm9kZXNNYXAgPSB7fTtcclxuICAgIGZ1bmN0aW9uIHJlY3Vyc2lvbiAocm9vdE5vZGUpIHtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbklkcyA9IHt9O1xyXG4gICAgICAgIHJvb3ROb2RlLmNoaWxkcmVuID0gcm9vdE5vZGUuY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+IHtcclxuICAgICAgICAgICAgaWYgKCghcHJvY2Vzc2VkTm9kZXNNYXBbY2hpbGQuaWRdKSAmJiAoIWNoaWxkcmVuSWRzW2NoaWxkLmlkXSkpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuSWRzW2NoaWxkLmlkXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWROb2Rlc01hcFtjaGlsZC5pZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmVjdXJzaW9uKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZE5vZGVzTWFwW2NoaWxkLmlkXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdG9wTm9kZXMuZmlsdGVyKHRvcCA9PiB7XHJcbiAgICAgICAgaWYgKCFwcm9jZXNzZWROb2Rlc01hcFt0b3AuaWRdKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZE5vZGVzTWFwW3RvcC5pZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICByZWN1cnNpb24odG9wKTtcclxuICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZXNNYXBbdG9wLmlkXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZU1vZGVsIChyYXdOb2RlLCBjaGlsZHJlbiwgdHlwZUljb24pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IHVuaXF1ZUlkKCdtYXBFbGVtZW50JyksXHJcbiAgICAgICAgZW5kcG9pbnRJZDogcmF3Tm9kZS5pZCxcclxuICAgICAgICBsYWJlbDogcmF3Tm9kZS5sYWJlbCB8fCBnZXRMYWJlbEZyb21JZChyYXdOb2RlLmlkKSxcclxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4gfHwgW10sXHJcbiAgICAgICAgcmVzb3VyY2VUeXBlOiByYXdOb2RlLnJlc291cmNlVHlwZSB8fCAndW5kZWZpbmVkJyxcclxuICAgICAgICByZXNvdXJjZTogcmF3Tm9kZS5yZXNvdXJjZSB8fCAndW5kZWZpbmVkJyxcclxuICAgICAgICB0eXBlOiByYXdOb2RlLnR5cGUgfHwgJ3VuZGVmaW5lZCcsXHJcbiAgICAgICAgY29sbGFwc2VkOiByYXdOb2RlLmNvbGxhcHNlZCxcclxuICAgICAgICBpY29uOiByYXdOb2RlLmljb24gfHwgdHlwZUljb24sXHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVEaWFncmFtTm9kZXMgKHRvcE5vZGVNb2RlbHMsIHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IGRlcml2YXRpb25NYXBOb2RlcyA9IFtdO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNvcHkgKGVsZW1lbnQsIGR1YmxpY2F0aW9uTWFwKSB7XHJcbiAgICAgICAgY29uc3QgZHVibGljYXRpb24gPSBkdWJsaWNhdGlvbk1hcCB8fCB7fTtcclxuICAgICAgICBpZiAoIWR1YmxpY2F0aW9uW2VsZW1lbnQuaWRdKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZEVsZW1lbnQgPSBjbG9uZShlbGVtZW50KTtcclxuICAgICAgICAgICAgY2xvbmVkRWxlbWVudC5pZCA9IHVuaXF1ZUlkKCdjb3B5T2ZNYXBFbGVtZW50Jyk7XHJcblxyXG4gICAgICAgICAgICBkdWJsaWNhdGlvbltlbGVtZW50LmlkXSA9IGNsb25lZEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGNsb25lZEVsZW1lbnQuY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjb3B5KGNoaWxkLCBkdWJsaWNhdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZHVibGljYXRpb25bZWxlbWVudC5pZF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlR3JvdXAgKG1vZGVsMSwgbW9kZWwyKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IHVuaXF1ZUlkKCdHcm91cCcpLFxyXG4gICAgICAgICAgICBsYWJlbDogJ0dyb3VwJyxcclxuICAgICAgICAgICAgZW5kcG9pbnRJZDogJ25vbmUnLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogWyBtb2RlbDEsIG1vZGVsMiBdLFxyXG4gICAgICAgICAgICBzeW50aGV0aWM6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbGxhcHNlZDogdHJ1ZSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZFRvR3JvdXAgKGdyb3VwLCBtb2RlbCkge1xyXG4gICAgICAgIGdyb3VwLmNoaWxkcmVuLnB1c2gobW9kZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHRoZXJlIGlzIG1vcmUgdGhlbiBvbmUgdG9wRWxlbWVudCBmb3Igc29tZSBtb2RlbFxyXG4gICAgY29uc3QgdG9wRWxlbWVudEZvcklkID0ge307XHJcbiAgICBjb25zdCBmaWx0ZXJlZFRvcE1vZGVscyA9IHt9O1xyXG4gICAgdG9wTm9kZU1vZGVscy5mb3JFYWNoKHRvcEVsZW1lbnQgPT4ge1xyXG4gICAgICAgIHJlY3Vyc2lvbih0b3BFbGVtZW50KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVjdXJzaW9uIChjdXJNb2RlbCkge1xyXG4gICAgICAgICAgICBpZiAodG9wRWxlbWVudEZvcklkW2N1ck1vZGVsLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0b3BFbGVtZW50Rm9ySWRbY3VyTW9kZWwuaWRdLnN5bnRoZXRpYyAmJiB0b3BFbGVtZW50LmlkICE9PSB0b3BFbGVtZW50Rm9ySWRbY3VyTW9kZWwuaWRdLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZpbHRlcmVkVG9wTW9kZWxzW3RvcEVsZW1lbnQuaWRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmaWx0ZXJlZFRvcE1vZGVsc1t0b3BFbGVtZW50Rm9ySWRbY3VyTW9kZWwuaWRdLmlkXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdG9wRWxlbWVudEZvcklkW2N1ck1vZGVsLmlkXSA9IGNyZWF0ZUdyb3VwKHRvcEVsZW1lbnRGb3JJZFtjdXJNb2RlbC5pZF0sIHRvcEVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZFRvcE1vZGVsc1t0b3BFbGVtZW50Rm9ySWRbY3VyTW9kZWwuaWRdLmlkXSA9IHRvcEVsZW1lbnRGb3JJZFtjdXJNb2RlbC5pZF07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZFRvR3JvdXAodG9wRWxlbWVudEZvcklkW2N1ck1vZGVsLmlkXSwgdG9wRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29weShjdXJNb2RlbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0b3BFbGVtZW50Rm9ySWRbY3VyTW9kZWwuaWRdID0gdG9wRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkVG9wTW9kZWxzW3RvcEVsZW1lbnQuaWRdID0gdG9wRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGN1ck1vZGVsLmNoaWxkcmVuID0gY3VyTW9kZWwuY2hpbGRyZW4ubWFwKFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0+IHJlY3Vyc2lvbihjaGlsZCksXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1ck1vZGVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgT2JqZWN0LmtleXMoZmlsdGVyZWRUb3BNb2RlbHMpLmZvckVhY2godG9wRWxlbWVudElkID0+IHtcclxuICAgICAgICBjb25zdCB0b3BFbGVtZW50ID0gZmlsdGVyZWRUb3BNb2RlbHNbdG9wRWxlbWVudElkXTtcclxuXHJcbiAgICAgICAgY29uc3QgZ3JhcGhOb2RlID0gbmV3IEdyYXBoTm9kZSh0b3BFbGVtZW50LCBwYXJhbWV0ZXJzKTtcclxuICAgICAgICBjb25zdCBwcm9jZXNzZWROb2RlcyA9IHt9O1xyXG4gICAgICAgIHJlY3Vyc2lvbih0b3BFbGVtZW50LCBbXSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlY3Vyc2lvbiAoY3VyTW9kZWwsIHBvc3NpYmxlSWRzKSB7XHJcbiAgICAgICAgICAgIGlmICghcHJvY2Vzc2VkTm9kZXNbY3VyTW9kZWwuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IGNsb25lRGVlcChjdXJNb2RlbCk7XHJcbiAgICAgICAgICAgICAgICBtb2RlbC5vcmRlcmVkUG9zc2libGVJZHMgPSBwb3NzaWJsZUlkcztcclxuICAgICAgICAgICAgICAgIG1vZGVsLmdyYXBoTm9kZSA9IGdyYXBoTm9kZTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZXNbY3VyTW9kZWwuaWRdID0gbmV3IE5vZGUobW9kZWwsIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZXNbY3VyTW9kZWwuaWRdLmNoaWxkcmVuID0gY3VyTW9kZWwuY2hpbGRyZW4ubWFwKFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0+IHJlY3Vyc2lvbihjaGlsZCwgcG9zc2libGVJZHMuY29uY2F0KFtjdXJNb2RlbC5pZF0pKSxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBkZXJpdmF0aW9uTWFwTm9kZXMucHVzaChwcm9jZXNzZWROb2Rlc1tjdXJNb2RlbC5pZF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzZWROb2Rlc1tjdXJNb2RlbC5pZF07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGRlcml2YXRpb25NYXBOb2RlcztcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TGFiZWxGcm9tSWQgKGlkKSB7XHJcbiAgICBjb25zdCB0ZXJtcyA9IGlkLnNwbGl0KCcvJyk7XHJcbiAgICBjb25zdCBzbGFzaExhYmVsID0gdGVybXNbdGVybXMubGVuZ3RoIC0gMV07XHJcbiAgICBpZiAoc2xhc2hMYWJlbCkge1xyXG4gICAgICAgIHJldHVybiBzbGFzaExhYmVsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBoYXNoSW5kZXggPSBpZC5pbmRleE9mKCcjJyk7XHJcbiAgICAgICAgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgY29uc3QgaGFzaExhYmVsID0gaWQuc3Vic3RyaW5nKGhhc2hJbmRleCwgaWQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBoYXNoTGFiZWw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgVFFHcmFtVUkgZnJvbSAndmlzdWFsaXphdGlvbnMtbGlicmFyeSc7XHJcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHByb2Nlc3NEYXRhIGZyb20gJy4vZGF0YVByb2Nlc3NpbmcnO1xyXG5pbXBvcnQgKiBhcyBtYXBFbGVtZW50cyBmcm9tICcuL21hcEVsZW1lbnRzJztcclxuaW1wb3J0IHsgTWFwTGF5b3V0IH0gZnJvbSAnLi9tYXBMYXlvdXQnO1xyXG5pbXBvcnQgeyBETURlZmF1bHRVSSB9IGZyb20gJy4uLy4uL2h0bWxVSS9kbURlZmF1bHRVSSc7XHJcbmltcG9ydCB7IERFRkFVTFRfREVSSVZBVElPTl9NQVBfTElOS19TVFlMRSB9IGZyb20gJy4uLy4uL2RhdGEvcmVzb3VyY2VQcm92aWRlcic7XHJcbmltcG9ydCB7IGNoZWNrRG1SYXdEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbHMvZGF0YVV0aWxzJztcclxuaW1wb3J0IFN1YnNjcmliYWJsZSBmcm9tICcuLi8uLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZSc7XHJcblxyXG4vKipcclxuICogTGluayBzdHlsZSBkZWZpbml0aW9uIGZvciBETVxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBETUxpbmtTdHlsZURlZmluaXRpb25cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNzc0NsYXNzIC0gQ1NTIGNsYXNzIHdoaWNoIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIHN2ZyBjb21wb25lbnRcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxpbmVUeXBlIC0gJ3NvbGlkJyBvciAnZGFzaGVkJ1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29sb3IgLSBDb2xvciBvZiB0aGUgbGluZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGV4dENvbG9yIC0gQ29sb3Igb2YgdGhlIHRleHQgb24gdGhlIGxpbmVcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRleHRCYWNrZ3JvdW5kQ29sb3IgLSBDb2xvciBvZiB0aGUgYmFja2dyb3VuZCBvZiB0aGUgdGV4dCBvbiB0aGUgbGluZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGhpY2tuZXNzXHJcbiovXHJcblxyXG4vKipcclxuICogU2V0IG9mIHBhcmFtZXRlcnMgZm9yIERlcml2YXRpb24gTWFwXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlcml2YXRpb25NYXBQYXJhbWV0ZXJzXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIExpbmtTdHlsZURlZmluaXRpb24+fSBsaW5rU3R5bGVzIC0gTWFwIGJldHdlZW4gdGhlIGxpbmtUeXBlcyBhbmQgTGlua1N0eWxlcy5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlZmF1bHRFbGVtZW50V2lkdGhcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlZmF1bHRFbGVtZW50SGVpZ2h0XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZWZhdWx0TGlua0xhYmVsTGVuZ3RoXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZWZhdWx0TGF5b3V0U3RlcFxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlcnJvckNhbGxCYWNrIC0gaXQgaXMgY2FsbGVkIGluIHJlc3BvbnNlIHRvIHdhcm5pbmdzIGFuZCBlcnJvcnNcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGRlZmF1bHQgc2V0IG9mIHBhcmFtZXRlcnNcclxuICogQHJldHVybnMge0Rlcml2YXRpb25NYXBQYXJhbWV0ZXJzfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRQYXJhbWV0ZXJzU2V0ICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGVmYXVsdEVsZW1lbnRXaWR0aDogMjUwLFxyXG4gICAgICAgIGRlZmF1bHRFbGVtZW50SGVpZ2h0OiAyNTAsXHJcbiAgICAgICAgZGVmYXVsdExpbmtMYWJlbExlbmd0aDogMTAwLFxyXG4gICAgICAgIGRlZmF1bHRMYXlvdXRTdGVwOiAxNTAsXHJcbiAgICAgICAgbGlua1N0eWxlczoge1xyXG4gICAgICAgICAgICAnZGVmYXVsdC1saW5rLXN0eWxlJzogREVGQVVMVF9ERVJJVkFUSU9OX01BUF9MSU5LX1NUWUxFLFxyXG4gICAgICAgICAgICAvLyBFeGFtcGxlOlxyXG4gICAgICAgICAgICAvLyAndHlwZS1pZC0xMjM0Jzoge1xyXG4gICAgICAgICAgICAvLyAgICAgbGluZVR5cGU6ICdkYXNoZWQnLCAvLyAnc29saWQnXHJcbiAgICAgICAgICAgIC8vICAgICBjc3NDbGFzczogJ2NsYXNzLTEyMydcclxuICAgICAgICAgICAgLy8gICAgIGNvbG9yOiAnZ3JlZW4nLFxyXG4gICAgICAgICAgICAvLyAgICAgdGV4dENvbG9yOiAnYmx1ZScsXHJcbiAgICAgICAgICAgIC8vICAgICB0ZXh0QmFja2dyb3VuZENvbG9yOiAneWVsbG93JyxcclxuICAgICAgICAgICAgLy8gICAgIHRoaWNrbmVzczogNSxcclxuICAgICAgICAgICAgLy8gfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGljb25zOiB7XHJcbiAgICAgICAgICAgICdTUUwgc2NyaXB0JzogJ2dseXBoaWNvbiBnbHlwaGljb24tY29nJyxcclxuICAgICAgICAgICAgJ0RhdGFiYXNlIFRhYmxlJzogJ2dseXBoaWNvbiBnbHlwaGljb24tZm9sZGVyLWNsb3NlJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvb2xzOltdLFxyXG4gICAgICAgIGVycm9yQ2FsbEJhY2s6IHVuZGVmaW5lZCwgLy8gSXQgaXMgY2FsbGVkIGluIHJlc3BvbnNlIHRvIHdhcm5pbmdzIGFuZCBlcnJvcnNcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3NcclxuICogRGlzcGxheXMgZGVyaXZhdGlvbiB2aWV3IGZvciBzZWxlY3RlZCBsaW5rXHJcbiAqXHJcbiAqIENvbnN0cnVjdG9yIHBhcmFtZXRlcnM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQHBhcmFtIHtcclxuICogIGRhdGFQcm92aWRlcjogRGF0YUNvbnRhaW5lclxyXG4gKiAgcm9vdEVsZW1lbnQ6IEhUTUxFbGVtZW50XHJcbiAqICByZWxhdGlvbjogeyBzb3VyY2U6IHN0cmluZywgdGFyZ2V0OiBzdHJpbmcgfVxyXG4gKiB9IG9wdGlvbnNcclxuICogQHBhcmFtIHtEZXJpdmF0aW9uTWFwUGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIHBhcmFtZXRlcnMgc2V0XHJcbiAqXHJcbiAqIFB1YmxpYyBwcm9wZXJ0aWVzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIHJlbGF0aW9uOiB7IHNvdXJjZTogc3RyaW5nLCB0YXJnZXQ6IHN0cmluZyB9XHJcbiAqXHJcbiAqIFB1YmxpYyBtZXRob2RzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIG9wZW5XaXRoUmVsYXRpb24gKHJlbGF0aW9uOiB7IHNvdXJjZTogc3RyaW5nLCB0YXJnZXQ6IHN0cmluZyB9KSAtIEluaXRpYWxpemVzIERNIGRpYWdyYW1cclxuICogZXhwb3J0VG9TdmcoKVxyXG4gKiBleHBvcnRUb1BuZygpXHJcbiAqIHJlc2V0Rm9jdXMoKVxyXG4gKiB6b29tSW4oKVxyXG4gKiB6b29tT3V0KClcclxuICogem9vbVRvRml0KClcclxuICogcHJpbnQoKVxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIG9uIChldmVudDogc3RyaW5nLCBjYWxsYmFjazogZnVuY3Rpb24pOiB2b2lkXHJcbiAqIHVuc3Vic2NyaWJlIChjYWxsYmFjazogZnVuY3Rpb24pOiB2b2lkXHJcbiAqIHRyaWdnZXIgKGV2ZW50OiBzdHJpbmcsIHBhcmFtZXRlcnM6IGFueSk6IHZvaWRcclxuICpcclxuICogRXZlbnRzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBmaXJlcyBkaWFncmFtLXN0YXRlLWNoYW5nZWQgKHN0YXRlSWQ6IHN0cmluZylcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBEZXJpdmF0aW9uTWFwIChwcm9wZXJ0aWVzLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7XHJcblxyXG4gICAgY29uc3QgZGVmYXVsdFBhcmFtZXRlclNldCA9IGdldERlZmF1bHRQYXJhbWV0ZXJzU2V0KCk7XHJcbiAgICAvLyBNZXJnaW5nIHBhcmFtZXRlcnMgZGVmYXVsdCBhbmQgdXNlclxyXG4gICAgY29uc3QgX3BhcmFtZXRlcnMgPSBfLm1lcmdlKGRlZmF1bHRQYXJhbWV0ZXJTZXQsIHBhcmFtZXRlcnMgfHwge30pO1xyXG5cclxuICAgIGNvbnN0IF9lcnJvckNhbGxiYWNrID0gKGUpID0+IHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIF9wYXJhbWV0ZXJzLmVycm9yQ2FsbGJhY2sgJiZcclxuICAgICAgICAgICAgX3BhcmFtZXRlcnMuZXJyb3JDYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdHlwZW9mIGUgPT09ICdzdHJpbmcnID8gbmV3IEVycm9yKGUpIDogZTtcclxuICAgICAgICAgICAgX3BhcmFtZXRlcnMuZXJyb3JDYWxsYmFjay5jYWxsKHRoaXMsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhdGUgY2hhbmdlZCBldmVudCAtIGZpcmVzIHdoZW4gRE0gc3RhdGUgY2hhbmdlcy5cclxuICAgICAqIEUuZy4gZnJvbSBhIGZldGNoaW5nIHN0YXRlIHRvIGEgcmVuZGVyaW5nIHN0YXRlLlxyXG4gICAgICogVGhlIHN0YXRlIHN0cmluZyBpZGVudGlmaWVyIGlzIHJldHVybmVkIGFzIGEgcGFyYW1ldGVyIG9mIHRoZSBldmVudFxyXG4gICAgICogQGV2ZW50IGRpYWdyYW0tc3RhdGUtY2hhbmdlZFxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGF0ZSAtIFBhcmFtZXRlciBjYW4gdGFrZSB0aGUgZm9sbG93aW5nIHZhbHVlczogJ2ZldGNoaW5nJyB8ICdyZW5kZXJpbmcnIHwgJ2NvbXBsZXRlZCcgfCAnZXJyb3InXHJcbiAgICAqL1xyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgY29uc3QgX2RhdGFQcm92aWRlciA9IHByb3BlcnRpZXMuZGF0YVByb3ZpZGVyO1xyXG4gICAgY29uc3QgX2Jhc2UgPSBfY3JlYXRlQmFzZShwcm9wZXJ0aWVzLnJvb3RFbGVtZW50KTtcclxuXHJcbiAgICBjb25zdCBfbGF5b3V0ID0gbmV3IE1hcExheW91dCh7XHJcbiAgICAgICAgcm9vdEVsZW1lbnQ6IF9iYXNlLmRlcml2YXRpb25NYXBSb290SHRtbFxyXG4gICAgfSwgX3BhcmFtZXRlcnMpO1xyXG4gICAgY29uc3QgX3Byb2dyZXNzU2NyZWVuID0gbmV3IFRRR3JhbVVJLlByb2dyZXNzU2NyZWVuKHtcclxuICAgICAgICBiYXNlRWxlbWVudDogX2Jhc2UuY29udGFpbmVyLFxyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IF9zZWxlY3RlZEVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6YXRpb25cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgY29uc3QgX2RlZmF1bHRVSSA9IG5ldyBETURlZmF1bHRVSSh7XHJcbiAgICAgICAgYmFzZUVsZW1lbnQ6IF9iYXNlLnRvb2xiYXIsXHJcbiAgICAgICAgaW5mb1BhbmVsOiBfYmFzZS5pbmZvUGFuZWwsXHJcbiAgICAgICAgdG9vbHM6IF9wYXJhbWV0ZXJzLnRvb2xzIHx8IG51bGwsXHJcbiAgICAgICAgZGVyaXZhdGlvbk1hcDogc2VsZixcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChwcm9wZXJ0aWVzLnJlbGF0aW9uKSB7XHJcbiAgICAgICAgX29wZW5XaXRoUmVsYXRpb24ocHJvcGVydGllcy5yZWxhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgIC8vIFB1YmxpYyBmdW5jdGlvbnNcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgc2VsZi5yZWxhdGlvbjtcclxuICAgIHNlbGYub3BlbldpdGhSZWxhdGlvbiA9IF9vcGVuV2l0aFJlbGF0aW9uO1xyXG5cclxuICAgIHNlbGYucmVzZXRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfbGF5b3V0Lnpvb20oKTtcclxuICAgICAgICBfbGF5b3V0Lnpvb20oLTAuMiwgeyBtYXg6IDIsIG1pbjogMC4yIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldFNlbGVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3NlbGVjdGVkRWxlbWVudDtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5zZXRTZWxlY3RlZEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudElkKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRFTGVtZW50ID0gX2xheW91dC5nZXROb2RlcygpLmZpbmQoZWwgPT4gZWwuaWQgPT09IGVsZW1lbnRJZCk7XHJcbiAgICAgICAgX3NldFNlbGVjdGVkRWxlbWVudChzZWxlY3RlZEVMZW1lbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNldFNlYXJjaEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBfbGF5b3V0LnNldFNlYXJjaEtleShrZXkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmV4cGFuZEFsbEVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9sYXlvdXQuZ2V0Tm9kZXMoKS5mb3JFYWNoKGVsID0+IHtcclxuICAgICAgICAgICAgZWwuZXhwYW5kKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuY29sbGFwc2VBbGxFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfbGF5b3V0LmdldE5vZGVzKCkuZm9yRWFjaChlbCA9PiB7XHJcbiAgICAgICAgICAgIGVsLmNvbGxhcHNlKCk7XHJcbiAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5leHBvcnRUb1N2ZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfbGF5b3V0LmV4cG9ydCh7IHR5cGU6ICdzdmcnIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmV4cG9ydFRvUG5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9sYXlvdXQuZXhwb3J0KHsgdHlwZTogJ3BuZycgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuem9vbUluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9sYXlvdXQuem9vbSgwLjIsIHsgbWF4OiA0IH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnpvb21PdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2xheW91dC56b29tKC0wLjIsIHsgbWluOiAwLjIgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuem9vbVRvRml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9sYXlvdXQuem9vbSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnByaW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9sYXlvdXQucHJpbnQoKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gUHJpdmF0ZSBmdW5jdGlvbnNcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgZnVuY3Rpb24gX29wZW5XaXRoUmVsYXRpb24gKHJlbGF0aW9uKSB7XHJcbiAgICAgICAgX3NldFNlbGVjdGVkRWxlbWVudCh1bmRlZmluZWQpO1xyXG4gICAgICAgIGlmIChyZWxhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoIXNlbGYucmVsYXRpb24gfHwgcmVsYXRpb24uc291cmNlICE9PSBzZWxmLnJlbGF0aW9uLnNvdXJjZSB8fCByZWxhdGlvbi50YXJnZXQgIT09IHNlbGYucmVsYXRpb24udGFyZ2V0IHx8IHJlbGF0aW9uLmxpbmtUeXBlICE9PSBzZWxmLnJlbGF0aW9uLmxpbmtUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBfbGF5b3V0LmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJlbGF0aW9uID0gcmVsYXRpb247XHJcbiAgICAgICAgICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdmZXRjaGluZycpO1xyXG4gICAgICAgICAgICAgICAgX2RhdGFQcm92aWRlci5yZWxhdGlvbkluZm8ocmVsYXRpb24pLnRoZW4ocmF3RGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3NldERpYWdyYW1TdGF0ZSgncmVuZGVyaW5nJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRG1SYXdEYXRhKHJhd0RhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXBFbGVtZW50cyA9IHByb2Nlc3NEYXRhKHJhd0RhdGEsIF9wYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICBfbGF5b3V0LmFkZEVsZW1lbnRzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBFbGVtZW50cy5lbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChtYXBFbGVtZW50cy5saW5rcylcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVzZXRGb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdWJzY3JpYmVPbkVsZW1lbnRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3NldERpYWdyYW1TdGF0ZSgnY29tcGxldGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHR5cGVvZiBlID09PSAnc3RyaW5nJyA/IG5ldyBFcnJvcihlKSA6IGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9zZXREaWFncmFtU3RhdGUoJ2Vycm9yJywgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2Vycm9yQ2FsbGJhY2soZXJyb3IpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3Iuc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJlc2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9ICdUaGUgcmVsYXRpb24geW91IHdhbnQgdG8gdXNlIGlzIGVtcHR5ISc7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGVycm9yVGV4dCk7XHJcbiAgICAgICAgICAgIF9zZXREaWFncmFtU3RhdGUoJ2Vycm9yJywgZXJyb3JUZXh0KTtcclxuICAgICAgICAgICAgX2Vycm9yQ2FsbGJhY2soZXJyb3IpO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3N1YnNjcmliZU9uRWxlbWVudHMgKCkge1xyXG4gICAgICAgIF9sYXlvdXQuZ2V0Tm9kZXMoKS5mb3JFYWNoKGVsID0+IHtcclxuICAgICAgICAgICAgZWwub24oJ2VsZW1lbnQtY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBfc2V0U2VsZWN0ZWRFbGVtZW50KGVsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGVsLm9uKCdjb2xsYXBzZS1idXR0b24tY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IGVsLmdldE1vZGVsKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobW9kZWwuY29sbGFwc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuZXhwYW5kKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLmNvbGxhcHNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfbGF5b3V0LmdldExpbmtzKCkuZm9yRWFjaChlbCA9PiB7XHJcbiAgICAgICAgICAgIGVsLm9uKCdlbGVtZW50LWNsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgX3NldFNlbGVjdGVkRWxlbWVudChlbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIF9sYXlvdXQub24oJ2JsYW5rLWNsaWNrJywgKCkgPT4gX3NldFNlbGVjdGVkRWxlbWVudCh1bmRlZmluZWQpKTtcclxuXHJcbiAgICBmdW5jdGlvbiBfc2V0U2VsZWN0ZWRFbGVtZW50IChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKF9zZWxlY3RlZEVsZW1lbnQpIF9zZWxlY3RlZEVsZW1lbnQuaGlnaGxpZ2h0aW5nKGZhbHNlKTtcclxuICAgICAgICBfc2VsZWN0ZWRFbGVtZW50ID0gZWxlbWVudDtcclxuXHJcbiAgICAgICAgaWYgKF9zZWxlY3RlZEVsZW1lbnQpIF9zZWxlY3RlZEVsZW1lbnQuaGlnaGxpZ2h0aW5nKHRydWUpO1xyXG4gICAgICAgIF9kZWZhdWx0VUkuaW5mb1BhbmVsLnNldFNlbGVjdGVkRWxlbWVudChlbGVtZW50KTtcclxuXHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWQnLCBfZ2V0TW9kZWwoZWxlbWVudCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBzdGF0ZSBvZiBpbmRpY2F0b3JcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdGUgLSBmZXRjaGluZyB8IHJlbmRlcmluZyB8IGNvbXBsZXRlZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBDdXN0b20gbWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfc2V0RGlhZ3JhbVN0YXRlIChzdGF0ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHNlbGYuc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICBpZiAoc3RhdGUgPT09ICdmZXRjaGluZycpIHtcclxuICAgICAgICAgICAgX3Byb2dyZXNzU2NyZWVuLnNldFN0YXRlKCdhY3RpdmUnLCBtZXNzYWdlIHx8ICdGZXRjaGluZyBkYXRhJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ3JlbmRlcmluZycpIHtcclxuICAgICAgICAgICAgX3Byb2dyZXNzU2NyZWVuLnNldFN0YXRlKCdhY3RpdmUnLCBtZXNzYWdlIHx8ICdSZW5kZXJpbmcgZ3JhcGgnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnY29tcGxldGVkJykge1xyXG4gICAgICAgICAgICBfcHJvZ3Jlc3NTY3JlZW4uc2V0U3RhdGUoJ2NvbXBsZXRlZCcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdlcnJvcicpIHtcclxuICAgICAgICAgICAgX3Byb2dyZXNzU2NyZWVuLnNldFN0YXRlKCdlcnJvcicsIG1lc3NhZ2UgfHwgJ0Vycm9yIGhhcyBvY2N1cnJlZCEnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdkaWFncmFtLXN0YXRlLWNoYW5nZWQnLCBtZXNzYWdlIHx8IHN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0TW9kZWwgKGVsZW1lbnQpIHtcclxuICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIG1hcEVsZW1lbnRzLk5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlkOiBlbGVtZW50LmlkLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IGVsZW1lbnQubGFiZWwsXHJcbiAgICAgICAgICAgICAgICByZXNvdXJjZTogZWxlbWVudC5yZXNvdXJjZSxcclxuICAgICAgICAgICAgICAgIHBhcmVudDogZWxlbWVudC5wYXJlbnQsXHJcbiAgICAgICAgICAgICAgICByZXNvdXJjZVR5cGU6IGVsZW1lbnQucmVzb3VyY2VUeXBlLFxyXG4gICAgICAgICAgICAgICAgZGlhZ3JhbVR5cGU6ICdub2RlJyxcclxuICAgICAgICAgICAgICAgIGVuZHBvaW50SWQ6IGVsZW1lbnQuZW5kcG9pbnRJZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIG1hcEVsZW1lbnRzLkxpbmspIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlkOiBlbGVtZW50LmlkLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiBlbGVtZW50LnNvdXJjZS5lbmRwb2ludElkLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBlbGVtZW50LnRhcmdldC5lbmRwb2ludElkLFxyXG4gICAgICAgICAgICAgICAgZGlhZ3JhbVR5cGU6ICdsaW5rJyxcclxuICAgICAgICAgICAgICAgIHR5cGVJZDogZWxlbWVudC50eXBlSWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgaHRtbCBtYXJrdXAuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaHRtbE5vZGUgLSBSb290IG5vZGUgZm9yIG1hcmt1cFxyXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCBIVE1MRWxlbWVudD59IC0gTWFwIG9mIGh0bWwgZWxlbWVudHNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUJhc2UgKGh0bWxOb2RlKSB7XHJcbiAgICAgICAgaHRtbE5vZGUuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgaHRtbE5vZGUudGFiSW5kZXggPSAxO1xyXG5cclxuICAgICAgICBjb25zdCByb3dDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgICAgICByb3dDb250YWluZXIuY2xhc3NOYW1lID0gJ3RxLXJvdy1jb250YWluZXInO1xyXG4gICAgICAgIGh0bWxOb2RlLmFwcGVuZENoaWxkKHJvd0NvbnRhaW5lcik7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgICAgICBiYXNlRGl2LmNsYXNzTmFtZSA9ICd0cS1kZXJpdmF0aW9uLW1hcCc7XHJcbiAgICAgICAgYmFzZURpdi5pZCA9ICd0cS1kZXJpdmF0aW9uLW1hcCc7XHJcbiAgICAgICAgcm93Q29udGFpbmVyLmFwcGVuZENoaWxkKGJhc2VEaXYpO1xyXG5cclxuICAgICAgICBjb25zdCBkZXJpdmF0aW9uTWFwUm9vdEh0bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgICAgICBkZXJpdmF0aW9uTWFwUm9vdEh0bWwuY2xhc3NOYW1lID0gJ3RxLWRlcml2YXRpb24tbWFwLWRpYWdyYW0nO1xyXG4gICAgICAgIGRlcml2YXRpb25NYXBSb290SHRtbC5pZCA9ICd0cS1kZXJpdmF0aW9uLW1hcC1kaWFncmFtJztcclxuICAgICAgICBiYXNlRGl2LmFwcGVuZENoaWxkKGRlcml2YXRpb25NYXBSb290SHRtbCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHByb2dyZXNzSW5kaWNhdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgICAgIHByb2dyZXNzSW5kaWNhdGlvbi5jbGFzc05hbWUgPSAndHEtbGctcHJvZ3Jlc3Mtc2NyZWVuJztcclxuICAgICAgICBiYXNlRGl2LmFwcGVuZENoaWxkKHByb2dyZXNzSW5kaWNhdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHRvb2xiYXJCYXNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgdG9vbGJhckJhc2UuY2xhc3NOYW1lID0gJ3RxLWRlcml2YXRpb24tbWFwX190b29sYmFyJztcclxuICAgICAgICB0b29sYmFyQmFzZS5pZCA9ICd0cS1kZXJpdmF0aW9uLW1hcC10b29sYmFyJztcclxuICAgICAgICBiYXNlRGl2LmFwcGVuZENoaWxkKHRvb2xiYXJCYXNlKTtcclxuXHJcbiAgICAgICAgY29uc3QgaW5mb1BhbmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgaW5mb1BhbmVsLmNsYXNzTmFtZSA9ICd0cS1yb3ctY29udGFpbmVyX19wcm9wZXJ0aWVzLXBhbmUnO1xyXG4gICAgICAgIGluZm9QYW5lbC5pZCA9ICd0cS1wcm9wZXJ0aWVzLXBhbmUnO1xyXG4gICAgICAgIHJvd0NvbnRhaW5lci5hcHBlbmRDaGlsZChpbmZvUGFuZWwpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb250YWluZXI6IGh0bWxOb2RlLFxyXG4gICAgICAgICAgICBiYXNlRGl2OiBiYXNlRGl2LFxyXG4gICAgICAgICAgICBpbmZvUGFuZWw6IGluZm9QYW5lbCxcclxuICAgICAgICAgICAgdG9vbGJhcjogdG9vbGJhckJhc2UsXHJcbiAgICAgICAgICAgIGRlcml2YXRpb25NYXBSb290SHRtbDogZGVyaXZhdGlvbk1hcFJvb3RIdG1sLFxyXG4gICAgICAgICAgICBwcm9ncmVzczogcHJvZ3Jlc3NJbmRpY2F0aW9uLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IERlcml2YXRpb25NYXA7XHJcbiIsImltcG9ydCAqIGFzIGpvaW50IGZyb20gJ3JhcHBpZCc7XHJcbmltcG9ydCBTdWJzY3JpYmFibGUgZnJvbSAnLi4vLi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGUnO1xyXG5pbXBvcnQgeyBSZXNvdXJjZVByb3ZpZGVyIH0gZnJvbSAnLi4vLi4vZGF0YS9yZXNvdXJjZVByb3ZpZGVyJztcclxuXHJcbmNvbnN0IERFRkFVTFRfTElOS19UWVBFID0gJ2Rlcml2YXRpb24tbGluayc7XHJcbmNvbnN0IE1BUktFUl9UQVJHRVQgPSB7XHJcbiAgICBmaWxsOiAnYmxhY2snLFxyXG4gICAgc3Ryb2tlOiAnYmxhY2snLFxyXG4gICAgZDogJ00gMTAgMCBMIDAgNSBMIDEwIDEwIHonLFxyXG59O1xyXG5leHBvcnQgY29uc3QgTElOS19MQUJFTF9GT05UX1NJWkUgPSAxNjtcclxuZXhwb3J0IGNvbnN0IFpfSU5ERVhFUyA9IHtcclxuICAgIE5PREU6IDMwLFxyXG4gICAgU0VMRUNURURfRUxFTUVOVDogMjAsXHJcbiAgICBMSU5LOiAxNSxcclxuICAgIEJMVVJFRF9OT0RFOiAxMCxcclxuICAgIEJMVVJFRF9MSU5LOiA1LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5vZGVcclxuICogQHByaXZhdGVcclxuICogQGNsYXNzXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAZmlyZXMgZWxlbWVudC1jbGlja1xyXG4gKiBAZmlyZXMgY29sbGFwc2UtYnV0dG9uLWNsaWNrXHJcbiAqIEBmaXJlcyBwb3J0cy1zdGF0ZS1jaGFuZ2VkXHJcbiAqIEBmaXJlcyBlbGVtZW50LXN0YXRlLWNoYW5nZWRcclxuICogQGZpcmVzIHBvc2l0aW9uLWNoYW5nZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBOb2RlIChvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBmaXJlcyB3aGVuIHVzZXIgY2xpY2sgb24gbm9kZS5cclxuICAgICAqIEBldmVudCBlbGVtZW50LWNsaWNrXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBldmVudCAtIG9yaWdpbiBNb3VzZUV2dG50XHJcbiAgICAqL1xyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgY29uc3QgX2dyYXBoTm9kZSA9IG9wdGlvbnMuZ3JhcGhOb2RlIHx8IG5ldyBHcmFwaE5vZGUob3B0aW9ucy5tb2RlbCwgcGFyYW1ldGVycyk7XHJcblxyXG4gICAgc2VsZi5pZCA9IG9wdGlvbnMuaWQ7XHJcbiAgICBzZWxmLmVuZHBvaW50SWQgPSBvcHRpb25zLmVuZHBvaW50SWQ7XHJcbiAgICBzZWxmLnJlc291cmNlVHlwZSA9IG9wdGlvbnMucmVzb3VyY2VUeXBlO1xyXG4gICAgc2VsZi5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcclxuICAgIHNlbGYubGFiZWwgPSBvcHRpb25zLmxhYmVsO1xyXG4gICAgc2VsZi5jaGlsZHJlbiA9IG9wdGlvbnMuY2hpbGRyZW47XHJcbiAgICBzZWxmLm9yZGVyZWRQb3NzaWJsZUlkcyA9IG9wdGlvbnMub3JkZXJlZFBvc3NpYmxlSWRzO1xyXG4gICAgc2VsZi5yZXNvdXJjZSA9IG9wdGlvbnMucmVzb3VyY2U7XHJcblxyXG4gICAgc2VsZi5oaWdobGlnaHRpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIF9ncmFwaE5vZGUuc2V0SGlnaGxpZ2h0ZWRJZChzZWxmLmlkKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLmlkID09PSBfZ3JhcGhOb2RlLmhpZ2hsaWdodGVkSWQpIHtcclxuICAgICAgICAgICAgICAgIF9ncmFwaE5vZGUuc2V0SGlnaGxpZ2h0ZWRJZCh1bmRlZmluZWQpOyAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfZ3JhcGhOb2RlLmhpZ2hsaWdodGVkSWQgPT09IHNlbGYuaWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuY29sbGFwc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2dyYXBoTm9kZS5fY29sbGFwc2VFbGVtZW50KHNlbGYuaWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmV4cGFuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfZ3JhcGhOb2RlLl9leHBhbmRFbGVtZW50KHNlbGYuaWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gbm90IGltcGxlbWVudGVkLi5cclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIG5vdCBpbXBsZW1lbnRlZC4uXHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldENlbGxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbX2dyYXBoTm9kZV07XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0UG9ydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogX2dldEF2YWlsYWJsZVBvcnRJZCgpLFxyXG4gICAgICAgICAgICBwcmltaXRpdmU6IF9ncmFwaE5vZGUsXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5nZXRNb2RlbCA9IF9nZXRNb2RlbDtcclxuXHJcbiAgICBzZWxmLmdldFBvcnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBzdmdPYmplY3QgPSBfZ3JhcGhOb2RlLmF0dHIoYC4ke2dldFBvcnRJZChfZ2V0QXZhaWxhYmxlUG9ydElkKCksIGRpcmVjdGlvbil9YCk7XHJcbiAgICAgICAgY29uc3QgcHJpbWl0aXZlUG9zaXRpb24gPSBzZWxmLmdldFBvcnQoKS5wcmltaXRpdmUucG9zaXRpb24oKTtcclxuICAgICAgICBpZiAoc3ZnT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiBzdmdPYmplY3RbJ3JlZi14J10gKyBwcmltaXRpdmVQb3NpdGlvbi54LFxyXG4gICAgICAgICAgICAgICAgeTogc3ZnT2JqZWN0WydyZWYteSddICsgcHJpbWl0aXZlUG9zaXRpb24ueSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlUG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLm9uUGFwZXJDZWxsUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gLi4uXHJcbiAgICB9O1xyXG5cclxuICAgIF9ncmFwaE5vZGUub24oJ3BvcnRzLXN0YXRlLWNoYW5nZWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdwb3J0cy1zdGF0ZS1jaGFuZ2VkJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBfZ3JhcGhOb2RlLm9uKCdlbGVtZW50cy1zdGF0ZS1jaGFuZ2VkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcignZWxlbWVudC1zdGF0ZS1jaGFuZ2VkJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBfZ3JhcGhOb2RlLm9uKCdib2R5LWNsaWNrJywgZnVuY3Rpb24gKHtldmVudCwgZWxlbWVudElkfSkge1xyXG4gICAgICAgIGlmIChzZWxmLmlkID09PSBlbGVtZW50SWQpIHtcclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdlbGVtZW50LWNsaWNrJywgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIF9ncmFwaE5vZGUub24oJ2NoYW5nZTpwb3NpdGlvbicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3Bvc2l0aW9uLWNoYW5nZWQnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9ncmFwaE5vZGUub24oJ2NvbGxhcHNlLWJ1dHRvbi1jbGljaycsIGZ1bmN0aW9uIChlbGVtZW50SWQpIHtcclxuICAgICAgICBpZiAoZWxlbWVudElkID09PSBzZWxmLmlkKSB7XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignY29sbGFwc2UtYnV0dG9uLWNsaWNrJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldE1vZGVsICgpIHtcclxuICAgICAgICByZXR1cm4gX2dyYXBoTm9kZS5lbGVtZW50c01hcFtzZWxmLmlkXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0QXZhaWxhYmxlUG9ydElkICgpIHtcclxuICAgICAgICBjb25zdCBtb2RlbCA9IF9nZXRNb2RlbCgpO1xyXG4gICAgICAgIGlmICghbW9kZWwuaW52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGYub3JkZXJlZFBvc3NpYmxlSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cklkID0gc2VsZi5vcmRlcmVkUG9zc2libGVJZHNbaV07XHJcbiAgICAgICAgICAgIGlmIChfZ3JhcGhOb2RlLmVsZW1lbnRzTWFwW2N1cklkXS5pbnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZJZCA9IHNlbGYub3JkZXJlZFBvc3NpYmxlSWRzW2kgLSAxXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2SWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlbGYub3JkZXJlZFBvc3NpYmxlSWRzW3NlbGYub3JkZXJlZFBvc3NpYmxlSWRzLmxlbmd0aCAtIDFdO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogTGlua1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3NcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gTGluayAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgU3Vic2NyaWJhYmxlLmFwcGx5KHRoaXMpO1xyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHNlbGYuc291cmNlID0gb3B0aW9ucy5zb3VyY2U7XHJcbiAgICBzZWxmLnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xyXG4gICAgc2VsZi5sYWJlbCA9IG9wdGlvbnMubGFiZWw7XHJcbiAgICBzZWxmLnR5cGVJZCA9IG9wdGlvbnMudHlwZUlkO1xyXG4gICAgc2VsZi5ncm91cGVkQnkgPSBvcHRpb25zLmdyb3VwZWRCeTsgLy8gc291cmNlIHwgdGFyZ2V0IHwgdW5kZWZpbmVkXHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHNvdXJjZSxcclxuICAgICAgICB0YXJnZXQsXHJcbiAgICB9ID0gX2dldENvbm5lY3Rpb25QYXJhbWV0ZXJzKCk7XHJcblxyXG4gICAgY29uc3QgcHJpbWl0aXZlc0FyZURlZmluZWQgPSBvcHRpb25zLmdyYXBoUHJpbWl0aXZlcyAmJiBvcHRpb25zLmdyYXBoUHJpbWl0aXZlcy5sZW5ndGggPiAwO1xyXG4gICAgY29uc3QgX2dyYXBoUHJpbWl0aXZlcyA9IHByaW1pdGl2ZXNBcmVEZWZpbmVkID9cclxuICAgIG9wdGlvbnMuZ3JhcGhQcmltaXRpdmVzIDogW1xyXG4gICAgICAgIG5ldyBHcmFwaExpbmsoe1xyXG4gICAgICAgICAgICB0eXBlSWQ6IG9wdGlvbnMudHlwZUlkLFxyXG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgICAgICAgIGxhYmVsOiBfZ2V0TGFiZWwoKSxcclxuICAgICAgICB9LCBwYXJhbWV0ZXJzKSxcclxuICAgIF07XHJcblxyXG4gICAgX3JlZnJlc2hQb3J0cygpO1xyXG5cclxuICAgIHNlbGYuZ2V0Q2VsbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9ncmFwaFByaW1pdGl2ZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIGxldCBfaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcclxuICAgIHNlbGYuaGlnaGxpZ2h0aW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgX2hpZ2hsaWdodGVkID0gdmFsdWU7XHJcbiAgICAgICAgICAgIF9ncmFwaFByaW1pdGl2ZXMuZm9yRWFjaChwcmltaXRpdmUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpbWl0aXZlLmhpZ2hsaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUudW5oaWdobGlnaHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfaGlnaGxpZ2h0ZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2hvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfZ3JhcGhQcmltaXRpdmVzLmZvckVhY2gocHJpbWl0aXZlID0+XHJcbiAgICAgICAgICAgIHByaW1pdGl2ZS5zaG93KClcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2dyYXBoUHJpbWl0aXZlcy5mb3JFYWNoKHByaW1pdGl2ZSA9PlxyXG4gICAgICAgICAgICBwcmltaXRpdmUuaGlkZSgpXHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICFzZWxmLmdldCgnaGlkZGVuJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYub25QYXBlckNlbGxQb2ludGVyRG93biA9IGZ1bmN0aW9uIChjZWxsKSB7XHJcbiAgICAgICAgY29uc3QgY2VsbElzTXlQcmltaXRpdmUgPSBfZ3JhcGhQcmltaXRpdmVzLmluZGV4T2YoY2VsbCkgIT09IC0xO1xyXG4gICAgICAgIGlmIChjZWxsSXNNeVByaW1pdGl2ZSkge1xyXG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2VsZW1lbnQtY2xpY2snLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmFsaWduQ3Jvc3NOb2RlID0gX2FsaWduQ3Jvc3NOb2RlO1xyXG4gICAgc2VsZi5nZXRDcm9zc05vZGUgPSBfZ2V0Q3Jvc3NOb2RlO1xyXG5cclxuICAgIGZ1bmN0aW9uIF9nZXRDcm9zc05vZGUgKCkge1xyXG4gICAgICAgIGNvbnN0IGlzQ3Jvc3NlZCA9IF9ncmFwaFByaW1pdGl2ZXMubGVuZ3RoID4gMTtcclxuICAgICAgICBpZiAoaXNDcm9zc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZ3JhcGhQcmltaXRpdmVzWzBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9hbGlnbkNyb3NzTm9kZSAoKSB7XHJcbiAgICAgICAgY29uc3QgY3Jvc3NOb2RlID0gX2dldENyb3NzTm9kZSgpO1xyXG4gICAgICAgIGlmICghY3Jvc3NOb2RlKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGNyb3NzZWRFbGVtZW50cyA9IGNyb3NzTm9kZS5nZXRDcm9zc2VkRWxlbWVudHMoKTtcclxuICAgICAgICBjb25zdCBmaXJzdENyb3NzZWRFbGVtZW50ID0gY3Jvc3NlZEVsZW1lbnRzWzBdO1xyXG4gICAgICAgIGNvbnN0IGdyb3VwZWRCeVNvdXJjZSA9IGZpcnN0Q3Jvc3NlZEVsZW1lbnQuZ3JvdXBlZEJ5ID09PSAnc291cmNlJztcclxuICAgICAgICBjb25zdCBERUZBVUxUX1BBRERJTkcgPSAzMDtcclxuICAgICAgICBsZXQgc3VtWSA9IDA7XHJcbiAgICAgICAgbGV0IG1pblggPSBJbmZpbml0eTtcclxuICAgICAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcclxuXHJcbiAgICAgICAgY3Jvc3NlZEVsZW1lbnRzLmZvckVhY2goY3Jvc3NlZExpbmtzID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYWxsaWduVG8gPSBncm91cGVkQnlTb3VyY2UgP1xyXG4gICAgICAgICAgICAgICAgY3Jvc3NlZExpbmtzLnRhcmdldC5nZXRQb3J0UG9zaXRpb24oJ2luJykgOlxyXG4gICAgICAgICAgICAgICAgY3Jvc3NlZExpbmtzLnNvdXJjZS5nZXRQb3J0UG9zaXRpb24oJ291dCcpO1xyXG5cclxuICAgICAgICAgICAgc3VtWSArPSBhbGxpZ25Uby55O1xyXG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgYWxsaWduVG8ueCk7XHJcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBhbGxpZ25Uby54KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCB4UG9zaXRpb24gPSBncm91cGVkQnlTb3VyY2UgPyBtaW5YIC0gREVGQVVMVF9QQURESU5HIDogbWF4WCArIERFRkFVTFRfUEFERElORztcclxuICAgICAgICBjb25zdCB5UG9zaXRpb24gPSBzdW1ZIC8gY3Jvc3NlZEVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgICBjcm9zc05vZGUucG9zaXRpb24oeFBvc2l0aW9uLCB5UG9zaXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9nZXRMYWJlbCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGpvaW50LnV0aWwuYnJlYWtUZXh0KHNlbGYubGFiZWwsIHtcclxuICAgICAgICAgICAgd2lkdGg6IHBhcmFtZXRlcnMuZGVmYXVsdExpbmtMYWJlbExlbmd0aCxcclxuICAgICAgICB9LCB7ICdmb250LXNpemUnOiBMSU5LX0xBQkVMX0ZPTlRfU0laRSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfcmVmcmVzaFBvcnRzICgpIHtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIHRhcmdldFRvcElkLFxyXG4gICAgICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICB9ID0gX2dldENvbm5lY3Rpb25QYXJhbWV0ZXJzKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNvdXJjZVByaW1pdGl2ZSA9IF9ncmFwaFByaW1pdGl2ZXNbMV0gfHwgX2dyYXBoUHJpbWl0aXZlc1swXTtcclxuICAgICAgICBjb25zdCB0YXJnZXRQcmltaXRpdmUgPSBfZ3JhcGhQcmltaXRpdmVzWzJdIHx8IF9ncmFwaFByaW1pdGl2ZXNbMF07XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgdGFyZ2V0TGlua1N0eWxlID0gdGFyZ2V0UHJpbWl0aXZlLmdldExpbmtTdHlsZSgpO1xyXG4gICAgICAgIGlmICh0YXJnZXQuaWQgPT09IHRhcmdldFRvcElkKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFByaW1pdGl2ZS5hdHRyKCcubWFya2VyLXRhcmdldCcsIGdldExpbmtNYXJrZXJUYXJnZXQodGFyZ2V0TGlua1N0eWxlKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGFyZ2V0UHJpbWl0aXZlLnJlbW92ZUF0dHIoJy5tYXJrZXItdGFyZ2V0Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzb3VyY2VQcmltaXRpdmUucHJvcCh7IHNvdXJjZTogc291cmNlIH0pO1xyXG4gICAgICAgIHRhcmdldFByaW1pdGl2ZS5wcm9wKHsgdGFyZ2V0OiB0YXJnZXQgfSk7XHJcblxyXG4gICAgICAgIF9hbGlnbkNyb3NzTm9kZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9nZXRDb25uZWN0aW9uUGFyYW1ldGVycyAoKSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlUG9ydCA9IHNlbGYuc291cmNlLmdldFBvcnQoKTtcclxuICAgICAgICBjb25zdCB0YXJnZXRQb3J0ID0gc2VsZi50YXJnZXQuZ2V0UG9ydCgpO1xyXG5cclxuICAgICAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IHNvdXJjZVBvcnQucHJpbWl0aXZlLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSB0YXJnZXRQb3J0LnByaW1pdGl2ZS5wb3NpdGlvbigpO1xyXG5cclxuICAgICAgICBjb25zdCByZXZlcnNlID0gc291cmNlUG9zaXRpb24ueCA+IHRhcmdldFBvc2l0aW9uLng7XHJcbiAgICAgICAgY29uc3Qgc291cmNlID0ge1xyXG4gICAgICAgICAgICBpZDogc291cmNlUG9ydC5wcmltaXRpdmUuaWQsXHJcbiAgICAgICAgICAgIHBvcnQ6IGdldFBvcnRJZChzb3VyY2VQb3J0LmlkLCAocmV2ZXJzZSA/ICdpbicgOiAnb3V0JykpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0ge1xyXG4gICAgICAgICAgICBpZDogdGFyZ2V0UG9ydC5wcmltaXRpdmUuaWQsXHJcbiAgICAgICAgICAgIHBvcnQ6IGdldFBvcnRJZCh0YXJnZXRQb3J0LmlkLCAocmV2ZXJzZSA/ICdvdXQnIDogJ2luJykpLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNvdXJjZVRvcElkOiBzb3VyY2VQb3J0LmlkLFxyXG4gICAgICAgICAgICB0YXJnZXRUb3BJZDogdGFyZ2V0UG9ydC5pZCxcclxuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZi5zb3VyY2Uub24oJ2VsZW1lbnQtc3RhdGUtY2hhbmdlZCcsIF9yZWZyZXNoUG9ydHMpO1xyXG4gICAgc2VsZi50YXJnZXQub24oJ2VsZW1lbnQtc3RhdGUtY2hhbmdlZCcsIF9yZWZyZXNoUG9ydHMpO1xyXG4gICAgc2VsZi5zb3VyY2Uub24oJ3BvcnRzLXN0YXRlLWNoYW5nZWQnLCBfYWxpZ25Dcm9zc05vZGUpO1xyXG4gICAgc2VsZi50YXJnZXQub24oJ3BvcnRzLXN0YXRlLWNoYW5nZWQnLCBfYWxpZ25Dcm9zc05vZGUpO1xyXG4gICAgc2VsZi5zb3VyY2Uub24oJ3Bvc2l0aW9uLWNoYW5nZWQnLCBfcmVmcmVzaFBvcnRzKTtcclxuICAgIHNlbGYudGFyZ2V0Lm9uKCdwb3NpdGlvbi1jaGFuZ2VkJywgX3JlZnJlc2hQb3J0cyk7XHJcbiAgICBcclxufVxyXG5cclxuLyoqXHJcbiAqIEpvaW50Tm9kZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3NcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBmaXJlcyBib2R5LWNsaWNrXHJcbiAqIEBmaXJlcyBoaWdobGlnaHRlZC1pZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEdyYXBoTm9kZSAobW9kZWwsIHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgZmlyZXMgd2hlbiB1c2VyIGNsaWNrIG9uIG5vZGUuXHJcbiAgICAgKiBAZXZlbnQgYm9keS1jbGlja1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7XHJcbiAgICAgKiAgZXZlbnQ6IE1vdXNlRXZlbnQsIC8vIG9yaWdpbmFsIG1vdXNlIGV2ZW50XHJcbiAgICAgKiAgZWxlbWVudElkOiBzdHJpbmcsIC8vIGlkIG9mIHRoZSBjbGlja2VkIGVsZW1lbnRcclxuICAgICAqIH1cclxuICAgICovXHJcblxyXG4gICAgc2VsZi5lbGVtZW50c01hcCA9IF9nZXRGbGF0RWxlbWVudHNNYXAobW9kZWwpO1xyXG4gICAgc2VsZi5tb2RlbCA9IG1vZGVsO1xyXG4gICAgc2VsZi5zY2FsZSA9IDE7XHJcbiAgICBzZWxmLmFjdGl2ZVBvcnRzID0ge307XHJcblxyXG4gICAgam9pbnQuc2hhcGVzLmJhc2ljLkdlbmVyaWMuYXBwbHkoc2VsZiwgW3tcclxuICAgICAgICBpZDogbW9kZWwuaWQsXHJcbiAgICAgICAgbWFya3VwOiBgPGcgY2xhc3M9XCJyb3RhdGFibGVcIj5cclxuICAgICAgICAgICAgPGcgY2xhc3M9XCJzY2FsYWJsZSBleHBvcnQtYW5jaG9yXCI+XHJcbiAgICAgICAgICAgICAgICA8cmVjdCBjbGFzcz1cImJvZHlcIi8+XHJcbiAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICAgJHtfcG9ydHNUZW1wbGF0ZSgpfVxyXG4gICAgICAgIDwvZz5gLFxyXG4gICAgICAgIHR5cGU6ICdncmFwaC1kZXJpdmF0aW9uLW5vZGUuR3JhcGhOb2RlJyxcclxuICAgICAgICBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICAgICAgejogWl9JTkRFWEVTLk5PREUsXHJcbiAgICAgICAgc2l6ZToge1xyXG4gICAgICAgICAgICB3aWR0aDogcGFyYW1ldGVycy5kZWZhdWx0RWxlbWVudFdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHBhcmFtZXRlcnMuZGVmYXVsdEVsZW1lbnRIZWlnaHQsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICByZWN0OiB7XHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNpcmNsZToge1xyXG4gICAgICAgICAgICAgICAgcjogMCxcclxuICAgICAgICAgICAgICAgIGZpbGw6ICdyZWQnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLmRuLWluLXBvcnQnOiB7XHJcbiAgICAgICAgICAgICAgICByZWY6ICcuYm9keScsXHJcbiAgICAgICAgICAgICAgICAncmVmLXgnOiAwLFxyXG4gICAgICAgICAgICAgICAgJ3JlZi15JzogMCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJy5kbi1vdXQtcG9ydCc6IHtcclxuICAgICAgICAgICAgICAgIHJlZjogJy5ib2R5JyxcclxuICAgICAgICAgICAgICAgICdyZWYteCc6IHBhcmFtZXRlcnMuZGVmYXVsdEVsZW1lbnRXaWR0aCArIDIwLFxyXG4gICAgICAgICAgICAgICAgJ3JlZi15JzogMCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfV0pO1xyXG5cclxuICAgIHNlbGYuc2V0KCdjb2xsYXBzZWQnLCBmYWxzZSk7XHJcbiAgICBzZWxmLnNjdG9sbFRvcCA9IDA7XHJcblxyXG4gICAgc2VsZi5zZXRIaWdobGlnaHRlZElkID0gZnVuY3Rpb24gKHRhcmdldElkKSB7XHJcbiAgICAgICAgc2VsZi5oaWdobGlnaHRlZElkID0gdGFyZ2V0SWQ7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlZElkcyA9IF91cGRhdGVTdGF0ZSh0aGlzLm1vZGVsKTtcclxuICAgICAgICBjaGFuZ2VkSWRzLmNvbmNhdChfdXBkYXRlVmlzaWJpbGl0eSh0aGlzLm1vZGVsKSk7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdlbGVtZW50cy1zdGF0ZS1jaGFuZ2VkJywgW2NoYW5nZWRJZHNdKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuTk9ERSB9KTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5fY29sbGFwc2VFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnRJZCkge1xyXG4gICAgICAgIGlmIChlbGVtZW50SWQpIHtcclxuICAgICAgICAgICAgc2VsZi5lbGVtZW50c01hcFtlbGVtZW50SWRdLmNvbGxhcHNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZWRJZHMgPSBfdXBkYXRlVmlzaWJpbGl0eShzZWxmLmVsZW1lbnRzTWFwW2VsZW1lbnRJZF0pOyAgIFxyXG4gICAgICAgICAgICBjaGFuZ2VkSWRzLnB1c2goZWxlbWVudElkKTtcclxuICAgICAgICAgICAgaWYgKGNoYW5nZWRJZHMubGVuZ3RoID4gMCkgc2VsZi50cmlnZ2VyKCdlbGVtZW50cy1zdGF0ZS1jaGFuZ2VkJywgW2NoYW5nZWRJZHNdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZWxmLnNldCgnY29sbGFwc2VkJywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLl9leHBhbmRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnRJZCkge1xyXG4gICAgICAgIGlmIChlbGVtZW50SWQpIHtcclxuICAgICAgICAgICAgc2VsZi5lbGVtZW50c01hcFtlbGVtZW50SWRdLmNvbGxhcHNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VkSWRzID0gX3VwZGF0ZVZpc2liaWxpdHkoc2VsZi5lbGVtZW50c01hcFtlbGVtZW50SWRdKTsgICBcclxuICAgICAgICAgICAgY2hhbmdlZElkcy5wdXNoKGVsZW1lbnRJZCk7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkSWRzLmxlbmd0aCA+IDApIHNlbGYudHJpZ2dlcignZWxlbWVudHMtc3RhdGUtY2hhbmdlZCcsIFtjaGFuZ2VkSWRzXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZi5zZXQoJ2NvbGxhcHNlZCcsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYub25DbGlja0NvbGxhcHNlQnV0dG9uID0gZnVuY3Rpb24gKGVsZW1lbnRJZCkge1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcignY29sbGFwc2UtYnV0dG9uLWNsaWNrJywgZWxlbWVudElkKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi51cGRhdGVQb3J0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3BvcnRzLXN0YXRlLWNoYW5nZWQnKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5maXJlQ2xpY2tFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgZWxlbWVudElkKSB7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdib2R5LWNsaWNrJywge1xyXG4gICAgICAgICAgICBldmVudDogZXZlbnQsXHJcbiAgICAgICAgICAgIGVsZW1lbnRJZDogZWxlbWVudElkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldEFsbENoaWxkcmVuID0gX2dldEFsbENoaWxkcmVuO1xyXG5cclxuICAgIHNlbGYuYWN0aXZlUG9ydHMgPSB7fTtcclxuICAgIHNlbGYucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3JlZHJhdy12aWV3Jyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2V0U2NhbGUgPSBmdW5jdGlvbiAoc2NhbGUpIHtcclxuICAgICAgICBzZWxmLnNjYWxlID0gc2NhbGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2V0U2VhcmNoS2V5ID0gZnVuY3Rpb24gKHNlYXJjaEtleSkge1xyXG4gICAgICAgIHNlbGYuc2VhcmNoS2V5ID0gc2VhcmNoS2V5ID8gc2VhcmNoS2V5LnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgY2hhbmdlZElkcyA9IF91cGRhdGVWaXNpYmlsaXR5KHRoaXMubW9kZWwpO1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcignZWxlbWVudHMtc3RhdGUtY2hhbmdlZCcsIFtjaGFuZ2VkSWRzXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF91cGRhdGVTdGF0ZSAocm9vdE1vZGVsKSB7XHJcbiAgICAgICAgY29uc3QgaGlnaGxpZ2h0ZWRJZCA9IHNlbGYuaGlnaGxpZ2h0ZWRJZDtcclxuICAgICAgICBjb25zdCBjaGFuZ2VkSWRzID0gW107XHJcbiAgICAgICAgXHJcbiAgICAgICAgdXBkYXRlU3RhdGUocm9vdE1vZGVsKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZWRJZHM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlU3RhdGUgKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBtb2RlbC5pZCA9PT0gaGlnaGxpZ2h0ZWRJZDtcclxuXHJcbiAgICAgICAgICAgIGxldCBjb250YWluU2VsZWN0ZWRFbGVtZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG1vZGVsLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29udGFpblNlbGVjdGVkRWxlbWVudCA9IHVwZGF0ZVN0YXRlKGNoaWxkKSB8fCBjb250YWluU2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbGxhcHNlZFN0YXRlID0gbW9kZWwuY29sbGFwc2VkICYmICFjb250YWluU2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAoQm9vbGVhbihuZXdDb2xsYXBzZWRTdGF0ZSkgIT09IEJvb2xlYW4obW9kZWwuY29sbGFwc2VkKSkgY2hhbmdlZElkcy5wdXNoKG1vZGVsLmlkKTtcclxuICAgICAgICAgICAgbW9kZWwuY29sbGFwc2VkID0gbmV3Q29sbGFwc2VkU3RhdGU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaXNTZWxlY3RlZCB8fCBjb250YWluU2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlVmlzaWJpbGl0eSAocm9vdE1vZGVsKSB7XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoS2V5ID0gc2VsZi5zZWFyY2hLZXk7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlZElkcyA9IFtdO1xyXG5cclxuICAgICAgICB1cGRhdGVWaXNpYmlsaXR5KHJvb3RNb2RlbCwgZmFsc2UpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2hhbmdlZElkcztcclxuICAgICAgICBcclxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVWaXNpYmlsaXR5IChtb2RlbCwgcGFyZW50SW52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdENvbnRhaW5LZXkgPSAoIXNlYXJjaEtleSkgfHwgbW9kZWwubGFiZWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKHNlYXJjaEtleSkgPT09IC0xO1xyXG4gICAgICAgICAgICBjb25zdCBpbnZpc2libGUgPSBwYXJlbnRJbnZpc2libGUgJiYgbm90Q29udGFpbktleTtcclxuXHJcbiAgICAgICAgICAgIGxldCBub1Zpc2libGVDaGlsZHJlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIG1vZGVsLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgbm9WaXNpYmxlQ2hpbGRyZW4gPSB1cGRhdGVWaXNpYmlsaXR5KGNoaWxkLCBwYXJlbnRJbnZpc2libGUgfHwgbW9kZWwuY29sbGFwc2VkKSAmJiBub1Zpc2libGVDaGlsZHJlbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Zpc2liaWJsaXR5ID0gaW52aXNpYmxlICYmIG5vVmlzaWJsZUNoaWxkcmVuO1xyXG4gICAgICAgICAgICBpZiAoQm9vbGVhbihuZXdWaXNpYmlibGl0eSkgIT09IEJvb2xlYW4obW9kZWwuaW52aXNpYmxlKSkgY2hhbmdlZElkcy5wdXNoKG1vZGVsLmlkKTtcclxuICAgICAgICAgICAgbW9kZWwuaW52aXNpYmxlID0gaW52aXNpYmxlICYmIG5vVmlzaWJsZUNoaWxkcmVuO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG1vZGVsLmludmlzaWJsZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldEFsbENoaWxkcmVuICgpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc2VsZi5lbGVtZW50c01hcCkubWFwKGlkID0+IHNlbGYuZWxlbWVudHNNYXBbaWRdKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0RmxhdEVsZW1lbnRzTWFwIChtb2RlbCkge1xyXG4gICAgICAgIGxldCBlbGVtZW50c01hcCA9IHt9O1xyXG4gICAgICAgIHJlY3Vyc2lvbihtb2RlbCwgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50c01hcDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVjdXJzaW9uIChlbGVtZW50LCBpbnZpc2libGUpIHtcclxuICAgICAgICAgICAgaWYgKCFlbGVtZW50c01hcFtlbGVtZW50LmlkXSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudHNNYXBbZWxlbWVudC5pZF0gPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5pbnZpc2libGUgPSBpbnZpc2libGU7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNoaWxkcmVuLm1hcChjaGlsZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaW9uKGNoaWxkLCBlbGVtZW50LmNvbGxhcHNlZCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfcG9ydHNUZW1wbGF0ZSAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9nZXRBbGxDaGlsZHJlbigpLm1hcChlbGVtZW50ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5Qb3J0SWQgPSBnZXRQb3J0SWQoZWxlbWVudC5pZCwgJ2luJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dFBvcnRJZCA9IGdldFBvcnRJZChlbGVtZW50LmlkLCAnb3V0Jyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICAgICAgPGNpcmNsZSBjbGFzcz1cImRuLWluLXBvcnQgJHtpblBvcnRJZH1cIiBwb3J0PVwiJHtpblBvcnRJZH1cIi8+XHJcbiAgICAgICAgICAgICAgICA8Y2lyY2xlIGNsYXNzPVwiZG4tb3V0LXBvcnQgJHtvdXRQb3J0SWR9XCIgcG9ydD1cIiR7b3V0UG9ydElkfVwiLz5cclxuICAgICAgICAgICAgYDtcclxuICAgICAgICB9KS5qb2luKCcnKTtcclxuICAgIH1cclxufVxyXG5HcmFwaE5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShqb2ludC5zaGFwZXMuZGV2cy5Nb2RlbC5wcm90b3R5cGUpO1xyXG5cclxuXHJcbmNvbnN0IERFRkFVTFRfQ1JPU1NfTk9ERV9TSVpFID0ge1xyXG4gICAgd2lkdGg6IDEsIGhlaWdodDogMSxcclxufTtcclxuLyoqXHJcbiAqIEpvaW50Q3Jvc3NOb2RlXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBHcmFwaENyb3NzTm9kZSAobW9kZWwpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHNlbGYubW9kZWwgPSBtb2RlbDtcclxuICAgIHNlbGYuaGlkZGVuID0gZmFsc2U7XHJcblxyXG4gICAgam9pbnQuc2hhcGVzLmJhc2ljLkdlbmVyaWMuYXBwbHkoc2VsZiwgW3tcclxuICAgICAgICB0eXBlOiAnZGVyaXZhdGlvbkNyb3NzTm9kZScsXHJcbiAgICAgICAgbWFya3VwOiBgPGcgY2xhc3M9XCJyb3RhdGFibGVcIj5cclxuICAgICAgICAgICAgPGcgY2xhc3M9XCJzY2FsYWJsZSBleHBvcnQtYW5jaG9yXCI+XHJcbiAgICAgICAgICAgICAgICA8Y2lyY2xlIGNsYXNzPVwiYm9keVwiLz5cclxuICAgICAgICAgICAgPC9nPlxyXG4gICAgICAgIDwvZz5gLFxyXG4gICAgICAgIHNpemU6IERFRkFVTFRfQ1JPU1NfTk9ERV9TSVpFLFxyXG4gICAgICAgIHo6IFpfSU5ERVhFUy5MSU5LLFxyXG4gICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgIGNpcmNsZToge1xyXG4gICAgICAgICAgICAgICAgcjogJzVweCcsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICdibGFjaycsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfV0pO1xyXG5cclxuICAgIHNlbGYuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYuaGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLlNFTEVDVEVEX0VMRU1FTlQgfSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZ2hsaWdodGVkJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYudW5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLkxJTksgfSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZ2hsaWdodGVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuTElOSyB9KTtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3VwZGF0ZS1zdGF0ZScpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5CTFVSRURfTElOSyB9KTtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3VwZGF0ZS1zdGF0ZScpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldENyb3NzZWRFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi5tb2RlbC5jcm9zc2VkRWxlbWVudHM7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3JlZHJhdy12aWV3Jyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2V0U2NhbGUgPSBmdW5jdGlvbiAoc2NhbGUpIHtcclxuICAgICAgICBzZWxmLnNjYWxlID0gc2NhbGU7XHJcbiAgICB9O1xyXG59XHJcbkdyYXBoQ3Jvc3NOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoam9pbnQuc2hhcGVzLmJhc2ljLkdlbmVyaWMucHJvdG90eXBlKTtcclxuXHJcbi8qKlxyXG4gKiBETUxpbmtNb2RlbCAtIGRhdGEgbW9kZWwgZm9yIGEge0BsaW5rIExpbmt9IG9iamVjdFxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBETUxpbmtNb2RlbFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZUlkIC0gTGluayB0eXBlIGlkZW50aWZ5ZXJcclxuICogQHByb3BlcnR5IHtHcmFwaE5vZGV9IHRhcmdldCAtIFRhcmdldCBOb2RlXHJcbiAqIEBwcm9wZXJ0eSB7R3JhcGhOb2RlfSBzb3VyY2UgLSBTb3VyY2UgTm9kZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWwgLSBUZXh0IGluIHRoZSBtaWRkbGUgb2YgdGhlIGxpbmtcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxpbmt0eXBlIC0gVHlwZSBvZiB0aGUgTGlua1xyXG4gKiBAcHJvcGVydHkge0dyYXBoTGlua1tdfSBjcm9zc2VkRWxlbWVudHMgLSBpbiBjYXNlIG9mIHRoZSBsaW5rIGlzIGEgcGFydCBvZiBncm91cGVkIGxpbmtzXHJcbiovXHJcblxyXG4vKipcclxuICogSm9pbnRMaW5rXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0ge0RNTGlua01vZGVsfSBtb2RlbFxyXG4gKiBAcGFyYW0ge1BhcmFtdGVyc30gcGFyYW1ldGVyc1xyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBHcmFwaExpbmsgKG1vZGVsLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgc2VsZi5tb2RlbCA9IG1vZGVsO1xyXG4gICAgc2VsZi5oaWRkZW4gPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdCBfcmVzID0gbmV3IFJlc291cmNlUHJvdmlkZXIocGFyYW1ldGVycyk7XHJcbiAgICBjb25zdCBfbGlua1N0eWxlID0gX3Jlcy5nZXRMaW5rU3R5bGUobW9kZWwudHlwZUlkKTtcclxuICAgIGNvbnN0IHR5cGVzID0gW0RFRkFVTFRfTElOS19UWVBFXTtcclxuXHJcbiAgICBpZiAoX2xpbmtTdHlsZS5jc3NDbGFzcyAmJiBfbGlua1N0eWxlLmNzc0NsYXNzICE9PSBERUZBVUxUX0xJTktfVFlQRSkge1xyXG4gICAgICAgIHR5cGVzLnB1c2goX2xpbmtTdHlsZS5jc3NDbGFzcyk7XHJcbiAgICB9XHJcblxyXG4gICAgam9pbnQuZGlhLkxpbmsuYXBwbHkoc2VsZiwgW3tcclxuICAgICAgICB0eXBlOiB0eXBlcy5qb2luKCcgJyksXHJcbiAgICAgICAgejogWl9JTkRFWEVTLkxJTkssXHJcbiAgICAgICAgc291cmNlOiBtb2RlbC5zb3VyY2UsXHJcbiAgICAgICAgdGFyZ2V0OiBtb2RlbC50YXJnZXQsXHJcbiAgICAgICAgYXR0cnM6IF9nZXRMaW5rQXR0cmlidXRlcyhfbGlua1N0eWxlKSxcclxuICAgICAgICBsYWJlbHM6IFt7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAuNSxcclxuICAgICAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgICAgIHJlY3Q6IHsgZmlsbDogX2xpbmtTdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yIH0sXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB7IGZpbGw6IF9saW5rU3R5bGUudGV4dENvbG9yLCB0ZXh0OiBtb2RlbC5sYWJlbCB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XSxcclxuICAgICAgICBjb25uZWN0b3I6IHtuYW1lOiAncm91bmRlZCd9LFxyXG4gICAgfV0pO1xyXG5cclxuICAgIHNlbGYuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYuaGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLlNFTEVDVEVEX0VMRU1FTlQgfSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZ2hsaWdodGVkJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYudW5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLkxJTksgfSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZ2hsaWdodGVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldExpbmtTdHlsZSA9ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gX2xpbmtTdHlsZTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYuaGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLkxJTksgfSk7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCd1cGRhdGUtc3RhdGUnKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYuaGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuQkxVUkVEX0xJTksgfSk7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCd1cGRhdGUtc3RhdGUnKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldExpbmtBdHRyaWJ1dGVzIChsaW5rU3R5bGUsIGhhc0Fycm93KSB7XHJcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xyXG4gICAgICAgIGF0dHJpYnV0ZXNbJy5jb25uZWN0aW9uJ10gPSB7XHJcbiAgICAgICAgICAgIHN0cm9rZTogbGlua1N0eWxlLmNvbG9yLFxyXG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogbGlua1N0eWxlLnRoaWNrbmVzcyxcclxuICAgICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiBsaW5rU3R5bGUubGluZVR5cGUgPT09ICdzb2xpZCcgPyB1bmRlZmluZWQgOiAnNSw1JyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChoYXNBcnJvdykge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzWycubWFya2VyLXRhcmdldCddID0gZ2V0TGlua01hcmtlclRhcmdldChsaW5rU3R5bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcclxuICAgIH1cclxufVxyXG5HcmFwaExpbmsucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShqb2ludC5kaWEuTGluay5wcm90b3R5cGUpO1xyXG5cclxuLyoqXHJcbiAqIEpvaW50TGlua1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3NcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gR3JhcGhDcm9zc0xpbmsgKG1vZGVsLCBwYXJhbXRlcnMpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICBzZWxmLm1vZGVsID0gbW9kZWw7XHJcblxyXG4gICAgR3JhcGhMaW5rLmFwcGx5KHNlbGYsIFttb2RlbCwgcGFyYW10ZXJzXSk7XHJcblxyXG4gICAgc2VsZi5nZXRDcm9zc2VkRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYubW9kZWwuY3Jvc3NlZEVsZW1lbnRzO1xyXG4gICAgfTtcclxufVxyXG5HcmFwaENyb3NzTGluay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdyYXBoTGluay5wcm90b3R5cGUpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvcnRJZCAocG9ydElkLCBkaXJlY3Rpb24pIHtcclxuICAgIGNvbnN0IGlzVGFyZ2V0ID0gZGlyZWN0aW9uID09PSAnaW4nO1xyXG4gICAgcmV0dXJuIGAke2lzVGFyZ2V0ID8gJ0luXycgOiAnT3V0Xyd9UG9ydF8ke2VuY29kZVVSSShwb3J0SWQpfWA7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMaW5rTWFya2VyVGFyZ2V0IChsaW5rU3R5bGUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZmlsbDogbGlua1N0eWxlLmNvbG9yLFxyXG4gICAgICAgIHN0cm9rZTogbGlua1N0eWxlLmNvbG9yLFxyXG4gICAgICAgIGQ6IE1BUktFUl9UQVJHRVQuZCxcclxuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogbGlua1N0eWxlLnRoaWNrbmVzcyxcclxuICAgIH07XHJcbn0iLCJpbXBvcnQgKiBhcyBqb2ludCBmcm9tICdyYXBwaWQnO1xyXG5pbXBvcnQgc2F2ZUFzIGZyb20gJ2ZpbGUtc2F2ZXJqcyc7XHJcblxyXG5pbXBvcnQgeyBHcmFwaE5vZGVWaWV3LCBHcmFwaExpbmtWaWV3IH0gZnJvbSAnLi9tYXBWaWV3cyc7XHJcbmltcG9ydCB7IE5vZGUsIExpbmssIEdyYXBoTm9kZSwgR3JhcGhMaW5rIH0gZnJvbSAnLi9tYXBFbGVtZW50cyc7XHJcbmltcG9ydCB7IGV4cG9ydFRvU1ZHLCB0b0RhdGFVUkwgfSBmcm9tICcuLi90b1N2Zyc7XHJcbmltcG9ydCBTdWJzY3JpYmFibGUgZnJvbSAnLi4vLi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGUnO1xyXG5pbXBvcnQgU2Fua2V5IGZyb20gJy4uLy4uL2xheW91dC9zYW5rZXknO1xyXG5pbXBvcnQgeyByZW1vdmVDeWNsZXMgfSBmcm9tICcuLi8uLi9sYXlvdXQvbGF5b3V0JztcclxuaW1wb3J0IHsgY29udmVydERNRWxlbWVudHNUb0xheW91dE1vZGVscywgY29udmVydEpvaW50RWxlbWVudHNUb0xheW91dE1vZGVscyB9IGZyb20gJy4uLy4uL3V0aWxzL2xheW91dFV0aWxzJztcclxuaW1wb3J0IHsgZGF0ZTJTdHJpbmcsIHBuZzJCbG9iIH0gZnJvbSAnLi4vLi4vdXRpbHMvZGF0YVV0aWxzJztcclxuaW1wb3J0IHsgYWRqdXN0VmVydGljZXMgfSBmcm9tICcuLi8uLi91dGlscy9saW5lYWdlRGlhZ3JhbVV0aWxzJztcclxuaW1wb3J0IHsgYXJyYXlUb01hcCB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcclxuXHJcbmpvaW50LnNoYXBlc1snZ3JhcGgtZGVyaXZhdGlvbi1ub2RlJ10gPSB7XHJcbiAgICBHcmFwaE5vZGU6IEdyYXBoTm9kZSxcclxuICAgIEdyYXBoTm9kZVZpZXc6IEdyYXBoTm9kZVZpZXcsXHJcbn07XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSBwcm9wZXJ0aWVzXHJcbiAqIEBmaXJlcyBibGFuay1jbGlja1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE1hcExheW91dCAocHJvcGVydGllcywgcGFyYW1ldGVycykge1xyXG4gICAgU3Vic2NyaWJhYmxlLmFwcGx5KHRoaXMpO1xyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgY29uc3QgX2dyYXBoID0gbmV3IGpvaW50LmRpYS5HcmFwaCgpO1xyXG4gICAgbGV0IF9zdGFydFBvaW50ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGNvbnN0IF9wYXBlciA9IG5ldyBqb2ludC5kaWEuUGFwZXIoe1xyXG4gICAgICAgIG1vZGVsOiBfZ3JhcGgsXHJcbiAgICAgICAgLy8gZWxlbWVudFZpZXc6IEdyYXBoTm9kZVZpZXcsXHJcbiAgICAgICAgbGlua1ZpZXc6IEdyYXBoTGlua1ZpZXcsXHJcbiAgICAgICAgZ3JpZFNpemU6IDEsXHJcbiAgICAgICAgcHJldmVudENvbnRleHRNZW51OiBmYWxzZSxcclxuICAgICAgICBpbnRlcmFjdGl2ZTogKCkgPT4geyByZXR1cm4geyB2ZXJ0ZXhBZGQ6IGZhbHNlIH07IH0sXHJcbiAgICAgICAgd2lkdGg6IDUwMDAsXHJcbiAgICAgICAgaGVpZ2h0OiA1MDAwLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBfcGFwZXJTY3JvbGxlciA9IG5ldyBqb2ludC51aS5QYXBlclNjcm9sbGVyKHtcclxuICAgICAgICBwYXBlcjogX3BhcGVyLFxyXG4gICAgICAgIGF1dG9SZXNpemVQYXBlcjogdHJ1ZSxcclxuICAgIH0pO1xyXG5cclxuICAgIGxldCBfbm9kZXMgPSBbXTtcclxuICAgIGxldCBfbGlua3MgPSBbXTtcclxuXHJcbiAgICBwcm9wZXJ0aWVzLnJvb3RFbGVtZW50LmlubmVySFRNTCA9ICcnO1xyXG4gICAgcHJvcGVydGllcy5yb290RWxlbWVudC5hcHBlbmRDaGlsZChfcGFwZXJTY3JvbGxlci5yZW5kZXIoKS5lbCk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6YXRpb25cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsaW5nIG11bHRpcGxlIGxpbmsgc2l0dWF0aW9ucyAtIGJlbmRzIHRoZW0gc28gdGhleSBkb24ndCBjcm9zc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICovXHJcblxyXG4gICAgLy8gSnVzdCByZWZyZXNoZXMgcmVsYXRlZCBlbGVtZW50cyBvbiBjaGFuZ2VzLlxyXG4gICAgX2dyYXBoLm9uKCdjaGFuZ2U6c291cmNlIGNoYW5nZTp0YXJnZXQnLCBfcmVmcmVzaFJlbGF0ZWRFbGVtZW50KTtcclxuXHJcbiAgICBfcGFwZXIub24oJ2JsYW5rOnBvaW50ZXJkb3duJywgKGV2ZW50LCB4LCB5KSA9PiB7XHJcbiAgICAgICAgX3N0YXJ0UG9pbnQgPSB7IHg6IGV2ZW50LnBhZ2VYLCB5OiBldmVudC5wYWdlWSB9O1xyXG4gICAgICAgIF9wYXBlclNjcm9sbGVyLnN0YXJ0UGFubmluZyhldmVudCwgeCwgeSk7XHJcbiAgICB9KTtcclxuICAgIF9wYXBlci5vbignYmxhbms6cG9pbnRlcmNsaWNrJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKCFfc3RhcnRQb2ludCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBuZXdQb2ludCA9IHsgeDogZXZlbnQucGFnZVgsIHk6IGV2ZW50LnBhZ2VZIH07XHJcbiAgICAgICAgY29uc3QgT0ZGU0VUX1RIUkVTSE9MRCA9IDU7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0RXhjZWVkVGhyZXNob2xkID0gTWF0aC5hYnMobmV3UG9pbnQueCAtIF9zdGFydFBvaW50LngpIDwgT0ZGU0VUX1RIUkVTSE9MRCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMobmV3UG9pbnQueCAtIF9zdGFydFBvaW50LngpIDwgT0ZGU0VUX1RIUkVTSE9MRDtcclxuICAgICAgICBpZiAob2Zmc2V0RXhjZWVkVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignYmxhbmstY2xpY2snLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zdGFydFBvaW50ID0gdW5kZWZpbmVkO1xyXG4gICAgfSk7XHJcbiAgICBfcGFwZXIub24oJ2NlbGw6cG9pbnRlcmRvd24nLCBmdW5jdGlvbiAoY2VsbFZpZXcpIHtcclxuICAgICAgICBfbm9kZXMuZm9yRWFjaChlbCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlbC5vblBhcGVyQ2VsbFBvaW50ZXJEb3duKSBlbC5vblBhcGVyQ2VsbFBvaW50ZXJEb3duKGNlbGxWaWV3Lm1vZGVsKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBfbGlua3MuZm9yRWFjaChlbCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlbC5vblBhcGVyQ2VsbFBvaW50ZXJEb3duKSBlbC5vblBhcGVyQ2VsbFBvaW50ZXJEb3duKGNlbGxWaWV3Lm1vZGVsKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IG9uTW91c2VXaGVlbCA9IChldnQsIHgsIHksIGRlbHRhKSA9PiB7XHJcbiAgICAgICAgaWYgKGV2dC5jdHJsS2V5KSB7XHJcbiAgICAgICAgICAgIHNlbGYuem9vbSgwLjEgKiAoZGVsdGEgPCAwID8gLTEgOiAxKSwgeyBtYXg6IDQgfSk7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfcGFwZXIub24oJ2NlbGw6bW91c2V3aGVlbCcsIChjZWxsLCBldnQsIHgsIHksIGRlbHRhKSA9PiBvbk1vdXNlV2hlZWwoZXZ0LCB4LCB5LCBkZWx0YSkpO1xyXG4gICAgX3BhcGVyLm9uKCdibGFuazptb3VzZXdoZWVsJywgb25Nb3VzZVdoZWVsKTtcclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgc2VsZi5nZXROb2RlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX25vZGVzO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldExpbmtzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfbGlua3M7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0R3JhcGhOb2RlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2dyYXBoLmdldEVsZW1lbnRzKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0R3JhcGhMaW5rcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2dyYXBoLmdldExpbmtzKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX25vZGVzPVtdO1xyXG4gICAgICAgIF9saW5rcz1bXTtcclxuICAgICAgICBfZ3JhcGguY2xlYXIoKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi56b29tID0gZnVuY3Rpb24gKHNjYWxlRGlmZiwgb3B0KSB7XHJcbiAgICAgICAgaWYgKCFzY2FsZURpZmYpIHtcclxuICAgICAgICAgICAgX3BhcGVyU2Nyb2xsZXIuem9vbVRvRml0KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX3BhcGVyU2Nyb2xsZXIuem9vbShzY2FsZURpZmYsIG9wdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZXdTY2FsZSA9IF9wYXBlclNjcm9sbGVyLl9zeDtcclxuXHJcbiAgICAgICAgX2dyYXBoLmdldEVsZW1lbnRzKCkuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgbm9kZS5zZXRTY2FsZShuZXdTY2FsZSk7XHJcbiAgICAgICAgICAgIG5vZGUucmVmcmVzaCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmFkZEVsZW1lbnRzID0gZnVuY3Rpb24gKG5ld0VsZW1lbnRzKSB7XHJcbiAgICAgICAgY29uc3QgbmV3Tm9kZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBuZXdMaW5rcyA9IFtdO1xyXG4gICAgICAgIG5ld0VsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdOb2Rlcy5wdXNoKGVsKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlbCBpbnN0YW5jZW9mIExpbmspIHtcclxuICAgICAgICAgICAgICAgIG5ld0xpbmtzLnB1c2goZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9ub2RlcyA9IF9ub2Rlcy5jb25jYXQobmV3Tm9kZXMpO1xyXG4gICAgICAgIF9saW5rcyA9IF9saW5rcy5jb25jYXQobmV3TGlua3MpO1xyXG5cclxuICAgICAgICBjb25zdCBwcm9jZXNzZWRJZHMgPSB7fTtcclxuICAgICAgICBjb25zdCBjZWxscyA9IFtdO1xyXG5cclxuICAgICAgICBuZXdFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50Q2VsbHMgPSBlbGVtZW50LmdldENlbGxzKCk7XHJcbiAgICAgICAgICAgIGVsZW1lbnRDZWxscy5mb3JFYWNoKGNlbGwgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwcm9jZXNzZWRJZHNbY2VsbC5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRJZHNbY2VsbC5pZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goY2VsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNlbGxzLnNvcnQoKGNlbGwxLCBjZWxsMikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjMSA9IGNlbGwxIGluc3RhbmNlb2Ygam9pbnQuc2hhcGVzLmJhc2ljLkdlbmVyaWMgPyAxIDogMDtcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBjZWxsMiBpbnN0YW5jZW9mIGpvaW50LnNoYXBlcy5iYXNpYy5HZW5lcmljID8gMSA6IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBjMiAtIGMxO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIF9ncmFwaC5hZGRDZWxscyhjZWxscyk7XHJcblxyXG4gICAgICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiBfcmVmcmVzaFJlbGF0ZWRFbGVtZW50KGNlbGwpKTtcclxuICAgICAgICBfc3Vic2NyaWJlT25FbGVtZW50cygpO1xyXG4gICAgICAgIF9kb0xheW91dCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4cG9ydHMgZ3JhcGggdG8gcG5nIG9yIHN2ZyBmaWxlXHJcbiAgICAgKiBAcGFyYW0ge1xyXG4gICAgICogIG5hbWU/OiBzdHJpbmcgLSBmaWxlIG5hbWVcclxuICAgICAqICB0eXBlPzogc3RyaW5nIC0gKHBuZy9zdmcpXHJcbiAgICAgKiB9IG9wdGlvbnNcclxuICAgICovXHJcbiAgICBzZWxmLmV4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBvcHRpb25zLm5hbWUgfHxcclxuICAgICAgICAgICAgJ0RNX2xpbmVhZ2VfZGlhZ3JhbV9zbmFwc2hvdF8nICsgZGF0ZTJTdHJpbmcobmV3IERhdGUoKSk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdwbmcnKSB7XHJcbiAgICAgICAgICAgIHRvRGF0YVVSTChfcGFwZXIsIHtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgICAgIHN2Z09wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1RvUmVtb3ZlU2VsZWN0b3I6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRIdG1sOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS50aGVuKGJhc2U2NFVSTCA9PiB7XHJcbiAgICAgICAgICAgICAgICBzYXZlRGF0YShiYXNlNjRVUkwsIGZpbGVOYW1lLCAncG5nJyk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSBhbGVydChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGFsZXJ0KCdUaGlzIHR5cGUgb2YgZXhwb3J0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIEludGVybmV0IEV4cGxvcmVyJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXhwb3J0VG9TVkcoX3BhcGVyLCB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50c1RvUmVtb3ZlU2VsZWN0b3I6ICcnLFxyXG4gICAgICAgICAgICAgICAgY29udmVydEh0bWw6IHRydWUsXHJcbiAgICAgICAgICAgIH0pLnRoZW4oc3ZnU3RyaW5nID0+IHtcclxuICAgICAgICAgICAgICAgIHNhdmVEYXRhKHN2Z1N0cmluZywgZmlsZU5hbWUsICdzdmcnKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2F2ZURhdGEgKGRhdGEsIGZpbGVOYW1lLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIGxldCBibG9iO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N2ZycpIHtcclxuICAgICAgICAgICAgICAgIGJsb2IgPSBuZXcgQmxvYihbZGF0YV0sIHsgdHlwZTogdHlwZSB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncG5nJykge1xyXG4gICAgICAgICAgICAgICAgYmxvYiA9IHBuZzJCbG9iIChkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzYXZlQXMoYmxvYiwgZmlsZU5hbWUgKyAnLicgKyB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MgcHJpbnQgZGlhbG9nLlxyXG4gICAgKi9cclxuICAgIHNlbGYucHJpbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdG9EYXRhVVJMKF9wYXBlciwge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgIHN2Z09wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzVG9SZW1vdmVTZWxlY3RvcjogJycsXHJcbiAgICAgICAgICAgICAgICBjb252ZXJ0SHRtbDogdHJ1ZSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLnRoZW4oYmFzZTY0VVJMID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJpbnRXaW5kb3cgPSB3aW5kb3cub3BlbignJywgdW5kZWZpbmVkLCAnd2lkdGg9MTI4MCxoZWlnaHQ9NzIwJyk7XHJcbiAgICAgICAgICAgIGlmIChwcmludFdpbmRvdykge1xyXG4gICAgICAgICAgICAgICAgcHJpbnRXaW5kb3cuZG9jdW1lbnQud3JpdGUoYFxyXG4gICAgICAgICAgICAgICAgICAgIDxodG1sPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiJHtiYXNlNjRVUkx9XCIvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2JvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9odG1sPlxyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBwcmludFdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbWcnKS5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRXaW5kb3cuZG9jdW1lbnQuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBwcmludFdpbmRvdy5wcmludCgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFsZXJ0KCdZb3Ugc2hvdWxkIHVuYmxvY2sgcG9wdXAgd2luZG93cyBmb3IgdGhlIGN1cnJlbnQgdXJsIHRvIGJlIGFibGUgdG8gcHJpbnQgdGhpcyBkaWFncmFtIScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykgYWxlcnQoZXJyb3IpO1xyXG4gICAgICAgICAgICBlbHNlIGFsZXJ0KCdUaGlzIHR5cGUgb2YgZXhwb3J0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIEludGVybmV0IEV4cGxvcmVyJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNldFNlYXJjaEtleSA9IGZ1bmN0aW9uIChzZWFyY2hLZXkpIHtcclxuICAgICAgICBfZ3JhcGguZ2V0RWxlbWVudHMoKS5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBub2RlLnNldFNlYXJjaEtleShzZWFyY2hLZXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfZG9MYXlvdXQgKCkgeyAvLyB0b2RvOiByZWZhY3RvciB0aGlzIGFsZ29yaXRobVxyXG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBfcGFwZXJTY3JvbGxlci5vcHRpb25zLmJhc2VXaWR0aCAvIDI7XHJcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IF9wYXBlclNjcm9sbGVyLm9wdGlvbnMuYmFzZUhlaWdodCAvIDI7XHJcblxyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gY29udmVydERNRWxlbWVudHNUb0xheW91dE1vZGVscyhfbm9kZXMsIF9saW5rcyk7XHJcbiAgICAgICAgcmVtb3ZlQ3ljbGVzKGVsZW1lbnRzLm5vZGVzLCBlbGVtZW50cy5saW5rcyk7XHJcbiAgICAgICAgdHFTYW5rZXlMYXlvdXQoZWxlbWVudHMubm9kZXMsIGVsZW1lbnRzLmxpbmtzKTtcclxuXHJcbiAgICAgICAgY29uc3Qgam9pbnRFbGVtZW50cyA9IGNvbnZlcnRKb2ludEVsZW1lbnRzVG9MYXlvdXRNb2RlbHMoX2dyYXBoLmdldEVsZW1lbnRzKCksIF9ncmFwaC5nZXRMaW5rcygpKTtcclxuICAgICAgICByZW1vdmVDeWNsZXMoam9pbnRFbGVtZW50cy5ub2Rlcywgam9pbnRFbGVtZW50cy5saW5rcyk7XHJcbiAgICAgICAgdHFTYW5rZXlMYXlvdXQoam9pbnRFbGVtZW50cy5ub2Rlcywgam9pbnRFbGVtZW50cy5saW5rcyk7XHJcbiAgICAgICAgY29uc3QgZGVwdGhNYXAgPSBhcnJheVRvTWFwKFxyXG4gICAgICAgICAgICBqb2ludEVsZW1lbnRzLm5vZGVzLm1hcChqZSA9PiAoeyBpZDogamUuaWQsIGRlcHRoOiBqZS55IH0pKSxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBsZXQgbWF4Q29sID0gLUluZmluaXR5O1xyXG4gICAgICAgIGVsZW1lbnRzLm5vZGVzLmZvckVhY2gobiA9PiB7XHJcbiAgICAgICAgICAgIG1heENvbCA9IE1hdGgubWF4KG4ueCwgbWF4Q29sKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgcG9zc2libGVYZXMgPSB7fTtcclxuICAgICAgICBjb25zdCBvcmRlciA9IHt9O1xyXG4gICAgICAgIGVsZW1lbnRzLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIHBvc3NpYmxlWGVzW25vZGUueF0gPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHBvc3NpYmxlQ29sdW1uc0xpc3QgPSBPYmplY3Qua2V5cyhwb3NzaWJsZVhlcykubWFwKHB4ID0+IE1hdGgucm91bmQoK3B4KSk7XHJcbiAgICAgICAgcG9zc2libGVDb2x1bW5zTGlzdC5zb3J0KCh4MSwgeDIpID0+IHtcclxuICAgICAgICAgICAgaWYgKHgxID4geDIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHgxIDwgeDIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkuZm9yRWFjaCgoeCwgaW5kZXgpID0+IG9yZGVyW3hdID0gaW5kZXgpO1xyXG5cclxuICAgICAgICBjb25zdCBzdGVwWCA9IChcclxuICAgICAgICAgICAgcGFyYW1ldGVycy5kZWZhdWx0RWxlbWVudFdpZHRoICtcclxuICAgICAgICAgICAgcGFyYW1ldGVycy5kZWZhdWx0TGF5b3V0U3RlcFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IGNlbnRlclggLSBzdGVwWCAqIChwb3NzaWJsZUNvbHVtbnNMaXN0Lmxlbmd0aCArIDEpIC8gMjtcclxuXHJcbiAgICAgICAgY29uc3QgY29sdW1ucyA9IHt9O1xyXG4gICAgICAgIGVsZW1lbnRzLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTm9kZSA9IG5vZGUub3JpZ2luYWxOb2RlO1xyXG4gICAgICAgICAgICBjb25zdCB4ID0gc3RhcnRQb3NpdGlvbiArIHN0ZXBYICogb3JkZXJbTWF0aC5yb3VuZChub2RlLngpXTtcclxuICAgICAgICAgICAgaWYgKCFjb2x1bW5zW3hdKSBjb2x1bW5zW3hdID0gW107XHJcbiAgICAgICAgICAgIGNvbHVtbnNbeF0ucHVzaChvcmlnaW5hbE5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBCT1RUT01fTUFSR0lOID0gNTA7XHJcbiAgICAgICAgT2JqZWN0LmtleXMoY29sdW1ucykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW2tleV07XHJcbiAgICAgICAgICAgIGxldCB0b3RhbEhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIGNvbHVtbi5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRoZUxhc3QgPSBpbmRleCA9PT0gY29sdW1uLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gKHRoZUxhc3QgPyAwIDogQk9UVE9NX01BUkdJTik7XHJcbiAgICAgICAgICAgICAgICB0b3RhbEhlaWdodCArPSBlbC5nZXQoJ3NpemUnKS5oZWlnaHQgKyBzdGVwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29sdW1uLnNvcnQoKGUxLCBlMikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZTFEZXB0aCA9IChkZXB0aE1hcFtlMS5pZF0gPyBkZXB0aE1hcFtlMS5pZF0uZGVwdGggOiAwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUyRGVwdGggPSAoZGVwdGhNYXBbZTIuaWRdID8gZGVwdGhNYXBbZTIuaWRdLmRlcHRoIDogMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGUxRGVwdGggPiBlMkRlcHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUxRGVwdGggPCBlMkRlcHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0WSA9IGNlbnRlclkgLSB0b3RhbEhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSAra2V5O1xyXG4gICAgICAgICAgICBsZXQgY3VyWSA9IDA7XHJcbiAgICAgICAgICAgIGNvbHVtbi5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRoZUxhc3QgPSBpbmRleCA9PT0gY29sdW1uLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gKHRoZUxhc3QgPyAwIDogQk9UVE9NX01BUkdJTik7XHJcbiAgICAgICAgICAgICAgICBlbC5wb3NpdGlvbih4LCBzdGFydFkgKyBjdXJZKTtcclxuICAgICAgICAgICAgICAgIGN1clkgKz0gZWwuZ2V0KCdzaXplJykuaGVpZ2h0ICsgc3RlcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgX3BhcGVyU2Nyb2xsZXIuY2VudGVyKGNlbnRlclgsIGNlbnRlclkpO1xyXG5cclxuICAgICAgICAvLyBXZSBoaWRlIGR1YmxpY2F0aW9ucyB1c2luZyBoaWdobGlnaHRlci5cclxuICAgICAgICAvLyBUaGF0J3Mgd2h5IHdlIG5lZWQgdG8gYmUgc3VyZSB0aGF0IG5vZGVzIGFyZVxyXG4gICAgICAgIC8vIG9uIHRoZSBwYWdlLCBzbyB3ZSB1c2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIF9hbGlnbkNyb3NzTm9kZXMoKTtcclxuICAgICAgICAgICAgX2dyYXBoLmdldExpbmtzKCkuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgICAgIF9hZGp1c3RBbGxWZXJ0aWNlcyhsaW5rKTtcclxuICAgICAgICAgICAgfSk7ICAgIFxyXG4gICAgICAgICAgICBfaGlkZUR1YmxpY2F0aW9ucygpO1xyXG4gICAgICAgIH0sIDMwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRqdXN0aW5nIHZlcnRpY2VzXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBfZ3JhcGgub24oJ2NoYW5nZTpzb3VyY2UgY2hhbmdlOnRhcmdldCB1cGRhdGUtdmVydGljZXMnLCBfYWRqdXN0VmVydGljZXMpO1xyXG4gICAgX3BhcGVyLm9uKCdjZWxsOnBvaW50ZXJ1cCcsIF9hZGp1c3RWZXJ0aWNlcyk7XHJcblxyXG4gICAgZnVuY3Rpb24gX2FkanVzdEFsbFZlcnRpY2VzICgpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgX2dyYXBoLmdldExpbmtzKCkuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgICAgIGFkanVzdFZlcnRpY2VzKF9ncmFwaCwgbGluayk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIDEwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2FkanVzdFZlcnRpY2VzIChjZWxsKSB7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGFkanVzdFZlcnRpY2VzKF9ncmFwaCwgY2VsbCk7XHJcbiAgICAgICAgfSwgMTAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBmdW5jdGlvbiBfc3Vic2NyaWJlT25FbGVtZW50cyAoKSB7XHJcbiAgICAgICAgX25vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIG5vZGUub24oJ2VsZW1lbnQtc3RhdGUtY2hhbmdlZCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIF9hZGp1c3RWZXJ0aWNlcyhub2RlLmdldFBvcnQoKS5wcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfcmVmcmVzaFJlbGF0ZWRFbGVtZW50IChjZWxsKSB7XHJcbiAgICAgICAgaWYgKGNlbGwgaW5zdGFuY2VvZiBHcmFwaExpbmspIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudHNUb1VwZGF0ZSA9IHt9O1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbGluayA9IGNlbGw7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZTb3VyY2VEZXNjcmlwdG9yID0gbGluay5wcmV2aW91cygnc291cmNlJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZUYXJnZXREZXNjcmlwdG9yID0gbGluay5wcmV2aW91cygndGFyZ2V0Jyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZTb3VyY2UgPSBwcmV2U291cmNlRGVzY3JpcHRvciA/IF9ncmFwaC5nZXRDZWxsKHByZXZTb3VyY2VEZXNjcmlwdG9yLmlkKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgY29uc3QgcHJldlRhcmdldCA9IHByZXZUYXJnZXREZXNjcmlwdG9yID8gX2dyYXBoLmdldENlbGwocHJldlRhcmdldERlc2NyaXB0b3IuaWQpIDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc291cmNlRGVzY3JpcHRvciA9IGxpbmsuZ2V0KCdzb3VyY2UnKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGVzY3JpcHRvciA9IGxpbmsuZ2V0KCd0YXJnZXQnKTtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gX2dyYXBoLmdldENlbGwoc291cmNlRGVzY3JpcHRvci5pZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IF9ncmFwaC5nZXRDZWxsKHRhcmdldERlc2NyaXB0b3IuaWQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHByZXZTb3VyY2UgJiYgcHJldlNvdXJjZS5hY3RpdmVQb3J0cykge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudHNUb1VwZGF0ZVtwcmV2U291cmNlLmlkXSA9IHByZXZTb3VyY2U7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0SWQgPSBwcmV2U291cmNlRGVzY3JpcHRvci5wb3J0O1xyXG4gICAgICAgICAgICAgICAgcHJldlNvdXJjZS5hY3RpdmVQb3J0c1twb3J0SWRdID0gcHJldlNvdXJjZS5hY3RpdmVQb3J0c1twb3J0SWRdIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHByZXZTb3VyY2UuYWN0aXZlUG9ydHNbcG9ydElkXVtsaW5rLmlkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJldlRhcmdldCAmJiBwcmV2VGFyZ2V0LmFjdGl2ZVBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50c1RvVXBkYXRlW3ByZXZUYXJnZXQuaWRdID0gcHJldlRhcmdldDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnRJZCA9IHByZXZUYXJnZXREZXNjcmlwdG9yLnBvcnQ7XHJcbiAgICAgICAgICAgICAgICBwcmV2VGFyZ2V0LmFjdGl2ZVBvcnRzW3BvcnRJZF0gPSBwcmV2VGFyZ2V0LmFjdGl2ZVBvcnRzW3BvcnRJZF0gfHwge307XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJldlRhcmdldC5hY3RpdmVQb3J0c1twb3J0SWRdW2xpbmsuaWRdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc291cmNlLmFjdGl2ZVBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50c1RvVXBkYXRlW3NvdXJjZS5pZF0gPSBzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UuYWN0aXZlUG9ydHNbc291cmNlRGVzY3JpcHRvci5wb3J0XSA9IHNvdXJjZS5hY3RpdmVQb3J0c1tzb3VyY2VEZXNjcmlwdG9yLnBvcnRdIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgc291cmNlLmFjdGl2ZVBvcnRzW3NvdXJjZURlc2NyaXB0b3IucG9ydF1bbGluay5pZF0gPSBsaW5rO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0LmFjdGl2ZVBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50c1RvVXBkYXRlW3RhcmdldC5pZF0gPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWN0aXZlUG9ydHNbdGFyZ2V0RGVzY3JpcHRvci5wb3J0XSA9IHRhcmdldC5hY3RpdmVQb3J0c1t0YXJnZXREZXNjcmlwdG9yLnBvcnRdIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFjdGl2ZVBvcnRzW3RhcmdldERlc2NyaXB0b3IucG9ydF1bbGluay5pZF0gPSBsaW5rO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhlbGVtZW50c1RvVXBkYXRlKVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZWxJZCA9PiBlbGVtZW50c1RvVXBkYXRlW2VsSWRdLnJlZnJlc2goKSk7XHJcbiAgICAgICAgICAgIF9oaWRlRHVibGljYXRpb25zKCk7XHJcbiAgICAgICAgICAgIF9hbGlnbkNyb3NzTm9kZXMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2FsaWduQ3Jvc3NOb2RlcyAoKSB7XHJcbiAgICAgICAgY29uc3QgdGVtcE1hcCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IHVuaXF1ZUNyb3NzTGlua3MgPSBbXTtcclxuICAgICAgICBfbGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY3Jvc3NOb2RlID0gbGluay5nZXRDcm9zc05vZGUoKTtcclxuICAgICAgICAgICAgaWYgKGNyb3NzTm9kZSAmJiAhdGVtcE1hcFtjcm9zc05vZGUuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wTWFwW2Nyb3NzTm9kZS5pZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdW5pcXVlQ3Jvc3NMaW5rcy5wdXNoKGxpbmspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHVuaXF1ZUNyb3NzTGlua3MuZm9yRWFjaChsID0+IGwuYWxpZ25Dcm9zc05vZGUoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2hpZGVEdWJsaWNhdGlvbnMgKCkge1xyXG4gICAgICAgIGNvbnN0IHVuaXF1ZU1hcCA9IHt9O1xyXG4gICAgICAgIF9saW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0eXBlSWQgPSAvKmxpbmsudHlwZUlkIHx8Ki8gbGluay5sYWJlbDtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlUG9ydElkID0gbGluay5zb3VyY2UuZ2V0UG9ydCgpLmlkO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQb3J0SWQgPSBsaW5rLnRhcmdldC5nZXRQb3J0KCkuaWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gY2FjaGVGdW5jdGlvbiAodHlwZUlkLCBzb3VyY2VQb3J0SWQsIHRhcmdldFBvcnRJZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzSGlnaGxpZ2h0ZWQgPSBsaW5rLmhpZ2hsaWdodGluZygpO1xyXG4gICAgICAgICAgICBpZiAoaXNIaWdobGlnaHRlZCB8fCAhdW5pcXVlTWFwW2NhY2hlS2V5XSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHVuaXF1ZU1hcFtjYWNoZUtleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmlxdWVNYXBbY2FjaGVLZXldLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVuaXF1ZU1hcFtjYWNoZUtleV0gPSBsaW5rO1xyXG4gICAgICAgICAgICAgICAgbGluay5zaG93KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsaW5rLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjYWNoZUZ1bmN0aW9uIChsYWJlbCwgc291cmNlUG9ydElkLCB0YXJnZXRQb3J0SWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAke2xhYmVsfX4jdHFETUxpbmsjfiR7c291cmNlUG9ydElkfX4jdHFETUxpbmsjfiR7dGFyZ2V0UG9ydElkfWA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IE1hcExheW91dDtcclxuXHJcblxyXG5mdW5jdGlvbiB0cVNhbmtleUxheW91dCAobm9kZXMsIGxpbmtzKSB7XHJcbiAgICBTYW5rZXkoKS5zdGVwKFsxMCwgMTBdKVxyXG4gICAgLmdyb3Vwcyhbe1xyXG4gICAgICAgIG5vZGVzOiBub2RlcyxcclxuICAgICAgICBsaW5rczogbGlua3MsXHJcbiAgICB9XSlcclxuICAgIC5ub2RlV2lkdGgoMSlcclxuICAgIC5ub2RlSGVpZ2h0KDEpXHJcbiAgICAubm9kZXMobm9kZXMpXHJcbiAgICAubGlua3MobGlua3MpXHJcbiAgICAubGF5b3V0KDIwMDApO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIGpvaW50IGZyb20gJ3JhcHBpZCc7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRQb3J0SWQsXHJcbn0gZnJvbSAnLi9tYXBFbGVtZW50cyc7XHJcbmltcG9ydCB7XHJcbiAgICBvbkRyYWdTdGFydCxcclxufSBmcm9tICcuLi8uLi91dGlscy91dGlscyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gR3JhcGhOb2RlVmlldyAoKSB7XHJcbiAgICBqb2ludC5kaWEuRWxlbWVudFZpZXcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IE1BWF9OT0RFX0hFSUdIVCA9IDIwMDtcclxuZXhwb3J0IGNvbnN0IENTU19DTEFTU19OVU1CRVIgPSAzO1xyXG5cclxuR3JhcGhOb2RlVmlldy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LmRpYS5FbGVtZW50Vmlldy5wcm90b3R5cGUpO1xyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fcHJvY2Vzc2VkSWRzOyAvLyBwcmV2ZW50IGN5Y2xlc1xyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fc2NhbGUgPSAxOyAvLyBkZWZhdWx0IHNjYWxlXHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgam9pbnQuZGlhLkVsZW1lbnRWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB0aGlzLl9wcm9jZXNzZWRJZHMgPSB7fTtcclxuICAgIHRoaXMucGFydHMgPSB7fTtcclxuXHJcbiAgICBjb25zdCBib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgIGJveC5jbGFzc05hbWUgPSAnZGVyaXZhdGlvbi1ub2RlJztcclxuICAgIGJveC5pZCA9IHRoaXMubW9kZWwuaWQ7XHJcbiAgICBib3gub25tb3VzZWRvd24gPSAoZXZlbnQpID0+IHtcclxuICAgICAgICBvbkRyYWdTdGFydChldmVudCwgKGRpZmYpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY3VyUG9zID0gdGhpcy5tb2RlbC5wb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBvc2l0aW9uKGN1clBvcy54ICsgZGlmZi54IC8gdGhpcy5fc2NhbGUsIGN1clBvcy55ICsgZGlmZi55IC8gdGhpcy5fc2NhbGUpO1xyXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9LCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwuZ3JhcGgpXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLmdyYXBoLnRyaWdnZXIoJ3VwZGF0ZS12ZXJ0aWNlcycsIGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5wYXJ0c1snYm94J10gPSBib3g7XHJcbiAgICBcclxuICAgIGNvbnN0IHNjcm9sbGVyID0gdGhpcy5fY3JlYXRlU2Nyb2xsZXIoKTtcclxuICAgIGJveC5hcHBlbmRDaGlsZChzY3JvbGxlcik7XHJcbiAgICB0aGlzLnBhcnRzWydzY3JvbGxlciddID0gc2Nyb2xsZXI7XHJcblxyXG4gICAgY29uc3QgaGVhZGVyID0gdGhpcy5fY3JlYXRlSGVhZGVyKHRoaXMubW9kZWwubW9kZWwpO1xyXG4gICAgYm94LmFwcGVuZENoaWxkKGhlYWRlcik7XHJcbiAgICB0aGlzLnBhcnRzWydoZWFkZXInXSA9IGhlYWRlcjtcclxuXHJcbiAgICBjb25zdCBib2R5ID0gdGhpcy5fY3JlYXRlQm9keSh0aGlzLm1vZGVsLm1vZGVsKTtcclxuICAgIGJveC5hcHBlbmRDaGlsZChib2R5KTtcclxuICAgIHRoaXMucGFydHNbJ2JvZHknXSA9IGJvZHk7XHJcbiAgICBcclxuICAgIGNvbnN0IGNvbGxhcHNlQnV0dG9uID0gdGhpcy5fY3JlYXRlQ29sbGFwc2VCdXR0b24oKTtcclxuICAgIGhlYWRlci5hcHBlbmRDaGlsZChjb2xsYXBzZUJ1dHRvbik7XHJcbiAgICB0aGlzLnBhcnRzWydjb2xsYXBzZUJ1dHRvbiddID0gY29sbGFwc2VCdXR0b247XHJcblxyXG4gICAgdGhpcy5tb2RlbC5vbignY2hhbmdlJywgdGhpcy5fdXBkYXRlQm94LCB0aGlzKTtcclxuICAgIHRoaXMubW9kZWwub24oJ3JlbW92ZScsIHRoaXMuX3JlbW92ZUJveCwgdGhpcyk7XHJcbiAgICB0aGlzLm1vZGVsLm9uKCdyZWRyYXctdmlldycsIHRoaXMuZGVib3VuY2VkUmVuZGVyLCB0aGlzKTtcclxuICAgIHRoaXMubW9kZWwub24oJ2VsZW1lbnRzLXN0YXRlLWNoYW5nZWQnLCB0aGlzLmRlYm91bmNlZFJlbmRlciwgdGhpcyk7XHJcbiAgICB0aGlzLm1vZGVsLm9uKCdwb3J0cy1zdGF0ZS1jaGFuZ2VkJywgdGhpcy5fdXBkYXRlUG9ydHMsIHRoaXMpO1xyXG4gICAgdGhpcy5tb2RlbC5vbignY2hhbmdlOmNvbGxhcHNlZCcsIHRoaXMuZGVib3VuY2VkUmVuZGVyLCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLmRlYm91bmNlcjtcclxuR3JhcGhOb2RlVmlldy5wcm90b3R5cGUuZGVib3VuY2VkUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5kZWJvdW5jZXIpO1xyXG4gICAgdGhpcy5kZWJvdW5jZXIgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuX3Byb2Nlc3NlZElkcyA9IHt9O1xyXG4gICAgam9pbnQuZGlhLkVsZW1lbnRWaWV3LnByb3RvdHlwZS5yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIGNvbnN0IGJveCA9IHRoaXMucGFydHNbJ2JveCddO1xyXG4gICAgaWYgKHRoaXMucGFwZXIpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGUoKTsgICAgICAgIFxyXG4gICAgICAgIHRoaXMucGFwZXIuJGVsLnByZXBlbmQoYm94KTsgXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsZXIoKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNvbXBvbmVudHMpIHtcclxuICAgIHRoaXMuX3VwZGF0ZUJvZHkoKTtcclxuXHJcbiAgICBjb21wb25lbnRzID0gY29tcG9uZW50cyB8fCB0aGlzLm1vZGVsLmdldEFsbENoaWxkcmVuKCk7XHJcbiAgICBjb21wb25lbnRzLmZvckVhY2gobW9kZWwgPT4gdGhpcy5fdXBkYXRlTW9kZWwobW9kZWwpKTtcclxuXHJcbiAgICB0aGlzLl91cGRhdGVDb2xsYXBzZUJ1dHRvbigpO1xyXG4gICAgdGhpcy5fdXBkYXRlQm94KCk7XHJcbiAgICB0aGlzLl91cGRhdGVQb3J0cygpO1xyXG59O1xyXG5cclxuR3JhcGhOb2RlVmlldy5wcm90b3R5cGUuX3VwZGF0ZUJveCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IGJveCA9IHRoaXMucGFydHNbJ2JveCddOyBcclxuXHJcbiAgICBjb25zdCBlbGVtZW50QkJveCA9IHRoaXMubW9kZWwuZ2V0QkJveCgpO1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gYm94LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCAvIHRoaXMuX3NjYWxlO1xyXG4gICAgXHJcbiAgICBib3guc3R5bGUud2lkdGggPSBlbGVtZW50QkJveC53aWR0aCArICdweCc7XHJcbiAgICB0aGlzLm1vZGVsLnJlc2l6ZShlbGVtZW50QkJveC53aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICBjb25zdCB4X2Vycm9yID0gZWxlbWVudEJCb3gud2lkdGggLyAyO1xyXG4gICAgY29uc3QgeV9lcnJvciA9IGhlaWdodCAvIDI7XHJcbiAgICBib3guc3R5bGUubGVmdCA9ICgoZWxlbWVudEJCb3gueCArIHhfZXJyb3IpICogdGhpcy5tb2RlbC5zY2FsZSkgLSB4X2Vycm9yICsgJ3B4JztcclxuICAgIGJveC5zdHlsZS50b3AgPSAoKGVsZW1lbnRCQm94LnkgKyB5X2Vycm9yKSAqIHRoaXMubW9kZWwuc2NhbGUpIC0geV9lcnJvciArICdweCc7XHJcblxyXG4gICAgdGhpcy5fc2NhbGUgPSB0aGlzLm1vZGVsLnNjYWxlO1xyXG4gICAgYm94LnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgnICsgdGhpcy5fc2NhbGUgKyAnKSc7XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fdXBkYXRlUG9ydHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCBib3ggPSB0aGlzLnBhcnRzWydib3gnXTsgXHJcbiAgICBjb25zdCBib2R5ID0gdGhpcy5wYXJ0c1snYm9keSddO1xyXG4gICAgY29uc3QgZnJlc2hQb3J0cyA9IHt9O1xyXG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMubW9kZWwuZ2V0KCdzaXplJyk7XHJcbiAgICB0aGlzLm1vZGVsLmdldEFsbENoaWxkcmVuKCkuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICBjb25zdCBpblBvcnRJZCA9IGdldFBvcnRJZChlbGVtZW50LmlkLCAnaW4nKTtcclxuICAgICAgICBjb25zdCBvdXRQb3J0SWQgPSBnZXRQb3J0SWQoZWxlbWVudC5pZCwgJ291dCcpO1xyXG4gICAgICAgIGNvbnN0IGh0bWxFbGVtZW50ID0gYm94LnF1ZXJ5U2VsZWN0b3IoJyMnICsgZWxlbWVudC5pZCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgaGVhZGVyID0gaHRtbEVsZW1lbnQgP1xyXG4gICAgICAgICAgICBodG1sRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tZ3JvdXBfaGVhZGVyJykgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IHBvcnRIdG1sRWxlbWVudDtcclxuICAgICAgICBpZiAoaGVhZGVyKSB7XHJcbiAgICAgICAgICAgIHBvcnRIdG1sRWxlbWVudCA9IGhlYWRlcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwb3J0SHRtbEVsZW1lbnQgPSBodG1sRWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBvcnRIdG1sRWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRUb3AgPSBnZXRPZmZzZXRUb3AocG9ydEh0bWxFbGVtZW50KTtcclxuICAgICAgICAgICAgY29uc3QgY2xpZW50SGVpZ2h0ID0gcG9ydEh0bWxFbGVtZW50LmNsaWVudEhlaWdodDtcclxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVG9Ub3AgPSBib2R5LnNjcm9sbFRvcDtcclxuICAgICAgICAgICAgY29uc3QgbWluWSA9IGJvZHkub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhZID0gYm9keS5jbGllbnRIZWlnaHQgKyBtaW5ZO1xyXG4gICAgICAgICAgICBjb25zdCBtaWRkbGVQb2ludCA9ICgtc2Nyb2xsVG9Ub3ApICsgb2Zmc2V0VG9wICsgY2xpZW50SGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgY29uc3QgcmVmWSA9IE1hdGgubWF4KE1hdGgubWluKG1pZGRsZVBvaW50LCBtYXhZKSwgbWluWSk7XHJcblxyXG4gICAgICAgICAgICBmcmVzaFBvcnRzWycuJyArIGluUG9ydElkXSA9IHtcclxuICAgICAgICAgICAgICAgIHJlZjogJy5ib2R5JyxcclxuICAgICAgICAgICAgICAgICdyZWYteSc6IHJlZlksXHJcbiAgICAgICAgICAgICAgICAncmVmLXgnOiAwLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBmcmVzaFBvcnRzWycuJyArIG91dFBvcnRJZF0gPSB7XHJcbiAgICAgICAgICAgICAgICByZWY6ICcuYm9keScsXHJcbiAgICAgICAgICAgICAgICAncmVmLXknOiByZWZZLFxyXG4gICAgICAgICAgICAgICAgJ3JlZi14Jzogc2l6ZS53aWR0aCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLm1vZGVsLmF0dHIoZnJlc2hQb3J0cyk7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0T2Zmc2V0VG9wIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYoZWxlbWVudC5jbGFzc05hbWUgIT09ICdkZXJpdmF0aW9uLW5vZGUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lm9mZnNldFRvcCArIGVsZW1lbnQuY2xpZW50VG9wICsgKGVsZW1lbnQub2Zmc2V0UGFyZW50ID8gZ2V0T2Zmc2V0VG9wKGVsZW1lbnQub2Zmc2V0UGFyZW50KSA6IDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl9jcmVhdGVTY3JvbGxlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IHNjcm9sbGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICBzY3JvbGxlci5jbGFzc05hbWUgPSAnZGVyaXZhdGlvbi1ub2RlX2JvZHktc2Nyb2xsZXInO1xyXG4gICAgc2Nyb2xsZXIub25zY3JvbGwgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5wYXJ0c1snYm9keSddLnNjcm9sbFRvcCA9IHRoaXMubW9kZWwuc2N0b2xsVG9wID0gc2Nyb2xsZXIuc2Nyb2xsVG9wO1xyXG4gICAgICAgIHRoaXMubW9kZWwudXBkYXRlUG9ydHMoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBib2R5U2l6ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgYm9keVNpemUuY2xhc3NOYW1lID0gJ2Rlcml2YXRpb24tbm9kZV9ib2R5LXNjcm9sbGVyX19zaXplJztcclxuICAgIHNjcm9sbGVyLmFwcGVuZENoaWxkKGJvZHlTaXplKTtcclxuXHJcbiAgICByZXR1cm4gc2Nyb2xsZXI7XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fdXBkYXRlU2Nyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCBzY3JvbGxlciA9IHRoaXMucGFydHNbJ3Njcm9sbGVyJ107XHJcbiAgICBjb25zdCBib2R5ID0gdGhpcy5wYXJ0c1snYm9keSddO1xyXG4gICAgY29uc3QgY29sbGFwc2VCdXR0b24gPSB0aGlzLnBhcnRzWydjb2xsYXBzZUJ1dHRvbiddO1xyXG5cclxuICAgIGNvbnN0IGJib3ggPSBib2R5LmZpcnN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBjb25zdCBib2R5SGVpZ2h0ID0gYmJveC5oZWlnaHQgLyB0aGlzLl9zY2FsZTtcclxuICAgIGNvbnN0IGJvZHlXaWR0aCA9IGJib3gud2lkdGggLyB0aGlzLl9zY2FsZTtcclxuICAgIGlmIChzY3JvbGxlci5maXJzdENoaWxkKSB7IC8vIGZvciBJRTExXHJcbiAgICAgICAgc2Nyb2xsZXIuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPSBib2R5SGVpZ2h0ICsgJ3B4JztcclxuICAgICAgICBzY3JvbGxlci5maXJzdENoaWxkLnN0eWxlLndpZHRoID0gYm9keVdpZHRoICsgJ3B4JztcclxuICAgIH1cclxuICAgIGNvbnN0IGV4Y2VlZFNpemUgPSBib2R5SGVpZ2h0IDw9IE1BWF9OT0RFX0hFSUdIVDtcclxuICAgIGNvbnN0IGlzU2Nyb2xsYWJsZSA9IGV4Y2VlZFNpemUgfHwgIXRoaXMubW9kZWwuZ2V0KCdjb2xsYXBzZWQnKTtcclxuICAgIGNvbGxhcHNlQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSBleGNlZWRTaXplID8gJ25vbmUnIDogbnVsbDtcclxuICAgIHNjcm9sbGVyLnN0eWxlLmRpc3BsYXkgPSBpc1Njcm9sbGFibGUgPyAnbm9uZScgOiBudWxsO1xyXG5cclxuICAgIGJvZHkuc2Nyb2xsVG9wID0gdGhpcy5tb2RlbC5zY3RvbGxUb3A7XHJcbiAgICBzY3JvbGxlci5zY3JvbGxUb3AgPSB0aGlzLm1vZGVsLnNjdG9sbFRvcDtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl9yZW1vdmVCb3ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnBhcnRzWydib3gnXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucGFydHNbJ2JveCddKTtcclxuICAgIHRoaXMucGFydHMgPSB7fTtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl9jcmVhdGVCb2R5ID0gZnVuY3Rpb24gKG1vZGVsKSB7XHJcbiAgICBjb25zdCBib2R5ID0gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgYm9keS5jbGFzc05hbWUgPSAnZGVyaXZhdGlvbi1ub2RlX2JvZHknO1xyXG4gICAgY29uc3QgcmVuZGVyZWRNb2RlbCA9IHRoaXMuX2NyZWF0ZU1vZGVsKG1vZGVsLCAwKTtcclxuICAgIGJvZHkuYXBwZW5kQ2hpbGQocmVuZGVyZWRNb2RlbCk7XHJcblxyXG4gICAgcmV0dXJuIGJvZHk7XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fdXBkYXRlQm9keSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IGJvZHkgPSAgdGhpcy5wYXJ0c1snYm9keSddO1xyXG4gICAgXHJcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2NvbGxhcHNlZCcpKSB7XHJcbiAgICAgICAgYm9keS5zdHlsZS5tYXhIZWlnaHQgPSBNQVhfTk9ERV9IRUlHSFQgKyAncHgnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBib2R5LnN0eWxlLm1heEhlaWdodCA9IG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fY3JlYXRlQ29sbGFwc2VCdXR0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCBjb2xsYXBzZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0lNRycpO1xyXG4gICAgY29sbGFwc2VCdXR0b24uY2xhc3NOYW1lID0gJ2Rlcml2YXRpb24tbm9kZS1jb2xsYXBzZS1idXR0b24nO1xyXG4gICAgY29sbGFwc2VCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2NvbGxhcHNlZCcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuX2V4cGFuZEVsZW1lbnQoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLl9jb2xsYXBzZUVsZW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBjb2xsYXBzZUJ1dHRvbjtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl91cGRhdGVDb2xsYXBzZUJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IGNvbGxhcHNlQnV0dG9uID0gdGhpcy5wYXJ0c1snY29sbGFwc2VCdXR0b24nXTtcclxuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnY29sbGFwc2VkJykpIHtcclxuICAgICAgICBjb2xsYXBzZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzZWQnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29sbGFwc2VCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2VkJyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fY3JlYXRlSGVhZGVyID0gZnVuY3Rpb24gKG1vZGVsKSB7XHJcbiAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgIGhlYWRlci5jbGFzc05hbWUgPSAnZGVyaXZhdGlvbi1ub2RlX2hlYWRlcic7XHJcblxyXG4gICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdMQUJFTCcpO1xyXG4gICAgbGFiZWwuY2xhc3NOYW1lID0gJ2Rlcml2YXRpb24tbm9kZV9oZWFkZXJfX2xhYmVsJztcclxuICAgIGxhYmVsLmlubmVyVGV4dCA9IG1vZGVsLnRpdGxlIHx8ICcnO1xyXG5cclxuICAgIGhlYWRlci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG4gICAgcmV0dXJuIGhlYWRlcjtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl9jcmVhdGVNb2RlbCA9IGZ1bmN0aW9uIChtb2RlbCwgZGVlcCkge1xyXG4gICAgaWYgKCF0aGlzLl9wcm9jZXNzZWRJZHNbbW9kZWwuaWRdKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvY2Vzc2VkSWRzW21vZGVsLmlkXSA9IHRydWU7XHJcblxyXG4gICAgICAgIGxldCBtb2RlbFZpZXc7XHJcbiAgICAgICAgaWYgKG1vZGVsLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbW9kZWxWaWV3ID0gdGhpcy5fY3JlYXRlR3JvdXAobW9kZWwsIGRlZXApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1vZGVsVmlldyA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQobW9kZWwsIGRlZXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhcnRzW21vZGVsLmlkXSA9IG1vZGVsVmlldztcclxuICAgICAgICByZXR1cm4gbW9kZWxWaWV3O1xyXG4gICAgfVxyXG59O1xyXG5cclxuR3JhcGhOb2RlVmlldy5wcm90b3R5cGUuX3VwZGF0ZU1vZGVsID0gZnVuY3Rpb24gKG1vZGVsKSB7XHJcbiAgICBpZiAobW9kZWwuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUdyb3VwKG1vZGVsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlRWxlbWVudChtb2RlbCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fY3JlYXRlR3JvdXAgPSBmdW5jdGlvbiAocm9vdE1vZGVsLCBkZWVwKSB7XHJcbiAgICBjb25zdCBpY29uID0gcm9vdE1vZGVsLmljb24gPyBgPHNwYW4gY2xhc3M9XCJkbi1oZWFkZXItaWNvblwiPjxpIGNsYXNzPVwiJHtyb290TW9kZWwuaWNvbn1cIj48L2k+PC9zcGFuPmAgOiAnJztcclxuICAgIGNvbnN0IGdyb3VwRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgY29uc3QgY3NzQ2xhc3MgPSAnZGVyaXZhdGlvbi1ub2RlX2dyb3VwXycgKyBkZWVwICUgKENTU19DTEFTU19OVU1CRVIgKyAxKTtcclxuICAgIGdyb3VwRWxlbWVudC5pZCA9IHJvb3RNb2RlbC5pZDtcclxuICAgIGdyb3VwRWxlbWVudC5jbGFzc05hbWUgPSBgJHtjc3NDbGFzc30gZG4tZ3JvdXBgO1xyXG4gICAgZ3JvdXBFbGVtZW50LmlubmVySFRNTCA9IGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZG4tZ3JvdXBfaGVhZGVyXCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZG4tYXJyb3cgZG5fX2luY29taW5nLWFycm93XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZG4tYXJyb3ctdHJpYW5nbGVcIj48L2Rpdj5cclxuICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICA8aW1nLz5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRuLWdyb3VwX2hlYWRlcl9fbGFiZWxcIiAgdGl0bGU9XCIke3Jvb3RNb2RlbC5lbmRwb2ludElkICsgJyh0eXBlOiAnICsgcm9vdE1vZGVsLnR5cGUgKyAnKSd9XCI+XHJcbiAgICAgICAgICAgICAgICAke2ljb259XHJcbiAgICAgICAgICAgICAgICA8bGFiZWw+JHtyb290TW9kZWwubGFiZWx9PC9sYWJlbD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZG4tYXJyb3cgZG5fX291dGdvaW5nLWFycm93XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZG4tYXJyb3ctdHJpYW5nbGVcIj48L2Rpdj5cclxuICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDx1bCBjbGFzcz1cImRlcml2YXRpb24tbm9kZV9saXN0LW9mLWVsZW1lbnRzXCI+PC91bD5cclxuICAgIGA7XHJcblxyXG4gICAgY29uc3QgYWN0aXZlSGVhZGVyQXJlYSA9IGdyb3VwRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tZ3JvdXBfaGVhZGVyX19sYWJlbCcpO1xyXG4gICAgYWN0aXZlSGVhZGVyQXJlYS5vbmNsaWNrID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5maXJlQ2xpY2tFdmVudChldmVudCwgZ3JvdXBFbGVtZW50LmlkKTtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGNvbnN0IGNoaWxkcmVuID0gZ3JvdXBFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kZXJpdmF0aW9uLW5vZGVfbGlzdC1vZi1lbGVtZW50cycpO1xyXG4gICAgcm9vdE1vZGVsLmNoaWxkcmVuLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVuZGVyZWRNb2RlbCA9IHRoaXMuX2NyZWF0ZU1vZGVsKGVsZW1lbnQsIGRlZXAgKyAxKTtcclxuICAgICAgICBpZiAocmVuZGVyZWRNb2RlbCkge1xyXG4gICAgICAgICAgICBjaGlsZHJlbi5hcHBlbmRDaGlsZChyZW5kZXJlZE1vZGVsKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBjb2xsYXBzZUJ1dHRvbiA9IGdyb3VwRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tZ3JvdXAgaW1nJyk7XHJcbiAgICBjb2xsYXBzZUJ1dHRvbi5vbmNsaWNrID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5vbkNsaWNrQ29sbGFwc2VCdXR0b24ocm9vdE1vZGVsLmlkKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGdyb3VwRWxlbWVudDtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl91cGRhdGVHcm91cCA9IGZ1bmN0aW9uIChyb290TW9kZWwpIHtcclxuICAgIGNvbnN0IGdyb3VwRWxlbWVudCA9IHRoaXMucGFydHNbcm9vdE1vZGVsLmlkXTtcclxuXHJcbiAgICBncm91cEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHJvb3RNb2RlbC5pbnZpc2libGUgPyAnbm9uZScgOiBudWxsO1xyXG4gICAgaWYgKHJvb3RNb2RlbC5pbnZpc2libGUpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBub1Zpc2libGVDaGlsZHJlbiA9ICghcm9vdE1vZGVsLmNoaWxkcmVuKSB8fCByb290TW9kZWwuY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+ICFjaGlsZC5pbnZpc2libGUpLmxlbmd0aCA9PT0gMDtcclxuICAgIGlmIChyb290TW9kZWwuY29sbGFwc2VkICYmIG5vVmlzaWJsZUNoaWxkcmVuKSB7XHJcbiAgICAgICAgZ3JvdXBFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2RuLWNvbGxhcHNlZCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBncm91cEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZG4tY29sbGFwc2VkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJvb3RNb2RlbC5jb2xsYXBzZWQgJiYgbm9WaXNpYmxlQ2hpbGRyZW4pIHtcclxuICAgICAgICBncm91cEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZG4tY29sbGFwc2VkJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdyb3VwRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdkbi1jb2xsYXBzZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpc0hpZ2hsaWdodGVkID0gdGhpcy5tb2RlbC5oaWdobGlnaHRlZElkID09PSByb290TW9kZWwuaWQ7XHJcbiAgICBpZiAoaXNIaWdobGlnaHRlZCkge1xyXG4gICAgICAgIGdyb3VwRWxlbWVudC5jbGFzc0xpc3QuYWRkKCd0cS1kbS1oaWdobGlnaHRlZCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBncm91cEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgndHEtZG0taGlnaGxpZ2h0ZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBodG1sSW5Qb3J0cyA9IGdyb3VwRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tYXJyb3cuZG5fX2luY29taW5nLWFycm93Jyk7XHJcbiAgICBjb25zdCBodG1sSW5UcmlhbmdlbCA9IGh0bWxJblBvcnRzLnF1ZXJ5U2VsZWN0b3IoJy5kbi1hcnJvdy10cmlhbmdsZScpO1xyXG4gICAgY29uc3QgaW5Qb3J0SWQgPSBnZXRQb3J0SWQocm9vdE1vZGVsLmlkLCAnaW4nKTtcclxuICAgIGNvbnN0IGluY29taW5nTGlua3NNYXAgPSB0aGlzLm1vZGVsLmFjdGl2ZVBvcnRzW2luUG9ydElkXSB8fCB7fTtcclxuICAgIGNvbnN0IGFjdGl2ZUluTGlua3MgPSBPYmplY3Qua2V5cyhpbmNvbWluZ0xpbmtzTWFwKS5tYXAoa2V5ID0+IGluY29taW5nTGlua3NNYXBba2V5XSk7XHJcbiAgICBjb25zdCBpblBvcnRWaXNpYmxlID0gYWN0aXZlSW5MaW5rcy5sZW5ndGggPiAwICYmIHJvb3RNb2RlbCE9PSB0aGlzLm1vZGVsLm1vZGVsO1xyXG4gICAgY29uc3QgbmVlZEluQXJyb3cgPSBhY3RpdmVJbkxpbmtzICYmIGNoZWNrQXJyb3codGhpcy5tb2RlbCwgYWN0aXZlSW5MaW5rcyk7XHJcbiAgICBodG1sSW5Qb3J0cy5zdHlsZS5kaXNwbGF5ID0gaW5Qb3J0VmlzaWJsZSA/IG51bGwgOiAnbm9uZSc7XHJcbiAgICBodG1sSW5UcmlhbmdlbC5zdHlsZS5kaXNwbGF5ID0gbmVlZEluQXJyb3cgPyBudWxsIDogJ25vbmUnO1xyXG5cclxuICAgIGNvbnN0IGh0bWxPdXRQb3J0cyA9IGdyb3VwRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tYXJyb3cuZG5fX291dGdvaW5nLWFycm93Jyk7XHJcbiAgICBjb25zdCBodG1sT3V0VHJpYW5nZWwgPSBodG1sT3V0UG9ydHMucXVlcnlTZWxlY3RvcignLmRuLWFycm93LXRyaWFuZ2xlJyk7XHJcbiAgICBjb25zdCBvdXRQb3J0SWQgPSBnZXRQb3J0SWQocm9vdE1vZGVsLmlkLCAnb3V0Jyk7XHJcbiAgICBjb25zdCBvdXRnb2luZ0xpbmtzTWFwID0gdGhpcy5tb2RlbC5hY3RpdmVQb3J0c1tvdXRQb3J0SWRdIHx8IHt9O1xyXG4gICAgY29uc3QgYWN0aXZlT3V0TGlua3MgPSBPYmplY3Qua2V5cyhvdXRnb2luZ0xpbmtzTWFwKS5tYXAoa2V5ID0+IG91dGdvaW5nTGlua3NNYXBba2V5XSk7XHJcbiAgICBjb25zdCBuZWVkT3V0QXJyb3cgPSBhY3RpdmVPdXRMaW5rcyAmJiBjaGVja0Fycm93KHRoaXMubW9kZWwsIGFjdGl2ZU91dExpbmtzKTtcclxuICAgIGNvbnN0IG91dFBvcnRWaXNpYmxlID0gYWN0aXZlT3V0TGlua3MubGVuZ3RoID4gMCAmJiByb290TW9kZWwhPT0gdGhpcy5tb2RlbC5tb2RlbDtcclxuICAgIGh0bWxPdXRQb3J0cy5zdHlsZS5kaXNwbGF5ID0gb3V0UG9ydFZpc2libGUgPyBudWxsIDogJ25vbmUnO1xyXG4gICAgaHRtbE91dFRyaWFuZ2VsLnN0eWxlLmRpc3BsYXkgPSBuZWVkT3V0QXJyb3cgPyBudWxsIDogJ25vbmUnO1xyXG5cclxuICAgIGNvbnN0IGltZyA9IGdyb3VwRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tZ3JvdXBfaGVhZGVyIGltZycpO1xyXG4gICAgaW1nLmNsYXNzTmFtZSA9IHJvb3RNb2RlbC5jb2xsYXBzZWQgPyAnZG4tY29sbGFwc2VkJyA6ICcnO1xyXG5cclxuICAgIGNvbnN0IGxhYmVsID0gZ3JvdXBFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kbi1ncm91cF9oZWFkZXJfX2xhYmVsIGxhYmVsJyk7XHJcbiAgICBsYWJlbC5pbm5lckhUTUwgPSBnZXRDb2xvcmVkTGFiZWwocm9vdE1vZGVsLmxhYmVsLCB0aGlzLm1vZGVsLnNlYXJjaEtleSk7XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChyb290TW9kZWwsIGRlZXApIHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGNvbnN0IGljb24gPSByb290TW9kZWwuaWNvbiA/IGA8c3BhbiBjbGFzcz1cImRuLWhlYWRlci1pY29uXCI+PGkgY2xhc3M9XCIke3Jvb3RNb2RlbC5pY29ufVwiPjwvaT48L3NwYW4+YCA6ICcnO1xyXG5cclxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gYGRuLWVsZW1lbnQgZGVyaXZhdGlvbi1ub2RlX2VsZW1lbnRfJHtkZWVwfWA7XHJcbiAgICBlbGVtZW50LmlkID0gcm9vdE1vZGVsLmlkO1xyXG4gICAgZWxlbWVudC5vbmNsaWNrID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5maXJlQ2xpY2tFdmVudChldmVudCwgZWxlbWVudC5pZCk7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9O1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSBgXHJcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJkbi1hcnJvdyBkbl9faW5jb21pbmctYXJyb3dcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRuLWFycm93LXRyaWFuZ2xlXCI+PC9kaXY+XHJcbiAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkbi1lbGVtZW50X2NlbnRlclwiPlxyXG4gICAgICAgICAgICAke2ljb259XHJcbiAgICAgICAgICAgIDxsYWJlbCB0aXRsZT1cIiR7cm9vdE1vZGVsLmVuZHBvaW50SWQgKyAnKHR5cGU6ICcgKyByb290TW9kZWwudHlwZSArICcpJ31cIj5cclxuICAgICAgICAgICAgICAgICR7cm9vdE1vZGVsLmxhYmVsfVxyXG4gICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiZG4tYXJyb3cgZG5fX291dGdvaW5nLWFycm93XCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkbi1hcnJvdy10cmlhbmdsZVwiPjwvZGl2PlxyXG4gICAgICAgIDwvc3Bhbj5cclxuICAgIGA7XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fdXBkYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChyb290TW9kZWwpIHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnBhcnRzW3Jvb3RNb2RlbC5pZF07XHJcblxyXG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gcm9vdE1vZGVsLmludmlzaWJsZSA/ICdub25lJyA6IG51bGw7XHJcbiAgICBpZiAocm9vdE1vZGVsLmludmlzaWJsZSkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGh0bWxJblBvcnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tYXJyb3cuZG5fX2luY29taW5nLWFycm93Jyk7XHJcbiAgICBjb25zdCBodG1sSW5UcmlhbmdlbCA9IGh0bWxJblBvcnRzLnF1ZXJ5U2VsZWN0b3IoJy5kbi1hcnJvdy10cmlhbmdsZScpO1xyXG4gICAgY29uc3QgaW5Qb3J0SWQgPSBnZXRQb3J0SWQocm9vdE1vZGVsLmlkLCAnaW4nKTtcclxuICAgIGNvbnN0IGluY29taW5nTGlua3NNYXAgPSB0aGlzLm1vZGVsLmFjdGl2ZVBvcnRzW2luUG9ydElkXSB8fCB7fTtcclxuICAgIGNvbnN0IGFjdGl2ZUluTGlua3MgPSBPYmplY3Qua2V5cyhpbmNvbWluZ0xpbmtzTWFwKS5tYXAoa2V5ID0+IGluY29taW5nTGlua3NNYXBba2V5XSk7XHJcbiAgICBjb25zdCBpblBvcnRWaXNpYmxlID0gYWN0aXZlSW5MaW5rcy5sZW5ndGggPiAwICYmIHJvb3RNb2RlbCE9PSB0aGlzLm1vZGVsLm1vZGVsO1xyXG4gICAgY29uc3QgbmVlZEluQXJyb3cgPSBhY3RpdmVJbkxpbmtzICYmIGNoZWNrQXJyb3codGhpcy5tb2RlbCwgYWN0aXZlSW5MaW5rcyk7XHJcbiAgICBodG1sSW5Qb3J0cy5zdHlsZS5kaXNwbGF5ID0gaW5Qb3J0VmlzaWJsZSA/IG51bGwgOiAnbm9uZSc7XHJcbiAgICBodG1sSW5UcmlhbmdlbC5zdHlsZS5kaXNwbGF5ID0gbmVlZEluQXJyb3cgPyBudWxsIDogJ25vbmUnO1xyXG5cclxuICAgIGNvbnN0IGh0bWxPdXRQb3J0cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignLmRuLWFycm93LmRuX19vdXRnb2luZy1hcnJvdycpO1xyXG4gICAgY29uc3QgaHRtbE91dFRyaWFuZ2VsID0gaHRtbE91dFBvcnRzLnF1ZXJ5U2VsZWN0b3IoJy5kbi1hcnJvdy10cmlhbmdsZScpO1xyXG4gICAgY29uc3Qgb3V0UG9ydElkID0gZ2V0UG9ydElkKHJvb3RNb2RlbC5pZCwgJ291dCcpO1xyXG4gICAgY29uc3Qgb3V0Z29pbmdMaW5rc01hcCA9IHRoaXMubW9kZWwuYWN0aXZlUG9ydHNbb3V0UG9ydElkXSB8fCB7fTtcclxuICAgIGNvbnN0IGFjdGl2ZU91dExpbmtzID0gT2JqZWN0LmtleXMob3V0Z29pbmdMaW5rc01hcCkubWFwKGtleSA9PiBvdXRnb2luZ0xpbmtzTWFwW2tleV0pO1xyXG4gICAgY29uc3QgbmVlZE91dEFycm93ID0gYWN0aXZlT3V0TGlua3MgJiYgY2hlY2tBcnJvdyh0aGlzLm1vZGVsLCBhY3RpdmVPdXRMaW5rcyk7XHJcbiAgICBjb25zdCBvdXRQb3J0VmlzaWJsZSA9IGFjdGl2ZU91dExpbmtzLmxlbmd0aCA+IDAgJiYgcm9vdE1vZGVsIT09IHRoaXMubW9kZWwubW9kZWw7XHJcbiAgICBodG1sT3V0UG9ydHMuc3R5bGUuZGlzcGxheSA9IG91dFBvcnRWaXNpYmxlID8gbnVsbCA6ICdub25lJztcclxuICAgIGh0bWxPdXRUcmlhbmdlbC5zdHlsZS5kaXNwbGF5ID0gbmVlZE91dEFycm93ID8gbnVsbCA6ICdub25lJztcclxuXHJcbiAgICBjb25zdCBpc0hpZ2hsaWdodGVkID0gdGhpcy5tb2RlbC5oaWdobGlnaHRlZElkID09PSByb290TW9kZWwuaWQ7XHJcbiAgICBpZiAoaXNIaWdobGlnaHRlZCkge1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgndHEtZG0taGlnaGxpZ2h0ZWQnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCd0cS1kbS1oaWdobGlnaHRlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGxhYmVsID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tZWxlbWVudF9jZW50ZXIgbGFiZWwnKTtcclxuICAgIGxhYmVsLmlubmVySFRNTCA9IGdldENvbG9yZWRMYWJlbChyb290TW9kZWwubGFiZWwsIHRoaXMubW9kZWwuc2VhcmNoS2V5KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGdldENvbG9yZWRMYWJlbCAobGFiZWwsIGtleSkge1xyXG4gICAgaWYgKCFrZXkpIHJldHVybiBsYWJlbDtcclxuICAgIGNvbnN0IGxvd2VyQ2FzZUxhYmVsID0gbGFiZWwudG9Mb3dlckNhc2UoKTtcclxuICAgIGNvbnN0IGtleUluZGV4ID0gbG93ZXJDYXNlTGFiZWwuaW5kZXhPZihrZXkpO1xyXG5cclxuICAgIGlmIChrZXlJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm4gbGFiZWw7XHJcbiAgICB9IGVsc2UgaWYgKGtleUluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gbGFiZWwuc3Vic3RyaW5nKDAsIGtleS5sZW5ndGgpOyBcclxuICAgICAgICBjb25zdCBzZWNvbmRQYXJ0ID0gbGFiZWwuc3Vic3RyaW5nKGtleS5sZW5ndGgsIGxhYmVsLmxlbmd0aCk7IFxyXG4gICAgICAgIHJldHVybiBgPGkgY2xhc3M9XCJ0cS1kbS1oaWdobGlnaHRlZC1rZXlcIj4ke2ZpcnN0UGFydH08L2k+JHtzZWNvbmRQYXJ0fWA7XHJcbiAgICB9IGVsc2UgaWYgKGtleUluZGV4ICsga2V5Lmxlbmd0aCA9PT0gbGFiZWwubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gbGFiZWwuc3Vic3RyaW5nKDAsIGtleUluZGV4KTsgXHJcbiAgICAgICAgY29uc3Qgc2Vjb25kUGFydCA9IGxhYmVsLnN1YnN0cmluZyhrZXlJbmRleCwgbGFiZWwubGVuZ3RoKTsgXHJcbiAgICAgICAgcmV0dXJuIGAke2ZpcnN0UGFydH08aSBjbGFzcz1cInRxLWRtLWhpZ2hsaWdodGVkLWtleVwiPiR7c2Vjb25kUGFydH08L2k+YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gbGFiZWwuc3Vic3RyaW5nKDAsIGtleUluZGV4KTsgXHJcbiAgICAgICAgY29uc3Qgc2Vjb25kUGFydCA9IGxhYmVsLnN1YnN0cmluZyhrZXlJbmRleCwga2V5SW5kZXggKyBrZXkubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCB0aGlyZFBhcnQgPSBsYWJlbC5zdWJzdHJpbmcoa2V5SW5kZXggKyBrZXkubGVuZ3RoLCBsYWJlbC5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBgJHtmaXJzdFBhcnR9PGkgY2xhc3M9XCJ0cS1kbS1oaWdobGlnaHRlZC1rZXlcIj4ke3NlY29uZFBhcnR9PC9pPiR7dGhpcmRQYXJ0fWA7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBUaGUgR3JhcGhMaW5rVmlldyBjbGFzcy4gTWFpbmx5IGluIGNoYXJnZSBvZiBsaW5rIGhpZ2hsaWdodGluZy5cclxuICogTGlzdGVuIHRvIGV2ZW50cyBhbmQgYXBwbHkgaGlnaGxpZ2h0ZXJzLlxyXG4gKiBAY2xhc3NcclxuICogQGF1Z21lbnRzIGpvaW50LmRpYS5MaW5rVmlld1xyXG4gKiBAcGFyYW0ge05vZGVNb2RlbH0gZGF0YU1vZGVsIC0gTW9kZWwgb2YgZ3JhcGggbm9kZVxyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSBUaGUgc2V0IG9mIHBhcmFtZXRlcnNcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEdyYXBoTGlua1ZpZXcgKCkge1xyXG4gICAgam9pbnQuZGlhLkxpbmtWaWV3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuR3JhcGhMaW5rVmlldy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LmRpYS5MaW5rVmlldy5wcm90b3R5cGUpO1xyXG5HcmFwaExpbmtWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgam9pbnQuZGlhLkxpbmtWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2U6aGlnaGxpZ2h0ZWQgY2hhbmdlOmJsdXJlZCB1cGRhdGUtc3RhdGUnLCBvbkV2ZW50KTtcclxufTtcclxuXHJcbmNvbnN0IExHX0RNX0NFTExfSElHSExJR0hURVIgPSB7XHJcbiAgICBoaWdobGlnaHRlcjoge1xyXG4gICAgICAgIG5hbWU6ICdhZGRDbGFzcycsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBjbGFzc05hbWU6ICd0cS1kbS1oaWdobGlnaHRlZCdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IExHX0RNX0NFTExfQkxVUkVSID0ge1xyXG4gICAgaGlnaGxpZ2h0ZXI6IHtcclxuICAgICAgICBuYW1lOiAnYWRkQ2xhc3MnLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiAndHEtZG0tYmx1cmVkJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmNvbnN0IExHX0RNX0NFTExfSElEREVOID0ge1xyXG4gICAgaGlnaGxpZ2h0ZXI6IHtcclxuICAgICAgICBuYW1lOiAnYWRkQ2xhc3MnLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiAndHEtZG0taGlkZGVuJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIG9uRXZlbnQgKCkge1xyXG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdoaWdobGlnaHRlZCcpKSB7XHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHQobnVsbCwgTEdfRE1fQ0VMTF9ISUdITElHSFRFUik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudW5oaWdobGlnaHQobnVsbCwgTEdfRE1fQ0VMTF9ISUdITElHSFRFUik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2JsdXJlZCcpKSB7XHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHQobnVsbCwgTEdfRE1fQ0VMTF9CTFVSRVIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnVuaGlnaGxpZ2h0KG51bGwsIExHX0RNX0NFTExfQkxVUkVSKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm1vZGVsLmhpZGRlbikge1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0KG51bGwsIExHX0RNX0NFTExfSElEREVOKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy51bmhpZ2hsaWdodChudWxsLCBMR19ETV9DRUxMX0hJRERFTik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrQXJyb3cgKHNlbGYsIGxpbmtzKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbGluayA9IGxpbmtzW2ldO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChsaW5rLmdldCgndGFyZ2V0JykuaWQgPT09IHNlbGYuaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59IiwiaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuaW1wb3J0IHsgUmVzb3VyY2VQcm92aWRlciB9IGZyb20gJy4uLy4uL2RhdGEvcmVzb3VyY2VQcm92aWRlcic7XHJcbmltcG9ydCB7IFpfSU5ERVhFUyB9IGZyb20gJy4vZWxlbWVudHMnO1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEFzcGVjdExpbmtNb2RlbCAtIGRhdGEgbW9kZWwgb2YgYW4gQXNwZWN0TGluayBvYmplY3RcclxuICogQHR5cGVkZWYge09iamVjdH0gQXNwZWN0TGlua01vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZSB8IFRlcm1pbmF0aW9uTm9kZX0gdGFyZ2V0IC0gVGFyZ2V0IE5vZGVcclxuICogQHByb3BlcnR5IHtOb2RlIHwgVGVybWluYXRpb25Ob2RlfSBzb3VyY2UgLSBTb3VyY2UgTm9kZVxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIFRoZSBncmFwaCBMaW5rIGJhc2VkIG9uIGpvaW50LmRpYS5MaW5rLlxyXG4gKiBAY2xhc3NcclxuICogQGF1Z21lbnRzIGpvaW50LmRpYS5MaW5rXHJcbiAqIEBwYXJhbSB7QXNwZWN0TGlua01vZGVsfSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIFRoZSBzZXQgb2YgcGFyYW1ldGVyc1xyXG4gKiBAcHJvcGVydHkge1NpbXBsZUxpbmtNb2RlbH0gbW9kZWwgLSBEYXRhIG1vZGVsIFxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gQXNwZWN0TGluayAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgY29uc3QgX3JlcyA9IG5ldyBSZXNvdXJjZVByb3ZpZGVyKHBhcmFtZXRlcnMpO1xyXG5cclxuICAgIGNvbnN0IHNvdXJjZSA9IHsgaWQ6IG9wdGlvbnMuc291cmNlLmlkLCBwb3J0OiAnY2xpcFJlY3RQb3J0JyB9O1xyXG4gICAgY29uc3QgdGFyZ2V0ID0geyBpZDogb3B0aW9ucy50YXJnZXQuaWQsIHBvcnQ6ICdjbGlwUmVjdFBvcnQnIH07XHJcblxyXG4gICAgY29uc3QgbGlua0NvbG9yID0gX3Jlcy5nZXRDb2xvcignYXNwZWN0TGluaycpO1xyXG5cclxuICAgIGpvaW50LmRpYS5MaW5rLmFwcGx5KHNlbGYsIFt7XHJcbiAgICAgICAgaWQ6IG9wdGlvbnMuaWQsXHJcbiAgICAgICAgdHlwZTogJ2FzcGVjdC1saW5rJyxcclxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcclxuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICB6OiBaX0lOREVYRVMuQVNQRUNUX0xJTkssXHJcbiAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgJy5jb25uZWN0aW9uJzoge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5rQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICcxMCwgMTAnLFxyXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6ICc1cHgnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLm1hcmtlci1zb3VyY2UnOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBsaW5rQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IGxpbmtDb2xvcixcclxuICAgICAgICAgICAgICAgIGQ6ICdNMCwzYTMsMyAwIDEsMCA2LDBhMywzIDAgMSwwIC02LDAnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLm1hcmtlci10YXJnZXQnOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBsaW5rQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IGxpbmtDb2xvcixcclxuICAgICAgICAgICAgICAgIGQ6ICdNMCwzYTMsMyAwIDEsMCA2LDBhMywzIDAgMSwwIC02LDAnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gdmFyaWFudHMgZm9yIHRoZSBleHBlcmltZW50aW5nXHJcbiAgICAgICAgY29ubmVjdG9yOiB7bmFtZTogJ3JvdW5kZWQnIH0sXHJcbiAgICB9XSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCbHVycyB0aGUgQXNwZWN0TGluay5cclxuICAgICAqIEBtZW1iZXJvZiBBc3BlY3RMaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5ibHVyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBibHVyIGZyb20gdGhlIEFzcGVjdExpbmsuXHJcbiAgICAgKiBAbWVtYmVyb2YgQXNwZWN0TGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYudW5ibHVyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIHRoZSBBc3BlY3RMaW5rLlxyXG4gICAgICogQG1lbWJlcm9mIEFzcGVjdExpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3dzIHRoZSBBc3BlY3RMaW5rLlxyXG4gICAgICogQG1lbWJlcm9mIEFzcGVjdExpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZGRlbicsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5tb2RlbCA9IHsgc291cmNlOiBvcHRpb25zLnNvdXJjZS5pZCwgdGFyZ2V0OiBvcHRpb25zLnRhcmdldC5pZCB9O1xyXG59XHJcbkFzcGVjdExpbmsucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShqb2ludC5kaWEuTGluay5wcm90b3R5cGUpO1xyXG5cclxuIiwiaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5cclxuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vbm9kZSc7XHJcbmltcG9ydCB7IExpbmsgfSBmcm9tICcuL2xpbmsnO1xyXG5pbXBvcnQgeyBUZXJtaW5hdGlvbkxpbmsgfSBmcm9tICcuL3Rlcm1pbmF0aW9uTGluayc7XHJcbmltcG9ydCB7IFRlcm1pbmF0aW9uTm9kZSB9IGZyb20gJy4vdGVybWluYXRpb25Ob2RlJztcclxuaW1wb3J0IHsgQXNwZWN0TGluayB9IGZyb20gJy4vYXNwZWN0TGluayc7XHJcblxyXG5leHBvcnQgeyBOb2RlLCBMaW5rLCBUZXJtaW5hdGlvbk5vZGUsIFRlcm1pbmF0aW9uTGluaywgQXNwZWN0TGluayB9O1xyXG5cclxuY29uc3QgViA9IGpvaW50LlY7XHJcbmNvbnN0IGcgPSBqb2ludC5nO1xyXG5cclxuZXhwb3J0IGNvbnN0IFpfSU5ERVhFUyA9IHtcclxuICAgIEFTUEVDVF9MSU5LOiAyNSxcclxuICAgIFRFUk1JTkFUSU9OX0VMRU1FTlQ6IDI1LFxyXG4gICAgU0VMRUNURURfRUxFTUVOVDogMzAsXHJcbiAgICBOT0RFOiAyMCxcclxuICAgIExJTks6IDE1LFxyXG4gICAgQkxVUkVEX05PREU6IDEwLFxyXG4gICAgQkxVUkVEX0xJTks6IDUsXHJcbiAgICBWSUVXX0ZSQU1FOiAxLFxyXG59O1xyXG5cclxuY29uc3QgTEdfQ0VMTF9ISUdITElHSFRFUiA9IHtcclxuICAgIGhpZ2hsaWdodGVyOiB7XHJcbiAgICAgICAgbmFtZTogJ2FkZENsYXNzJyxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3RxLWxnLWhpZ2hsaWdodGVkJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3QgTEdfQ0VMTF9ISURERU4gPSB7XHJcbiAgICBoaWdobGlnaHRlcjoge1xyXG4gICAgICAgIG5hbWU6ICdhZGRDbGFzcycsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBjbGFzc05hbWU6ICd0cS1sZy1oaWRkZW4tZWxlbWVudCdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IExHX0NFTExfQkxVUkVSID0ge1xyXG4gICAgaGlnaGxpZ2h0ZXI6IHtcclxuICAgICAgICBuYW1lOiAnYWRkQ2xhc3MnLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiAndHEtbGctYmx1cmVkJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3QgTEdfU0hPUlRfTEFCRUwgPSB7XHJcbiAgICBoaWdobGlnaHRlcjoge1xyXG4gICAgICAgIG5hbWU6ICdhZGRDbGFzcycsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBjbGFzc05hbWU6ICd0cS1sZy1zaG9ydC1sYWJlbCdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IExHX0RSQUdHRURfTk9ERSA9IHtcclxuICAgIGhpZ2hsaWdodGVyOiB7XHJcbiAgICAgICAgbmFtZTogJ2FkZENsYXNzJyxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3RxLWxnLWRyYWdnZWQtbm9kZSdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRDbGFzcyAoKSB7XHJcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2hpZ2hsaWdodGVkJykpIHtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodChudWxsLCBMR19DRUxMX0hJR0hMSUdIVEVSKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy51bmhpZ2hsaWdodChudWxsLCBMR19DRUxMX0hJR0hMSUdIVEVSKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnYmx1cmVkJykpIHtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodChudWxsLCBMR19DRUxMX0JMVVJFUik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudW5oaWdobGlnaHQobnVsbCwgTEdfQ0VMTF9CTFVSRVIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdoaWRkZW4nKSkge1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0KG51bGwsIExHX0NFTExfSElEREVOKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy51bmhpZ2hsaWdodChudWxsLCBMR19DRUxMX0hJRERFTik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ3Nob3J0LWxhYmVsJykpIHtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodChudWxsLCBMR19TSE9SVF9MQUJFTCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudW5oaWdobGlnaHQobnVsbCwgTEdfU0hPUlRfTEFCRUwpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdkcmFnZ2VkJykpIHtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodChudWxsLCBMR19EUkFHR0VEX05PREUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnVuaGlnaGxpZ2h0KG51bGwsIExHX0RSQUdHRURfTk9ERSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBUaGUgTGlua1ZpZXcgY2xhc3MuIE1haW5seSBpbiBjaGFyZ2Ugb2Ygbm9kZSBoaWdobGlnaHRpbmcuXHJcbiAqIExpc3RlbiB0byBldmVudHMgYW5kIGFwcGx5IGhpZ2hsaWdodGVycy5cclxuICogQGNsYXNzXHJcbiAqIEBhdWdtZW50cyBqb2ludC5kaWEuTGlua1ZpZXdcclxuICogQHBhcmFtIHtOb2RlTW9kZWx9IGRhdGFNb2RlbCAtIE1vZGVsIG9mIGdyYXBoIG5vZGVcclxuICogQHBhcmFtIHt2ZXJ9IHBhcmFtZXRlcnMgLSBUaGUgc2V0IG9mIHBhcmFtZXRlcnNcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE5vZGVWaWV3ICgpIHtcclxuICAgIGpvaW50LmRpYS5FbGVtZW50Vmlldy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcbk5vZGVWaWV3LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoam9pbnQuZGlhLkVsZW1lbnRWaWV3LnByb3RvdHlwZSk7XHJcbk5vZGVWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgam9pbnQuZGlhLkVsZW1lbnRWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFtcclxuICAgICAgICAnY2hhbmdlOmRyYWdnZWQnLFxyXG4gICAgICAgICdjaGFuZ2U6aGlnaGxpZ2h0ZWQnLFxyXG4gICAgICAgICdjaGFuZ2U6Ymx1cmVkJyxcclxuICAgICAgICAnY2hhbmdlOmhpZGRlbicsXHJcbiAgICAgICAgJ3JlZnJlc2gtaGlnaGxpZ2h0aW5nJyxcclxuICAgICAgICAnY2hhbmdlOnNob3J0LWxhYmVsJ1xyXG4gICAgXS5qb2luKCcgJyksIHRoaXMuZGVib3VuY2VkSGlnaGxpZ2h0aW5nKTtcclxufTtcclxuTm9kZVZpZXcucHJvdG90eXBlLmRlYm91bmNlcjtcclxuTm9kZVZpZXcucHJvdG90eXBlLmRlYm91bmNlZEhpZ2hsaWdodGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVib3VuY2VyKTtcclxuICAgIHRoaXMuZGVib3VuY2VyID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICBnZXRDbGFzcy5jYWxsKHRoaXMpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIFRoZSBMaW5rVmlldyBjbGFzcy4gTWFpbmx5IGluIGNoYXJnZSBvZiBsaW5rIGhpZ2hsaWdodGluZy5cclxuICogTGlzdGVuIHRvIGV2ZW50cyBhbmQgYXBwbHkgaGlnaGxpZ2h0ZXJzLlxyXG4gKiBAY2xhc3NcclxuICogQGF1Z21lbnRzIGpvaW50LmRpYS5MaW5rVmlld1xyXG4gKiBAcGFyYW0ge05vZGVNb2RlbH0gZGF0YU1vZGVsIC0gTW9kZWwgb2YgZ3JhcGggbm9kZVxyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSBUaGUgc2V0IG9mIHBhcmFtZXRlcnNcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIExpbmtWaWV3ICgpIHtcclxuICAgIGpvaW50LmRpYS5MaW5rVmlldy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcbkxpbmtWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBqb2ludC5kaWEuTGlua1ZpZXcucHJvdG90eXBlLnJlbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5MaW5rVmlldy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LmRpYS5MaW5rVmlldy5wcm90b3R5cGUpO1xyXG5MaW5rVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGpvaW50LmRpYS5MaW5rVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFtcclxuICAgICAgICAnY2hhbmdlOmhpZ2hsaWdodGVkJyxcclxuICAgICAgICAnY2hhbmdlOmJsdXJlZCcsXHJcbiAgICAgICAgJ2NoYW5nZTpoaWRkZW4nLFxyXG4gICAgICAgICdyZWZyZXNoLWhpZ2hsaWdodGluZycsXHJcbiAgICBdLmpvaW4oJyAnKSwgdGhpcy5kZWJvdW5jZWRIaWdobGlnaHRpbmcpO1xyXG59O1xyXG5MaW5rVmlldy5wcm90b3R5cGUuZ2V0UG9pbnRBdExlbmd0aCA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fVi5jb25uZWN0aW9uLm5vZGUuZ2V0UG9pbnRBdExlbmd0aCh0aGlzLl9WLmNvbm5lY3Rpb24ubm9kZS5nZXRUb3RhbExlbmd0aCgpICogayk7XHJcbn07XHJcbkxpbmtWaWV3LnByb3RvdHlwZS5kZWJvdW5jZXI7XHJcbkxpbmtWaWV3LnByb3RvdHlwZS5kZWJvdW5jZWRIaWdobGlnaHRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlYm91bmNlcik7XHJcbiAgICB0aGlzLmRlYm91bmNlciA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgZ2V0Q2xhc3MuY2FsbCh0aGlzKTtcclxuICAgIH0pO1xyXG59O1xyXG5MaW5rVmlldy5wcm90b3R5cGUudXBkYXRlVG9vbHNQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBpZiAoIXRoaXMuX1YubGlua1Rvb2xzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAvLyBNb3ZlIHRoZSB0b29scyBhIGJpdCB0byB0aGUgdGFyZ2V0IHBvc2l0aW9uIGJ1dCBkb24ndCBjb3ZlciB0aGUgYHNvdXJjZUFycm93aGVhZGAgbWFya2VyLlxyXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBvZmZzZXQgaXMgaGFyZGNvZGVkIGhlcmUuIFRoZSBvZmZzZXQgc2hvdWxkIGJlIGFsd2F5c1xyXG4gICAgLy8gbW9yZSB0aGFuIHRoZSBgdGhpcy4kKCcubWFya2VyLWFycm93aGVhZFtlbmQ9XCJzb3VyY2VcIl0nKVswXS5iYm94KCkud2lkdGhgIGJ1dCBsb29raW5nXHJcbiAgICAvLyB0aGlzIHVwIGFsbCB0aGUgdGltZSB3b3VsZCBiZSBzbG93LlxyXG5cclxuICAgIGxldCBzY2FsZSA9ICcnO1xyXG4gICAgY29uc3QgY29ubmVjdGlvbkxlbmd0aCA9IHRoaXMuZ2V0Q29ubmVjdGlvbkxlbmd0aCgpO1xyXG5cclxuICAgIC8vIEZpcmVmb3ggcmV0dXJucyBjb25uZWN0aW9uTGVuZ3RoPU5hTiBpbiBvZGQgY2FzZXMgKGZvciBiZXppZXIgY3VydmVzKS5cclxuICAgIC8vIEluIHRoYXQgY2FzZSB3ZSB3b24ndCB1cGRhdGUgdG9vbHMgcG9zaXRpb24gYXQgYWxsLlxyXG4gICAgaWYgKCFfLmlzTmFOKGNvbm5lY3Rpb25MZW5ndGgpKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBsaW5rIGlzIHRvbyBzaG9ydCwgbWFrZSB0aGUgdG9vbHMgaGFsZiB0aGUgc2l6ZSBhbmQgdGhlIG9mZnNldCB0d2ljZSBhcyBsb3cuXHJcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25MZW5ndGggPCB0aGlzLm9wdGlvbnMuc2hvcnRMaW5rTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gJ3NjYWxlKC41KSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl90b29sQ2FjaGUuZm9yRWFjaCgodG9vbCwgaW5kZXgsIGFycikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICBjb25zdCBsID0gYXJyLmxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgIGNvbnN0IGsgPSBpIC8gbDtcclxuICAgICAgICAgICAgY29uc3QgdG9vbFBvc2l0aW9uID0gdGhpcy5nZXRQb2ludEF0TGVuZ3RoKGspO1xyXG4gICAgICAgICAgICBpZiAodG9vbC5ub2RlIGluc3RhbmNlb2YgU1ZHR0VsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRvb2wuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgdG9vbFBvc2l0aW9uLnggKyAnLCAnICsgdG9vbFBvc2l0aW9uLnkgKyAnKSAnICsgc2NhbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG91YmxlTGlua1Rvb2xzICYmIGNvbm5lY3Rpb25MZW5ndGggPj0gdGhpcy5vcHRpb25zLmxvbmdMaW5rTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLmdldFBvaW50QXRMZW5ndGgoayAvKmNvbm5lY3Rpb25MZW5ndGggLSBkb3VibGVMaW5rVG9vbHNPZmZzZXQqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbDJDYWNoZS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBuZXdQb3NpdGlvbi54ICsgJywgJyArIG5ld1Bvc2l0aW9uLnkgKyAnKSAnICsgc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2wyQ2FjaGUuYXR0cigndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5kb3VibGVMaW5rVG9vbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sMkNhY2hlLmF0dHIoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkxpbmtWaWV3LnByb3RvdHlwZS5yZW5kZXJUb29scyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBpZiAoIXRoaXMuX1YubGlua1Rvb2xzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAvLyBUb29scyBhcmUgYSBncm91cCBvZiBjbGlja2FibGUgZWxlbWVudHMgdGhhdCBtYW5pcHVsYXRlIHRoZSB3aG9sZSBsaW5rLlxyXG4gICAgLy8gQSBnb29kIGV4YW1wbGUgb2YgdGhpcyBpcyB0aGUgcmVtb3ZlIHRvb2wgdGhhdCByZW1vdmVzIHRoZSB3aG9sZSBsaW5rLlxyXG4gICAgLy8gVG9vbHMgYXBwZWFyIGFmdGVyIGhvdmVyaW5nIHRoZSBsaW5rIGNsb3NlIHRvIHRoZSBgc291cmNlYCBlbGVtZW50L3BvaW50IG9mIHRoZSBsaW5rXHJcbiAgICAvLyBidXQgYXJlIG9mZnNldCBhIGJpdCBzbyB0aGF0IHRoZXkgZG9uJ3QgY292ZXIgdGhlIGBtYXJrZXItYXJyb3doZWFkYC5cclxuXHJcbiAgICB2YXIgaHRtbFRvb2xzID0gdGhpcy5fVi5saW5rVG9vbHMubm9kZTtcclxuICAgIHZhciB0b29sVGVtcGxhdGUgPSBqb2ludC51dGlsLnRlbXBsYXRlKHRoaXMubW9kZWwuZ2V0KCd0b29sTWFya3VwJykgfHwgdGhpcy5tb2RlbC50b29sTWFya3VwKTtcclxuICAgIHZhciB2VG9vbHMgPSBWKHRvb2xUZW1wbGF0ZSgpKTtcclxuXHJcbiAgICB2YXIgdG9vbHM7XHJcbiAgICBpZiAodlRvb2xzIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICB0b29scyA9IHZUb29scztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdG9vbHMgPSBbdlRvb2xzXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdG9vbHMuZm9yRWFjaCh0b29sID0+IHtcclxuICAgICAgICBodG1sVG9vbHMuYXBwZW5kQ2hpbGQodG9vbC5ub2RlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENhY2hlIHRoZSB0b29sIG5vZGUgc28gdGhhdCB0aGUgYHVwZGF0ZVRvb2xzUG9zaXRpb24oKWAgY2FuIHVwZGF0ZSB0aGUgdG9vbCBwb3NpdGlvbiBxdWlja2x5LlxyXG4gICAgdGhpcy5fdG9vbENhY2hlID0gdG9vbHM7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5jb25zdCBvdmVycmlkZWRGdW5jdGlvbiA9IExpbmtWaWV3LnByb3RvdHlwZS5nZXRDb25uZWN0aW9uUG9pbnQ7XHJcbkxpbmtWaWV3LnByb3RvdHlwZS5nZXRDb25uZWN0aW9uUG9pbnQgPSBmdW5jdGlvbiAoZW5kLCBzZWxlY3Rvck9yUG9pbnQsIHJlZmVyZW5jZVNlbGVjdG9yT3JQb2ludCkge1xyXG4gICAgbGV0IGNvbm5lY3Rpb25Qb2ludCA9IG92ZXJyaWRlZEZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgbGV0IGxpbWl0Qm94O1xyXG4gICAgXy5pc0VtcHR5KHNlbGVjdG9yT3JQb2ludCkgJiYgKHNlbGVjdG9yT3JQb2ludCA9IHsgeDogMCwgeTogMCB9KTtcclxuICAgIF8uaXNFbXB0eShyZWZlcmVuY2VTZWxlY3Rvck9yUG9pbnQpICYmIChyZWZlcmVuY2VTZWxlY3Rvck9yUG9pbnQgPSB7IHg6IDAsIHk6IDAgfSk7XHJcblxyXG4gICAgaWYgKCFzZWxlY3Rvck9yUG9pbnQuaWQpIHtcclxuICAgICAgICBjb25zdCBwb2ludCA9IGcucG9pbnQoc2VsZWN0b3JPclBvaW50KTtcclxuICAgICAgICBsaW1pdEJveCA9IHtcclxuICAgICAgICAgICAgeDogcG9pbnQueCxcclxuICAgICAgICAgICAgeTogcG9pbnQueSxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMCxcclxuICAgICAgICAgICAgY2VudGVyOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBsaW1pdEJveCA9IChlbmQgPT09ICdzb3VyY2UnID8gdGhpcy5zb3VyY2VCQm94IDogdGhpcy50YXJnZXRCQm94KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxpbWl0Q2V0ZXIgPSBsaW1pdEJveC5jZW50ZXIoKTtcclxuXHJcbiAgICBjb25zdCByaWdodEJvcmRlciA9IE1hdGgucm91bmQobGltaXRDZXRlci54ICsgbGltaXRCb3gud2lkdGggLyAyKTtcclxuICAgIGNvbnN0IGxlZnRCb3JkZXIgPSBNYXRoLnJvdW5kKGxpbWl0Q2V0ZXIueCAtIGxpbWl0Qm94LndpZHRoIC8gMik7XHJcbiAgICBjb25zdCBib3R0b21Cb3JkZXIgPSBNYXRoLnJvdW5kKGxpbWl0Q2V0ZXIueSArIGxpbWl0Qm94LmhlaWdodCAvIDIpO1xyXG4gICAgY29uc3QgdG9wQm9yZGVyID0gTWF0aC5yb3VuZChsaW1pdENldGVyLnkgLSBsaW1pdEJveC5oZWlnaHQgLyAyKTtcclxuXHJcbiAgICBjb25zdCB4SW5zaWRlID0gbGVmdEJvcmRlciA8IGNvbm5lY3Rpb25Qb2ludC54ICYmIGNvbm5lY3Rpb25Qb2ludC54IDwgcmlnaHRCb3JkZXI7XHJcbiAgICBjb25zdCB5SW5zaWRlID0gdG9wQm9yZGVyIDwgY29ubmVjdGlvblBvaW50LnkgJiYgY29ubmVjdGlvblBvaW50LnkgPCBib3R0b21Cb3JkZXI7XHJcbiAgICBjb25zdCBpc0luVGhlQm9keSA9IHhJbnNpZGUgJiYgeUluc2lkZTtcclxuXHJcbiAgICBpZiAoaXNJblRoZUJvZHkpIHtcclxuICAgICAgICBjb25zdCByaWdodERpc3QgPSByaWdodEJvcmRlciAtIGNvbm5lY3Rpb25Qb2ludC54O1xyXG4gICAgICAgIGNvbnN0IGxlZnREaXN0ID0gY29ubmVjdGlvblBvaW50LnggLSBsZWZ0Qm9yZGVyO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbURpc3QgPSBib3R0b21Cb3JkZXIgLSBjb25uZWN0aW9uUG9pbnQueTtcclxuICAgICAgICBjb25zdCB0b3BEaXN0ID0gY29ubmVjdGlvblBvaW50LnkgLSB0b3BCb3JkZXI7XHJcblxyXG4gICAgICAgIGNvbnN0IG1pbkRpc3QgPSBNYXRoLm1pbihyaWdodERpc3QsIGxlZnREaXN0LCBib3R0b21EaXN0LCB0b3BEaXN0KTtcclxuXHJcbiAgICAgICAgaWYgKHJpZ2h0RGlzdCA9PT0gbWluRGlzdCkge1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uUG9pbnQub2Zmc2V0KHJpZ2h0RGlzdCwgMCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsZWZ0RGlzdCA9PT0gbWluRGlzdCkge1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uUG9pbnQub2Zmc2V0KC1sZWZ0RGlzdCwgMCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0b3BEaXN0ID09PSBtaW5EaXN0KSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Qb2ludC5vZmZzZXQoMCwgLXRvcERpc3QpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYm90dG9tRGlzdCA9PT0gbWluRGlzdCkge1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uUG9pbnQub2Zmc2V0KDAsIGJvdHRvbURpc3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgcmVmZXJlbmNlO1xyXG4gICAgdmFyIHNwb3RCYm94ID0gZW5kID09PSAnc291cmNlJyA/IHRoaXMuc291cmNlQkJveCA6IHRoaXMudGFyZ2V0QkJveDtcclxuICAgIGlmICghcmVmZXJlbmNlU2VsZWN0b3JPclBvaW50LmlkKSB7XHJcbiAgICAgICAgcmVmZXJlbmNlID0gZy5wb2ludChyZWZlcmVuY2VTZWxlY3Rvck9yUG9pbnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCByZWZlcmVuY2VCYm94ID0gZW5kID09PSAnc291cmNlJyA/IHRoaXMudGFyZ2V0QkJveCA6IHRoaXMuc291cmNlQkJveDtcclxuXHJcbiAgICAgICAgcmVmZXJlbmNlID0gZy5yZWN0KHJlZmVyZW5jZUJib3gpLmludGVyc2VjdGlvbldpdGhMaW5lRnJvbUNlbnRlclRvUG9pbnQoZy5yZWN0KHNwb3RCYm94KS5jZW50ZXIoKSk7XHJcbiAgICAgICAgcmVmZXJlbmNlID0gcmVmZXJlbmNlIHx8IGcucmVjdChyZWZlcmVuY2VCYm94KS5jZW50ZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhbGlnblggPSBNYXRoLmFicyhyZWZlcmVuY2UueCAtIGNvbm5lY3Rpb25Qb2ludC54KTtcclxuICAgIGNvbnN0IGFsaWduWSA9IE1hdGguYWJzKHJlZmVyZW5jZS55IC0gY29ubmVjdGlvblBvaW50LnkpO1xyXG5cclxuICAgIGNvbnN0IHJvdXRlcklkID0gdGhpcy5tb2RlbC5nZXQoJ3JvdXRlcicpICYmIHRoaXMubW9kZWwuZ2V0KCdyb3V0ZXInKS5uYW1lO1xyXG4gICAgY29uc3Qgc3BlY2lhbFJvdXRlciA9IHJvdXRlcklkICYmIChyb3V0ZXJJZCA9PT0gJ2xncm91dGVyJyB8fCByb3V0ZXJJZCA9PT0gJ21ldHJvJyk7XHJcbiAgICBpZiAodGhpcy5tb2RlbCBpbnN0YW5jZW9mIExpbmsgJiYgc3BlY2lhbFJvdXRlcikge1xyXG4gICAgICAgIGlmIChhbGlnblggPD0gYWxpZ25ZKSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Qb2ludC5vZmZzZXQocmVmZXJlbmNlLnggLSBjb25uZWN0aW9uUG9pbnQueCwgMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29ubmVjdGlvblBvaW50Lm9mZnNldCgwLCByZWZlcmVuY2UueSAtIGNvbm5lY3Rpb25Qb2ludC55KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29ubmVjdGlvblBvaW50ID0gZy5wb2ludCh7XHJcbiAgICAgICAgeDogTWF0aC5tYXgoTWF0aC5taW4oTWF0aC5yb3VuZChjb25uZWN0aW9uUG9pbnQueCksIHJpZ2h0Qm9yZGVyKSwgbGVmdEJvcmRlciksXHJcbiAgICAgICAgeTogTWF0aC5tYXgoTWF0aC5taW4oTWF0aC5yb3VuZChjb25uZWN0aW9uUG9pbnQueSksIGJvdHRvbUJvcmRlciksIHRvcEJvcmRlciksXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gY29ubmVjdGlvblBvaW50O1xyXG59OyIsImltcG9ydCAqIGFzIGpvaW50IGZyb20gJ3JhcHBpZCc7XHJcbmltcG9ydCB7IFJlc291cmNlUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9kYXRhL3Jlc291cmNlUHJvdmlkZXInO1xyXG5pbXBvcnQgeyBaX0lOREVYRVMgfSBmcm9tICcuL2VsZW1lbnRzJztcclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0xJTktfVFlQRSA9ICdsaW5lYWdlLWdyYW0tbGluayc7XHJcbmV4cG9ydCBjb25zdCBBTFdBWVNfVklTSUJMRV9UT09MX0JVVFRPTlM9ICdsZy12aXNpYmxlLXRvb2wtYnV0dG9ucyc7XHJcblxyXG4vKipcclxuICogTGlua01vZGVsIC0gZGF0YSBtb2RlbCBmb3IgYSB7QGxpbmsgTGlua30gb2JqZWN0XHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExpbmtNb2RlbFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBMaW5rIGlkZW50aWZ5ZXJcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRhcmdldCAtIFRhcmdldCBOb2RlIGlkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBTb3VyY2UgTm9kZSBpZFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGlua3R5cGUgLSBUeXBlIG9mIHRoZSBMaW5rXHJcbiovXHJcblxyXG4vKipcclxuICogVGhlIGdyYXBoIExpbmsgY2xhc3Mgd2hpY2ggaXMgIGJhc2VkIG9uIGpvaW50LmRpYS5MaW5rLiBJcyB0aGUgb25lIG9mIHRoZSBtYWluIGVsZW1lbnRzIG9mIHRoZSBMaW5lYWdlRnJhbS5cclxuICogUmVwcmVzZW50cyBleGlzdGluZyByZWxhdGlvbiBvZiB0aGUgcGFydHMgb2YgdGhlIGRhdGFzZXQuICBIYXMgc3BlY2lmaWMgdHlwZSBhbmQgaWQuXHJcbiAqIEBjbGFzc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAYXVnbWVudHMgam9pbnQuZGlhLkxpbmtcclxuICogXHJcbiAqIEBwYXJhbSB7TGlua01vZGVsfSBkYXRhTW9kZWwgLSBEYXRhIG1vZGVsXHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIFRoZSBzZXQgb2YgcGFyYW1ldGVyc1xyXG4gKiBcclxuICogQHByb3BlcnR5IHtMaW5rTW9kZWx9IG1vZGVsIC0gRGF0YSBtb2RlbFxyXG4gKiBAcHJvcGVydHkge1Rlcm1pbmF0aW9uTGlua30gdGVybWluYXRpb25MaW5rIC0gVGVybWluYXRpb24gbGluayB3aGljaFxyXG4gKiByZXByZXNlbnRzIHRoaXMgbGluaywgd2hlbiB0aGUgbm9kZSBpcyBvdXQgb2YgdGhlIHZpZXdGcmFtZVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhpZ2hsaWdodGVkIC0gVGVsbHMgd2hldGVyIGhpZ2hsaWdodGVkIGxpbmsgb3Igbm90ICh1c2UgbWV0aG9kIGdldCB0byBnZXQgdGhpcyBwcm9wZXJ0eSwgZS5nLiBsaW5rLmdldCgnaGlnaGxpZ2h0ZWQnKSlcclxuICogQHByb3BlcnR5IHtib29sZWFufSBibHVyZWQgLSBUZWxscyB3aGV0ZXIgYmx1cmVkIGxpbmsgb3Igbm90ICh1c2UgbWV0aG9kIGdldCB0byBnZXQgdGhpcyBwcm9wZXJ0eSwgZS5nLiBsaW5rLmdldCgnYmx1cmVkJykpXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBMaW5rIChkYXRhTW9kZWwsIHBhcmFtZXRlcnMpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIGNvbnN0IF9yZXMgPSBuZXcgUmVzb3VyY2VQcm92aWRlcihwYXJhbWV0ZXJzKTtcclxuXHJcbiAgICBzZWxmLnRlcm1pbmF0aW9uTGlua3MgPSBbXTtcclxuICAgIHNlbGYuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcclxuICAgIHNlbGYuYmx1cmVkID0gZmFsc2U7XHJcbiAgICBcclxuICAgIGxldCBfbGlua1N0eWxlO1xyXG4gICAgbGV0IF90b29sTWFya3VwO1xyXG4gICAgaWYgKGRhdGFNb2RlbC5ncm91cCkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0ZWRUeXBlSWRzID0gW107XHJcbiAgICAgICAgY29uc3QgZ3JvdXBUb29scyA9IGRhdGFNb2RlbC5ncm91cFxyXG4gICAgICAgICAgICAuZmlsdGVyKG1vZGVsID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlY2lzaW9uID0gZXhpc3RlZFR5cGVJZHMuaW5kZXhPZihtb2RlbC5saW5rVHlwZSkgPT09IC0xO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlY2lzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RlZFR5cGVJZHMucHVzaChtb2RlbC5saW5rVHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjaXNpb247XHJcbiAgICAgICAgICAgIH0pLm1hcChtb2RlbCA9PiAoe1xyXG4gICAgICAgICAgICAgICAgbGlua1R5cGU6IG1vZGVsLmxpbmtUeXBlLFxyXG4gICAgICAgICAgICAgICAgbGlua1N0eWxlOiBfcmVzLmdldExpbmtTdHlsZShtb2RlbC5saW5rVHlwZSksXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgaWYgKGdyb3VwVG9vbHMubGVuZ3RoID09PSAxKSBfbGlua1N0eWxlID0gZ3JvdXBUb29sc1swXS5saW5rU3R5bGU7XHJcbiAgICAgICAgZWxzZSBfbGlua1N0eWxlID0gX3Jlcy5nZXRMaW5rU3R5bGUoZGF0YU1vZGVsLmxpbmtUeXBlKTsgXHJcbiAgICAgICAgX3Rvb2xNYXJrdXAgPSBfZ2V0VG9vbE1hcmt1cChncm91cFRvb2xzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX2xpbmtTdHlsZSA9IF9yZXMuZ2V0TGlua1N0eWxlKGRhdGFNb2RlbC5saW5rVHlwZSk7IFxyXG4gICAgICAgIF90b29sTWFya3VwID0gX2dldFRvb2xNYXJrdXAoW3tcclxuICAgICAgICAgICAgbGlua1R5cGU6IGRhdGFNb2RlbC5saW5rVHlwZSxcclxuICAgICAgICAgICAgbGlua1N0eWxlOiBfbGlua1N0eWxlLFxyXG4gICAgICAgIH1dKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgdHlwZXMgPSBbREVGQVVMVF9MSU5LX1RZUEVdO1xyXG4gICAgaWYgKF9saW5rU3R5bGUuY3NzQ2xhc3MgJiYgX2xpbmtTdHlsZS5jc3NDbGFzcyAhPT0gREVGQVVMVF9MSU5LX1RZUEUpIHtcclxuICAgICAgICB0eXBlcy5wdXNoKF9saW5rU3R5bGUuY3NzQ2xhc3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChfbGlua1N0eWxlLnRvb2xCdXR0b24uYWx3YXlzVmlzaWJsZSkge1xyXG4gICAgICAgIHR5cGVzLnB1c2goQUxXQVlTX1ZJU0lCTEVfVE9PTF9CVVRUT05TKTtcclxuICAgIH1cclxuXHJcbiAgICBqb2ludC5kaWEuTGluay5hcHBseShzZWxmLCBbe1xyXG4gICAgICAgIHR5cGU6IHR5cGVzLmpvaW4oJyAnKSxcclxuICAgICAgICBzb3VyY2U6IHsgaWQ6IGRhdGFNb2RlbC5zb3VyY2UsIHBvcnQ6ICdjbGlwUmVjdFBvcnQnIH0sXHJcbiAgICAgICAgdGFyZ2V0OiB7IGlkOiBkYXRhTW9kZWwudGFyZ2V0LCBwb3J0OiAnY2xpcFJlY3RQb3J0JyB9LFxyXG4gICAgICAgIHo6IFpfSU5ERVhFUy5MSU5LLFxyXG4gICAgICAgIGF0dHJzOiBfZ2V0TGlua0F0dHJpYnV0ZXMoX2xpbmtTdHlsZSksXHJcbiAgICAgICAgY29ubmVjdG9yOiB7bmFtZTogJ3JvdW5kZWQnIH0sXHJcbiAgICAgICAgLy8gY29ubmVjdG9yOiB7IG5hbWU6ICdqdW1wb3ZlcicsIGFyZ3M6IHsgdHlwZTogJ2dhcCcgfX0sXHJcbiAgICAgICAgcm91dGVyOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IGRhdGFNb2RlbC5yb3V0aW5nLFxyXG4gICAgICAgICAgICBhcmdzOiB7XHJcbiAgICAgICAgICAgICAgICBleGNsdWRlVHlwZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAndmlld0ZyYW1lJyxcclxuICAgICAgICAgICAgICAgICAgICAndGVybWluYXRpb25MaW5rJyxcclxuICAgICAgICAgICAgICAgICAgICAndGVybWluYXRpb25Ob2RlJyxcclxuICAgICAgICAgICAgICAgICAgICAndmlldy1mcmFtZS1zcGxpdHRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3ZpZXctZnJhbWUtc3BsaXR0ZXItdmVydGljYWwnLFxyXG4gICAgICAgICAgICAgICAgICAgICdhc3BlY3RMaW5rJyxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBtYXhpbXVtTG9vcHM6IDMwMDAsXHJcbiAgICAgICAgICAgICAgICBtYXhBbGxvd2VkRGlyZWN0aW9uQ2hhbmdlOiAzMDAwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9vbE1hcmt1cDogX3Rvb2xNYXJrdXAsXHJcbiAgICB9XSk7XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldExpbmtBdHRyaWJ1dGVzIChsaW5rU3R5bGUpIHtcclxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XHJcbiAgICAgICAgYXR0cmlidXRlc1snLmNvbm5lY3Rpb24nXSA9IHtcclxuICAgICAgICAgICAgc3Ryb2tlOiBsaW5rU3R5bGUuY29sb3IsXHJcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBsaW5rU3R5bGUudGhpY2tuZXNzLFxyXG4gICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IGxpbmtTdHlsZS5saW5lVHlwZSA9PT0gJ3NvbGlkJyA/IHVuZGVmaW5lZCA6ICc1LDUnLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGxpbmtTdHlsZS5oYXNBcnJvdykge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzWycubWFya2VyLXNvdXJjZSddID0ge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogbGlua1N0eWxlLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5rU3R5bGUuY29sb3IsXHJcbiAgICAgICAgICAgICAgICBkOiAnTTAsM2EzLDMgMCAxLDAgNiwwYTMsMyAwIDEsMCAtNiwwJyxcclxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBsaW5rU3R5bGUudGhpY2tuZXNzLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzWycubWFya2VyLXRhcmdldCddID0ge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogbGlua1N0eWxlLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5rU3R5bGUuY29sb3IsXHJcbiAgICAgICAgICAgICAgICBkOiAnTSAxMCAwIEwgMCA1IEwgMTAgMTAgeicsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogbGlua1N0eWxlLnRoaWNrbmVzcyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldFRvb2xNYXJrdXAgKGxpbmtUb29scykge1xyXG4gICAgICAgIHJldHVybiBsaW5rVG9vbHMubWFwKGxpbmtUb29sID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbGlua1R5cGVJZCA9IGxpbmtUb29sLmxpbmtUeXBlO1xyXG4gICAgICAgICAgICBjb25zdCB0b29sID0gbGlua1Rvb2wubGlua1N0eWxlLnRvb2xCdXR0b247XHJcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdG9vbC53aWR0aCB8fCAzMDtcclxuICAgICAgICAgICAgY29uc3QgaGllZ2h0ID0gdG9vbC5oaWVnaHQgfHwgMzA7XHJcbiAgICAgICAgICAgIHJldHVybiBgPGcgY2xhc3M9XCJsaW5rLXRvb2xcIj5cclxuICAgICAgICAgICAgICAgIDxnIGNsYXNzPVwidG9vbC1vcHRpb25zXCIgZXZlbnQ9XCJsaW5rOm9wdGlvbnNcIiBsaW5rVHlwZT1cIiR7bGlua1R5cGVJZH1cIj5cclxuICAgICAgICAgICAgICAgICAgICA8aW1hZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9XCIke3dpZHRofVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD1cIiR7aGllZ2h0fVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg9XCItJHt3aWR0aC8yfVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk9XCItJHtoaWVnaHQvMn1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4bGluazpocmVmPVwiJHt0b29sLmltYWdlfVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJyb3I9XCJ0aGlzLnNldEF0dHJpYnV0ZSggJ3hsaW5rOmhyZWYnLCAnJHtfcmVzLmdldEltYWdlKCdkZWZhdWx0LWxpbmstb3B0aW9ucycpfScgKTtcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRpdGxlPk9wZW4gZGVyaXZhdGlvbiBtYXAke2xpbmtUeXBlSWQgPyAnIGZvciAnICsgbGlua1R5cGVJZCA6ICcnfTwvdGl0bGU+XHJcbiAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgIDwvZz5gO1xyXG4gICAgICAgIH0pLmpvaW4oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHVzIHdoZXRoZXIgdGhlIGxpbmsgaXMgY3VycmVudGx5XHJcbiAgICAgKiBvbiB0aGUgZ3JhcGggKGluIHRoZSBhbnkgb2YgdmlldyBmcmFtZXMpIG9yIG5vdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlbmF9XHJcbiAgICAgKi9cclxuICAgIHNlbGYuaXNPblRoZUdyYXBoID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiAoc2VsZi5ncmFwaCA/IHRydWUgOiBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGlnaGxpZ2h0cyB0aGUgTGluay5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zZWxlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbkxpbmtzLmZvckVhY2godGwgPT4gdGwuc2VsZWN0KHRydWUpKTtcclxuICAgICAgICBpZiAoc2VsZi5nZXQoJ2JsdXJlZCcpKSBzZWxmLnVuYmx1cmUoKTtcclxuICAgICAgICBpZiAoc2VsZi5nZXQoJ2hpZGRlbicpKSBzZWxmLnNob3coKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuU0VMRUNURURfRUxFTUVOVCB9KTtcclxuICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGhpZ2hsaWdodGluZyBmcm9tIHRoZSBMaW5rLlxyXG4gICAgICogQG1lbWJlcm9mIExpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnVuc2VsZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYudGVybWluYXRpb25MaW5rcy5mb3JFYWNoKHRsID0+IHRsLnVuc2VsZWN0KHRydWUpKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuTElOSyB9KTtcclxuICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQmx1cnMgdGhlIExpbmsuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuYmx1cmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHNlbGYuZ2V0KCdoaWdobGlnaHRlZCcpKSByZXR1cm47XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbkxpbmtzLmZvckVhY2godGwgPT4gdGwuYmx1cmUodHJ1ZSkpO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5CTFVSRURfTElOSyB9KTtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBibHVyIGZyb20gdGhlIExpbmsuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYudW5ibHVyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRlcm1pbmF0aW9uTGlua3MuZm9yRWFjaCh0bCA9PiB0bC51bmJsdXJlKHRydWUpKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuTElOSyB9KTtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIHRoZSBMaW5rLlxyXG4gICAgICogQG1lbWJlcm9mIExpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbkxpbmtzLmZvckVhY2godGwgPT4gdGwuaGlkZSh0cnVlKSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyB0aGUgTGluay5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYudGVybWluYXRpb25MaW5rcy5mb3JFYWNoKHRsID0+IHRsLnNob3codHJ1ZSkpO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWRkZW4nLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIGhpZ2hsaWdodGVycyBvZiB0aGUgdmlldyBvZiB0aGlzIGVsZW1lbnQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYucmVmcmVzaEhpZ2hsaWdodGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3JlZnJlc2gtaGlnaGxpZ2h0aW5nJywgc2VsZik7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYubW9kZWwgPSBkYXRhTW9kZWw7XHJcbn1cclxuTGluay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LmRpYS5MaW5rLnByb3RvdHlwZSk7XHJcbiIsImltcG9ydCAqIGFzIGpvaW50IGZyb20gJ3JhcHBpZCc7XHJcbmltcG9ydCB7IHVuaXF1ZUlkIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgUmVzb3VyY2VQcm92aWRlciB9IGZyb20gJy4uLy4uL2RhdGEvcmVzb3VyY2VQcm92aWRlcic7XHJcbmltcG9ydCB7IFpfSU5ERVhFUyB9IGZyb20gJy4vZWxlbWVudHMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IExBQkVMX0xFRlRfUklHSFRfUEFERElORyA9IDU7XHJcbmV4cG9ydCBjb25zdCBMQUJFTF9UT1BfQk9UVE9NX1BBRERJTkcgPSAxMDtcclxuZXhwb3J0IGNvbnN0IExBQkVMX0xJTkVfSEVJR0hUID0gMjA7XHJcbmV4cG9ydCBjb25zdCBCT0RZX1BBRERJTkcgPSAyNTtcclxuZXhwb3J0IGNvbnN0IElNR19QQURESU5HID0gMTA7XHJcbmV4cG9ydCBjb25zdCBGT05UX1NJWkUgPSAxNjtcclxuZXhwb3J0IGNvbnN0IEVYUEFOREVEX05PREVfR1JPV0lORyA9IDEuNTtcclxuXHJcbi8qKlxyXG4gKiBOb2RlTW9kZWwgLSBkYXRhIG1vZGVsIGZvciBhIHtAbGluayBOb2RlfSBvYmplY3RcclxuICogQHR5cGVkZWYge09iamVjdH0gTm9kZU1vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIE5vZGUgaWRlbnRpZnllclxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWwgLSBUaXRsZSBvZiB0aGUgTm9kZSxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZpZXdGcmFtZSAtIElkIG9mIFZpZXdGcmFtZSB3aWNoIHdpbGwgaW5jbHVkZSB0aGlzIG5vZGVcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVJZCAtIFR5cGUgaWRlbnRpZnllclxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIFRoZSBncmFwaCBOb2RlIGNsYXNzIHdoaWNoIGlzIGJhc2VkIG9uIGpvaW50LnNoYXBlcy5iYXNpYy5HZW5lcmljLiBJcyB0aGUgb25lIG9mIHRoZSBtYWluIGVsZW1lbnRzIG9mIHRoZSBMaW5lYWdlRnJhbS5cclxuICogUmVwcmVzZW50cyBleGlzdGluZyBwYXJ0IG9mIHRoZSBkYXRhc2V0IHdpdGggc3BlY2lmaWVkIGltYWdlLCBjb2xvciwgdHlwZSBhbmQgaWQgYW5kIHBsYWNlZCBpbiBzZXBhcmF0ZWQgVmlld0ZyYW1lLlxyXG4gKiBAY2xhc3NcclxuICogQHByaXZhdGVcclxuICogQGF1Z21lbnRzIGpvaW50LnNoYXBlcy5iYXNpYy5HZW5lcmljXHJcbiAqIEBwYXJhbSB7Tm9kZU1vZGVsfSBkYXRhTW9kZWwgLSBNb2RlbCBvZiBncmFwaCBub2RlXHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIFRoZSBzZXQgb2YgcGFyYW1ldGVyc1xyXG4gKiBcclxuICogQHByb3BlcnR5IHtOb2RlW119IGFzcGVjdHMgLSBDb3BpZXMgb2YgdGhpcyBub2RlIGluIG90aGVyIGZyYW1lc1xyXG4gKiBAcHJvcGVydHkge05vZGVNb2RlbH0gbW9kZWwgLSBEYXRhIG1vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7VGVybWluYXRpb25Ob2RlW119IHRlcm1pbmF0aW9uTm9kZXMgLSBUZXJtaW5hdGlvbiBub2RlcyB3aGljaCBleGlzdHMgb24gaW4gdGhlIGZyYW1lXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGlnaGxpZ2h0ZWQgLSBUZWxscyB3aGV0ZXIgaGlnaGxpZ2h0ZWQgbm9kZSBvciBub3QgKHVzZSBtZXRob2QgZ2V0IHRvIGdldCB0aGlzIHByb3BlcnR5LCBlLmcuIG5vZGUuZ2V0KCdoaWdobGlnaHRlZCcpKVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGJsdXJlZCAtIFRlbGxzIHdoZXRlciBibHVyZWQgbm9kZSBvciBub3QgKHVzZSBtZXRob2QgZ2V0IHRvIGdldCB0aGlzIHByb3BlcnR5LCBlLmcuIG5vZGUuZ2V0KCdibHVyZWQnKSlcclxuICogQHByb3BlcnR5IHtWaWV3RnJhbWV9IHZpZXdGcmFtZU93bmVySWQgLSBFeGlzdHMgb25seSBpZiBlbGVtZW50IHdhcyBkcmFnZ2VkIGZyb20gb25lIHRvIGFub3RoZXIgZnJhbWVcclxuICogQHByb3BlcnR5IHtib29sZWFufSBkcmFnZ2VkIC0gSWYgc29tZWJvZHkgaXMgZHJhZ2dpbmcgdGhpcyBOb2RlIG5vdywgdGhlbiB0cnVlLlxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gTm9kZSAoZGF0YU1vZGVsLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIGNvbnN0IF9zaXplID0gcGFyYW1ldGVycy5lbGVtZW50U2l6ZTtcclxuICAgIGNvbnN0IF9yZXMgPSBuZXcgUmVzb3VyY2VQcm92aWRlcihwYXJhbWV0ZXJzKTtcclxuICAgIFxyXG4gICAgbGV0IF9pc1ZlcnRpY2FsT3JpZW50ZWQgPSBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICd0b3AtdG8tYm90dG9tJyB8fFxyXG4gICAgICAgIHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnO1xyXG5cclxuICAgIHNlbGYubW9kZWwgPSBkYXRhTW9kZWw7XHJcbiAgICBzZWxmLnRlcm1pbmF0aW9uTm9kZXMgPSBbXTtcclxuICAgIHNlbGYuYXNwZWN0cyA9IFtdO1xyXG4gICAgc2VsZi52aWV3RnJhbWVPd25lcklkID0gbnVsbDtcclxuICAgIHNlbGYuZHJhZ2dlZCA9IGZhbHNlO1xyXG4gICAgc2VsZi5ibHVyZWQgPSBmYWxzZTtcclxuICAgIHNlbGYuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcclxuICAgIHNlbGYuc2l6ZSA9IHsgd2lkdGg6IF9zaXplLndpZHRoLCBoZWlnaHQ6IF9zaXplLmhlaWdodCwgbWF4V2lkdGg6IF9zaXplLndpZHRoLCBtYXhIZWlnaHQ6IF9zaXplLmhlaWdodCB9O1xyXG4gICAgXHJcbiAgICBjb25zdCBpbWFnZSA9IF9yZXMuZ2V0SW1hZ2UoZGF0YU1vZGVsLnR5cGVJZCk7XHJcblxyXG4gICAgY29uc3QgSUQgPSB1bmlxdWVJZCgnTm9kZScpO1xyXG4gICAgam9pbnQuc2hhcGVzLmJhc2ljLkdlbmVyaWMuYXBwbHkoc2VsZiwgW3tcclxuICAgICAgICB0eXBlOiAnbGluZWFnZS1ncmFtLW5vZGUnLFxyXG4gICAgICAgIGlkOiBJRCxcclxuICAgICAgICBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICAgICAgbWFya3VwOiBgPGcgY2xhc3M9XCJyb3RhdGFibGVcIiBjbGlwLXBhdGg9XCJ1cmwoJHsnIycgKyBJRCArICdfY2xpcFBhdGgnfSlcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZyBjbGFzcz1cInNjYWxhYmxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWN0IGNsYXNzPVwiYm9keVwiLz5cclxuICAgICAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICAgICAgICAgPHJlY3QgY2xhc3M9XCJ0cS1sZy1ib2R5XCI+PC9yZWN0PlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbWFnZSBjbGFzcz1cInNjYWxhYmxlXCIgb25lcnJvcj1cInRoaXMuc2V0QXR0cmlidXRlKCAneGxpbms6aHJlZicsICcke19yZXMuZ2V0SW1hZ2UoKX0nICk7XCIvPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZXh0IGNsYXNzPVwibGFiZWxcIi8+XHJcbiAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICAgICA8cmVjdCBjbGFzcz1cImNsaXBSZWN0XCI+PC9yZWN0PlxyXG4gICAgICAgICAgICAgICAgPGRlZnM+XHJcbiAgICAgICAgICAgICAgICAgICAgPGNsaXBQYXRoIGlkPVwiJHtJRCArICdfY2xpcFBhdGgnfVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cmVjdCBjbGFzcz1cImNsaXBSZWN0XCI+PC9yZWN0PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvY2xpcFBhdGg+XHJcbiAgICAgICAgICAgICAgICA8L2RlZnM+YCxcclxuICAgICAgICBzaXplOiBzZWxmLnNpemUsXHJcbiAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgJ2NpcmNsZSc6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgICAgICByOiAxLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLmNsaXBSZWN0Jzoge1xyXG4gICAgICAgICAgICAgICAgcG9ydDogJ2NsaXBSZWN0UG9ydCcsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogc2VsZi5zaXplLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzZWxmLnNpemUuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMCxcclxuICAgICAgICAgICAgICAgIHJ4OiA1LFxyXG4gICAgICAgICAgICAgICAgcnk6IDUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcuYm9keSc6IHtcclxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAwLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgICAgIHJ4OiA1LFxyXG4gICAgICAgICAgICAgICAgcnk6IDUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcubGFiZWwnOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBfcmVzLmdldENvbG9yKCd0ZXh0JyksXHJcbiAgICAgICAgICAgICAgICAnZm9udC1zaXplJzogRk9OVF9TSVpFLFxyXG4gICAgICAgICAgICAgICAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdoYW5naW5nJyxcclxuICAgICAgICAgICAgICAgIHJlZjogJy5ib2R5JyxcclxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IHNlbGYubW9kZWwubGFiZWwsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLnRxLWxnLWJvZHknOiB7XHJcbiAgICAgICAgICAgICAgICAncmVmLXgnOiAuNSxcclxuICAgICAgICAgICAgICAgICd4LWFsaWdubWVudCc6ICdtaWRkbGUnLFxyXG4gICAgICAgICAgICAgICAgJ3ktYWxpZ25tZW50JzogJ3RvcCcsXHJcbiAgICAgICAgICAgICAgICByZWY6ICcuYm9keScsXHJcbiAgICAgICAgICAgICAgICByeDogNSxcclxuICAgICAgICAgICAgICAgIHJ5OiA1LFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBfcmVzLmdldENvbG9yKGRhdGFNb2RlbC50eXBlSWQpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbWFnZToge1xyXG4gICAgICAgICAgICAgICAgJ3hsaW5rOmhyZWYnOiBpbWFnZSxcclxuICAgICAgICAgICAgICAgICdyZWYteCc6IC41LFxyXG4gICAgICAgICAgICAgICAgcmVmOiAnLmJvZHknLFxyXG4gICAgICAgICAgICAgICAgJ3gtYWxpZ25tZW50JzogJ21pZGRsZScsXHJcbiAgICAgICAgICAgICAgICAneS1hbGlnbm1lbnQnOiAndG9wJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJy5sYWJlbCB0c3Bhbic6IHtcclxuICAgICAgICAgICAgICAgIGR5OiBMQUJFTF9MSU5FX0hFSUdIVCxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgejogWl9JTkRFWEVTLk5PREUsXHJcbiAgICB9XSk7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGxldCBfYmxvY2tTdWJzY3JpcHRpb24gPSBmYWxzZTtcclxuICAgIGNvbnN0IG9sZFBvc2l0aW9uID0gc2VsZi5wb3NpdGlvbjtcclxuICAgIHNlbGYucG9zaXRpb24gPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgIF9ibG9ja1N1YnNjcmlwdGlvbiA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gb2xkUG9zaXRpb24uY2FsbChzZWxmLCB4LCB5KTtcclxuICAgICAgICBfYmxvY2tTdWJzY3JpcHRpb24gPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIHNlbGYub24oJ2NoYW5nZTpwb3NpdGlvbicsICgpID0+IHtcclxuICAgICAgICBpZiAoX2Jsb2NrU3Vic2NyaXB0aW9uKSByZXR1cm47XHJcbiAgICAgICAgc2VsZi5zZXRDbGlwcGluZyh1bmRlZmluZWQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgc2VsZi5vbignY2hhbmdlOnNpemUnLCAoY2VsbCwgc2l6ZSkgPT4ge1xyXG4gICAgICAgIHNlbGYuYXR0cih7XHJcbiAgICAgICAgICAgICcuY2xpcFJlY3QnOiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHNlbGYub24oJ2NoYW5nZTpleHBhbmRlZCcsICgpID0+IHtcclxuICAgICAgICBfcmVmcmVzaFNpemUoc2VsZi5jb2xsYXBzZWRTaXplKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBfcmVmcmVzaFNpemUoc2VsZi5zaXplKTtcclxuXHJcbiAgICBzZWxmLnNldCgnZXhwYW5kZWQnLCBmYWxzZSk7XHJcblxyXG4gICAgc2VsZi5zZXRTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHNlbGYuY29sbGFwc2VkU2l6ZS53aWR0aCAhPT0gc2l6ZS53aWR0aCB8fFxyXG4gICAgICAgICAgICBzZWxmLmNvbGxhcHNlZFNpemUuaGVpZ2h0ICE9PSBzaXplLmhlaWdodCB8fFxyXG4gICAgICAgICAgICBzZWxmLnNpemUubWF4V2lkdGggIT09IHNpemUubWF4V2lkdGggfHxcclxuICAgICAgICAgICAgc2VsZi5zaXplLm1heEhlaWdodCAhPT0gc2l6ZS5tYXhIZWlnaHRcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgX3JlZnJlc2hTaXplKHNpemUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5zZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIChvcmllbnRhdGlvbikge1xyXG4gICAgICAgIF9pc1ZlcnRpY2FsT3JpZW50ZWQgPSBvcmllbnRhdGlvbiA9PT0gJ3RvcC10by1ib3R0b20nIHx8IG9yaWVudGF0aW9uID09PSAnYm90dG9tLXRvLXRvcCc7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdXMgd2hldGhlciB0aGUgbm9kZSBpcyBjdXJyZW50bHlcclxuICAgICAqIG9uIHRoZSBncmFwaCAoaW4gdGhlIGFueSBvZiB2aWV3IGZyYW1lcykgb3Igbm90XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVuYX1cclxuICAgICAqL1xyXG4gICAgc2VsZi5pc09uVGhlR3JhcGggPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIChzZWxmLmdyYXBoID8gdHJ1ZSA6IGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5jYWxjdWxhdGVTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgICAgICBjb25zdCBjYWxjdWxhdGlvbnMgPSBfY2FsY3VsYXRlTm9kZShzaXplKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB3aWR0aDogY2FsY3VsYXRpb25zLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGNhbGN1bGF0aW9ucy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1heFdpZHRoOiBjYWxjdWxhdGlvbnMubWF4V2lkdGgsXHJcbiAgICAgICAgICAgIG1heEhlaWdodDogY2FsY3VsYXRpb25zLm1heEhlaWdodFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGlnaGxpZ2h0cyB0aGUgTm9kZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSAtIEJvb2xlYW4gZmxhZyB0byBwcm90ZWN0IGNvZGUgZnJvbSByZWN1cnNpb24gKG9wdGlvbmFsKVxyXG4gICAgICogQG1lbWJlcm9mIE5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnNlbGVjdCA9IGZ1bmN0aW9uIChvbmNlKSB7XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbk5vZGVzLmZvckVhY2godG4gPT4gdG4uc2VsZWN0KHRydWUpKTtcclxuICAgICAgICBpZiAoIW9uY2UpIHNlbGYuYXNwZWN0cy5mb3JFYWNoKGEgPT4gYS5zZWxlY3QodHJ1ZSkpO1xyXG4gICAgICAgIGlmIChzZWxmLmdldCgnYmx1cmVkJykpIHNlbGYudW5ibHVyZSgpO1xyXG4gICAgICAgIGlmIChzZWxmLmdldCgnaGlkZGVuJykpIHNlbGYuc2hvdygpO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5TRUxFQ1RFRF9FTEVNRU5UIH0pO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWdobGlnaHRlZCcsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgaGlnaGxpZ2h0aW5nIGZyb20gdGhlIE5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgLSBCb29sZWFuIGZsYWcgdG8gcHJvdGVjdCBjb2RlIGZyb20gcmVjdXJzaW9uIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBOb2RlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi51bnNlbGVjdCA9IGZ1bmN0aW9uIChvbmNlKSB7XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbk5vZGVzLmZvckVhY2godG4gPT4gdG4udW5zZWxlY3QodHJ1ZSkpO1xyXG4gICAgICAgIGlmICghb25jZSkgc2VsZi5hc3BlY3RzLmZvckVhY2goYSA9PiBhLnVuc2VsZWN0KHRydWUpKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuTk9ERSB9KTtcclxuICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQmx1cnMgdGhlIE5vZGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgTm9kZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuYmx1cmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHNlbGYuZ2V0KCdoaWdobGlnaHRlZCcpKSByZXR1cm47XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbk5vZGVzLmZvckVhY2godG4gPT4gdG4uYmx1cmUodHJ1ZSkpO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5CTFVSRURfTk9ERSB9KTtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBibHVyIGZyb20gdGhlIE5vZGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgTm9kZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYudW5ibHVyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRlcm1pbmF0aW9uTm9kZXMuZm9yRWFjaCh0biA9PiB0bi51bmJsdXJlKHRydWUpKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuTk9ERSB9KTtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIHRoZSBOb2RlLlxyXG4gICAgICogQG1lbWJlcm9mIE5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbk5vZGVzLmZvckVhY2godG4gPT4gdG4uaGlkZSh0cnVlKSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3dzIHRoZSBOb2RlLlxyXG4gICAgICogQG1lbWJlcm9mIE5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbk5vZGVzLmZvckVhY2godG4gPT4gdG4uc2hvdyh0cnVlKSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZGRlbicsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoZXMgaGlnaGxpZ2h0ZXJzIG9mIHRoZSB2aWV3IG9mIHRoaXMgZWxlbWVudC5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5yZWZyZXNoSGlnaGxpZ2h0aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcigncmVmcmVzaC1oaWdobGlnaHRpbmcnLCBzZWxmKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIG9mZnNldCBhbmQgc2l6ZSBvZiBjbGlwcGluZyByZWN0YW5nbGUuXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIE9mZnNldCBvZiB0aGUgY2xpcHBpbmcgcmVjdGFuZ2xlXHJcbiAgICAgKiBAbWVtYmVyb2YgTm9kZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuc2V0Q2xpcHBpbmcgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICBwb2ludCA9IHBvaW50IHx8IHsgeDogMCwgeTogMCB9O1xyXG5cclxuICAgICAgICBjb25zdCB4ID0gKHBvaW50LnggPiAwID8gcG9pbnQueCA6IDApO1xyXG4gICAgICAgIGNvbnN0IHkgPSAocG9pbnQueSA+IDAgPyBwb2ludC55IDogMCk7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBzZWxmLnNpemUud2lkdGggLSBNYXRoLmFicyhwb2ludC54KTtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBzZWxmLnNpemUuaGVpZ2h0IC0gTWF0aC5hYnMocG9pbnQueSk7XHJcblxyXG4gICAgICAgIHNlbGYuYXR0cih7XHJcbiAgICAgICAgICAgICcuY2xpcFJlY3QnOiB7XHJcbiAgICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgICAgeTogeSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCA+IDAgPyB3aWR0aCA6IDAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA+IDAgPyBoZWlnaHQgOiAwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfcmVmcmVzaFNpemUgKHNpemUpIHtcclxuICAgICAgICBzZWxmLmNvbGxhcHNlZFNpemUgPSBzaXplO1xyXG5cclxuICAgICAgICBjb25zdCBjYWxjdWxhdGlvbnMgPSBfY2FsY3VsYXRlTm9kZShzaXplKTtcclxuICAgICAgICBzZWxmLnNpemUgPSB7XHJcbiAgICAgICAgICAgIHdpZHRoOiBjYWxjdWxhdGlvbnMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogY2FsY3VsYXRpb25zLmhlaWdodCxcclxuICAgICAgICAgICAgbWF4V2lkdGg6IGNhbGN1bGF0aW9ucy5tYXhXaWR0aCxcclxuICAgICAgICAgICAgbWF4SGVpZ2h0OiBjYWxjdWxhdGlvbnMubWF4SGVpZ2h0XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBzY2FsZSA9IGNhbGN1bGF0aW9ucy5zY2FsZTtcclxuICAgICAgICBjb25zdCBib2R5UGFkZGluZyA9IEJPRFlfUEFERElORyAqIHNjYWxlO1xyXG4gICAgICAgIGNvbnN0IHRvcEJvdHRvbVBhZGRpbmcgPSBMQUJFTF9UT1BfQk9UVE9NX1BBRERJTkcgKiBzY2FsZTtcclxuICAgICAgICBjb25zdCBsYWJlbExpbmVIZWlnaHQgPSBMQUJFTF9MSU5FX0hFSUdIVCAqIHNjYWxlO1xyXG5cclxuICAgICAgICBzZWxmLmF0dHIoe1xyXG4gICAgICAgICAgICAnLnRxLWxnLWJvZHknOiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogY2FsY3VsYXRpb25zLnJlY3RXaWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogY2FsY3VsYXRpb25zLnJlY3RIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAncmVmLXknOiBib2R5UGFkZGluZyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW1hZ2U6IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1heCgwLCBjYWxjdWxhdGlvbnMucmVjdFdpZHRoIC0gSU1HX1BBRERJTkcgKiAyKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgY2FsY3VsYXRpb25zLnJlY3RIZWlnaHQgLSBJTUdfUEFERElORyAqIDIpLFxyXG4gICAgICAgICAgICAgICAgJ3JlZi15JzogYm9keVBhZGRpbmcgKyBJTUdfUEFERElORyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJy5sYWJlbCc6IHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IGNhbGN1bGF0aW9ucy5sYWJlbCxcclxuICAgICAgICAgICAgICAgICdyZWYteSc6IGJvZHlQYWRkaW5nICtcclxuICAgICAgICAgICAgICAgICAgICB0b3BCb3R0b21QYWRkaW5nICtcclxuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGlvbnMucmVjdEhlaWdodCArXHJcbiAgICAgICAgICAgICAgICAgICAgRk9OVF9TSVpFICogc2NhbGUgLVxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsTGluZUhlaWdodCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJy5sYWJlbCB0c3Bhbic6IHtcclxuICAgICAgICAgICAgICAgICdmb250LXNpemUnOiBGT05UX1NJWkUgKiBzY2FsZSxcclxuICAgICAgICAgICAgICAgIGR5OiBsYWJlbExpbmVIZWlnaHQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNlbGYucmVzaXplKHNlbGYuc2l6ZS53aWR0aCwgc2VsZi5zaXplLmhlaWdodCk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ3Nob3J0LWxhYmVsJywgY2FsY3VsYXRpb25zLnNob3J0TGFiZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBfY2F0Y2hlZFJlc3VsdCA9IG51bGw7XHJcbiAgICBmdW5jdGlvbiBfY2FsY3VsYXRlTm9kZSAoc2l6ZSkge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgX2NhdGNoZWRSZXN1bHQgJiZcclxuICAgICAgICAgICAgX2NhdGNoZWRSZXN1bHQuaW5TaXplLndpZHRoID09PSBzaXplLndpZHRoICYmXHJcbiAgICAgICAgICAgIF9jYXRjaGVkUmVzdWx0LmluU2l6ZS5oZWlnaHQgPT09IHNpemUuaGVpZ2h0ICYmXHJcbiAgICAgICAgICAgIF9jYXRjaGVkUmVzdWx0LmluU2l6ZS5tYXhXaWR0aCA9PT0gc2l6ZS5tYXhXaWR0aCAmJlxyXG4gICAgICAgICAgICBfY2F0Y2hlZFJlc3VsdC5pblNpemUubWF4SGVpZ2h0ID09PSBzaXplLm1heEhlaWdodCAmJlxyXG4gICAgICAgICAgICBfY2F0Y2hlZFJlc3VsdC5leHBhbmRlZCA9PT0gc2VsZi5nZXQoJ2V4cGFuZGVkJylcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9jYXRjaGVkUmVzdWx0Lm91dFNpemU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgd2lkdGg7XHJcbiAgICAgICAgbGV0IGhlaWdodDtcclxuICAgICAgICBpZiAoIXNlbGYuZ2V0KCdleHBhbmRlZCcpKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gc2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1pbihzaXplLm1heFdpZHRoLCBzaXplLndpZHRoICogRVhQQU5ERURfTk9ERV9HUk9XSU5HKTtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5taW4oc2l6ZS5tYXhIZWlnaHQsIHNpemUuaGVpZ2h0ICogRVhQQU5ERURfTk9ERV9HUk9XSU5HKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHhTY2FsZSA9IHNpemUud2lkdGggLyBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplLndpZHRoOyBcclxuICAgICAgICBjb25zdCB5U2NhbGUgPSBzaXplLmhlaWdodCAvIHBhcmFtZXRlcnMuZWxlbWVudFNpemUuaGVpZ2h0OyBcclxuICAgICAgICBjb25zdCBzY2FsZSA9IE1hdGgubWluKHhTY2FsZSwgeVNjYWxlKTtcclxuICAgICAgICBjb25zdCBib2R5UGFkZGluZyA9IEJPRFlfUEFERElORyAqIHNjYWxlO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsTGluZUhlaWdodCA9IExBQkVMX0xJTkVfSEVJR0hUICogc2NhbGU7XHJcblxyXG4gICAgICAgIGxldCBjYWxjdWxhdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgIG1heFdpZHRoOiBzaXplLm1heFdpZHRoLFxyXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IHNpemUubWF4SGVpZ2h0LFxyXG4gICAgICAgICAgICByZWN0V2lkdGg6IHdpZHRoIC0gYm9keVBhZGRpbmcgKiAyLFxyXG4gICAgICAgICAgICByZWN0SGVpZ2h0OiBoZWlnaHQgLSBib2R5UGFkZGluZyAqIDIsXHJcbiAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcclxuICAgICAgICAgICAgc2hvcnRMYWJlbDogZmFsc2UsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKHNlbGYubW9kZWwubGFiZWwpIHtcclxuICAgICAgICAgICAgY2FsY3VsYXRpb25zLmhlaWdodCAtPSBib2R5UGFkZGluZztcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gRk9OVF9TSVpFICogc2NhbGU7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnRSaWdodFBhZGRpbmcgPSBMQUJFTF9MRUZUX1JJR0hUX1BBRERJTkcgKiBzY2FsZSAqIDI7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvcEJvdHRvbVBhZGRpbmcgPSBMQUJFTF9UT1BfQk9UVE9NX1BBRERJTkcgKiBzY2FsZSAqIDI7XHJcblxyXG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBfYnJlYWtUZXh0QnlMaW5lcyhcclxuICAgICAgICAgICAgICAgIHNlbGYubW9kZWwubGFiZWwsXHJcbiAgICAgICAgICAgICAgICB3aWR0aCAtIGxlZnRSaWdodFBhZGRpbmcsXHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgbGV0IGxhYmVsSGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgbGV0IHN1YnN0cmluZ3MgPSBsYWJlbC5zcGxpdCgnXFxuJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3Vic3RyaW5ncy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWF4Um93Q291bnQgPSAoX2lzVmVydGljYWxPcmllbnRlZCA/IDIgOiAzKSArIChzZWxmLmdldCgnZXhwYW5kZWQnKSA/IDEgOiAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3Vic3RyaW5ncy5sZW5ndGggPiBtYXhSb3dDb3VudCkgY2FsY3VsYXRpb25zLnNob3J0TGFiZWwgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHN1YnN0cmluZ3MgPSBzdWJzdHJpbmdzLnNsaWNlKDAsIG1heFJvd0NvdW50KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKF9pc1ZlcnRpY2FsT3JpZW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaW5hbExhYmVsID0gc3Vic3RyaW5ncy5qb2luKCcgJykgKyAoY2FsY3VsYXRpb25zLnNob3J0TGFiZWwgPyAnLi4uJyA6ICcnKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gX2dldFRleHRXaWR0aChmaW5hbExhYmVsLCBmb250U2l6ZSArICdweCBzYW5zLXNlcmlmJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRpb25zLndpZHRoID0gbGFiZWxXaWR0aCArIGxlZnRSaWdodFBhZGRpbmcgKiBzdWJzdHJpbmdzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGlvbnMubGFiZWwgPSBmaW5hbExhYmVsO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gZm9udFNpemUgKyB0b3BCb3R0b21QYWRkaW5nO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB1c2UgZHkgcHJvcGVydHkgZm9yIGVhY2ggbGluZSB0aGF0J3Mgd2h5IGZvbnQtc2l6ZSBnb2VzIG9ubHkgb25lIHRpbWUgaW50byBhY291bnQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBkeCBpcyBkaXN0YW5jZSBiZXR3ZWVuIHRvcCBsaW5lcyBvZiBlYWNoIHRleHQgbGluZS4gQW5kIGZvciBhIGZ1bGwgdGV4dCBoZWlnaHQgd2UgYWRkIGZvbnQgc2l6ZSBvZiBsdXN0IGxpbmUuXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxIZWlnaHQgPSAoZm9udFNpemUpICsgdG9wQm90dG9tUGFkZGluZyArIChzdWJzdHJpbmdzLmxlbmd0aCAtIDEpICogKGxhYmVsTGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRpb25zLmxhYmVsID0gc3Vic3RyaW5ncy5qb2luKCdcXG4nKSArIChjYWxjdWxhdGlvbnMuc2hvcnRMYWJlbCA/ICcuLi4nIDogJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGFiZWxIZWlnaHQgPSAoZm9udFNpemUpICsgdG9wQm90dG9tUGFkZGluZztcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0aW9ucy5sYWJlbCA9IHNlbGYubW9kZWwubGFiZWw7XHJcbiAgICAgICAgICAgIH0gXHJcblxyXG4gICAgICAgICAgICBjYWxjdWxhdGlvbnMuaGVpZ2h0ICs9IGxhYmVsSGVpZ2h0O1xyXG4gICAgICAgICAgICBjYWxjdWxhdGlvbnMubGFiZWxIZWlnaHQgPSBsYWJlbEhlaWdodDtcclxuICAgICAgICAgICAgY2FsY3VsYXRpb25zLmV4cGFuZGVkID0gc2VsZi5nZXQoJ2V4cGFuZGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9jYXRjaGVkUmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBpblNpemU6IHNpemUsXHJcbiAgICAgICAgICAgIG91dFNpemU6IGNhbGN1bGF0aW9ucyxcclxuICAgICAgICAgICAgZXhwYW5kZWQ6IGNhbGN1bGF0aW9ucy5leHBhbmRlZCxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gY2FsY3VsYXRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9icmVha1RleHRCeUxpbmVzIChcclxuICAgICAgICBsYWJlbCwgd2lkdGgsIGZvbnRTaXplLFxyXG4gICAgKSB7XHJcbiAgICAgICAgY29uc3QgYnJva2VuVGV4dCA9IGpvaW50LnV0aWwuYnJlYWtUZXh0KGxhYmVsLCB7XHJcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICB9LCB7ICdmb250LXNpemUnOiBmb250U2l6ZSB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgbGluZXMgPSBicm9rZW5UZXh0LnNwbGl0KCdcXG4nKTtcclxuXHJcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgY29uc3QgbGFzdENoaWxkID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGNvbnN0IE1JTl9DSEFSQUNURVJfTlVNQkVSID0gNDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChsYXN0Q2hpbGQubGVuZ3RoIDwgTUlOX0NIQVJBQ1RFUl9OVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBNSU5fQ0hBUkFDVEVSX05VTUJFUiAtIGxhc3RDaGlsZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aHJlc2hvbGQgPSBsaW5lcy5sZW5ndGggLSAoZGlmZiArIDEpO1xyXG4gICAgICAgICAgICAgICAgLy8gbWF4IGVycm9yIGlzIDMgZXh0cmEgbGV0dGVycywgc28gSSBob3BlIGl0J3MgT0suXHJcbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJPZlN0ZWFsZWROb2RlcyA9IE1hdGgucm91bmQoZGlmZiAvIE1hdGgubWluKGRpZmYsIGxpbmVzLmxlbmd0aCAtIDEpKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgbGV0IHByZXZSZXN0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmVzID0gbGluZXMubWFwKChsaW5lLCBpbmRleCwgYXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0xhc3RMaW5lID0gaW5kZXggPT09IChhcnIubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxMaW5lID0gcHJldlJlc3QgKyBsaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gbnVtYmVyT2ZTdGVhbGVkTm9kZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0xhc3RMaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVsbExpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2UmVzdCA9IGZ1bGxMaW5lLnN1YnN0cmluZyhmdWxsTGluZS5sZW5ndGggLSBvZmZzZXQsIGZ1bGxMaW5lLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVsbExpbmUuc3Vic3RyaW5nKDAsIGZ1bGxMaW5lLmxlbmd0aCAtIG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3TGluZXMuam9pbignXFxuJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJva2VuVGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYWJlbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogVXBkYXRlIHNpemUgb2YgZWxlbWVudC4gVGFrZXMgY29sbGFwc2VkIHNpemUsXHJcbiAgICAgKiBhbmQgaWYgZWxlbWVudCBhcmUgZXhwYW5kZWQgdHJ5aW5nIHRvIHNldCBhIHR3aXNlIHNpemUuXHJcbiAgICAgKiBAcGFyYW0ge1NpemV9IHNpemUgXHJcbiAgICAqL1xyXG4gICAgXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9udCBcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0VGV4dFdpZHRoICh0ZXh0LCBmb250KSB7XHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gX2dldFRleHRXaWR0aC5jYW52YXMgfHwgKF9nZXRUZXh0V2lkdGguY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQ0FOVkFTJykpO1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udDtcclxuICAgICAgICB2YXIgbWV0cmljcyA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIG1ldHJpY3Mud2lkdGg7XHJcbiAgICB9XHJcbn1cclxuXHJcbk5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShqb2ludC5zaGFwZXMuZGV2cy5Nb2RlbC5wcm90b3R5cGUpO1xyXG4iLCJpbXBvcnQgKiBhcyBqb2ludCBmcm9tICdyYXBwaWQnO1xyXG5pbXBvcnQgeyBSZXNvdXJjZVByb3ZpZGVyIH0gZnJvbSAnLi4vLi4vZGF0YS9yZXNvdXJjZVByb3ZpZGVyJztcclxuaW1wb3J0IHsgWl9JTkRFWEVTIH0gZnJvbSAnLi9lbGVtZW50cyc7XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogVGVybWluYXRpb25MaW5rT3B0aW9ucyAtIG9wdGlvbnMgZm9yIFRlcm1pbmF0aW9uTGluayBvYmplY3RcclxuICogQHR5cGVkZWYge09iamVjdH0gVGVybWluYXRpb25MaW5rT3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge0xpbmt9IGxpbmsgLSBPcmlnaW5hbCBsaW5rXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZX0gdGFyZ2V0IC0gVGFyZ2V0IE5vZGVcclxuICogQHByb3BlcnR5IHtOb2RlfSBzb3VyY2UgLSBTb3VyY2UgTm9kZVxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIFNpbXBsZUxpbmtNb2RlbCAtIGRhdGEgbW9kZWwgb2YgYSBUZXJtaW5hdGlvbkxpbmsgb2JqZWN0XHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNpbXBsZUxpbmtNb2RlbCAtIERhdGEgbW9kZWxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRhcmdldCAtIFRhcmdldCBOb2RlIGlkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBTb3VyY2UgTm9kZSBpZFxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIFRoZSBncmFwaCBMaW5rIGJhc2VkIG9uIGpvaW50LmRpYS5MaW5rLlxyXG4gKiBAY2xhc3NcclxuICogQGF1Z21lbnRzIGpvaW50LmRpYS5MaW5rXHJcbiAqIFxyXG4gKiBAcGFyYW0ge1Rlcm1pbmF0aW9uTGlua09wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBUZXJtaW5hdGlvbkxpbmsgb2JqZWN0XHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIHRoZSBzZXQgb2YgcGFyYW1ldGVyc1xyXG4gKiBcclxuICogQHByb3BlcnR5IHtMaW5rfSBvcmlnaW5hbExpbmsgLSBPcmlnaW5hbCBMaW5rIC0gdGhlIGxpbmsgdG8gYSBub2RlIHdoaWNoIGlzIG91dCBvZiB0aGUgVmlld0ZybWFlXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGlnaGxpZ2h0ZWQgLSBUZWxscyB3aGV0ZXIgaGlnaGxpZ2h0ZWQgbGluayBvciBub3QgKHVzZSBtZXRob2QgZ2V0IHRvIGdldCB0aGlzIHByb3BlcnR5LCBlLmcuIGxpbmsuZ2V0KCdoaWdobGlnaHRlZCcpKVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGJsdXJlZCAtIFRlbGxzIHdoZXRlciBibHVyZWQgbGluayBvciBub3QgKHVzZSBtZXRob2QgZ2V0IHRvIGdldCB0aGlzIHByb3BlcnR5LCBlLmcuIGxpbmsuZ2V0KCdibHVyZWQnKSlcclxuICogQHByb3BlcnR5IHtTaW1wbGVMaW5rTW9kZWx9IG1vZGVsIC0gRGF0YSBtb2RlbCBcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFRlcm1pbmF0aW9uTGluayAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICBjb25zdCBfcmVzID0gbmV3IFJlc291cmNlUHJvdmlkZXIocGFyYW1ldGVycyk7XHJcblxyXG4gICAgc2VsZi5vcmlnaW5hbExpbmsgPSBvcHRpb25zLmxpbms7XHJcbiAgICBzZWxmLmhpZ2hsaWdodGVkID0gZmFsc2U7XHJcbiAgICBzZWxmLmJsdXJlZCA9IGZhbHNlO1xyXG4gICAgc2VsZi5vcmlnaW5hbExpbmsudGVybWluYXRpb25MaW5rcy5wdXNoKHNlbGYpO1xyXG5cclxuICAgIGNvbnN0IHNvdXJjZSA9IHsgaWQ6IG9wdGlvbnMuc291cmNlLmlkLCBwb3J0OiAnY2xpcFJlY3RQb3J0JyB9O1xyXG4gICAgY29uc3QgdGFyZ2V0ID0geyBpZDogb3B0aW9ucy50YXJnZXQuaWQsIHBvcnQ6ICdjbGlwUmVjdFBvcnQnIH07XHJcblxyXG4gICAgY29uc3QgbGlua0NvbG9yID0gX3Jlcy5nZXRDb2xvcigndGVybWluYXRpb25MaW5rJyk7XHJcblxyXG4gICAgam9pbnQuZGlhLkxpbmsuYXBwbHkoc2VsZiwgW3tcclxuICAgICAgICB0eXBlOiAndGVybWluYXRpb24tbGluaycsXHJcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgICAgejogWl9JTkRFWEVTLlRFUk1JTkFUSU9OX0VMRU1FTlQsXHJcbiAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgJy5jb25uZWN0aW9uJzoge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5rQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogcGFyYW1ldGVycy5saW5rVGhpY2tuZXNzICogKDEgKyAoc2VsZi5vcmlnaW5hbExpbmsubW9kZWwudGhpY2tuZXNzIHx8IDApKSxcclxuICAgICAgICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogJzUsNScsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcubWFya2VyLXNvdXJjZSc6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IGxpbmtDb2xvcixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogbGlua0NvbG9yLFxyXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHBhcmFtZXRlcnMubGlua1RoaWNrbmVzcyAqICgxICsgKHNlbGYub3JpZ2luYWxMaW5rLm1vZGVsLnRoaWNrbmVzcyB8fCAwKSksXHJcbiAgICAgICAgICAgICAgICBkOiAnTTAsM2EzLDMgMCAxLDAgNiwwYTMsMyAwIDEsMCAtNiwwJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJy5tYXJrZXItdGFyZ2V0Jzoge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogbGlua0NvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5rQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogcGFyYW1ldGVycy5saW5rVGhpY2tuZXNzICogKDEgKyAoc2VsZi5vcmlnaW5hbExpbmsubW9kZWwudGhpY2tuZXNzIHx8IDApKSxcclxuICAgICAgICAgICAgICAgIGQ6ICdNIDEwIDAgTCAwIDUgTCAxMCAxMCB6JyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbm5lY3Rvcjoge25hbWU6ICdyb3VuZGVkJyB9LFxyXG4gICAgfV0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGlnaGxpZ2h0cyB0aGUgVGVybWluYXRpb25MaW5rLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvbmNlIC0gQm9vbGVhbiBmbGFnIHRvIHByb3RlY3QgY29kZSBmcm9tIHJlY3Vyc2lvbiAob3B0aW9uYWwpXHJcbiAgICAgKiBAbWVtYmVyb2YgVGVybWluYXRpb25MaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zZWxlY3QgPSBmdW5jdGlvbiAob25jZSkge1xyXG4gICAgICAgIGlmICghb25jZSkgc2VsZi5vcmlnaW5hbExpbmsuc2VsZWN0KHRydWUpO1xyXG4gICAgICAgIGlmIChzZWxmLmdldCgnYmx1cmVkJykpIHNlbGYudW5ibHVyZSgpO1xyXG4gICAgICAgIGlmIChzZWxmLmdldCgnaGlkZGVuJykpIHNlbGYuc2hvdygpO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5TRUxFQ1RFRF9FTEVNRU5UIH0pO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWdobGlnaHRlZCcsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGhpZ2hsaWdodGluZyBmcm9tIHRoZSBUZXJtaW5hdGlvbkxpbmsuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgLSBCb29sZWFuIGZsYWcgdG8gcHJvdGVjdCBjb2RlIGZyb20gcmVjdXJzaW9uIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbkxpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnVuc2VsZWN0ID0gZnVuY3Rpb24gKG9uY2UpIHtcclxuICAgICAgICBpZiAoIW9uY2UpIHNlbGYub3JpZ2luYWxMaW5rLnVuc2VsZWN0KHRydWUpO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5URVJNSU5BVElPTl9FTEVNRU5UIH0pO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWdobGlnaHRlZCcsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCbHVycyB0aGUgVGVybWluYXRpb25MaW5rLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvbmNlIC0gQm9vbGVhbiBmbGFnIHRvIHByb3RlY3QgY29kZSBmcm9tIHJlY3Vyc2lvbiAob3B0aW9uYWwpXHJcbiAgICAgKiBAbWVtYmVyb2YgVGVybWluYXRpb25MaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5ibHVyZSA9IGZ1bmN0aW9uIChvbmNlKSB7XHJcbiAgICAgICAgaWYgKHNlbGYuZ2V0KCdoaWdobGlnaHRlZCcpKSByZXR1cm47XHJcbiAgICAgICAgaWYgKCFvbmNlKSBzZWxmLm9yaWdpbmFsTGluay5ibHVyZSh0cnVlKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuQkxVUkVEX0xJTksgfSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2JsdXJlZCcsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYmx1ciBmcm9tIHRoZSBUZXJtaW5hdGlvbkxpbmsuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgLSBCb29sZWFuIGZsYWcgdG8gcHJvdGVjdCBjb2RlIGZyb20gcmVjdXJzaW9uIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbkxpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnVuYmx1cmUgPSBmdW5jdGlvbiAob25jZSkge1xyXG4gICAgICAgIGlmICghb25jZSkgc2VsZi5vcmlnaW5hbExpbmsudW5ibHVyZSh0cnVlKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuVEVSTUlOQVRJT05fRUxFTUVOVCB9KTtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIHRoZSBUZXJtaW5hdGlvbkxpbmsuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgLSBCb29sZWFuIGZsYWcgdG8gcHJvdGVjdCBjb2RlIGZyb20gcmVjdXJzaW9uIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbkxpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAob25jZSkge1xyXG4gICAgICAgIGlmICghb25jZSkgc2VsZi5vcmlnaW5hbExpbmsuaGlkZSh0cnVlKTtcclxuICAgICAgICBzZWxmLnNldCgnaGlkZGVuJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MgdGhlIFRlcm1pbmF0aW9uTGluay5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSAtIEJvb2xlYW4gZmxhZyB0byBwcm90ZWN0IGNvZGUgZnJvbSByZWN1cnNpb24gKG9wdGlvbmFsKVxyXG4gICAgICogQG1lbWJlcm9mIFRlcm1pbmF0aW9uTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuc2hvdyA9IGZ1bmN0aW9uIChvbmNlKSB7XHJcbiAgICAgICAgaWYgKCFvbmNlKSBzZWxmLm9yaWdpbmFsTGluay5zaG93KHRydWUpO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWRkZW4nLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIGhpZ2hsaWdodGVycyBvZiB0aGUgdmlldyBvZiB0aGlzIGVsZW1lbnQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYucmVmcmVzaEhpZ2hsaWdodGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3luY2hyb25pemVXaXRoT3JpZ2luKCk7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdyZWZyZXNoLWhpZ2hsaWdodGluZycsIHNlbGYpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IGhpZ2hsaWdodGluZyBmb3IgdGhlIFRlcm1pbmF0aW9uTGluay5cclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbkxpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfc3luY2hyb25pemVXaXRoT3JpZ2luICgpIHtcclxuICAgICAgICBpZiAoc2VsZi5vcmlnaW5hbExpbmsuZ2V0KCdoaWdobGlnaHRlZCcpKSB7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0KCdoaWdobGlnaHRlZCcsIHRydWUsIHsgc2lsZW50OiB0cnVlIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0KCdoaWdobGlnaHRlZCcsIGZhbHNlLCB7IHNpbGVudDogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNlbGYub3JpZ2luYWxMaW5rLmdldCgnYmx1cmVkJykpIHtcclxuICAgICAgICAgICAgc2VsZi5zZXQoJ2JsdXJlZCcsIHRydWUsIHsgc2lsZW50OiB0cnVlIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0KCdibHVyZWQnLCBmYWxzZSwgeyBzaWxlbnQ6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNlbGYubW9kZWwgPSB7IHNvdXJjZTogb3B0aW9ucy5zb3VyY2UuaWQsIHRhcmdldDogb3B0aW9ucy50YXJnZXQuaWQgfTtcclxuICAgIHNlbGYucmVmcmVzaEhpZ2hsaWdodGluZygpO1xyXG5cclxuICAgIGNvbnN0IG9uUmVtb3ZlID0gc2VsZi5yZW1vdmU7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBsaW5rIGZyb20gdGhlIHBhcGVyLlxyXG4gICAgICogQG1lbWJlcm9mIFRlcm1pbmF0aW9uTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2VsZi5vcmlnaW5hbExpbmsudGVybWluYXRpb25MaW5rcy5pbmRleE9mKHNlbGYpO1xyXG4gICAgICAgIHNlbGYub3JpZ2luYWxMaW5rLnRlcm1pbmF0aW9uTGlua3Muc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICBvblJlbW92ZS5jYWxsKHNlbGYpO1xyXG4gICAgfTtcclxufVxyXG5UZXJtaW5hdGlvbkxpbmsucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShqb2ludC5kaWEuTGluay5wcm90b3R5cGUpO1xyXG5cclxuXHJcbiIsImltcG9ydCAqIGFzIGpvaW50IGZyb20gJ3JhcHBpZCc7XHJcbmltcG9ydCB7IFJlc291cmNlUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9kYXRhL3Jlc291cmNlUHJvdmlkZXInO1xyXG5pbXBvcnQgeyBaX0lOREVYRVMgfSBmcm9tICcuL2VsZW1lbnRzJztcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBUZXJtaW5hdGlvbk5vZGVNb2RlbCAtIGRhdGEgbW9kZWwgb2YgYSBUZXJtaW5hdGlvbk5vZGUgb2JqZWN0XHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRlcm1pbmF0aW9uTm9kZU1vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7UG9pbnR9IHBvc2l0aW9uIC0gTm9kZSBpZGVudGlmeWVyXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZX0gbm9kZSAtIE9yaWdpbmFsIG5vZGVcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBUaGUgZ3JhcGggVGVybWluYXRpb25Ob2RlIGJhc2VkIG9uIGpvaW50LnNoYXBlcy5iYXNpYy5SZWN0LlxyXG4gKiBAY2xhc3NcclxuICogQGF1Z21lbnRzIGpvaW50LnNoYXBlcy5iYXNpYy5SZWN0XHJcbiAqIFxyXG4gKiBAcGFyYW0ge1Rlcm1pbmF0aW9uTm9kZU1vZGVsfSBvcHRpb25zIC0gRGF0YSBtb2RlbFxyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSBUaGUgc2V0IG9mIHBhcmFtZXRlcnNcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZX0gb3JpZ2luYWxOb2RlIC0gVGhlIG9yaWdpbmFsIG5vZGUsXHJcbiAqIHdoaWNoIGlzIG91dCBvZiB0aGUgdmlld0ZyYW1lIHNvIHdlIHVzZSB0ZXJtaW5hdGlvbiBpbnN0ZWFkXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZVtdfSByZWxhdGVkIC0gTGlzdCBvZiB0aGUgbm9kZXMgcmVsYXRlZCB3aXRoIHRoaXMgbm9kZVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhpZ2hsaWdodGVkIC0gVGVsbHMgd2hldGVyIGhpZ2hsaWdodGVkIG5vZGUgb3Igbm90ICh1c2UgbWV0aG9kIGdldCB0byBnZXQgdGhpcyBwcm9wZXJ0eSwgZS5nLiBub2RlLmdldCgnaGlnaGxpZ2h0ZWQnKSlcclxuICogQHByb3BlcnR5IHtib29sZWFufSBibHVyZWQgLSBUZWxscyB3aGV0ZXIgYmx1cmVkIG5vZGUgb3Igbm90ICh1c2UgbWV0aG9kIGdldCB0byBnZXQgdGhpcyBwcm9wZXJ0eSwgZS5nLiBub2RlLmdldCgnYmx1cmVkJykpXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcmVtb3ZlZCAtIElzIHRoZSBub2RlIHJlbW92ZWQgZnJvbSB0aGUgcGFwZXJcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFRlcm1pbmF0aW9uTm9kZSAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICBjb25zdCBfcmVzID0gbmV3IFJlc291cmNlUHJvdmlkZXIocGFyYW1ldGVycyk7XHJcbiAgICBcclxuICAgIHNlbGYub3JpZ2luYWxOb2RlID0gb3B0aW9ucy5ub2RlO1xyXG4gICAgc2VsZi5oaWdobGlnaHRlZCA9IGZhbHNlO1xyXG4gICAgc2VsZi5ibHVyZWQgPSBmYWxzZTtcclxuICAgIHNlbGYucmVsYXRlZCA9IFtdO1xyXG4gICAgc2VsZi5zaXplID0gcGFyYW1ldGVycy50ZXJtaW5hdGlvbk5vZGVTaXplO1xyXG4gICAgXHJcbiAgICBvcHRpb25zLm5vZGUudGVybWluYXRpb25Ob2Rlcy5wdXNoKHNlbGYpO1xyXG5cclxuICAgIGpvaW50LnNoYXBlcy5iYXNpYy5HZW5lcmljLmFwcGx5KHNlbGYsIFt7XHJcbiAgICAgICAgbWFya3VwOiBgPGcgY2xhc3M9XCJyb3RhdGFibGVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZyBjbGFzcz1cInNjYWxhYmxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWN0IGNsYXNzPVwiYm9keVwiLz5cclxuICAgICAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICAgICAgICAgPHJlY3QgY2xhc3M9XCJ0cS1sZy1ib2R5XCIvPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZXh0Lz5cclxuICAgICAgICAgICAgICAgIDwvZz5gLFxyXG4gICAgICAgIHR5cGU6ICd0ZXJtaW5hdGlvbi1ub2RlJyxcclxuICAgICAgICBwb3NpdGlvbjogb3B0aW9ucy5wb3NpdGlvbixcclxuICAgICAgICBzaXplOiBwYXJhbWV0ZXJzLnRlcm1pbmF0aW9uTm9kZVNpemUsXHJcbiAgICAgICAgYXR0cnM6IHsgXHJcbiAgICAgICAgICAgICcuYm9keSc6IHtcclxuICAgICAgICAgICAgICAgIHBvcnQ6ICdjbGlwUmVjdFBvcnQnLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAwLFxyXG4gICAgICAgICAgICAgICAgcng6IDEwLFxyXG4gICAgICAgICAgICAgICAgcnk6IDEwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLnRxLWxnLWJvZHknOiB7XHJcbiAgICAgICAgICAgICAgICAncmVmLXgnOiAuNSxcclxuICAgICAgICAgICAgICAgICdyZWYteSc6IC41LFxyXG4gICAgICAgICAgICAgICAgJ3gtYWxpZ25tZW50JzogJ21pZGRsZScsXHJcbiAgICAgICAgICAgICAgICAneS1hbGlnbm1lbnQnOiAnbWlkZGxlJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBwYXJhbWV0ZXJzLnRlcm1pbmF0aW9uTm9kZVNpemUud2lkdGggLSAxMCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyYW1ldGVycy50ZXJtaW5hdGlvbk5vZGVTaXplLmhlaWdodCAtIDEwLFxyXG4gICAgICAgICAgICAgICAgcmVmOiAnLmJvZHknLFxyXG4gICAgICAgICAgICAgICAgcng6IDIsXHJcbiAgICAgICAgICAgICAgICByeTogMixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogX3Jlcy5nZXRDb2xvcihvcHRpb25zLm5vZGUubW9kZWwudHlwZUlkKSxcclxuICAgICAgICAgICAgICAgIGZpbGw6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgICAgICBwb3J0OiAnY2xpcFJlY3RQb3J0JyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGV4dDoge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogJ9ChJyxcclxuICAgICAgICAgICAgICAgIGZpbGw6IF9yZXMuZ2V0Q29sb3Iob3B0aW9ucy5ub2RlLm1vZGVsLnR5cGVJZCksXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IF9yZXMuZ2V0Q29sb3Iob3B0aW9ucy5ub2RlLm1vZGVsLnR5cGVJZCksXHJcbiAgICAgICAgICAgICAgICAncmVmLXgnOiAuNSxcclxuICAgICAgICAgICAgICAgICdyZWYteSc6IC41NSxcclxuICAgICAgICAgICAgICAgIHJlZjogJy5ib2R5JyxcclxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IHNlbGYub3JpZ2luYWxOb2RlLm1vZGVsLmxhYmVsIC8vIHNlZSB0aGUgbGluZSAyMjEgYXQgbGluZWFnZUdyYW0uanNcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfSxcclxuICAgICAgICB6OiBaX0lOREVYRVMuVEVSTUlOQVRJT05fRUxFTUVOVCxcclxuICAgIH1dKTtcclxuXHJcbiAgICBsZXQgX2lzRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgY29uc3Qgb2xkUG9zaXRpb24gPSBzZWxmLnBvc2l0aW9uO1xyXG4gICAgc2VsZi5wb3NpdGlvbiA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgX2lzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBvbGRQb3NpdGlvbi5jYWxsKHNlbGYsIHgsIHkpO1xyXG4gICAgICAgIF9pc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIHNlbGYub24oJ2NoYW5nZTpwb3NpdGlvbicsICgpID0+IHtcclxuICAgICAgICBpZiAoX2lzRHJhZ2dpbmcpIHNlbGYuc2V0KCdkcmFnZ2VkJywgX2lzRHJhZ2dpbmcpO1xyXG4gICAgfSk7XHJcbiAgICBzZWxmLm9uKCdjaGFuZ2U6ZHJhZ2dlZCcsICgpID0+IHtcclxuICAgICAgICBjb25zdCBvbGRTaXplID0gc2VsZi5zaXplO1xyXG4gICAgICAgIGNvbnN0IG9sZFBvcyA9IHNlbGYucG9zaXRpb24oKTtcclxuXHJcbiAgICAgICAgaWYgKHNlbGYuZ2V0KCdkcmFnZ2VkJykpIHtcclxuICAgICAgICAgICAgc2VsZi5zaXplID0ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHNlbGYub3JpZ2luYWxOb2RlLnNpemUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICBzZWxmLm9yaWdpbmFsTm9kZS5zaXplLmhlaWdodCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgc2VsZi5hdHRyKHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnKycsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3JlZi15JzogLjUxLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICcuYm9keSc6IHtcclxuICAgICAgICAgICAgICAgICAgICByeDogMCxcclxuICAgICAgICAgICAgICAgICAgICByeTogMCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZWxmLnJlc2l6ZShzZWxmLnNpemUud2lkdGgsIHNlbGYuc2l6ZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICBzZWxmLnBvc2l0aW9uKFxyXG4gICAgICAgICAgICAgICAgb2xkUG9zLnggLSAoc2VsZi5zaXplLndpZHRoIC0gb2xkU2l6ZS53aWR0aCkgLyAyLFxyXG4gICAgICAgICAgICAgICAgb2xkUG9zLnkgLSAoc2VsZi5zaXplLmhlaWdodCAtIG9sZFNpemUuaGVpZ2h0KSAvIDIsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZi5zaXplID0ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHBhcmFtZXRlcnMudGVybWluYXRpb25Ob2RlU2l6ZS53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyYW1ldGVycy50ZXJtaW5hdGlvbk5vZGVTaXplLmhlaWdodCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgc2VsZi5hdHRyKHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnQycsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3JlZi15JzogLjU1LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICcuYm9keSc6IHtcclxuICAgICAgICAgICAgICAgICAgICByeDogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgcnk6IDEwLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNlbGYucmVzaXplKHNlbGYuc2l6ZS53aWR0aCwgc2VsZi5zaXplLmhlaWdodCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzZWxmLnBvc2l0aW9uKFxyXG4gICAgICAgICAgICAgICAgb2xkUG9zLnggKyAoc2VsZi5zaXplLndpZHRoIC0gb2xkU2l6ZS53aWR0aCkgLyAyLFxyXG4gICAgICAgICAgICAgICAgb2xkUG9zLnkgKyAoc2VsZi5zaXplLmhlaWdodCAtIG9sZFNpemUuaGVpZ2h0KSAvIDIsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIaWdobGlnaHRzIHRoZSBUZXJtaW5hdGlvbk5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgLSBCb29sZWFuIGZsYWcgdG8gcHJvdGVjdCBjb2RlIGZyb20gcmVjdXJzaW9uIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbk5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnNlbGVjdCA9IGZ1bmN0aW9uIChvbmNlKSB7XHJcbiAgICAgICAgaWYgKHNlbGYub3JpZ2luYWxOb2RlICYmICFvbmNlKSBzZWxmLm9yaWdpbmFsTm9kZS5zZWxlY3QodHJ1ZSk7XHJcbiAgICAgICAgaWYgKHNlbGYuZ2V0KCdibHVyZWQnKSkgc2VsZi51bmJsdXJlKCk7XHJcbiAgICAgICAgaWYgKHNlbGYuZ2V0KCdoaWRkZW4nKSkgc2VsZi5zaG93KCk7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLlNFTEVDVEVEX0VMRU1FTlQgfSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZ2hsaWdodGVkJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgaGlnaGxpZ2h0aW5nIGZyb20gdGhlIFRlcm1pbmF0aW9uTm9kZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSAtIEJvb2xlYW4gZmxhZyB0byBwcm90ZWN0IGNvZGUgZnJvbSByZWN1cnNpb24gKG9wdGlvbmFsKVxyXG4gICAgICogQG1lbWJlcm9mIFRlcm1pbmF0aW9uTm9kZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYudW5zZWxlY3QgPSBmdW5jdGlvbiAob25jZSkge1xyXG4gICAgICAgIGlmIChzZWxmLm9yaWdpbmFsTm9kZSAmJiAhb25jZSkgc2VsZi5vcmlnaW5hbE5vZGUudW5zZWxlY3QodHJ1ZSk7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLlRFUk1JTkFUSU9OX0VMRU1FTlQgfSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZ2hsaWdodGVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgIC8qKlxyXG4gICAgICogQmx1cnMgdGhlIFRlcm1pbmF0aW9uTm9kZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSAtIEJvb2xlYW4gZmxhZyB0byBwcm90ZWN0IGNvZGUgZnJvbSByZWN1cnNpb24gKG9wdGlvbmFsKVxyXG4gICAgICogQG1lbWJlcm9mIFRlcm1pbmF0aW9uTm9kZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi8gICAgXHJcbiAgICBzZWxmLmJsdXJlID0gZnVuY3Rpb24gKG9uY2UpIHtcclxuICAgICAgICBpZiAoc2VsZi5nZXQoJ2hpZ2hsaWdodGVkJykpIHJldHVybjtcclxuICAgICAgICBpZiAoc2VsZi5vcmlnaW5hbE5vZGUgJiYgIW9uY2UpIHNlbGYub3JpZ2luYWxOb2RlLmJsdXJlKHRydWUpO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5CTFVSRURfTk9ERSB9KTsgICAgICAgIFxyXG4gICAgICAgIHNlbGYuc2V0KCdibHVyZWQnLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGJsdXIgZnJvbSB0aGUgVGVybWluYXRpb25Ob2RlLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvbmNlIC0gQm9vbGVhbiBmbGFnIHRvIHByb3RlY3QgY29kZSBmcm9tIHJlY3Vyc2lvbiAob3B0aW9uYWwpXHJcbiAgICAgKiBAbWVtYmVyb2YgVGVybWluYXRpb25Ob2RlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi51bmJsdXJlID0gZnVuY3Rpb24gKG9uY2UpIHtcclxuICAgICAgICBpZiAoc2VsZi5vcmlnaW5hbE5vZGUgJiYgIW9uY2UpIHNlbGYub3JpZ2luYWxOb2RlLnVuYmx1cmUodHJ1ZSk7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLlRFUk1JTkFUSU9OX0VMRU1FTlQgfSk7ICAgICAgICBcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgIC8qKlxyXG4gICAgICogQmx1cnMgdGhlIFRlcm1pbmF0aW9uTm9kZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSAtIEJvb2xlYW4gZmxhZyB0byBwcm90ZWN0IGNvZGUgZnJvbSByZWN1cnNpb24gKG9wdGlvbmFsKVxyXG4gICAgICogQG1lbWJlcm9mIFRlcm1pbmF0aW9uTm9kZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi8gICAgXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAob25jZSkge1xyXG4gICAgICAgIGlmIChzZWxmLm9yaWdpbmFsTm9kZSAmJiAhb25jZSkgc2VsZi5vcmlnaW5hbE5vZGUuaGlkZSh0cnVlKTsgICAgIFxyXG4gICAgICAgIHNlbGYuc2V0KCdoaWRkZW4nLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBibHVyIGZyb20gdGhlIFRlcm1pbmF0aW9uTm9kZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSAtIEJvb2xlYW4gZmxhZyB0byBwcm90ZWN0IGNvZGUgZnJvbSByZWN1cnNpb24gKG9wdGlvbmFsKVxyXG4gICAgICogQG1lbWJlcm9mIFRlcm1pbmF0aW9uTm9kZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuc2hvdyA9IGZ1bmN0aW9uIChvbmNlKSB7XHJcbiAgICAgICAgaWYgKHNlbGYub3JpZ2luYWxOb2RlICYmICFvbmNlKSBzZWxmLm9yaWdpbmFsTm9kZS5zaG93KHRydWUpOyAgICBcclxuICAgICAgICBzZWxmLnNldCgnaGlkZGVuJywgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoZXMgaGlnaGxpZ2h0ZXJzIG9mIHRoZSB2aWV3IG9mIHRoaXMgZWxlbWVudC5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5yZWZyZXNoSGlnaGxpZ2h0aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zeW5jaHJvbml6ZVdpdGhPcmlnaW4oKTtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3JlZnJlc2gtaGlnaGxpZ2h0aW5nJywgc2VsZik7ICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX3N5bmNocm9uaXplV2l0aE9yaWdpbiAoKSB7XHJcbiAgICAgICAgaWYgKHNlbGYub3JpZ2luYWxOb2RlLmdldCgnaGlnaGxpZ2h0ZWQnKSkge1xyXG4gICAgICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCB0cnVlLCB7IHNpbGVudDogdHJ1ZSB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCBmYWxzZSwgeyBzaWxlbnQ6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWxmLm9yaWdpbmFsTm9kZS5nZXQoJ2JsdXJlZCcpKSB7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0KCdibHVyZWQnLCB0cnVlLCB7IHNpbGVudDogdHJ1ZSB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgZmFsc2UsIHsgc2lsZW50OiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvblJlbW92ZSA9IHNlbGYucmVtb3ZlO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgbm9kZSBmcm9tIHRoZSBwYXBlci5cclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbk5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHNlbGYub3JpZ2luYWxOb2RlLnRlcm1pbmF0aW9uTm9kZXMuaW5kZXhPZihzZWxmKTtcclxuICAgICAgICBzZWxmLm9yaWdpbmFsTm9kZS50ZXJtaW5hdGlvbk5vZGVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgb25SZW1vdmUuY2FsbChzZWxmKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5yZWZyZXNoSGlnaGxpZ2h0aW5nKCk7XHJcbn1cclxuVGVybWluYXRpb25Ob2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoam9pbnQuc2hhcGVzLmJhc2ljLlJlY3QucHJvdG90eXBlKTsiLCJpbXBvcnQgKiBhcyBqb2ludCBmcm9tICdyYXBwaWQnO1xyXG5pbXBvcnQgc2F2ZUFzIGZyb20gJ2ZpbGUtc2F2ZXJqcyc7XHJcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuXHJcbmltcG9ydCB7IFZpZXdNYW5hZ2VyLCBGUkFNRV9PVVRfTUFSR0lOLCBESVNUQU5DRV9CRVRXRUVOX0ZSQU1FUyB9IGZyb20gJy4vdmlld01hbmFnZXInO1xyXG5pbXBvcnQgeyBSb3V0aW5nTWFuYWdlciB9IGZyb20gJy4vbGlua1JvdXRpbmdNYW5hZ2VyL3JvdXRpbmdNYW5hZ2VyJztcclxuaW1wb3J0IHsgVmlld0ZyYW1lIH0gZnJvbSAnLi92aWV3RnJhbWUnO1xyXG5pbXBvcnQgeyBOb2RlLCBMaW5rLCBUZXJtaW5hdGlvbk5vZGUsIE5vZGVWaWV3LCBMaW5rVmlldywgQXNwZWN0TGluayB9IGZyb20gJy4vZ3JhcGhFbGVtZW50cy9lbGVtZW50cyc7XHJcbmltcG9ydCBWaWV3RnJhbWVzVUkgZnJvbSAnLi4vaHRtbFVJL3ZpZXdGcmFtZXNVSSc7XHJcbmltcG9ydCBTdWJzY3JpYmFibGUgZnJvbSAnLi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGUnO1xyXG5pbXBvcnQgeyBleHBvcnRUb1NWRywgdG9EYXRhVVJMIH0gZnJvbSAnLi90b1N2Zyc7XHJcbmltcG9ydCB7IGNvbWJpbmVPcGVyYXRpb24gfSBmcm9tICcuLi9sYXlvdXQvbGF5b3V0JztcclxuaW1wb3J0IHtcclxuICAgIGRhdGUyU3RyaW5nLFxyXG4gICAgcG5nMkJsb2IsXHJcbiAgICBnZXRCYXNlRWxlbWVudFxyXG59IGZyb20gJy4uL3V0aWxzL2RhdGFVdGlscyc7XHJcbmltcG9ydCB7XHJcbiAgICBsaW1pdFBvaW50UG9zaXRpb24sXHJcbiAgICBnZXREaXN0LFxyXG4gICAgZ2V0RGlmZixcclxuICAgIGxvY2FsVG9HbG9iYWxQb2ludCxcclxuICAgIGdldEdsb2JhbE5vZGVQb3NpdGlvbixcclxuICAgIGdldEdsb2JhbE5vZGVTaXplLFxyXG4gICAgZ2xvYmFsVG9TY2FsZWRTaXplLFxyXG59IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHsgZ2V0UGF0aCwgZ2V0Vmlld0ZyYW1lSWRGb3JOb2RlIH0gZnJvbSAnLi4vdXRpbHMvbGluZWFnZURpYWdyYW1VdGlscyc7XHJcblxyXG5jb25zdCBESVJFQ1RJT04gPSB7XHJcbiAgICBVUDogMzgsXHJcbiAgICBET1dOOiA0MCxcclxuICAgIExFRlQ6IDM3LFxyXG4gICAgUklHSFQ6IDM5LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiBNYW5hZ2VzIHRoZSBtYWluIHZpZXcgb2YgYXBwbGljYXRpb24gKFZpZXctMilcclxuICogQWxsIGNoYW5nZXMgZ29lcyB0aHJvdWdoIHRoZSByZW5kZXIgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIENvbnN0cnVjdG9yIHBhcmFtZXRlcnM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQHBhcmFtIHtcclxuICogIGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJcclxuICogIGdyYXBoUGxhY2U6IEhUTUxFbGVtZW50XHJcbiAqICB2aWV3RnJhbWVzOiBWaWV3RnJhbWVNb2RlbHNcclxuICogfSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIHBhcmFtZXRlcnMgc2V0XHJcbiAqXHJcbiAqIFB1YmxpYyBwcm9wZXJ0aWVzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIHNlbGVjdGVkRWxlbWVudDogTm9kZXxMaW5rXHJcbiAqXHJcbiAqIFB1YmxpYyBtZXRob2RzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIHJlZHJhdzogKG9wdGlvbnM6IHtcclxuICAgIHZpZXdGcmFtZXM6IFZpZXdGcmFtZVB1YmxpY01vZGVsW107XHJcbiAgICBzZWxlY3RlZEVsZW1lbnQ6IChOb2RlfExpbmspO1xyXG4gICAgcGF0aDogeyBbaWQ6IHN0cmluZ106IChOb2RlfExpbmspIH07XHJcbiAgICBxdWlja1VwZGF0ZTogYm9vbGVhbjtcclxuICAgIHVwZGF0ZUJvdW5kczogYm9vbGVhbjtcclxuICAgIHBhcGVyT3B0aW9uczoge1xyXG4gICAgICAgIG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbjtcclxuICAgICAgICB3aWR0aDogbnVtYmVyO1xyXG4gICAgICAgIGhlaWdodDpudW1iZXI7XHJcbiAgICAgICAgc2NhbGU6IFBvaW50O1xyXG4gICAgfTtcclxuICAgIGVsZW1lbnRPcHRpb25zOiB7XHJcbiAgICAgICAgZWxlbWVudFNpemU6IEVsZW1lbnRTaXplO1xyXG4gKiB9KSA9PiB2b2lkO1xyXG4gKiBkZWxheWVkUmVkcmF3OiAob3B0aW9uczogeyAuLi4gc2VlIHJlZHJhd30pID0+IHZvaWQ7XHJcbiAqIG9wZW5WaWV3RnJhbWU6IChpZDpzdHJpbmcpID0+IHZvaWQ7XHJcbiAqIGNsb3NlVmlld0ZyYW1lOiAoaWQ6c3RyaW5nKSA9PiB2b2lkO1xyXG4gKiBvcGVuT3ZlclZpZXdGcmFtZTogKCkgPT4gdm9pZDtcclxuICogY2xvc2VPdmVyVmlld0ZyYW1lOiAoKSA9PiB2b2lkO1xyXG4gKiB1cGRhdGVOb2Rlc1Bvc2l0aW9uczogKG5vZGVzOiBOb2RlW10pID0+IHZvaWQ7XHJcbiAqIGNvbWJpbmU6ICgpID0+IHZvaWQ7XHJcbiAqIHJlc2V0TGF5b3V0OiAoKSA9PiB2b2lkO1xyXG4gKiByZWZyZXNoOiAoKSA9PiB2b2lkO1xyXG4gKiBnZXRTZWxlY3RlZEVsZW1lbnQ6ICgpID0+IChOb2RlfExpbmspO1xyXG4gKiBnZXRWaXNpYmxlQ2VsbHM6ICgpID0+IChOb2RlfExpbmt8Vmlld0ZyYW1lfFRlcm1pbmF0aW9uTm9kZXxUZXJtaW5hdGlvbkxpbmspO1xyXG4gKiBnZXRWaXNpYmxlTm9kZXM6ICgpID0+IChOb2RlfFZpZXdGcmFtZXxUZXJtaW5hdGlvbk5vZGUpO1xyXG4gKiBnZXRWaXNpYmxlTGlua3M6ICgpID0+IChMaW5rfFRlcm1pbmF0aW9uTGluayk7XHJcbiAqIHNldFNlbGVjdGVkRWxlbWVudDogKGVsZW1lbnQ6IChOb2RlfExpbmt8dW5kZWZpbmVkKSwgZm9jdXNPbjogYm9vbGVhbikgPT4gdm9pZDtcclxuICogcG9zaXRpb25WaWV3UG9ydDogKHZmOiBWaWV3RnJhbWVQdWJsaWNNb2RlbCwgcG9pbnQ6IFBvaW50LCBhbmltYXRpb246IGJvb2xlYW4pID0+IHZvaWQ7XHJcbiAqIGV4cG9ydDogKCkgPT4gdm9pZDtcclxuICogcHJpbnQ6ICgpID0+IHZvaWQ7XHJcbiAqIHNldERhdGE6IChkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzOiBWaWV3RnJhbWVEZWZpbml0aW9uW10pID0+IHZvaWQ7XHJcbiAqIHNjYWxlOiAoc2NhbGU6IFBvaW50KSA9PiB2b2lkOyAtIFNldHMgYW5kIGxpbWl0cyB2YWx1ZSBvZiB0aGUgc2NhbGUgb2YgdGhlIGdyYXBoXHJcbiAqIHpvb21JbjogKCkgPT4gdm9pZDtcclxuICogem9vbU91dDogKCkgPT4gdm9pZDtcclxuICogem9vbVRvRml0OiAoKSA9PiB2b2lkO1xyXG4gKiBzZXRPcmllbnRhdGlvbjogKG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbikgPT4gdm9pZDsgVmFsdWVzOiAnbGVmdC10by1yaWdodCcsICdyaWdodC10by1sZWZ0JywgJ3RvcC10by1ib3R0b20nLCAnYm90dG9tLXRvLXRvcCdcclxuICogZ2V0Vmlld0ZyYW1lczogKCkgPT4gVmlld0ZyYW1lUHVibGljTW9kZWxbXTtcclxuICogdHJhbnNsYXRlVmlld1BvcnQgKHZmOiBWaWV3RnJhbWUsIGR4OiBudW1iZXIsIGR5OiBudW1iZXIsIGFuaW1hdGlvbjogYm9vbGVhbilcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBvbiAoZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6IGZ1bmN0aW9uKSA9PiB2b2lkXHJcbiAqIHVuc3Vic2NyaWJlIChjYWxsYmFjazogZnVuY3Rpb24pID0+IHZvaWRcclxuICogdHJpZ2dlciAoZXZlbnQ6IHN0cmluZywgcGFyYW1ldGVyczogYW55KSA9PiB2b2lkXHJcbiAqXHJcbiAqIEV2ZW50czpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAZmlyZXMgc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkIChOb2RlfExpbmspXHJcbiAqIEBmaXJlcyBzY2FsZS1jaGFuZ2VkIChzY2FsZSlcclxuICogQGZpcmVzIHZpZXctZnJhbWVzLXN0YXRlLWNoYW5nZWQgKFZpZXdGcmFtZSwgYm9vbGVhbilcclxuICogQGZpcmVzIHZpZXctZnJhbWVzLXNpemUtb3ItcG9zaXRpb24tY2hhbmdlZCAoVmlld0ZyYW1lLCBib29sZWFuKVxyXG4gKiBAZmlyZXMgY2VsbC1kb3VibGUtY2xpY2sgKGNlbGwpXHJcbiAqIEBmaXJlcyBjZWxsLXNpbmdsZS1jbGljayAoY2VsbClcclxuICogQGZpcmVzIGxpbmstb3B0aW9ucy1jbGljayAoTGluaylcclxuICogQGZpcmVzIG5vZGVzLXBvc2l0aW9uLWNoYW5nZWRcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExpbmVhZ2VEaWFncmFtIChvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICAvLyBJbml0XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7ICAgLy8gbWFrZSB0aGlzIGNsYXNzIFN1YnNjcmliYWJsZVxyXG5cclxuICAgIGNvbnN0IF9iYXNlID0gX2NyZWF0ZUJhc2Uob3B0aW9ucy5ncmFwaFBsYWNlKTtcclxuXHJcbiAgICAvLyBDcmVhdGluZyBhIGpvaW50IGdyYXBoIGFuZCBqb2ludCBwYXBlclxyXG4gICAgY29uc3QgX2dyYXBoID0gbmV3IGpvaW50LmRpYS5HcmFwaCgpO1xyXG4gICAgY29uc3QgX3BhcGVyID0gbmV3IGpvaW50LmRpYS5QYXBlcih7XHJcbiAgICAgICAgZWw6IF9iYXNlLmRpYWdyYW0sXHJcbiAgICAgICAgbW9kZWw6IF9ncmFwaCxcclxuICAgICAgICBlbGVtZW50VmlldzogTm9kZVZpZXcsXHJcbiAgICAgICAgbGlua1ZpZXc6IExpbmtWaWV3LFxyXG4gICAgICAgIGdyaWRTaXplOiAxLFxyXG4gICAgICAgIGludGVyYWN0aXZlOiAoKSA9PiB7IHJldHVybiB7IHZlcnRleEFkZDogZmFsc2UgfTsgfSxcclxuICAgICAgICBwcmV2ZW50Q29udGV4dE1lbnU6IGZhbHNlLFxyXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgX3NjYWxlID0gcGFyYW1ldGVycy5kZWZhdWx0U2NhbGU7XHJcbiAgICBsZXQgX2RhdGFDb250YWluZXI7XHJcblxyXG4gICAgbGV0IF9vcmllbnRhdGlvbiA9IHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbjtcclxuICAgIGxldCBfZnVsbFNjcmVlbk1vZGUgPSBwYXJhbWV0ZXJzLmZ1bGxTY3JlZW5Nb2RlO1xyXG4gICAgbGV0IF9wYXRoID0gbnVsbDsgLy8gaGlnaGxpZ2h0aW5nIHBhdGhcclxuICAgIGxldCBfbWFzayA9IHBhcmFtZXRlcnMubWFzazsgLy8gaGlnaGxpZ2h0aW5nIHBhdGhcclxuICAgIGxldCBfc2VsZWN0ZWRFbGVtZW50ID0gbnVsbDtcclxuICAgIGxldCBfcm91dGluZ01hbmFnZXI7XHJcbiAgICBsZXQgX3ZpZXdGcmFtZXNVSTtcclxuICAgIGxldCBfdmlld01hbmFnZXI7XHJcbiAgICBcclxuXHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIGNvbnN0IF9rZXlib2FyZCA9IG5ldyBqb2ludC51aS5LZXlib2FyZCgpO1xyXG4gICAgY29uc3QgX3NjYWxlQm91bmRzID0gXy5jbG9uZShwYXJhbWV0ZXJzLnNjYWxlQm91bmRzKTtcclxuICAgIGNvbnN0IF9vdmVyVmlld1NjYWxlQm91bmRzID0gXy5jbG9uZShwYXJhbWV0ZXJzLm92ZXJWaWV3U2NhbGVCb3VuZHMpO1xyXG4gICAgY29uc3QgX3NjYWxlU3RlcCA9IHBhcmFtZXRlcnMuc2NhbGVTdGVwO1xyXG5cclxuXHJcbiAgICBfc2V0RGF0YShvcHRpb25zLmRhdGFDb250YWluZXIsIG9wdGlvbnMudmlld0ZyYW1lcyk7XHJcbiAgICBfc3Vic2NyaWJlT25FdmVudHMoKTtcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdpbmcgb3B0aW9ucyAoZGVwcmVjYXRlZClcclxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IERyYXdpbmdPcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHF1aWNrVXBkYXRlIC0gZG9uJ3QgdXBkYXRlcyBsaW5rcyBhbmQgcmVtb3ZlIHRoZW0uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5IG9mIFZpZXdGcmFtZX0gdmlld0ZyYW1lcyAtIHVwZGF0ZSBvbmx5IGxpbWl0dGVkIG51bWJlciBvZiB2aWV3RnJhbWVzLlxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBncmFwaCdzIHN0YXRlLCAtIEFkZC9yZW1vdmVcclxuICAgICAqIHZpc2libGUgTm9kZXMgYW5kIFRlcm1pbmF0aW9uTm9kZXNcclxuICAgICAqIEBwYXJhbSB7RHJhd2luZ09wdGlvbnN9IG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgc2VsZi5yZWRyYXcgPSBfcmVkcmF3O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTYW1lIGFzIHJlZHJhdyBidXQgaXQncyBxdWljayB1cGRhdGVcclxuICAgICAqIHdpdGggZGVsYXllZCBmdWxsIHJlZHJhdyAoZGVib3VuY2VyKS5cclxuICAgICAqL1xyXG4gICAgc2VsZi5kZWxheWVkUmVkcmF3ID0gX2RlbGF5ZWRSZWRyYXc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBWaWV3RnJhbWUgd2l0aCBzcGVjaWZpZWQgaWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3RnJhbWVJZFxyXG4gICAgICovXHJcbiAgICBzZWxmLm9wZW5WaWV3RnJhbWUgPSBfb3BlblZpZXdGcmFtZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsb3NlcyBWaWV3RnJhbWUgd2l0aCBzcGVjaWZpZWQgaWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3RnJhbWVJZFxyXG4gICAgICovXHJcbiAgICBzZWxmLmNsb3NlVmlld0ZyYW1lID0gX2Nsb3NlVmlld0ZyYW1lO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyBtb2RlIGZ1bGxTY3JlZW4vdmlld0ZyYW1lLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxyXG4gICAgKi9cclxuICAgIHNlbGYuc2V0RnVsbFNjcmVlbk1vZGUgPSBfc2V0RnVsbFNjcmVlbk1vZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBPdmVyVmlld0ZyYW1lXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmlld0ZyYW1lSWRcclxuICAgICAqL1xyXG4gICAgc2VsZi5vcGVuT3ZlclZpZXdGcmFtZSA9ICgpID0+IF9vcGVuVmlld0ZyYW1lKF92aWV3TWFuYWdlci5nZXRPdmVyVmlld0ZyYW1lKCkuaWQpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIE92ZXJWaWV3RnJhbWVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3RnJhbWVJZFxyXG4gICAgICovXHJcbiAgICBzZWxmLmNsb3NlT3ZlclZpZXdGcmFtZSA9ICgpID0+IF9jbG9zZVZpZXdGcmFtZShfdmlld01hbmFnZXIuZ2V0T3ZlclZpZXdGcmFtZSgpLmlkKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgbGF5b3V0IHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMgdXNpbmcgcGFwZXIgcG9zaXRpb25zXHJcbiAgICAgKiBAcGFyYW0ge05vZGVbXX0gbm9kZXNcclxuICAgICAqL1xyXG4gICAgc2VsZi51cGRhdGVOb2Rlc1Bvc2l0aW9ucyA9IF91cGRhdGVOb2Rlc1Bvc2l0aW9ucztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdyb3VwcyBub2RlcyBhcm91bmQgc2VsZWN0ZWRcclxuICAgICAqIGFuZCBoaWdobGlnaHRzIG5laWdoYm91cnNcclxuICAgICAqL1xyXG4gICAgc2VsZi5jb21iaW5lID0gX2NvbWJpbmU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXN0b3JlIG5vZGVzIHBvc2l0aW9uc1xyXG4gICAgICovXHJcbiAgICBzZWxmLnJlc2V0TGF5b3V0ID0gX3Jlc2V0TGF5b3V0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIGFsbCB2aWV3RnJhbWVzIGJvdW5kcy5cclxuICAgICAqL1xyXG4gICAgc2VsZi5yZWZyZXNoID0gX3JlZnJlc2g7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7Tm9kZXxMaW5rfS5cclxuICAgICovXHJcbiAgICBzZWxmLmdldFNlbGVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3NlbGVjdGVkRWxlbWVudDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7KE5vZGV8TGlua3xWaWV3RnJhbWV8VGVybWluYXRpb25Ob2RlfFRlcm1pbmF0aW9uTGluayl9LlxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0VmlzaWJsZUNlbGxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfZ3JhcGguZ2V0Q2VsbHMoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7KE5vZGV8Vmlld0ZyYW1lfFRlcm1pbmF0aW9uTm9kZSl9LlxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0VmlzaWJsZU5vZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfZ3JhcGguZ2V0RWxlbWVudHMoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7KExpbmt8VGVybWluYXRpb25MaW5rKX0uXHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRWaXNpYmxlTGlua3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9ncmFwaC5nZXRMaW5rcygpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgc2VsZWN0ZWQgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtOb2RlfExpbmt8dW5kZWZpbmVkfS5cclxuICAgICovXHJcbiAgICBzZWxmLnNldFNlbGVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBmb2N1c09uKSB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgX3NlbGVjdChlbGVtZW50LCBmb2N1c09uKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfdW5zZWxlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgc2V0cyBvZmZzZXQgZm9yIGFsbCBlbGVtZW50cyBpbnRvIHRoZSB2aWV3UG9ydC5cclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lfSB2aWV3RnJhbWVcclxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFuaW1hdGlvbiAtIGl0J3Mgb3B0aW9uYWxcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gaXQncyBjYWxsZWQgYWZ0ZXIgZm9jdXNcclxuICAgICAqIEBmaXJlcyB2aWV3LWZyYW1lcy1zaXplLW9yLXBvc2l0aW9uLWNoYW5nZWRcclxuICAgICovXHJcbiAgICBzZWxmLnBvc2l0aW9uVmlld1BvcnQgPSBmdW5jdGlvbiAodmlld0ZyYW1lUHVibGljTW9kZWwsIHBvaW50LCBhbmltYXRpb24sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgcmVsZXZhbnRWaWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lQnlJZCh2aWV3RnJhbWVQdWJsaWNNb2RlbC5pZCk7XHJcbiAgICAgICAgX3Bvc2l0aW9uVmlld1BvcnQocmVsZXZhbnRWaWV3RnJhbWUsIHBvaW50LCBhbmltYXRpb24sICgpID0+IHtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgY29uc3QgY2hhbmdlZFZpZXdGcmFtZSA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVCeUlkKHZpZXdGcmFtZVB1YmxpY01vZGVsLmlkKTtcclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3LWZyYW1lcy1zaXplLW9yLXBvc2l0aW9uLWNoYW5nZWQnLCBbW2NoYW5nZWRWaWV3RnJhbWVdXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwb3J0cyBncmFwaCB0byBwbmcgb3Igc3ZnIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0ge1xyXG4gICAgICogIG5hbWU/OiBzdHJpbmcgLSBmaWxlIG5hbWVcclxuICAgICAqICB0eXBlPzogc3RyaW5nIC0gKHBuZy9zdmcpXHJcbiAgICAgKiB9IG9wdGlvbnNcclxuICAgICovXHJcbiAgICBzZWxmLmV4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XHJcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBvcHRpb25zLm5hbWUgfHwgJ0xHX2xpbmVhZ2VfZGlhZ3JhbV9zbmFwc2hvdF8nICsgZGF0ZTJTdHJpbmcobmV3IERhdGUoKSk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdwbmcnKSB7XHJcbiAgICAgICAgICAgIHRvRGF0YVVSTChfcGFwZXIsIHtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgICAgIHN2Z09wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1RvUmVtb3ZlU2VsZWN0b3I6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRJbWFnZXNUb0RhdGFVcmlzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS50aGVuKGJhc2U2NFVSTCA9PiB7XHJcbiAgICAgICAgICAgICAgICBzYXZlRGF0YShiYXNlNjRVUkwsIGZpbGVOYW1lLCAncG5nJyk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSBhbGVydChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGFsZXJ0KCdUaGlzIHR5cGUgb2YgZXhwb3J0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIEludGVybmV0IEV4cGxvcmVyJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXhwb3J0VG9TVkcoX3BhcGVyLCB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50c1RvUmVtb3ZlU2VsZWN0b3I6ICcnLFxyXG4gICAgICAgICAgICAgICAgY29udmVydEltYWdlc1RvRGF0YVVyaXM6IHRydWUsXHJcbiAgICAgICAgICAgIH0pLnRoZW4oc3ZnU3RyaW5nID0+IHtcclxuICAgICAgICAgICAgICAgIHNhdmVEYXRhKHN2Z1N0cmluZywgZmlsZU5hbWUsICdzdmcnKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2F2ZURhdGEgKGRhdGEsIGZpbGVOYW1lLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIGxldCBibG9iO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N2ZycpIHtcclxuICAgICAgICAgICAgICAgIGJsb2IgPSBuZXcgQmxvYihbZGF0YV0sIHsgdHlwZTogdHlwZSB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncG5nJykge1xyXG4gICAgICAgICAgICAgICAgYmxvYiA9IHBuZzJCbG9iIChkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzYXZlQXMoYmxvYiwgZmlsZU5hbWUgKyAnLicgKyB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MgcHJpbnQgZGlhbG9nLlxyXG4gICAgKi9cclxuICAgIHNlbGYucHJpbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZXhwb3J0VG9TVkcoX3BhcGVyLCB7XHJcbiAgICAgICAgICAgIHByZXNlcnZlRGltZW5zaW9uczogZmFsc2UsXHJcbiAgICAgICAgICAgIGVsZW1lbnRzVG9SZW1vdmVTZWxlY3RvcjogJycsXHJcbiAgICAgICAgICAgIGNvbnZlcnRJbWFnZXNUb0RhdGFVcmlzOiB0cnVlLFxyXG4gICAgICAgICAgICBwZGZNb2RlOiB0cnVlLFxyXG4gICAgICAgIH0pLnRoZW4oc3ZnU3RyaW5nID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJpbnRXaW5kb3cgPSB3aW5kb3cub3BlbignJywgdW5kZWZpbmVkLCAnd2lkdGg9MTI4MCxoZWlnaHQ9NzIwJyk7XHJcbiAgICAgICAgICAgIGlmIChwcmludFdpbmRvdykge1xyXG4gICAgICAgICAgICAgICAgcHJpbnRXaW5kb3cuZG9jdW1lbnQud3JpdGUoc3ZnU3RyaW5nKTtcclxuICAgICAgICAgICAgICAgIHByaW50V2luZG93LmRvY3VtZW50LmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICBwcmludFdpbmRvdy5wcmludCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoJ1lvdSBzaG91bGQgdW5ibG9jayBwb3B1cCB3aW5kb3dzIGZvciB0aGUgY3VycmVudCB1cmwgdG8gYmUgYWJsZSB0byBwcmludCB0aGlzIGRpYWdyYW0hJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmUgZGF0YSBjb250YWluZXIgd2l0aCBub2RlcyBhbmQgbGlua3MgZm9yIHRoZSBKb2ludGpzIHZpZXcgKHZpZXctMilcclxuICAgICAqIGFuZCBwYXRoIGl0IHRvIHRoZSBmb3Jtc1xyXG4gICAgICogQHBhcmFtIHtEYXRhQ29udGFpbmVyfSBkYXRhQ29udGFpbmVyIC0gZGF0YSBmb3IgdGhlIGdyYXBoXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZVB1YmxpY01vZGVsW119IHZpZXdGcmFtZXMgLSB2aWV3IGZyYW1lc1xyXG4gICAgKi9cclxuICAgIHNlbGYuc2V0RGF0YSA9IF9zZXREYXRhO1xyXG5cclxuICAgIHNlbGYuc2V0Um91dGluZyA9IGZ1bmN0aW9uIChyb3V0aW5nSWQpIHtcclxuICAgICAgICBfcm91dGluZ01hbmFnZXIuc2V0Um91dGluZyhyb3V0aW5nSWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldFJvdXRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9yb3V0aW5nTWFuYWdlci5nZXRSb3V0aW5nKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2NhbGUgPSBmdW5jdGlvbiAoc2NhbGUpIHtcclxuICAgICAgICBpZiAoc2NhbGUpIHtcclxuICAgICAgICAgICAgX3VwZGF0ZVNjYWxlKHNjYWxlKTtcclxuICAgICAgICAgICAgX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnMoX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZXMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc2NhbGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5jcmVhc2VzIHNjYWxlIG9mIHRoZSBncmFwaC5cclxuICAgICAqIEFuZCByZWRyYXcgaXQgYWZ0ZXIgdGhhdC5cclxuICAgICAqL1xyXG4gICAgc2VsZi56b29tSW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3VwZGF0ZVNjYWxlKHtcclxuICAgICAgICAgICAgeDogX3NjYWxlLnggKyBfc2NhbGVTdGVwLFxyXG4gICAgICAgICAgICB5OiBfc2NhbGUueSArIF9zY2FsZVN0ZXAsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnMoX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZXMoKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjcmVhc2VzIHNjYWxlIG9mIHRoZSBncmFwaC5cclxuICAgICAqIEFuZCByZWRyYXcgaXQgYWZ0ZXIgdGhhdC5cclxuICAgICAqL1xyXG4gICAgc2VsZi56b29tT3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF91cGRhdGVTY2FsZSh7XHJcbiAgICAgICAgICAgIHg6IF9zY2FsZS54IC0gX3NjYWxlU3RlcCxcclxuICAgICAgICAgICAgeTogX3NjYWxlLnkgLSBfc2NhbGVTdGVwLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIF9saW1pdFZpZXdQb3J0c1Bvc3Rpb25zKF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluY3JlYXNlcyBzY2FsZSBvZiB0aGUgZ3JhcGguXHJcbiAgICAgKiBBbmQgcmVkcmF3IGl0IGFmdGVyIHRoYXQuXHJcbiAgICAgKi9cclxuICAgIHNlbGYuem9vbVRvRml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IG92ZXJWaWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0T3ZlclZpZXdGcmFtZSgpO1xyXG4gICAgICAgIGNvbnN0IG5vZGVCb3VuZHMgPSBvdmVyVmlld0ZyYW1lLm5vZGVCb3VuZHM7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBfcGFwZXIuZWwuY2xpZW50V2lkdGggLSBGUkFNRV9PVVRfTUFSR0lOICogMjtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBfcGFwZXIuZWwuY2xpZW50SGVpZ2h0IC0gRlJBTUVfT1VUX01BUkdJTiAqIDI7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gb3ZlclZpZXdGcmFtZS5zY2FsZTtcclxuICAgICAgICBjb25zdCBuZWNlc3NhcnlTaXplID0gZ2xvYmFsVG9TY2FsZWRTaXplKHtcclxuICAgICAgICAgICAgd2lkdGg6IG5vZGVCb3VuZHMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogbm9kZUJvdW5kcy5oZWlnaHQsXHJcbiAgICAgICAgfSwgc2NhbGUpO1xyXG4gICAgICAgIGNvbnN0IHhSYXRpbyA9IHdpZHRoIC8gKG5lY2Vzc2FyeVNpemUud2lkdGggKyBwYXJhbWV0ZXJzLmZyYW1lUGFkZGluZy54ICogMik7XHJcbiAgICAgICAgY29uc3QgeVJhdGlvID0gaGVpZ2h0IC8gKG5lY2Vzc2FyeVNpemUuaGVpZ2h0ICsgcGFyYW1ldGVycy5mcmFtZVBhZGRpbmcueSAqIDIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIF91cGRhdGVTY2FsZSh7XHJcbiAgICAgICAgICAgIHg6IHNjYWxlLnggKiB4UmF0aW8sXHJcbiAgICAgICAgICAgIHk6IHNjYWxlLnkgKiB5UmF0aW8sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgX3JlZHJhdygpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBjaGFuZ2VzIG9yaWVudGF0aW9uIG9mIHRoZSBncmFwaC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmllbnRhdGlvbiAtIFZhbHVlczogJ2xlZnQtdG8tcmlnaHQnLCAncmlnaHQtdG8tbGVmdCcsICd0b3AtdG8tYm90dG9tJywgJ2JvdHRvbS10by10b3AnXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZURpYWdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5zZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIChvcmllbnRhdGlvbikge1xyXG4gICAgICAgIF9vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xyXG4gICAgICAgIF9yZWRyYXcoKTtcclxuICAgICAgICBfdmlld0ZyYW1lc1VJLnNldE9yaWVudGF0aW9uKG9yaWVudGF0aW9uKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCBWaWV3RnJhbWVzXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZURpYWdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVQdWJsaWNNb2RlbFtdfVxyXG4gICAgICovXHJcbiAgICBzZWxmLmdldFZpZXdGcmFtZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBvbmUgVmlld0ZyYW1lIGJ5IGlkIFxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VEaWFncmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmlld0ZyYW1lSWRcclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVQdWJsaWNNb2RlbH1cclxuICAgICovXHJcbiAgICBzZWxmLmdldFZpZXdGcmFtZUJ5SWQgPSBmdW5jdGlvbiAodmlld0ZyYW1lSWQpIHtcclxuICAgICAgICByZXR1cm4gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQodmlld0ZyYW1lSWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgb25lIFZpZXdGcmFtZSBieSBpZCBcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlRGlhZ3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVB1YmxpY01vZGVsfVxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0T3ZlclZpZXdGcmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3ZpZXdNYW5hZ2VyLmdldE92ZXJWaWV3RnJhbWUoKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5zZXRNYXNrID0gZnVuY3Rpb24gKG1hc2spIHtcclxuICAgICAgICBfbWFzayA9IG1hc2s7XHJcbiAgICAgICAgX3JlZHJhdygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldE1hc2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9tYXNrO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmlzRnVsbFNjcmVlbk1vZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF92aWV3TWFuYWdlci5pc0Z1bGxTY3JlZW5Nb2RlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9yZWRyYXcgKG9wdGlvbnMpIHtcclxuICAgICAgICBfcm91dGluZ01hbmFnZXIucmVzZXRSb3V0aW5nKCk7XHJcbiAgICAgICAgX3JvdXRpbmdNYW5hZ2VyLnNldEJvdW5kcyh7XHJcbiAgICAgICAgICAgIHg6IEZSQU1FX09VVF9NQVJHSU4gKyBwYXJhbWV0ZXJzLmZyYW1lQm9yZGVyV2lkdGgsXHJcbiAgICAgICAgICAgIHk6IEZSQU1FX09VVF9NQVJHSU4gKyBwYXJhbWV0ZXJzLmZyYW1lQm9yZGVyV2lkdGgsXHJcbiAgICAgICAgICAgIHdpZHRoOiBfcGFwZXIuZWwuY2xpZW50V2lkdGggLSAoRlJBTUVfT1VUX01BUkdJTiArIHBhcmFtZXRlcnMuZnJhbWVCb3JkZXJXaWR0aCkgKiAyLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IF9wYXBlci5lbC5jbGllbnRIZWlnaHQgLSAoRlJBTUVfT1VUX01BUkdJTiArIHBhcmFtZXRlcnMuZnJhbWVCb3JkZXJXaWR0aCkgKiAyLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBjb25zdCByZW5kZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICB2aWV3RnJhbWVzOiBvcHRpb25zLnZpZXdGcmFtZXMsXHJcbiAgICAgICAgICAgIGZ1bGxTY3JlZW5Nb2RlOiBvcHRpb25zLmZ1bGxTY3JlZW5Nb2RlLFxyXG4gICAgICAgICAgICBzZWxlY3RlZEVsZW1lbnQ6IF9zZWxlY3RlZEVsZW1lbnQsXHJcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoLFxyXG4gICAgICAgICAgICBtYXNrOiBfbWFzayxcclxuICAgICAgICAgICAgcXVpY2tVcGRhdGU6IG9wdGlvbnMucXVpY2tVcGRhdGUsXHJcbiAgICAgICAgICAgIHVwZGF0ZUJvdW5kczogb3B0aW9ucy51cGRhdGVCb3VuZHMsXHJcbiAgICAgICAgICAgIHBhcGVyT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb246IF9vcmllbnRhdGlvbixcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBfcGFwZXIuZWwuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IF9wYXBlci5lbC5jbGllbnRIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBzY2FsZTogX3NjYWxlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbGVtZW50T3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudFNpemU6IG9wdGlvbnMuZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKCFyZW5kZXJPcHRpb25zLnF1aWNrVXBkYXRlKSBjbGVhclRpbWVvdXQoX3RpbWVvdXRSZWYpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIF9ncmFwaC5zdGFydEJhdGNoKCdyZW1vdmUnKTtcclxuICAgICAgICBpZiAocmVuZGVyT3B0aW9ucy5xdWlja1VwZGF0ZSkgX2dyYXBoLnJlbW92ZUNlbGxzKF9ncmFwaC5nZXRMaW5rcygpKTtcclxuXHJcbiAgICAgICAgbGV0IHJlbmRlckRhdGEgPSBfdmlld01hbmFnZXIucHJlcGFyZVJlbmRlckRhdGEocmVuZGVyT3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHJlbmRlckRhdGEgPSBfcmVtb3ZlRGVwcmVjYXRlZEFuZEV4aXN0aW5nQ2VsbHMocmVuZGVyRGF0YSk7XHJcbiAgICAgICAgX2dyYXBoLnN0b3BCYXRjaCgncmVtb3ZlJyk7XHJcblxyXG4gICAgICAgIF9ncmFwaC5zdGFydEJhdGNoKCdhZGQnKTtcclxuICAgICAgICBfZ3JhcGguYWRkQ2VsbHMocmVuZGVyRGF0YSk7XHJcbiAgICAgICAgX2dyYXBoLnN0b3BCYXRjaCgnYWRkJyk7XHJcblxyXG4gICAgICAgIF91cGRhdGVIaWdobGlnaHRpbmcocmVuZGVyRGF0YSk7XHJcbiAgICAgICAgX3ZpZXdGcmFtZXNVSS5yZWZyZXNoKCk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1JlZHJhdycgKyAocmVuZGVyT3B0aW9ucy5xdWlja1VwZGF0ZSA/ICcgKHF1aWNrKScgOiAnJykpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBfdGltZW91dFJlZiA9IDA7XHJcbiAgICBsZXQgX2Jsb2NrTXVsdGlwbGVRdWVyaWVzID0gZmFsc2U7XHJcbiAgICBmdW5jdGlvbiBfZGVsYXllZFJlZHJhdyAob3B0aW9ucywgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoX2Jsb2NrTXVsdGlwbGVRdWVyaWVzKSByZXR1cm47XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aW1lb3V0UmVmKTtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgY29uc3QgcXVpY2tPcHRpb25zID0gXy5jbG9uZURlZXAob3B0aW9ucykgfHwge307XHJcbiAgICAgICAgcXVpY2tPcHRpb25zLnF1aWNrVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICBcclxuICAgICAgICBfYmxvY2tNdWx0aXBsZVF1ZXJpZXMgPSB0cnVlO1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIF9ibG9ja011bHRpcGxlUXVlcmllcyA9IGZhbHNlOyBcclxuICAgICAgICB9KTtcclxuICAgICAgICBfcmVkcmF3KHF1aWNrT3B0aW9ucyk7XHJcblxyXG4gICAgICAgIF90aW1lb3V0UmVmID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMucXVpY2tVcGRhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYFJlZHJhdyAoZGVsYXk6c3RhcnQtJHtfdGltZW91dFJlZn0pID0+IGApO1xyXG4gICAgICAgICAgICBfcmVkcmF3KG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfSwgMTUwKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhgUmVkcmF3IChkZWxheTp3YWl0LSR7X3RpbWVvdXRSZWZ9KWApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9yZW1vdmVEZXByZWNhdGVkQW5kRXhpc3RpbmdDZWxscyAobmV3Q2VsbHMpIHtcclxuICAgICAgICBjb25zdCBvbGRDZWxscyA9IF9ncmFwaC5nZXRDZWxscygpO1xyXG4gICAgICAgIGNvbnN0IGNlbGxNYXAgPSB7fTtcclxuXHJcbiAgICAgICAgbmV3Q2VsbHMuZm9yRWFjaChjZWxsID0+IHsgY2VsbE1hcFtjZWxsLmlkXSA9IGNlbGw7IH0pO1xyXG4gICAgICAgIG9sZENlbGxzLmZvckVhY2goY2VsbCA9PiB7XHJcbiAgICAgICAgICAgIGlmICghY2VsbE1hcFtjZWxsLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgY2VsbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjZWxsTWFwW2NlbGwuaWRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjZWxsTWFwKS5tYXAoa2V5ID0+IGNlbGxNYXBba2V5XSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3VwZGF0ZUhpZ2hsaWdodGluZyAoY2VsbHMpIHtcclxuICAgICAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2VsbC5yZWZyZXNoSGlnaGxpZ2h0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBjZWxsLnJlZnJlc2hIaWdobGlnaHRpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9jb21iaW5lICgpIHtcclxuICAgICAgICBjb25zdCBzZWxlY3RlZEVsZW1lbnRJc05vZGUgPSBfc2VsZWN0ZWRFbGVtZW50IGluc3RhbmNlb2YgTm9kZTtcclxuICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50SXNOb2RlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IF9zZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVNYXAgPSBfZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXA7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZU1hcCA9IF9kYXRhQ29udGFpbmVyLm1hcHMuc291cmNlTWFwO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRNYXAgPSBfZGF0YUNvbnRhaW5lci5tYXBzLnRhcmdldE1hcDtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlTGlua3MgPSAoc291cmNlTWFwW3NlbGVjdGVkTm9kZS5pZF0gfHwgW10pXHJcbiAgICAgICAgICAgICAgICAuY29uY2F0KHRhcmdldE1hcFtzZWxlY3RlZE5vZGUuaWRdIHx8IFtdKTtcclxuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVOb2RlcyA9IHJlbGF0aXZlTGlua3MubWFwKGwgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGwubW9kZWwuc291cmNlICE9PSBzZWxlY3RlZE5vZGUuaWQpIHJldHVybiBub2RlTWFwW2wubW9kZWwuc291cmNlXTsgZWxzZVxyXG4gICAgICAgICAgICAgICAgaWYgKGwubW9kZWwudGFyZ2V0ICE9PSBzZWxlY3RlZE5vZGUuaWQpIHJldHVybiBub2RlTWFwW2wubW9kZWwudGFyZ2V0XTsgZWxzZVxyXG4gICAgICAgICAgICAgICAgaWYgKGwubW9kZWwuc291cmNlID09PSBsLm1vZGVsLnRhcmdldCkgcmV0dXJuIG5vZGVNYXBbbC5tb2RlbC5zb3VyY2VdO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9ucyA9IGNvbWJpbmVPcGVyYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWROb2RlOiBzZWxlY3RlZE5vZGUsXHJcbiAgICAgICAgICAgICAgICByZWxhdGl2ZUxpbmtzOiByZWxhdGl2ZUxpbmtzLFxyXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVOb2RlczogcmVsYXRpdmVOb2RlcyxcclxuICAgICAgICAgICAgICAgIHNjYWxlOiBfc2NhbGUsXHJcbiAgICAgICAgICAgIH0sIHBhcmFtZXRlcnMpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0Vmlld0ZyYW1lSWQgPSBnZXRWaWV3RnJhbWVJZEZvck5vZGUoc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICAgY29uc3QgbmV3UGF0aCA9IHt9O1xyXG4gICAgICAgICAgICBjb25zdCBhZmZlY3RlZFZpZXdGcmFtZXNNYXAgPSB7fTtcclxuICAgICAgICAgICAgcmVsYXRpdmVOb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VyUG9zaXRpb24gPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24obm9kZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlLm1vZGVsLnBvc2l0aW9uID0gbmV3UG9zaXRpb25zW25vZGUuaWRdO1xyXG4gICAgICAgICAgICAgICAgX2RhdGFDb250YWluZXIudXBkYXRlWm9uZXNGb3JOb2RlKG5vZGUsIGN1clBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lRm9yTm9kZShub2RlKTtcclxuICAgICAgICAgICAgICAgIGFmZmVjdGVkVmlld0ZyYW1lc01hcFt2aWV3RnJhbWUuaWRdID0gdmlld0ZyYW1lO1xyXG4gICAgICAgICAgICAgICAgbm9kZS52aWV3RnJhbWVPd25lcklkID0gdGFyZ2V0Vmlld0ZyYW1lSWQ7XHJcbiAgICAgICAgICAgICAgICBuZXdQYXRoW25vZGUuaWRdID0gbm9kZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG5ld1BhdGhbc2VsZWN0ZWROb2RlLmlkXSA9IHNlbGVjdGVkTm9kZTtcclxuXHJcbiAgICAgICAgICAgIHJlbGF0aXZlTGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgICAgIG5ld1BhdGhbbGluay5pZF0gPSBsaW5rO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIF9wYXRoID0gbmV3UGF0aDtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGFmZmVjdGVkVmlld0ZyYW1lcyA9IE9iamVjdC5rZXlzKGFmZmVjdGVkVmlld0ZyYW1lc01hcCkubWFwKGtleSA9PiBhZmZlY3RlZFZpZXdGcmFtZXNNYXBba2V5XSk7XHJcbiAgICAgICAgICAgIF9yZWRyYXcoeyB2aWV3RnJhbWVzOiBhZmZlY3RlZFZpZXdGcmFtZXMsIHVwZGF0ZUJvdW5kczogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnMoYWZmZWN0ZWRWaWV3RnJhbWVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCBmcm9tIHRoZSBwYXBlciBiZXNpZGVzIHZpZXdGcmFtZXMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jbGVhciAoKSB7XHJcbiAgICAgICAgX3Vuc2VsZWN0KCk7XHJcbiAgICAgICAgX2dyYXBoLmNsZWFyKCk7XHJcbiAgICAgICAgX3ZpZXdNYW5hZ2VyID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lIGRhdGEgY29udGFpbmVyIHdpdGggbm9kZXMgYW5kIGxpbmtzIGZvciB0aGUgSm9pbnRqcyB2aWV3ICh2aWV3LTIpXHJcbiAgICAgKiBhbmQgcGF0aCBpdCB0byB0aGUgZm9ybXNcclxuICAgICAqIEBwYXJhbSB7RGF0YUNvbnRhaW5lcn0gZGF0YUNvbnRhaW5lciAtIGRhdGEgZm9yIHRoZSBncmFwaFxyXG4gICAgICogQHBhcmFtIHtWaWV3RnJhbWVQdWJsaWNNb2RlbFtdfSB2aWV3RnJhbWVzIC0gdmlldyBmcmFtZXNcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfc2V0RGF0YSAoZGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lcykge1xyXG4gICAgICAgIF9jbGVhcigpO1xyXG5cclxuICAgICAgICBfZGF0YUNvbnRhaW5lciA9IGRhdGFDb250YWluZXI7XHJcbiAgICAgICAgX3JvdXRpbmdNYW5hZ2VyID0gbmV3IFJvdXRpbmdNYW5hZ2VyKHtcclxuICAgICAgICAgICAgbGlua3M6IF9kYXRhQ29udGFpbmVyLmxpbmtzLFxyXG4gICAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgICAgIHg6IEZSQU1FX09VVF9NQVJHSU4gKyBwYXJhbWV0ZXJzLmZyYW1lQm9yZGVyV2lkdGgsXHJcbiAgICAgICAgICAgICAgICB5OiBGUkFNRV9PVVRfTUFSR0lOICsgcGFyYW1ldGVycy5mcmFtZUJvcmRlcldpZHRoLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IF9wYXBlci5lbC5jbGllbnRXaWR0aCAtIChGUkFNRV9PVVRfTUFSR0lOICsgcGFyYW1ldGVycy5mcmFtZUJvcmRlcldpZHRoKSAqIDIsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IF9wYXBlci5lbC5jbGllbnRIZWlnaHQgLSAoRlJBTUVfT1VUX01BUkdJTiArIHBhcmFtZXRlcnMuZnJhbWVCb3JkZXJXaWR0aCkgKiAyLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIF92aWV3TWFuYWdlciA9IG5ldyBWaWV3TWFuYWdlcih7XHJcbiAgICAgICAgICAgIGRhdGFDb250YWluZXI6IGRhdGFDb250YWluZXIsXHJcbiAgICAgICAgICAgIHZpZXdGcmFtZXM6IHZpZXdGcmFtZXMsXHJcbiAgICAgICAgICAgIGZ1bGxTY3JlZW5Nb2RlOiBfZnVsbFNjcmVlbk1vZGUsXHJcbiAgICAgICAgfSwgcGFyYW1ldGVycyk7XHJcblxyXG4gICAgICAgIF92aWV3RnJhbWVzVUkgPSBfY3JlYXRlVmlld0ZyYW1lc1VJKF92aWV3TWFuYWdlcik7XHJcblxyXG4gICAgICAgIF92aWV3TWFuYWdlci5vbignY2hhbmdlLXZpZXctcG9ydC1wb3NpdGlvbicsIHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgICAgIF9yZWRyYXcoeyB2aWV3RnJhbWVzOiBbdmlld0ZyYW1lXSwgcXVpY2tVcGRhdGU6IHRydWV9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2NvcnJlY3RTY2FsZSgpO1xyXG4gICAgICAgIF9yZWRyYXcoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3RnJhbWVJZCBcclxuICAgICAqIEBmaXJlcyB2aWV3LWZyYW1lcy1zaXplLW9yLXBvc2l0aW9uLWNoYW5nZWRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX29wZW5WaWV3RnJhbWUgKHZpZXdGcmFtZUlkKSB7XHJcbiAgICAgICAgY29uc3Qgdmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQodmlld0ZyYW1lSWQpO1xyXG4gICAgICAgIGlmICghdmlld0ZyYW1lKSByZXR1cm47XHJcblxyXG4gICAgICAgIHZpZXdGcmFtZS5leHBhbmRlZCA9IHRydWU7XHJcbiAgICAgICAgY29uc3Qgdmlld0ZyYW1lcyA9IFt2aWV3RnJhbWVdO1xyXG5cclxuICAgICAgICBfcmVkcmF3KHsgdmlld0ZyYW1lczogdmlld0ZyYW1lcyB9KTtcclxuXHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3LWZyYW1lcy1zdGF0ZS1jaGFuZ2VkJywgW3ZpZXdGcmFtZXNdKTtcclxuXHJcbiAgICAgICAgX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnMoX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZXMoKS5maWx0ZXIodmYgPT4gdmYuYWN0aXZlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2Nsb3NlVmlld0ZyYW1lICh2aWV3RnJhbWVJZCkge1xyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZSA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVCeUlkKHZpZXdGcmFtZUlkKTtcclxuICAgICAgICBpZiAoIXZpZXdGcmFtZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICB2aWV3RnJhbWUuZXhwYW5kZWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWVzID0gW3ZpZXdGcmFtZV07XHJcblxyXG4gICAgICAgIF9yZWRyYXcoeyB2aWV3RnJhbWVzOiB2aWV3RnJhbWVzIH0pO1xyXG5cclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3ZpZXctZnJhbWVzLXN0YXRlLWNoYW5nZWQnLCBbdmlld0ZyYW1lc10pO1xyXG5cclxuICAgICAgICBfbGltaXRWaWV3UG9ydHNQb3N0aW9ucyhfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lcygpLmZpbHRlcih2ZiA9PiB2Zi5hY3RpdmUpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfc2V0RnVsbFNjcmVlbk1vZGUgKHZhbHVlKSB7XHJcbiAgICAgICAgX2Z1bGxTY3JlZW5Nb2RlID0gdmFsdWU7XHJcblxyXG4gICAgICAgIGlmICghX2Z1bGxTY3JlZW5Nb2RlKSB7XHJcbiAgICAgICAgICAgIF9zY2FsZSA9IHtcclxuICAgICAgICAgICAgICAgIHg6IE1hdGgubWF4KE1hdGgubWluKF9zY2FsZS54LCBfc2NhbGVCb3VuZHMubWF4KSwgX3NjYWxlQm91bmRzLm1pbiksXHJcbiAgICAgICAgICAgICAgICB5OiBNYXRoLm1heChNYXRoLm1pbihfc2NhbGUueSwgX3NjYWxlQm91bmRzLm1heCksIF9zY2FsZUJvdW5kcy5taW4pLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3JlZHJhdyh7IGZ1bGxTY3JlZW5Nb2RlOiB2YWx1ZSB9KTtcclxuXHJcbiAgICAgICAgY29uc3Qgdmlld0ZyYW1lcyA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCk7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3LWZyYW1lcy1zdGF0ZS1jaGFuZ2VkJywgW3ZpZXdGcmFtZXNdKTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJWaWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0T3ZlclZpZXdGcmFtZSgpO1xyXG4gICAgICAgICAgICBfbGltaXRWaWV3UG9ydFBvc3Rpb24ob3ZlclZpZXdGcmFtZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgX3JlZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3LWZyYW1lcy1zaXplLW9yLXBvc2l0aW9uLWNoYW5nZWQnLCBbW292ZXJWaWV3RnJhbWVdXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9saW1pdFZpZXdQb3J0c1Bvc3Rpb25zKHZpZXdGcmFtZXMuZmlsdGVyKHZmID0+IHZmLmFjdGl2ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYW5kIGxpbWl0cyB2YWx1ZSBvZiB0aGUgc2NhbGUgb2YgdGhlIGdyYXBoLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogPT09PT09PT09PT09PT09PT1cclxuICAgICAqIEBmaXJlcyBzY2FsZS1jaGFuZ2VkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF91cGRhdGVTY2FsZSAoc2NhbGUpIHtcclxuICAgICAgICBjb25zdCBmdWxsU2NyZWVuID0gX3ZpZXdNYW5hZ2VyLmlzRnVsbFNjcmVlbk1vZGUoKTtcclxuXHJcbiAgICAgICAgc2NhbGUgPSBzY2FsZSB8fCBfc2NhbGU7XHJcbiAgICAgICAgaWYgKGZ1bGxTY3JlZW4pIHtcclxuICAgICAgICAgICAgX3NjYWxlID0ge1xyXG4gICAgICAgICAgICAgICAgeDogTWF0aC5tYXgoTWF0aC5taW4oc2NhbGUueCwgX292ZXJWaWV3U2NhbGVCb3VuZHMubWF4KSwgX292ZXJWaWV3U2NhbGVCb3VuZHMubWluKSxcclxuICAgICAgICAgICAgICAgIHk6IE1hdGgubWF4KE1hdGgubWluKHNjYWxlLnksIF9vdmVyVmlld1NjYWxlQm91bmRzLm1heCksIF9vdmVyVmlld1NjYWxlQm91bmRzLm1pbiksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX3NjYWxlID0ge1xyXG4gICAgICAgICAgICAgICAgeDogTWF0aC5tYXgoTWF0aC5taW4oc2NhbGUueCwgX3NjYWxlQm91bmRzLm1heCksIF9zY2FsZUJvdW5kcy5taW4pLFxyXG4gICAgICAgICAgICAgICAgeTogTWF0aC5tYXgoTWF0aC5taW4oc2NhbGUueSwgX3NjYWxlQm91bmRzLm1heCksIF9zY2FsZUJvdW5kcy5taW4pLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3NjYWxlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9jb3JyZWN0U2NhbGUgKCkge1xyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZXNOdW1iZXIgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lcygpLmxlbmd0aDtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IF9wYXBlci5lbC5jbGllbnRXaWR0aCAtIEZSQU1FX09VVF9NQVJHSU4gKiAyO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IF9wYXBlci5lbC5jbGllbnRIZWlnaHQgLSBGUkFNRV9PVVRfTUFSR0lOICogMjtcclxuXHJcbiAgICAgICAgY29uc3QgY3V0ZWRXaWR0aCA9IHdpZHRoICAtIERJU1RBTkNFX0JFVFdFRU5fRlJBTUVTICogKHZpZXdGcmFtZXNOdW1iZXIgLSAxKTtcclxuICAgICAgICBjb25zdCBjdXRlZEhlaWdodCA9IGhlaWdodCAgLSBESVNUQU5DRV9CRVRXRUVOX0ZSQU1FUyAqICh2aWV3RnJhbWVzTnVtYmVyIC0gMSk7XHJcblxyXG4gICAgICAgIGNvbnN0IG1pbkhvck51bSA9IDQ7IC8vIGl0J3MgZm9yIG1heCBzY2FsZSBiZWNhdXNlIHdoZW4gd2UgaGF2ZSBtYXggc2NhbGUgd2UgYWxzbyBoYXZlIG1pbmltdW0gbm9kZSBudW1iZXJcclxuICAgICAgICBjb25zdCBtaW5WZXJ0TnVtID0gMztcclxuXHJcbiAgICAgICAgY29uc3QgbWF4SG9yTnVtID0gODsgLy8gaXQncyBmb3IgbWluIHNjYWxlIGJlY2F1c2Ugd2hlbiB3ZSBoYXZlIG1pbiBzY2FsZSB3ZSBhbHNvIGhhdmUgbWF4aW11bSBub2RlIG51bWJlclxyXG4gICAgICAgIGNvbnN0IG1heFZlcnROdW0gPSA3O1xyXG5cclxuICAgICAgICBjb25zdCBub2RlU2l6ZSA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IHBhcmFtZXRlcnMuZWxlbWVudFNpemUud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogcGFyYW1ldGVycy5lbGVtZW50U2l6ZS5oZWlnaHQsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBzdGVwID0ge1xyXG4gICAgICAgICAgICB4OiBwYXJhbWV0ZXJzLmxheW91dFN0ZXAueCxcclxuICAgICAgICAgICAgeTogcGFyYW1ldGVycy5sYXlvdXRTdGVwLnksXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgbWluU2NhbGUgPSBnZXRTY2FsZUZvck5vZGVOdW1iZXIgKG1heEhvck51bSwgbWF4VmVydE51bSk7XHJcbiAgICAgICAgY29uc3QgbWF4U2NhbGUgPSBnZXRTY2FsZUZvck5vZGVOdW1iZXIgKG1pbkhvck51bSwgbWluVmVydE51bSk7XHJcblxyXG4gICAgICAgIC8vIHBhcmFtZXRlcnMuZGVmYXVsdFNjYWxlID0gc2NhbGU7XHJcbiAgICAgICAgX3NjYWxlQm91bmRzLm1pbiA9IE1hdGgubWF4KG1pblNjYWxlLngsIG1pblNjYWxlLnkpO1xyXG4gICAgICAgIF9zY2FsZUJvdW5kcy5tYXggPSBNYXRoLm1pbihtYXhTY2FsZS54LCBtYXhTY2FsZS55KTtcclxuICAgICAgICAvLyBfc2V0U2NhbGUoc2NhbGUpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRTY2FsZUZvck5vZGVOdW1iZXIgKGhvck51bSwgdmVydE51bSkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJYVmFsdWUgPSBob3JOdW0gKiBub2RlU2l6ZS53aWR0aCArIChob3JOdW0gLSAxKSAqIHN0ZXAueDtcclxuICAgICAgICAgICAgY29uc3QgY3VyWVZhbHVlID0gdmVydE51bSAqIG5vZGVTaXplLmhlaWdodCArIChob3JOdW0gLSAxKSAqIHN0ZXAueTtcclxuXHJcbiAgICAgICAgICAgIGxldCBzY2FsZTtcclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGN1dGVkV2lkdGggLSBjdXJYVmFsdWUpID49IE1hdGguYWJzKGN1dGVkSGVpZ2h0IC0gY3VyWVZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgc2NhbGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogY3V0ZWRXaWR0aCAvIGN1clhWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICB5OiBjdXRlZFdpZHRoIC8gY3VyWFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNjYWxlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IGN1dGVkSGVpZ2h0IC8gY3VyWVZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGN1dGVkSGVpZ2h0IC8gY3VyWVZhbHVlLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZmluZE5leHROb2RlIChkaXJlY3Rpb24pIHtcclxuICAgICAgICBpZiAoIV9zZWxlY3RlZEVsZW1lbnQpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IGN1clBvcztcclxuICAgICAgICBpZiAoX3NlbGVjdGVkRWxlbWVudCBpbnN0YW5jZW9mIE5vZGUpIHtcclxuICAgICAgICAgICAgY3VyUG9zID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKF9zZWxlY3RlZEVsZW1lbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IF9kYXRhQ29udGFpbmVyLm1hcHMubm9kZU1hcFtfc2VsZWN0ZWRFbGVtZW50Lm1vZGVsLnNvdXJjZV07XHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVBvcyA9IHNvdXJjZS5tb2RlbC5wb3NpdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gX2RhdGFDb250YWluZXIubWFwcy5ub2RlTWFwW19zZWxlY3RlZEVsZW1lbnQubW9kZWwudGFyZ2V0XTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UG9zID0gdGFyZ2V0Lm1vZGVsLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT04uVVApIHtcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UubW9kZWwueSA8IHRhcmdldC5tb2RlbC55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5ET1dOKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLm1vZGVsLnkgPiB0YXJnZXQubW9kZWwueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT04uTEVGVCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVBvcy54IDwgdGFyZ2V0UG9zLngpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OLlJJR0hUKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlUG9zLnggPiB0YXJnZXRQb3MueCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBwcmV2Tm9kZXMgPSBbXTsgLy8gdG8gYnJlYWsgY3ljbGluZ1xyXG4gICAgICAgIHJldHVybiBnZXROZXh0Tm9kZShjdXJQb3MpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0Tm9kZSAoY3VyUG9zKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRpZmZUb05vZGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVQb3NpdGlvbiA9IGdldEdsb2JhbE5vZGVQb3NpdGlvbihub2RlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogY3VyUG9zLnggLSBub2RlUG9zaXRpb24ueCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBjdXJQb3MueSAtIG5vZGVQb3NpdGlvbi55LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgWF9TVEVQID0gcGFyYW1ldGVycy5kYXRhWm9uZVNpemUud2lkdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IFlfU1RFUCA9IHBhcmFtZXRlcnMuZGF0YVpvbmVTaXplLmhlaWdodDtcclxuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHtcclxuICAgICAgICAgICAgICAgIHg6IGN1clBvcy54IC0gWF9TVEVQIC8gMixcclxuICAgICAgICAgICAgICAgIHk6IGN1clBvcy55IC0gWV9TVEVQIC8gMixcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBYX1NURVAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFlfU1RFUCxcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gX2RhdGFDb250YWluZXIuZ2V0RWxlbWVudHNGb3JSZWN0YW5nbGUocmVjdCkubm9kZXNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIobiA9PiBwcmV2Tm9kZXMuaW5kZXhPZihuKSA9PT0gLTEpO1xyXG4gICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSByZXR1cm4gX3NlbGVjdGVkRWxlbWVudDtcclxuICAgICAgICAgICAgcHJldk5vZGVzID0gbm9kZXM7XHJcblxyXG4gICAgICAgICAgICBsZXQgbmV4dEVsZW1lbnRzO1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT04uVVApIHtcclxuICAgICAgICAgICAgICAgIG5leHRFbGVtZW50cyA9IG5vZGVzLmZpbHRlcihuID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0ID0gZGlmZlRvTm9kZShuKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGRpc3QueSA+IDApICYmIChNYXRoLmFicyhkaXN0LnkpID4gTWF0aC5hYnMoZGlzdC54KSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0RWxlbWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE5leHROb2RlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogY3VyUG9zLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGN1clBvcy55IC0gWV9TVEVQLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OLkRPV04pIHtcclxuICAgICAgICAgICAgICAgIG5leHRFbGVtZW50cyA9IG5vZGVzLmZpbHRlcihuID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0ID0gZGlmZlRvTm9kZShuKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGRpc3QueSA8IDApICYmIChNYXRoLmFicyhkaXN0LnkpID4gTWF0aC5hYnMoZGlzdC54KSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0RWxlbWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE5leHROb2RlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogY3VyUG9zLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGN1clBvcy55ICsgWV9TVEVQLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OLkxFRlQpIHtcclxuICAgICAgICAgICAgICAgIG5leHRFbGVtZW50cyA9IG5vZGVzLmZpbHRlcihuID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0ID0gZGlmZlRvTm9kZShuKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGRpc3QueCA+IDApICYmIChNYXRoLmFicyhkaXN0LnkpIDwgTWF0aC5hYnMoZGlzdC54KSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0RWxlbWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE5leHROb2RlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogY3VyUG9zLnggLSBYX1NURVAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGN1clBvcy55LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OLlJJR0hUKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0RWxlbWVudHMgPSBub2Rlcy5maWx0ZXIobiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdCA9IGRpZmZUb05vZGUobik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChkaXN0LnggPCAwKSAmJiAoTWF0aC5hYnMoZGlzdC55KSA8IE1hdGguYWJzKGRpc3QueCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dEVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXROZXh0Tm9kZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGN1clBvcy54ICsgWF9TVEVQLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBjdXJQb3MueSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXh0RWxlbWVudHMuc29ydCgoYSxiKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhUG9zID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKGEpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYlBvcyA9IGdldEdsb2JhbE5vZGVQb3NpdGlvbihiKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFEaXN0ID0gZ2V0RGlzdChhUG9zLCBjdXJQb3MpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYkRpc3QgPSBnZXREaXN0KGJQb3MsIGN1clBvcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGFEaXN0ID4gYkRpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYURpc3QgPCBiRGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV4dEVsZW1lbnRzWzBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXMgb24gcGFwZXIgYW5kIEtleWJvYXJkIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3N1YnNjcmliZU9uRXZlbnRzICgpIHtcclxuICAgICAgICBsZXQgcXVlcnlBbmltYXRpb25GcmFtZTtcclxuXHJcbiAgICAgICAgX3BhcGVyLm9uKCdsaW5rOm9wdGlvbnMnLCAoY2VsbFZpZXcsIGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmtUeXBlID0gZXZlbnQudGFyZ2V0LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdsaW5rVHlwZScpO1xyXG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2xpbmstb3B0aW9ucy1jbGljaycsIHtcclxuICAgICAgICAgICAgICAgIGxpbms6IGNlbGxWaWV3Lm1vZGVsLFxyXG4gICAgICAgICAgICAgICAgbGlua1R5cGU6IGxpbmtUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2tleWJvYXJkLm9uKHtcclxuICAgICAgICAgICAgJ3VwIGRvd24gbGVmdCByaWdodCc6IChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHF1ZXJ5QW5pbWF0aW9uRnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgcXVlcnlBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3NlbGVjdChfZmluZE5leHROb2RlKGV2dC5rZXlDb2RlKSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IF9jbGlja0NvdW50ZXIgPSAwO1xyXG4gICAgICAgIF9wYXBlci5vbignY2VsbDpwb2ludGVydXAnLCAoY2VsbFZpZXcsIGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVmlld0ZyYW1lID0gY2VsbFZpZXcubW9kZWwgaW5zdGFuY2VvZiBWaWV3RnJhbWU7XHJcbiAgICAgICAgICAgIGlmIChpc1ZpZXdGcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgb25TaW5nbGVDbGljayhjZWxsVmlldywgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgX2NsaWNrQ291bnRlciA9IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2NsaWNrQ291bnRlciA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBvbkRvdWJsZUNsaWNrKGNlbGxWaWV3LCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NsaWNrQ291bnRlciA9IDA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2NsaWNrQ291bnRlciA9PT0gMSkgb25TaW5nbGVDbGljayhjZWxsVmlldywgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xpY2tDb3VudGVyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9LCAyMDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBvblNpbmdsZUNsaWNrIChjZWxsVmlldywgZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzRHJhZ2dpbmcgPSBNYXRoLmFicyhfbW91c2VEb3duUG9zaXRpb24ueCAtIGV2ZW50LnBhZ2VYKSA+IDUgfHwgTWF0aC5hYnMoX21vdXNlRG93blBvc2l0aW9uLnkgLSBldmVudC5wYWdlWSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gY2VsbFZpZXcubW9kZWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2VsbCBpbnN0YW5jZW9mIFZpZXdGcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZSA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVCeUlkKGNlbGwuaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFZpZXdGcmFtZSBjbGlja1xyXG4gICAgICAgICAgICAgICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0RyYWdnaW5nKSBfdW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICBfbGltaXRWaWV3UG9ydFBvc3Rpb24odmlld0ZyYW1lLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWRyYXcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3LWZyYW1lcy1zaXplLW9yLXBvc2l0aW9uLWNoYW5nZWQnLCBbW192aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVCeUlkKGNlbGwuaWQpXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vZGUvTGluayBjbGlja1xyXG4gICAgICAgICAgICAgICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHJhZ2dpbmdOb2RlID0gaXNEcmFnZ2luZyAmJiAoY2VsbCBpbnN0YW5jZW9mIE5vZGUgfHwgY2VsbCBpbnN0YW5jZW9mIFRlcm1pbmF0aW9uTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpY2tUZXJtaW5hdGlvbk5vZGUgPSBjZWxsIGluc3RhbmNlb2YgVGVybWluYXRpb25Ob2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWNrT25Ob2RlT3JMaW5rID0gIShjZWxsIGluc3RhbmNlb2YgQXNwZWN0TGluayk7IC8vIEV4Y2x1ZGUgQXNwZWN0TGlua1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmFnZ2luZ05vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZU5vZGVzUG9zaXRpb25zKFtjZWxsXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjbGlja1Rlcm1pbmF0aW9uTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2VsZWN0KGNlbGwsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xpY2tPbk5vZGVPckxpbmspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3NlbGVjdChjZWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignY2VsbC1zaW5nbGUtY2xpY2snLCBjZWxsVmlldy5tb2RlbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uRG91YmxlQ2xpY2sgKGNlbGxWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gY2VsbFZpZXcubW9kZWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldCgnZXhwYW5kZWQnLCAhY2VsbFZpZXcubW9kZWwuZ2V0KCdleHBhbmRlZCcpKTtcclxuICAgICAgICAgICAgICAgICAgICBfdXBkYXRlTm9kZXNQb3NpdGlvbnMoW2VsZW1lbnRdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignY2VsbC1kb3VibGUtY2xpY2snLCBjZWxsVmlldy5tb2RlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IF9tb3VzZURvd25Qb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgIF9wYXBlci5vbignY2VsbDpwb2ludGVyZG93bicsIChjZWxsLCBldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBfbW91c2VEb3duUG9zaXRpb24gPSB7IHg6IGV2ZW50LnBhZ2VYLCB5OiBldmVudC5wYWdlWSB9O1xyXG4gICAgICAgICAgICBfY2xpY2tDb3VudGVyKys7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9wYXBlci5vbignY2VsbDptb3VzZXdoZWVsJywgKGNlbGwsIGV2dCwgeCwgeSwgZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgU0NST0xMX1NURVAgPSAxMDA7XHJcbiAgICAgICAgICAgIGxldCB2aWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0VmllRnJhbWVCeVNjcmVlblBvaW50KHsgeDogeCwgeTogeSB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh2aWV3RnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChldnQuc2hpZnRLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbi54ICs9IChkZWx0YSA8IDAgPyAxIDogLTEpICogU0NST0xMX1NURVA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb24gPSBsaW1pdFBvaW50UG9zaXRpb24odmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb24sIHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uQm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICBfZGVsYXllZFJlZHJhdyh7IHZpZXdGcmFtZXM6IFt2aWV3RnJhbWVdIH0sICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3LWZyYW1lcy1zaXplLW9yLXBvc2l0aW9uLWNoYW5nZWQnLCBbW3ZpZXdGcmFtZV1dKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZ0LmN0cmxLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gKGRlbHRhID4gMCA/IF9zY2FsZVN0ZXAgOiAtX3NjYWxlU3RlcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IF9zY2FsZS54ICsgZGlmZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogX3NjYWxlLnkgKyBkaWZmLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZVNjYWxlKHNjYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICBfZGVsYXllZFJlZHJhdyh1bmRlZmluZWQsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnMoX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZXMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2NhbGUtY2hhbmdlZCcsIHNjYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb24ueSArPSAoZGVsdGEgPCAwID8gMSA6IC0xKSAqIFNDUk9MTF9TVEVQO1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uID0gbGltaXRQb2ludFBvc2l0aW9uKHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uLCB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbkJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2RlbGF5ZWRSZWRyYXcoeyB2aWV3RnJhbWVzOiBbdmlld0ZyYW1lXSB9LCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcigndmlldy1mcmFtZXMtc2l6ZS1vci1wb3NpdGlvbi1jaGFuZ2VkJywgW1t2aWV3RnJhbWVdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB3aW5kb3cub25yZXNpemUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIF9jb3JyZWN0U2NhbGUoKTtcclxuICAgICAgICAgICAgX2RlbGF5ZWRSZWRyYXcodW5kZWZpbmVkLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3NjYWxlLWNoYW5nZWQnKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlTm9kZXNQb3NpdGlvbnMgKG5vZGVzKSB7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlZFZpZXdGcmFtZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBvdmVyVmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldE92ZXJWaWV3RnJhbWUoKTtcclxuXHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChuID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGdldEJhc2VFbGVtZW50KG4pO1xyXG4gICAgICAgICAgICBjb25zdCBpc1Rlcm1pbmF0aW9uTm9kZSA9IG4gaW5zdGFuY2VvZiBUZXJtaW5hdGlvbk5vZGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZUJ5UG9zaXRpb24gPSBfdmlld01hbmFnZXIuZ2V0VmllRnJhbWVGb3JOb2RlQnlQb3NpdGlvbihuKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBwcmV2T3duZXJGcmFtZSA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVPd25lcihub2RlKSB8fCBvdmVyVmlld0ZyYW1lO1xyXG4gICAgICAgICAgICBsZXQgdmlld0ZyYW1lO1xyXG5cclxuICAgICAgICAgICAgdmlld0ZyYW1lID0gdmlld0ZyYW1lQnlQb3NpdGlvbiB8fCBwcmV2T3duZXJGcmFtZTtcclxuICAgICAgICAgICAgY29uc3QgZHJhZ2dlZEVsZW1lbnRQb3NpdGlvbiA9IG4ucG9zaXRpb24oKTsgLy8gY291bGQgYmUgdGVybWluYXRpb24gbm9kZVxyXG5cclxuICAgICAgICAgICAgaWYgKGlzVGVybWluYXRpb25Ob2RlKSB7XHJcbiAgICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudFBvc2l0aW9uLnggLT0gKG5vZGUuc2l6ZS53aWR0aCAtIG4uc2l6ZS53aWR0aCkgLyAyO1xyXG4gICAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRQb3NpdGlvbi55IC09IChub2RlLnNpemUuaGVpZ2h0IC0gbi5zaXplLmhlaWdodCkgLyAyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBuZXdHbG9iYWxQb3NpdGlvbiA9IGxvY2FsVG9HbG9iYWxQb2ludChcclxuICAgICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50UG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICBfZnVsbFNjcmVlbk1vZGUgPyBvdmVyVmlld0ZyYW1lLnNjYWxlIDogdmlld0ZyYW1lLnNjYWxlLFxyXG4gICAgICAgICAgICAgICAgX2Z1bGxTY3JlZW5Nb2RlID8gb3ZlclZpZXdGcmFtZSA6IHZpZXdGcmFtZSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgY29uc3Qgb2xkR2xvYmFsUG9zaXRpb24gPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24obm9kZSk7XHJcblxyXG4gICAgICAgICAgICBub2RlLm1vZGVsLnBvc2l0aW9uID0gbmV3R2xvYmFsUG9zaXRpb247XHJcbiAgICAgICAgICAgIG5vZGUudmlld0ZyYW1lT3duZXJJZCA9IHZpZXdGcmFtZS5pZDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIF9kYXRhQ29udGFpbmVyLnVwZGF0ZVpvbmVzRm9yTm9kZShub2RlLCBvbGRHbG9iYWxQb3NpdGlvbik7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBhZGRlZEZyYW1lSWRzID0gY2hhbmdlZFZpZXdGcmFtZXMubWFwKHZmID0+IHZmLmlkKTtcclxuICAgICAgICAgICAgY29uc3QgcHJldk93bmVyTm90QWRkZWRJbkxpc3QgPSBhZGRlZEZyYW1lSWRzLmluZGV4T2YocHJldk93bmVyRnJhbWUuaWQpID09PSAtMTtcclxuICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lTm90QWRkZWRJbkxpc3QgPSBhZGRlZEZyYW1lSWRzLmluZGV4T2Yodmlld0ZyYW1lLmlkKSA9PT0gLTE7XHJcbiAgICAgICAgICAgIGlmIChwcmV2T3duZXJOb3RBZGRlZEluTGlzdCAmJiBwcmV2T3duZXJGcmFtZS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIHByZXZPd25lckZyYW1lLnVwZGF0ZUJvdW5kcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkVmlld0ZyYW1lcy5wdXNoKHByZXZPd25lckZyYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmlld0ZyYW1lTm90QWRkZWRJbkxpc3QgJiYgdmlld0ZyYW1lLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lLnVwZGF0ZUJvdW5kcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkVmlld0ZyYW1lcy5wdXNoKHZpZXdGcmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKF9mdWxsU2NyZWVuTW9kZSkge1xyXG4gICAgICAgICAgICBvdmVyVmlld0ZyYW1lLnVwZGF0ZUJvdW5kcyA9IHRydWU7XHJcbiAgICAgICAgICAgIGNoYW5nZWRWaWV3RnJhbWVzLnB1c2gob3ZlclZpZXdGcmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgX3JlZHJhdyh7IHZpZXdGcmFtZXM6IGNoYW5nZWRWaWV3RnJhbWVzIH0pO1xyXG4gICAgICAgIF9saW1pdFZpZXdQb3J0c1Bvc3Rpb25zKGNoYW5nZWRWaWV3RnJhbWVzLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignbm9kZXMtcG9zaXRpb24tY2hhbmdlZCcsIFtub2Rlc10pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB1aSBmb3IgVmlld0ZyYW1lcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZVZpZXdGcmFtZXNVSSAodmlld01hbmFnZXIpIHtcclxuICAgICAgICBpZiAoX2Jhc2UudWkpIHtcclxuICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lc1VJID0gbmV3IFZpZXdGcmFtZXNVSSh7XHJcbiAgICAgICAgICAgICAgICByb290RWw6IF9iYXNlLnVpLFxyXG4gICAgICAgICAgICAgICAgdmlld01hbmFnZXI6IHZpZXdNYW5hZ2VyLFxyXG4gICAgICAgICAgICB9LCBwYXJhbWV0ZXJzKTtcclxuXHJcbiAgICAgICAgICAgIHZpZXdGcmFtZXNVSS5vbignc3BsaXR0ZXItcG9zaXRpb24tY2hhbmdlZCcsIChzLCBkaWZmT2JqKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hvcml6b250YWxPcmllbnRhdGVkID0gX29yaWVudGF0aW9uID09PSAnbGVmdC10by1yaWdodCcgfHwgX29yaWVudGF0aW9uID09PSAncmlnaHQtdG8tbGVmdCc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gZGlmZk9iai5kaWZmO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmZBID0gcy5tb2RlbC52aWV3RnJhbWVBO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmZCID0gcy5tb2RlbC52aWV3RnJhbWVCO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGhlcmVJc0RpZmZlcmVuY2UgPSBkaWZmICE9PSB1bmRlZmluZWQgJiYgZGlmZiAhPT0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGVyZUlzRGlmZmVyZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hvcml6b250YWxPcmllbnRhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZmQS5zaXplLndpZHRoICs9IGRpZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZmQi5zaXplLndpZHRoIC09IGRpZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZmQi5wb3NpdGlvbi54ICs9IGRpZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmZBLnNpemUuaGVpZ2h0ICs9IGRpZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZmQi5zaXplLmhlaWdodCAtPSBkaWZmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZkIucG9zaXRpb24ueSArPSBkaWZmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2ZkEuY3VzdG9tZVNpemVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHZmQi5jdXN0b21lU2l6ZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlmZk9iai5sYXN0Q2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3JlZHJhdyh7IHZpZXdGcmFtZXM6IFt2ZkEsIHZmQl0sIHF1aWNrVXBkYXRlOiBmYWxzZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICBfbGltaXRWaWV3UG9ydHNQb3N0aW9ucyhbdmZBLCB2ZkJdKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhlcmVJc0RpZmZlcmVuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBfcmVkcmF3KHsgdmlld0ZyYW1lczogW3ZmQSwgdmZCXSwgcXVpY2tVcGRhdGU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdmlld0ZyYW1lc1VJLm9uKCd2aWV3LXBvcnQtcG9zaXRpb24tY2hhbmdlZCcsICh2aWV3RnJhbWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbGV2YW50Vmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQodmlld0ZyYW1lLmlkKTtcclxuICAgICAgICAgICAgICAgIF9wb3NpdGlvblZpZXdQb3J0KHJlbGV2YW50Vmlld0ZyYW1lLCB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbiwgcGFyYW1ldGVycy5hbmltYXRpb24sICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VkVmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQodmlld0ZyYW1lLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3ZpZXctZnJhbWVzLXNpemUtb3ItcG9zaXRpb24tY2hhbmdlZCcsIFtbY2hhbmdlZFZpZXdGcmFtZV1dKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZpZXdGcmFtZXNVSS5vbigndmlldy1mcmFtZS1jb2xsYXBzZWQnLCB2aWV3RnJhbWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lLmV4cGFuZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfY2xvc2VWaWV3RnJhbWUodmlld0ZyYW1lLmlkKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdmlld0ZyYW1lc1VJO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGh0bWwgYmFzZSBmb3IgZGlhZ3JhbS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUJhc2UgKGJhc2VEaXYpIHtcclxuICAgICAgICBiYXNlRGl2LmlubmVySFRNTCA9ICcnO1xyXG5cclxuICAgICAgICBjb25zdCBkaWFncmFtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgZGlhZ3JhbS5jbGFzc05hbWUgPSAndHEtbGctbGluZWFnZS1kaWFncmFtJztcclxuICAgICAgICBkaWFncmFtLmlkID0gJ3RxX2xpbmVhZ2UtZ3JhcGgnO1xyXG4gICAgICAgIGJhc2VEaXYuYXBwZW5kQ2hpbGQoZGlhZ3JhbSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHVpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgdWkuY2xhc3NOYW1lID0gJ3RxLWxnLWxpbmVhZ2UtdWknO1xyXG4gICAgICAgIGJhc2VEaXYuYXBwZW5kQ2hpbGQodWkpO1xyXG5cclxuICAgICAgICByZXR1cm4geyB1aSwgZGlhZ3JhbSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHNlbGVjdGVkIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IC0gYmxvY2tzIHRocm93aW5nIG9mIGV2ZW50XHJcbiAgICAgKiBAZmlyZXMgc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF91bnNlbGVjdCAoc2lsZW50KSB7XHJcbiAgICAgICAgaWYgKF9zZWxlY3RlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgX3BhdGggPSBudWxsO1xyXG4gICAgICAgICAgICBfc2VsZWN0ZWRFbGVtZW50LnVuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgIF9zZWxlY3RlZEVsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzaWxlbnQpIHtcclxuICAgICAgICAgICAgICAgIF9yZWRyYXcoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkJywgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHNlbGVjdGVkIG9iamVjdCBhbmQgY2hhbmdlcyB2aWV3UG9ydCBwb3NpdGlvbiBpZiBpdCdzIG5lZWRlZC5cclxuICAgICAqIEBwYXJhbSB7Tm9kZXxMaW5rfSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvY3VzT25cclxuICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICogQGZpcmVzIHNlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfc2VsZWN0IChlbGVtZW50LCBmb2N1c09uKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50ID0gZ2V0QmFzZUVsZW1lbnQoZWxlbWVudCk7XHJcblxyXG4gICAgICAgIGlmIChzZWxlY3RlZEVsZW1lbnQgIT09IF9zZWxlY3RlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKF9zZWxlY3RlZEVsZW1lbnQpIF9zZWxlY3RlZEVsZW1lbnQudW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgX3NlbGVjdGVkRWxlbWVudCA9IHNlbGVjdGVkRWxlbWVudDtcclxuICAgICAgICAgICAgX3NlbGVjdGVkRWxlbWVudC5zZWxlY3QoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChmb2N1c09uKSB7XHJcbiAgICAgICAgICAgIF9mb2N1c09uRWxlbWVudChfc2VsZWN0ZWRFbGVtZW50LCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBfcGF0aCA9IGdldFBhdGgoX3NlbGVjdGVkRWxlbWVudCwgX2RhdGFDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgX3JlZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWQnLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBfcGF0aCA9IGdldFBhdGgoX3NlbGVjdGVkRWxlbWVudCwgX2RhdGFDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgX3JlZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWQnLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgbW92ZXMgcG9zaXRpb24gb2YgdGhlIHZpZXdQb3J0IHNvIHRoYXRcclxuICAgICAqIHRoZSBzZWxlY3RlZCBlbGVtZW50IGFwcGVhcnMgaW4gdGhlIHNlbnRlciBvZiB0aGUgdmlld1BvcnRcclxuICAgICAqIEBwYXJhbSB7Tm9kZXxMaW5rfSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIF9mb2N1c09uRWxlbWVudCBjYW4gYmUgYXN5bmNocm9ub3VzIGRlcGVuZHMgb24gYW5pbWF0aW9uIG1vZGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2ZvY3VzT25FbGVtZW50IChlbGVtZW50LCBjYWxsYmFjaykge1xyXG4gICAgICAgIGxldCBmb2N1c05vZGUgPSBudWxsO1xyXG4gICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgTGluaykge1xyXG4gICAgICAgICAgICBmb2N1c05vZGUgPSBfZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXBbZWxlbWVudC5tb2RlbC5zb3VyY2VdO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIE5vZGUpIHtcclxuICAgICAgICAgICAgZm9jdXNOb2RlID0gZWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvY3VzTm9kZSkge1xyXG4gICAgICAgICAgICBsZXQgdmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUZvck5vZGUoZm9jdXNOb2RlKTtcclxuICAgICAgICAgICAgaWYgKCF2aWV3RnJhbWUuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBfcmVkcmF3KHsgdmlld0ZyYW1lczogW3sgaWQ6IHZpZXdGcmFtZS5pZCwgZXhwYW5kZWQ6IHRydWUgfV0sIHF1aWNrVXBkYXRlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQodmlld0ZyYW1lLmlkKTtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcigndmlldy1mcmFtZXMtc3RhdGUtY2hhbmdlZCcsIFtbdmlld0ZyYW1lXV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdQb3J0U2l6ZSA9IHZpZXdGcmFtZS5zaXplO1xyXG4gICAgICAgICAgICBjb25zdCBub2RlU2l6ZSA9IGdldEdsb2JhbE5vZGVTaXplKGZvY3VzTm9kZSwgX3NjYWxlKTtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZVBvc2l0aW9uID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKGZvY3VzTm9kZSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0UG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBub2RlUG9zaXRpb24ueCArIChub2RlU2l6ZS53aWR0aCAtIHZpZXdQb3J0U2l6ZS53aWR0aCkgLyAyLFxyXG4gICAgICAgICAgICAgICAgeTogbm9kZVBvc2l0aW9uLnkgKyAobm9kZVNpemUuaGVpZ2h0IC0gdmlld1BvcnRTaXplLmhlaWdodCkgLyAyLFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgX3Bvc2l0aW9uVmlld1BvcnQodmlld0ZyYW1lLCB0YXJnZXRQb3NpdGlvbiwgcGFyYW1ldGVycy5hbmltYXRpb24sICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VkVmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQodmlld0ZyYW1lLmlkKTtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcigndmlldy1mcmFtZXMtc2l6ZS1vci1wb3NpdGlvbi1jaGFuZ2VkJywgW1tjaGFuZ2VkVmlld0ZyYW1lXV0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgdmlld1BvcnQgcG9zaXRpb24gY2hhbmdlcyBzaG91bGQgYmUgcGVyZm9ybWVkIHRocm91Z2ggdGhpcyBtZXRob2RzLlxyXG4gICAgICogX3Bvc2l0aW9uVmlld1BvcnQgKGV4Y2x1ZGUgc2NhbGUpXHJcbiAgICAgKiBJdCdzIG5lZWRlZCB0byBzdG9wIGFuaW1hdGlvbiBpbiBjYXNlIG9mIGFuaW1hdGlvbiBoYXZlbid0IGJlZW4gZG9uZS5cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgc2V0cyBvZmZzZXQgZm9yIGFsbCBlbGVtZW50cyBpbnRvIHRoZSB2aWV3UG9ydC5cclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lfSB2aWV3RnJhbWVcclxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFuaW1hdGlvbiAtIGl0J3Mgb3B0aW9uYWxcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gaXQncyBjYWxsZWQgYWZ0ZXIgZm9jdXNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3Bvc2l0aW9uVmlld1BvcnQgKHZpZXdGcmFtZSwgcG9pbnQsIGFuaW1hdGlvbiwgY2FsbGJhY2spIHtcclxuICAgICAgICBjb25zdCByZWxldmF0blZpZXdGcmFtZSA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVCeUlkKHZpZXdGcmFtZS5pZCk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0UG9zID0gbGltaXRQb2ludFBvc2l0aW9uKHBvaW50LCByZWxldmF0blZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uQm91bmRzKTtcclxuICAgICAgICBjb25zdCB2aWV3UG9ydFBvc2l0aW9uID0gcmVsZXZhdG5WaWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbjtcclxuICAgICAgICBjb25zdCB0YXJnZXRJc1JlYWNoZWQgPSB2aWV3UG9ydFBvc2l0aW9uLnggPT09IHRhcmdldFBvcy54ICYmIHZpZXdQb3J0UG9zaXRpb24ueSA9PT0gdGFyZ2V0UG9zLnk7XHJcblxyXG4gICAgICAgIGlmICgoIWFuaW1hdGlvbikgfHwgdGFyZ2V0SXNSZWFjaGVkIHx8ICghdmlld0ZyYW1lLmFjdGl2ZSkpIHtcclxuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoX2FuaW1hdGlvbklkKTtcclxuICAgICAgICAgICAgdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb24gPSB0YXJnZXRQb3M7XHJcbiAgICAgICAgICAgIF9yZWRyYXcoeyB2aWV3RnJhbWVzOiBbdmlld0ZyYW1lXSwgcXVpY2tVcGRhdGU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfYW5pbWF0ZWRWaWV3UG9ydENoYW5naW5nKHJlbGV2YXRuVmlld0ZyYW1lLCB0YXJnZXRQb3MsIGNhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnMgKHZpZXdGcmFtZXMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmVjdXJzaXZlQ2FsbCgwKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVjdXJzaXZlQ2FsbCAoaW5kZXgpIHtcclxuICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lID0gdmlld0ZyYW1lc1tpbmRleF07XHJcbiAgICAgICAgICAgIGlmICghdmlld0ZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFZpZXdGcmFtZSA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVCeUlkKHZpZXdGcmFtZS5pZCk7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0Vmlld0ZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9saW1pdFZpZXdQb3J0UG9zdGlvbih0YXJnZXRWaWV3RnJhbWUsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHZpZXdGcmFtZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlQ2FsbChpbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VkVmlld0ZyYW1lc01vZGVscyA9IHZpZXdGcmFtZXMubWFwKHZmID0+IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVCeUlkKHZmLmlkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3LWZyYW1lcy1zaXplLW9yLXBvc2l0aW9uLWNoYW5nZWQnLCBbY2hhbmdlZFZpZXdGcmFtZXNNb2RlbHNdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfbGltaXRWaWV3UG9ydFBvc3Rpb24gKHZpZXdGcmFtZSwgY2FsbGJhY2spIHtcclxuICAgICAgICBjb25zdCBsaW1pdHRlZFBvc2l0aW9uID0gbGltaXRQb2ludFBvc2l0aW9uKHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uLCB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbkJvdW5kcyk7XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb25Jc0luY29ycmVjdCA9IGxpbWl0dGVkUG9zaXRpb24ueCAhPT0gdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb24ueCB8fCBsaW1pdHRlZFBvc2l0aW9uLnkgIT09IHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uLnk7XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uSXNJbmNvcnJlY3QpIHtcclxuICAgICAgICAgICAgX3Bvc2l0aW9uVmlld1BvcnQodmlld0ZyYW1lLCBsaW1pdHRlZFBvc2l0aW9uLCBwYXJhbWV0ZXJzLmFuaW1hdGlvbiwgY2FsbGJhY2spO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFnZXMgdmlld1BvcnQgcG9zaXRpb24gc21vb3RobHkgZnJvbSBjdXJyZW50IHBvc2l0aW9uIHRvIHRhcmdldC5cclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lfSB2ZlxyXG4gICAgICogQHBhcmFtIHtQb2ludH0gdGFyZ2V0UG9zXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBsZXQgX2FuaW1hdGlvbklkID0gdW5kZWZpbmVkO1xyXG4gICAgZnVuY3Rpb24gX2FuaW1hdGVkVmlld1BvcnRDaGFuZ2luZyAodmlld0ZyYW1lLCB0YXJnZXRQb3MsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgY29uc3QgZGlmZlggPSBnZXREaWZmKHN0YXJ0UG9zLngsIHRhcmdldFBvcy54KTtcclxuICAgICAgICBjb25zdCBkaWZmWSA9IGdldERpZmYoc3RhcnRQb3MueSwgdGFyZ2V0UG9zLnkpO1xyXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGRpZmZYLCBkaWZmWSk7XHJcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB2aWV3RnJhbWUuc2NhbGUgfHwgX3NjYWxlO1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRTdGVwWCA9IHBhcmFtZXRlcnMuYW5pbWF0aW9uU3RlcCAvIHNjYWxlLng7XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdFN0ZXBZID0gcGFyYW1ldGVycy5hbmltYXRpb25TdGVwIC8gc2NhbGUueTtcclxuXHJcbiAgICAgICAgbGV0IHN0ZXBYLCBzdGVwWTtcclxuICAgICAgICBpZiAobWF4ID09PSBkaWZmWCkge1xyXG4gICAgICAgICAgICBzdGVwWCA9IGRlZmF1bHRTdGVwWDtcclxuICAgICAgICAgICAgc3RlcFkgPSBkaWZmWSAvIChkaWZmWCAvIGRlZmF1bHRTdGVwWSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RlcFggPSBkaWZmWCAvIChkaWZmWSAvIGRlZmF1bHRTdGVwWCk7XHJcbiAgICAgICAgICAgIHN0ZXBZID0gZGVmYXVsdFN0ZXBZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgc3RhcnREaXN0YW5jZSA9IGdldERpc3Qodmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb24sIHRhcmdldFBvcyk7XHJcblxyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKF9hbmltYXRpb25JZCk7XHJcblxyXG4gICAgICAgIGxldCB0aW1lO1xyXG4gICAgICAgIHJlcXVyc2l2ZUFuaW1hdGlvbigpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZXF1cnNpdmVBbmltYXRpb24gKG9sZFBvcykge1xyXG4gICAgICAgICAgICBfYW5pbWF0aW9uSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lUmF0ZSA9IDEwMDAgLyAobm93IC0gdGltZSkgfHwgcGFyYW1ldGVycy5taW5GcmFtZVJhdGU7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHRNb2RpZmllciA9IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1ldGVycy5taW5GcmFtZVJhdGUgPiB0aW1lUmF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRNb2RpZmllciA9IHBhcmFtZXRlcnMubWluRnJhbWVSYXRlIC8gdGltZVJhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZVJhdGUgPiBwYXJhbWV0ZXJzLm1heEZyYW1lUmF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRNb2RpZmllciA9IHBhcmFtZXRlcnMubWF4RnJhbWVSYXRlIC8gdGltZVJhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aW1lID0gbm93O1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1clBvcyA9IHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0SXNSZWFjaGVkID0gY3VyUG9zLnggPT09IHRhcmdldFBvcy54ICYmIGN1clBvcy55ID09PSB0YXJnZXRQb3MueTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdlQXJlTm90TW92aW5nID0gb2xkUG9zICYmIGN1clBvcy54ID09PSBvbGRQb3MueCAmJiBjdXJQb3MueSA9PT0gb2xkUG9zLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldElzUmVhY2hlZCB8fCB3ZUFyZU5vdE1vdmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIF9kZWxheWVkUmVkcmF3KHsgdmlld0ZyYW1lczogW3ZpZXdGcmFtZV0gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gX3JlZHJhdyh7IHZpZXdGcmFtZXM6IFt2aWV3RnJhbWVdLCBxdWlja1VwZGF0ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoX2FuaW1hdGlvbklkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmWCA9IGdldERpZmYoY3VyUG9zLngsIHRhcmdldFBvcy54KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmWSA9IGdldERpZmYoY3VyUG9zLnksIHRhcmdldFBvcy55KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UG9zID0geyB4OiBjdXJQb3MueCwgeTogY3VyUG9zLnkgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyRGlzdGFuY2UgPSBnZXREaXN0KGN1clBvcywgdGFyZ2V0UG9zKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrID0gMSAtIE1hdGguY29zKE1hdGguUEkgKiAoc3RhcnREaXN0YW5jZSAtIGN1ckRpc3RhbmNlKSAvIHN0YXJ0RGlzdGFuY2UpICogMC4zO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaW5hbFN0ZXBYID0gc3RlcFg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxTdGVwWSA9IHN0ZXBZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3UG9zLnggIT09IHRhcmdldFBvcy54KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBNYXRoLm1pbihkaWZmWCwgZmluYWxTdGVwWCAqIGsgKiB0TW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQb3MueCArPSBjdXJQb3MueCA8IHRhcmdldFBvcy54ID8gZCA6IC1kO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3UG9zLnkgIT09IHRhcmdldFBvcy55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBNYXRoLm1pbihNYXRoLmFicyhkaWZmWSksIGZpbmFsU3RlcFkgKiBrICogdE1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UG9zLnkgKz0gY3VyUG9zLnkgPCB0YXJnZXRQb3MueSA/IGQgOiAtZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb24gPSBuZXdQb3M7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9yZWRyYXcoeyB2aWV3RnJhbWVzOiBbdmlld0ZyYW1lXSwgcXVpY2tVcGRhdGU6IHRydWUgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVyc2l2ZUFuaW1hdGlvbihjdXJQb3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoZXMgYWxsIHZpZXdGcmFtZXMgYm91bmRzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfcmVmcmVzaCAodmlld0ZyYW1lcykge1xyXG4gICAgICAgIHZpZXdGcmFtZXMgPSB2aWV3RnJhbWVzIHx8IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCk7XHJcbiAgICAgICAgX3JlZHJhdyh7IHZpZXdGcmFtZXM6IHZpZXdGcmFtZXMsIHVwZGF0ZUJvdW5kczogdHJ1ZSB9KTtcclxuICAgICAgICBfbGltaXRWaWV3UG9ydHNQb3N0aW9ucyh2aWV3RnJhbWVzKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfcmVzZXRMYXlvdXQgKCkge1xyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZUFmZmVjdGVkSWRzID0ge307XHJcbiAgICAgICAgY29uc3Qgb3ZlclZpZXdGcmFtZUlkID0gX3ZpZXdNYW5hZ2VyLmdldE92ZXJWaWV3RnJhbWUoKS5pZDtcclxuXHJcbiAgICAgICAgX2RhdGFDb250YWluZXIubm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgaWYgKG5vZGUubW9kZWwuZGVmYXVsdFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJQb3MgPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24obm9kZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlLm1vZGVsLnBvc2l0aW9uID0gbm9kZS5tb2RlbC5kZWZhdWx0UG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBfZGF0YUNvbnRhaW5lci51cGRhdGVab25lc0Zvck5vZGUobm9kZSwgY3VyUG9zKTtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLnZpZXdGcmFtZU93bmVySWQpIHZpZXdGcmFtZUFmZmVjdGVkSWRzW25vZGUudmlld0ZyYW1lT3duZXJJZF0gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzRnVsbFNjcmVlbk1vZGUgPSBfdmlld01hbmFnZXIuaXNGdWxsU2NyZWVuTW9kZSgpO1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lQWZmZWN0ZWRJZHNbaXNGdWxsU2NyZWVuTW9kZSA/IG92ZXJWaWV3RnJhbWVJZCA6IG5vZGUubW9kZWwudmlld0ZyYW1lXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS52aWV3RnJhbWVPd25lcklkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3Qgdmlld0ZyYW1lcyA9IE9iamVjdC5rZXlzKHZpZXdGcmFtZUFmZmVjdGVkSWRzKVxyXG4gICAgICAgICAgICAubWFwKGtleSA9PiAoeyBpZDoga2V5LCB1cGRhdGVCb3VuZHM6IHRydWUgfSkpO1xyXG4gICAgICAgIF9yZWRyYXcoeyB2aWV3RnJhbWVzOiB2aWV3RnJhbWVzIH0pO1xyXG4gICAgICAgIF9saW1pdFZpZXdQb3J0c1Bvc3Rpb25zKHZpZXdGcmFtZXMpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuXHJcbmNvbnN0IGcgPSBqb2ludC5nO1xyXG5jb25zdCBMSU5LX09GRlNFVCA9IDc7XHJcblxyXG5leHBvcnQgY29uc3QgRU5BQkxFX1JPVVRJTkdTID0gWyAnbWV0cm8nLCAnbm9ybWFsJywgJ21hbmhhdHRhbicsICdvcnRob2dvbmFsJywgJ2xncm91dGVyJyBdO1xyXG5cclxuLyoqXHJcbiAqIFJvdXRpbmdNYW5hZ2VyXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7bGlua1JvdXRpbmcsIGxpbmtzLCBib3VuZHN9IG9wdGlvbnMgXHJcbiAqIEBwYXJhbSB7Kn0gcGFyYW1ldGVycyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBSb3V0aW5nTWFuYWdlciAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgbGV0IF9saW5rcztcclxuICAgIGxldCBfcm91dGluZyA9IG9wdGlvbnMubGlua1JvdXRpbmcgfHwgcGFyYW1ldGVycy5saW5rUm91dGluZztcclxuXHJcbiAgICBsZXQgX3ZlcnRleE1hcCA9IHt9O1xyXG4gICAgbGV0IF9pZFRvVmVydGV4ID0ge307XHJcbiAgICBsZXQgX2JvdW5kcyA9IG9wdGlvbnMuYm91bmRzO1xyXG5cclxuICAgIHNlbGYuc2V0RGF0YSA9IF9zZXREYXRhO1xyXG4gICAgc2VsZi5zZXRSb3V0aW5nID0gX3NldFJvdXRpbmc7XHJcbiAgICBzZWxmLnJlc2V0Um91dGluZyA9IF9yZXNldFJvdXRpbmc7XHJcbiAgICBzZWxmLnNldEJvdW5kcyA9IF9zZXRCb3VuZHM7XHJcblxyXG4gICAgc2VsZi5nZXRSb3V0aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfcm91dGluZztcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX2luaXQgKCkge1xyXG4gICAgICAgIF9zZXREYXRhKG9wdGlvbnMubGlua3MpO1xyXG4gICAgICAgIGpvaW50LnJvdXRlcnMubGdyb3V0ZXIgPSBsZ3JvdXRlcjtcclxuICAgICAgICBqb2ludC5yb3V0ZXJzLm1ldHJvID0gbmV3TWV0cm87XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3NldEJvdW5kcyAoYm91bmRzKSB7XHJcbiAgICAgICAgX2JvdW5kcyA9IGJvdW5kcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfc2V0RGF0YSAobGlua3MpIHtcclxuICAgICAgICBfbGlua3MgPSBsaW5rcztcclxuICAgICAgICBfdXBkYXRlTGlua1JvdXRpbmcoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfc2V0Um91dGluZyAocm91dGluZykge1xyXG4gICAgICAgIGNvbnN0IGlzVW5rbm93blJvdXRpbmdJZCA9IEVOQUJMRV9ST1VUSU5HUy5pbmRleE9mKHJvdXRpbmcpID09PSAtMTtcclxuICAgICAgICBpZiAoaXNVbmtub3duUm91dGluZ0lkKSB7XHJcbiAgICAgICAgICAgIHJvdXRpbmcgPSAnbWV0cm8nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm91dGluZyAhPT0gX3JvdXRpbmcpIHtcclxuICAgICAgICAgICAgX3JvdXRpbmcgPSByb3V0aW5nO1xyXG4gICAgICAgICAgICBfdXBkYXRlTGlua1JvdXRpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3VwZGF0ZUxpbmtSb3V0aW5nICgpIHtcclxuICAgICAgICBfdmVydGV4TWFwID0ge307XHJcbiAgICAgICAgX2lkVG9WZXJ0ZXggPSB7fTtcclxuICAgICAgICBfbGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgcm91dGVyID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogX3JvdXRpbmcsXHJcbiAgICAgICAgICAgICAgICBhcmdzOiBsaW5rLmdldCgncm91dGVyJykuYXJncyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGluay5zZXQoJ3JvdXRlcicsIHJvdXRlciwgbGluay5pc09uVGhlR3JhcGgoKSA/IHt9IDogeyBzaWxlbnQ6IHRydWUgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3Jlc2V0Um91dGluZyAoKSB7XHJcbiAgICAgICAgX3ZlcnRleE1hcCA9IHt9O1xyXG4gICAgICAgIF9pZFRvVmVydGV4ID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUm91dGVyc1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBjb25zdCBsZ3JvdXRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtYW51YWxWZXJ0aWNlcywgb3B0cywgbGlua1ZpZXcpIHtcclxuICAgICAgICAgICAgY29uc3QgZGVmYXVsdENvZmlnID0ge1xyXG4gICAgICAgICAgICAgICAgc3RlcDogMTAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCB2ZXJ0aWNlcyA9IGpvaW50LnJvdXRlcnMubWFuaGF0dGFuKG1hbnVhbFZlcnRpY2VzLCBfLmV4dGVuZCh7fSwgZGVmYXVsdENvZmlnLCBvcHRzKSwgbGlua1ZpZXcpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fZmluZENvbm5lY3Rpb25Qb2ludHModmVydGljZXMpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgYWxsVmVydGljZXMgPSBmaW5kSW50ZXJtZWRpYXRlVmVydGljZXMoXHJcbiAgICAgICAgICAgICAgICBbdGhpcy5zb3VyY2VQb2ludF0uY29uY2F0KHZlcnRpY2VzKS5jb25jYXQoW3RoaXMudGFyZ2V0UG9pbnRdKSxcclxuICAgICAgICAgICAgICAgIC8vIHZlcnRpY2VzLmxlbmd0aCA+IDAgPyB2ZXJ0aWNlcyA6IFt0aGlzLnNvdXJjZUJCb3guY2VudGVyKCksIHRoaXMudGFyZ2V0QkJveC5jZW50ZXIoKV0sXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29maWcuc3RlcCxcclxuICAgICAgICAgICAgKTtcclxuICAgIFxyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVkVmVydGljZXMgPSBbXTtcclxuICAgICAgICAgICAgY2xlYXJWZXJ0aWNlcyhsaW5rVmlldyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsZXQgbWF4T2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsVmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZWZXJ0ZXggPSBhbGxWZXJ0aWNlc1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJ0ZXggPSBhbGxWZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRWZXJ0ZXggPSBhbGxWZXJ0aWNlc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXgudHlwZSA9IGdldFBvc2l0aW9uVHlwZShwcmV2VmVydGV4LCB2ZXJ0ZXgsIG5leHRWZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgbWF4T2Zmc2V0ID0gZ2V0T2Zmc2V0KHZlcnRleCwgbWF4T2Zmc2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgIGFsbFZlcnRpY2VzLmZvckVhY2godmVydGV4ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZlcnRleCA9IHN0b3JlVmVlcnRleCh2ZXJ0ZXgsIG1heE9mZnNldCwgbGlua1ZpZXcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZlcnRpY2VzLmluZGV4T2YodmVydGV4KSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVkVmVydGljZXMucHVzaChuZXdWZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRlZFZlcnRpY2VzLm1hcCh2ZXJ0ZXggPT4gKHtcclxuICAgICAgICAgICAgICAgIHg6IE1hdGgubWluKE1hdGgubWF4KHZlcnRleC54LCBfYm91bmRzLnggKSwgX2JvdW5kcy54ICsgX2JvdW5kcy53aWR0aCksXHJcbiAgICAgICAgICAgICAgICB5OiBNYXRoLm1pbihNYXRoLm1heCh2ZXJ0ZXgueSwgX2JvdW5kcy55ICksIF9ib3VuZHMueSArIF9ib3VuZHMuaGVpZ2h0KSxcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIGNvbnN0IG5ld01ldHJvID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY29uZmlnID0ge1xyXG4gICAgICAgICAgICAvLyBjb3N0IG9mIGEgZGlhZ29uYWwgc3RlcCAoY2FsY3VsYXRlZCBpZiBub3QgZGVmaW5lZCkuXHJcbiAgICAgICAgICAgIGRpYWdvbmFsQ29zdDogbnVsbCxcclxuICAgICAgICAgICAgLy8gYW4gYXJyYXkgb2YgZGlyZWN0aW9ucyB0byBmaW5kIG5leHQgcG9pbnRzIG9uIHRoZSByb3V0ZVxyXG4gICAgICAgICAgICBkaXJlY3Rpb25zOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RlcCA9IHRoaXMuc3RlcDtcclxuICAgICAgICAgICAgICAgIHZhciBkaWFnb25hbENvc3QgPSB0aGlzLmRpYWdvbmFsQ29zdCB8fCBNYXRoLmNlaWwoTWF0aC5zcXJ0KHN0ZXAgKiBzdGVwIDw8IDEpKTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICB7IG9mZnNldFg6IHN0ZXAgICwgb2Zmc2V0WTogMCAgICAgLCBjb3N0OiBzdGVwIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBvZmZzZXRYOiBzdGVwICAsIG9mZnNldFk6IHN0ZXAgICwgY29zdDogZGlhZ29uYWxDb3N0IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBvZmZzZXRYOiAwICAgICAsIG9mZnNldFk6IHN0ZXAgICwgY29zdDogc3RlcCB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgb2Zmc2V0WDogLXN0ZXAgLCBvZmZzZXRZOiBzdGVwICAsIGNvc3Q6IGRpYWdvbmFsQ29zdCB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgb2Zmc2V0WDogLXN0ZXAgLCBvZmZzZXRZOiAwICAgICAsIGNvc3Q6IHN0ZXAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7IG9mZnNldFg6IC1zdGVwICwgb2Zmc2V0WTogLXN0ZXAgLCBjb3N0OiBkaWFnb25hbENvc3QgfSxcclxuICAgICAgICAgICAgICAgICAgICB7IG9mZnNldFg6IDAgICAgICwgb2Zmc2V0WTogLXN0ZXAgLCBjb3N0OiBzdGVwIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBvZmZzZXRYOiBzdGVwICAsIG9mZnNldFk6IC1zdGVwICwgY29zdDogZGlhZ29uYWxDb3N0IH1cclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1heEFsbG93ZWREaXJlY3Rpb25DaGFuZ2U6IDQ1LFxyXG4gICAgICAgICAgICAvLyBhIHNpbXBsZSByb3V0ZSB1c2VkIGluIHNpdHVhdGlvbnMsIHdoZW4gbWFpbiByb3V0aW5nIG1ldGhvZCBmYWlsc1xyXG4gICAgICAgICAgICAvLyAoZXhjZWVkIGxvb3BzLCBpbmFjY2Vzc2libGUpLlxyXG4gICAgICAgICAgICBmYWxsYmFja1JvdXRlOiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcclxuICAgICAgICAgICAgICAgIC8vIEZpbmQgYSByb3V0ZSB3aGljaCBicmVha3MgYnkgNDUgZGVncmVlcyBpZ25vcmluZyBhbGwgb2JzdGFjbGVzLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGhldGEgPSBmcm9tLnRoZXRhKHRvKTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgbGV0IGEgPSB7IHg6IHRvLngsIHk6IGZyb20ueSB9O1xyXG4gICAgICAgICAgICAgICAgbGV0IGIgPSB7IHg6IGZyb20ueCwgeTogdG8ueSB9O1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBpZiAodGhldGEgJSAxODAgPiA5MCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gYTtcclxuICAgICAgICAgICAgICAgICAgICBhID0gYjtcclxuICAgICAgICAgICAgICAgICAgICBiID0gdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICAgICAgY29uc3QgcDEgPSAodGhldGEgJSA5MCkgPCA0NSA/IGEgOiBiO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbDEgPSBnLmxpbmUoZnJvbSwgcDEpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWxwaGEgPSA5MCAqIE1hdGguY2VpbCh0aGV0YSAvIDkwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAyID0gZy5wb2ludC5mcm9tUG9sYXIobDEuc3F1YXJlZExlbmd0aCgpLCBnLnRvUmFkKGFscGhhICsgMTM1KSwgcDEpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbDIgPSBnLmxpbmUodG8sIHAyKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gbDEuaW50ZXJzZWN0aW9uKGwyKTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50ID8gW3BvaW50LnJvdW5kKCksIHRvXSA6IFt0b107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgXHJcbiAgICAgICAgLy8gcHVibGljIGZ1bmN0aW9uXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2ZXJ0aWNlcywgb3B0cywgbGlua1ZpZXcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxncm91dGVyLmNhbGwodGhpcywgdmVydGljZXMsIF8uZXh0ZW5kKHt9LCBjb25maWcsIG9wdHMpLCBsaW5rVmlldyk7XHJcbiAgICAgICAgfTtcclxuICAgIH0pKCk7XHJcbiAgICBcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UG9zaXRpb25UeXBlIChwcmV2VmVydGV4LCB2ZXJ0ZXgsIG5leHRWZXJ0ZXgpIHtcclxuICAgICAgICBpZiAocHJldlZlcnRleCB8fCBuZXh0VmVydGV4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLnJvdW5kKHZlcnRleC54KTtcclxuICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgucm91bmQodmVydGV4LnkpO1xyXG4gICAgICAgICAgICBjb25zdCBlcXVhbFggPSAoKCFwcmV2VmVydGV4KSB8fCBNYXRoLnJvdW5kKHByZXZWZXJ0ZXgueCkgPT09IHgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgoIW5leHRWZXJ0ZXgpIHx8IE1hdGgucm91bmQobmV4dFZlcnRleC54KSA9PT0geCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVxdWFsWSA9ICgoIXByZXZWZXJ0ZXgpIHx8IE1hdGgucm91bmQocHJldlZlcnRleC55KSA9PT0geSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCghbmV4dFZlcnRleCkgfHwgTWF0aC5yb3VuZChuZXh0VmVydGV4LnkpID09PSB5KTtcclxuICAgICAgICAgICAgaWYgKGVxdWFsWCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd2ZXJ0aWNhbCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXF1YWxZKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hvcml6b250YWwnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdwb2ludCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3BvaW50JztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlPZmZzZXQgKHZlcnRleCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gdmVydGV4LnR5cGUgPT09ICdob3Jpem9udGFsJzsgXHJcbiAgICAgICAgY29uc3QgaXNWZXJpY2FsID0gdmVydGV4LnR5cGUgPT09ICd2ZXJ0aWNhbCc7IFxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHZlcnRleC54ICsgKGlzSG9yaXpvbnRhbCA/IDAgOiBvZmZzZXQueCksXHJcbiAgICAgICAgICAgIHk6IHZlcnRleC55ICsgKGlzVmVyaWNhbCA/IDA6IG9mZnNldC55KSxcclxuICAgICAgICAgICAgdHlwZTogdmVydGV4LnR5cGUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRJZCAodmVydGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmVydGV4LngpICsgJ0AnICsgTWF0aC5yb3VuZCh2ZXJ0ZXgueSkgKyAnOicgKyB2ZXJ0ZXgudHlwZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmdW5jdGlvbiBnZXRPZmZzZXQgKHZlcnRleCwgZGVmYXVsdE9mZnNldCkge1xyXG4gICAgLy8gICAgIGNvbnN0IGN1clZlcnRleCA9IGFwcGx5T2Zmc2V0KHZlcnRleCwgZGVmYXVsdE9mZnNldCk7XHJcbiAgICAvLyAgICAgY29uc3QgdklkID0gZ2V0SWQoY3VyVmVydGV4KTtcclxuXHJcbiAgICAvLyAgICAgaWYgKF92ZXJ0ZXhNYXBbdklkXSkge1xyXG4gICAgLy8gICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSB2ZXJ0ZXgudHlwZSA9PT0gJ2hvcml6b250YWwnOyBcclxuICAgIC8vICAgICAgICAgY29uc3QgaXNWZXJpY2FsID0gdmVydGV4LnR5cGUgPT09ICd2ZXJ0aWNhbCc7XHJcbiAgICAvLyAgICAgICAgIHJldHVybiBnZXRPZmZzZXQgKHZlcnRleCwge1xyXG4gICAgLy8gICAgICAgICAgICAgeDogZGVmYXVsdE9mZnNldC54ICsgKGlzSG9yaXpvbnRhbCA/IDAgOiAtTElOS19PRkZTRVQpLFxyXG4gICAgLy8gICAgICAgICAgICAgeTogZGVmYXVsdE9mZnNldC55ICsgKGlzVmVyaWNhbCA/IDAgOiBMSU5LX09GRlNFVCksXHJcbiAgICAvLyAgICAgICAgIH0pO1xyXG4gICAgLy8gICAgIH0gZWxzZSB7XHJcbiAgICAvLyAgICAgICAgIHJldHVybiBkZWZhdWx0T2Zmc2V0O1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRPZmZzZXQgKHZlcnRleCwgZGVmYXVsdE9mZnNldCkge1xyXG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHZlcnRleC50eXBlID09PSAnaG9yaXpvbnRhbCc7IFxyXG4gICAgICAgIGNvbnN0IGlzVmVyaWNhbCA9IHZlcnRleC50eXBlID09PSAndmVydGljYWwnO1xyXG5cclxuICAgICAgICBsZXQgY3VyT2Zmc2V0ID0gZGVmYXVsdE9mZnNldDtcclxuICAgICAgICBsZXQgY3VyVmVydGV4ID0gYXBwbHlPZmZzZXQodmVydGV4LCBkZWZhdWx0T2Zmc2V0KTtcclxuICAgICAgICBsZXQgY3VySWQgPSBnZXRJZChjdXJWZXJ0ZXgpO1xyXG5cclxuICAgICAgICBjb25zdCB4VHlwZSA9IGRlZmF1bHRPZmZzZXQueCA9PT0gMCA/ICd0cmlnZ2VyJyA6IGRlZmF1bHRPZmZzZXQueCA+IDAgPyAncmlzZScgOiAnZmFsbCc7XHJcbiAgICAgICAgY29uc3QgeVR5cGUgPSBkZWZhdWx0T2Zmc2V0LnkgPT09IDAgPyAndHJpZ2dlcicgOiBkZWZhdWx0T2Zmc2V0LnkgPiAwID8gJ3Jpc2UnIDogJ2ZhbGwnO1xyXG4gICAgICAgIGxldCB4VHJpZ2dlciA9IDE7XHJcbiAgICAgICAgbGV0IHlUcmlnZ2VyID0gMTtcclxuICAgICAgICBsZXQgeFN0ZXAgPSAwO1xyXG4gICAgICAgIGxldCB5U3RlcCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKF92ZXJ0ZXhNYXBbY3VySWRdKSB7XHJcbiAgICAgICAgICAgIGN1ck9mZnNldCA9IHsgeDogZGVmYXVsdE9mZnNldC54LCB5OiBkZWZhdWx0T2Zmc2V0LnkgfTtcclxuICAgICAgICAgICAgaWYgKHhUeXBlID09PSAndHJpZ2dlcicpIHtcclxuICAgICAgICAgICAgICAgIHhUcmlnZ2VyID0gLXhUcmlnZ2VyO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhUcmlnZ2VyIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHhTdGVwKys7XHJcbiAgICAgICAgICAgICAgICB9ICAgIFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHhUeXBlID09PSAncmlzZScpIHtcclxuICAgICAgICAgICAgICAgIHhTdGVwKys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4U3RlcC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh5VHlwZSA9PT0gJ3RyaWdnZXInKSB7XHJcbiAgICAgICAgICAgICAgICB5VHJpZ2dlciA9IC15VHJpZ2dlcjtcclxuICAgICAgICAgICAgICAgIGlmICh5VHJpZ2dlciA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB5U3RlcCsrO1xyXG4gICAgICAgICAgICAgICAgfSAgICBcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh5VHlwZSA9PT0gJ3Jpc2UnKSB7XHJcbiAgICAgICAgICAgICAgICB5U3RlcCsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeVN0ZXAtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJPZmZzZXQgPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBkZWZhdWx0T2Zmc2V0LnggKyAoaXNIb3Jpem9udGFsID8gMCA6IHhTdGVwICogTElOS19PRkZTRVQgKiB4VHJpZ2dlciksXHJcbiAgICAgICAgICAgICAgICB5OiBkZWZhdWx0T2Zmc2V0LnkgKyAoaXNWZXJpY2FsID8gMCA6IHlTdGVwICogTElOS19PRkZTRVQgKiB5VHJpZ2dlciksXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBjdXJWZXJ0ZXggPSBhcHBseU9mZnNldCh2ZXJ0ZXgsIGN1ck9mZnNldCk7XHJcbiAgICAgICAgICAgIGN1cklkID0gZ2V0SWQoY3VyVmVydGV4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjdXJPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGNsZWFyVmVydGljZXMgKGxpbmtWaWV3KSB7XHJcbiAgICAgICAgaWYgKF9pZFRvVmVydGV4W2xpbmtWaWV3Lm1vZGVsLmlkXSkge1xyXG4gICAgICAgICAgICBfaWRUb1ZlcnRleFtsaW5rVmlldy5tb2RlbC5pZF0uZm9yRWFjaCh2ZXJ0ZXhJZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgX3ZlcnRleE1hcFt2ZXJ0ZXhJZF07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkZWxldGUgX2lkVG9WZXJ0ZXhbbGlua1ZpZXcubW9kZWwuaWRdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gc3RvcmVWZWVydGV4ICh2ZXJ0ZXgsIG9mZnNldCwgbGlua1ZpZXcsKSB7XHJcbiAgICAgICAgY29uc3QgbmV3VmVydGV4ID0gYXBwbHlPZmZzZXQodmVydGV4LCBvZmZzZXQpO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhJZCA9IGdldElkKG5ld1ZlcnRleCk7XHJcbiAgICAgICAgX3ZlcnRleE1hcFt2ZXJ0ZXhJZF0gPSBuZXdWZXJ0ZXg7XHJcbiAgICBcclxuICAgICAgICBpZiAoIV9pZFRvVmVydGV4W2xpbmtWaWV3Lm1vZGVsLmlkXSkge1xyXG4gICAgICAgICAgICBfaWRUb1ZlcnRleFtsaW5rVmlldy5tb2RlbC5pZF0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2lkVG9WZXJ0ZXhbbGlua1ZpZXcubW9kZWwuaWRdLnB1c2godmVydGV4SWQpO1xyXG4gICAgICAgIHJldHVybiBuZXdWZXJ0ZXg7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGZpbmRJbnRlcm1lZGlhdGVWZXJ0aWNlcyAodmVydGljZXMsIHN0ZXApIHtcclxuICAgICAgICBjb25zdCBhbGxWZXJ0aWNlcyA9IFtdO1xyXG4gICAgICAgIGxldCBwcmV2ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHZlcnRpY2VzLmZvckVhY2godmVydGV4ID0+IHtcclxuICAgICAgICAgICAgaWYgKHByZXYgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNWZXJ0aWNhbCA9IHByZXYueCA9PT0gdmVydGV4Lng7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSBwcmV2LnkgPT09IHZlcnRleC55O1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2LnkgPCB2ZXJ0ZXgueSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0gcHJldi55ICsgc3RlcDsgeSA8IHZlcnRleC55OyB5ICs9IHN0ZXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbFZlcnRpY2VzLnB1c2goeyB4OiB2ZXJ0ZXgueCwgeTogeSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSBwcmV2LnkgLSBzdGVwOyB5ID4gdmVydGV4Lnk7IHkgLT0gc3RlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsVmVydGljZXMucHVzaCh7IHg6IHZlcnRleC54LCB5OiB5IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldi54IDwgdmVydGV4LngpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IHByZXYueCArIHN0ZXA7IHggPCB2ZXJ0ZXgueDsgeCArPSBzdGVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxWZXJ0aWNlcy5wdXNoKHsgeDogeCwgeTogdmVydGV4LnkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gcHJldi54IC0gc3RlcDsgeCA+IHZlcnRleC54OyB4IC09IHN0ZXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbFZlcnRpY2VzLnB1c2goeyB4OiB4LCB5OiB2ZXJ0ZXgueSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhbGxWZXJ0aWNlcy5wdXNoKHZlcnRleCk7XHJcbiAgICAgICAgICAgIHByZXYgPSB2ZXJ0ZXg7XHJcbiAgICAgICAgfSk7XHJcbiAgICBcclxuICAgICAgICByZXR1cm4gYWxsVmVydGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgX2luaXQoKTtcclxufSIsImltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuXHJcbmltcG9ydCB7IExBQkVMX0xFRlRfUklHSFRfUEFERElORyB9IGZyb20gJy4vZ3JhcGhFbGVtZW50cy9lbGVtZW50cyc7XHJcblxyXG5leHBvcnQgY29uc3QgRk9SRUlHTl9PQkpFQ1RfUEFERElORyA9IDI7IC8vIGluIHB4XHJcbmV4cG9ydCBjb25zdCBQTkdfQ09OVEVOVF9QQURESU5HID0gMTsgLy8gaW4gcHhcclxuZXhwb3J0IGNvbnN0IEVYQ0xVREVEX0VMRU1FTlRTID0gW1xyXG4gICAgJy5kbi1hcnJvdycsXHJcbiAgICAnaW1nJyxcclxuICAgICcuZGVyaXZhdGlvbi1ub2RlX2JvZHktc2Nyb2xsZXInLFxyXG5dO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4cG9ydFRvU1ZHIChwYXBlciwgcHJvcHMpIHtcclxuICAgIHByb3BzID0gcHJvcHMgfHwge307XHJcblxyXG4gICAgY29uc3QgdnBUcmFuc2Zvcm0gPSBwYXBlci52aWV3cG9ydC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xyXG4gICAgcGFwZXIudmlld3BvcnQucmVtb3ZlQXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcclxuXHJcbiAgICAvLyBjb25zdCBwYXBlckJvdW5kaW5nQm94ID0gcGFwZXIudmlld3BvcnQuZ2V0QkJveCgpO1xyXG4gICAgY29uc3QgcGFwZXJCb3VuZGluZ0JveCA9IHBhcGVyLmdldENvbnRlbnRCQm94KCk7XHJcbiAgICBjb25zdCBzdmdDb3B5ID0gcHJvcHMuY29udmVydEh0bWwgPyBjcmVhdGVTVkdDb3B5KHBhcGVyKSA6IHNpbXBsZUNsb25lKHBhcGVyKTtcclxuXHJcbiAgICBwYXBlci52aWV3cG9ydC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIHZwVHJhbnNmb3JtIHx8ICcnKTtcclxuXHJcbiAgICBpZiAocHJvcHMucGRmTW9kZSkge1xyXG4gICAgICAgIHN2Z0NvcHkucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xyXG4gICAgICAgIHN2Z0NvcHkuc2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3hNaWRZTWlkIG1lZXQnKTtcclxuICAgICAgICBzdmdDb3B5LnJlbW92ZUF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XHJcbiAgICAgICAgaWYgKHByb3BzLnByZXNlcnZlRGltZW5zaW9ucykge1xyXG4gICAgICAgICAgICBzdmdDb3B5LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBwYXBlckJvdW5kaW5nQm94LndpZHRoLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN2Z0NvcHkuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcxMDAlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBQQURESU5HID0gNDA7XHJcbiAgICAgICAgc3ZnQ29weS5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbXHJcbiAgICAgICAgICAgIHBhcGVyQm91bmRpbmdCb3gueCAtIFBBRERJTkcsXHJcbiAgICAgICAgICAgIHBhcGVyQm91bmRpbmdCb3gueSAtIFBBRERJTkcsXHJcbiAgICAgICAgICAgIHBhcGVyQm91bmRpbmdCb3gueCArIHBhcGVyQm91bmRpbmdCb3gud2lkdGggKyBQQURESU5HLFxyXG4gICAgICAgICAgICBwYXBlckJvdW5kaW5nQm94LnkgKyBwYXBlckJvdW5kaW5nQm94LmhlaWdodCArIFBBRERJTkcsXHJcbiAgICAgICAgXS5qb2luKCcgJykpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBzdmdDb3B5LnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcclxuICAgICAgICBpZiAocHJvcHMucHJlc2VydmVEaW1lbnNpb25zKSB7XHJcbiAgICAgICAgICAgIHN2Z0NvcHkuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHBhcGVyQm91bmRpbmdCb3gud2lkdGgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIHN2Z0NvcHkuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBwYXBlckJvdW5kaW5nQm94LmhlaWdodC50b1N0cmluZygpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdmdDb3B5LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMTAwJScpO1xyXG4gICAgICAgICAgICBzdmdDb3B5LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzEwMCUnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN2Z0NvcHkuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgJycgK1xyXG4gICAgICAgIHBhcGVyQm91bmRpbmdCb3gueCArICcgJyArXHJcbiAgICAgICAgcGFwZXJCb3VuZGluZ0JveC55ICsgJyAnICtcclxuICAgICAgICBwYXBlckJvdW5kaW5nQm94LndpZHRoICsgJyAnICtcclxuICAgICAgICBwYXBlckJvdW5kaW5nQm94LmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICBjb25zdCBpc0lFID0gISh3aW5kb3cuQWN0aXZlWE9iamVjdCkgJiYgJ0FjdGl2ZVhPYmplY3QnIGluIHdpbmRvdztcclxuXHJcbiAgICBpZihpc0lFKXtcclxuICAgICAgYWxpZ25UZXh0KHN2Z0NvcHkucXVlcnlTZWxlY3RvckFsbCgndGV4dCcpKTtcclxuXHJcbiAgICAgIC8vU2hpbSBTVkdFbGVtZW50IGNsYXNzTGlzdFxyXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoU1ZHRWxlbWVudC5wcm90b3R5cGUsJ2NsYXNzTGlzdCcpKXtcclxuICAgICAgICAgIGlmIChIVE1MRWxlbWVudCAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEhUTUxFbGVtZW50LnByb3RvdHlwZSwnY2xhc3NMaXN0Jykpe1xyXG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnY2xhc3NMaXN0Jyk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTVkdFbGVtZW50LnByb3RvdHlwZSwnY2xhc3NMaXN0JywgZGVzY3JpcHRvcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd29ya2Fyb3VuZCB0byBpbmNsdWRlIG9ubHkgb250b2RpYS1yZWxhdGVkIHN0eWxlc2hlZXRzXHJcbiAgICBjb25zdCBjc3NTdHJpbmdzID0gZXh0cmFjdENTU0Zyb21QYXBlcihzdmdDb3B5KTtcclxuXHJcbiAgICBjb25zdCBkZWZzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdkZWZzJyk7XHJcbiAgICBkZWZzLmlkID0gJ2V4dHJhY3RlZC1zdHlsZXMnOyAvLyBGb3IgSUUtRURHRVxyXG4gICAgY3NzU3RyaW5ncy5mb3JFYWNoKChjc3NTdHJpbmcsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgY29uc3QgbW9jRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgbW9jRGl2LmlkID0gJ2V4dHJhY3RlZC1maWxlLScgKyBpbmRleDtcclxuICAgICAgICBtb2NEaXYuaW5uZXJIVE1MID0gJzxzdHlsZT4nICsgY3NzU3RyaW5ncyArICc8L3N0eWxlPic7XHJcbiAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChtb2NEaXYuZmlyc3RDaGlsZCk7XHJcbiAgICB9KTtcclxuICAgIHN2Z0NvcHkuaW5zZXJ0QmVmb3JlKGRlZnMsIHN2Z0NvcHkuZmlyc3RDaGlsZCk7XHJcblxyXG5cclxuICAgIGlmIChwcm9wcy5lbGVtZW50c1RvUmVtb3ZlU2VsZWN0b3IpIHtcclxuICAgICAgICBwcm9jZXNzTm9kZXMoc3ZnQ29weS5xdWVyeVNlbGVjdG9yQWxsKHByb3BzLmVsZW1lbnRzVG9SZW1vdmVTZWxlY3RvciksXHJcbiAgICAgICAgICAgIG5vZGUgPT4gbm9kZS5yZW1vdmUoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udmVydEltYWdlcyhzdmdDb3B5LnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltYWdlJykpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Z0NvcHkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFsaWduVGV4dCAodGV4dEJsb2Nrcykge1xyXG4gICAgcHJvY2Vzc05vZGVzKHRleHRCbG9ja3MsICh0ZXh0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGV4dC5nZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJyk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGV4dC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xyXG4gICAgICAgIGlmIChhbmNob3IgPT09ICdtaWRkbGUnICYmIHRyYW5zZm9ybS5pbmRleE9mKCd0cmFuc2xhdGUnKSkge1xyXG4gICAgICAgICAgICB0ZXh0LnJlbW92ZUF0dHJpYnV0ZSgndGV4dC1hbmNob3InKTtcclxuICAgICAgICAgICAgY29uc3QgeSA9IHRyYW5zZm9ybS5tYXRjaCgvLChbXFxkLC5dKylcXCkvKVsxXTtcclxuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtMQUJFTF9MRUZUX1JJR0hUX1BBRERJTkd9LCAke3l9KWApO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29udmVydEltYWdlcyAoaW1hZ2VzKSB7XHJcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgcHJvY2Vzc05vZGVzKGltYWdlcywgKGltYWdlKSA9PiB7XHJcbiAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWltYWdlKSByZXNvbHZlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaXJlZm94IHVzZXMgYGhyZWZgLCBhbGwgdGhlIG90aGVycyAneGxpbms6aHJlZidcclxuICAgICAgICAgICAgdmFyIHVybCA9IGltYWdlLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpIHx8IGltYWdlLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xyXG5cclxuICAgICAgICAgICAgam9pbnQudXRpbC5pbWFnZVRvRGF0YVVyaSh1cmwsIChlcnIsIGRhdGFVcmkpID0+IHtcclxuICAgICAgICAgICAgICAgIGltYWdlLnNldEF0dHJpYnV0ZSgneGxpbms6aHJlZicsIGRhdGFVcmkpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbn1cclxuXHJcbmNvbnN0IEVYQ0xVREVEX1NFTEVDVE9SUyA9IFsgJ2JvZHknIF07XHJcbmZ1bmN0aW9uIGV4dHJhY3RDU1NGcm9tUGFwZXIgKHBhcGVyKSB7XHJcbiAgICBjb25zdCBjc3NUZXh0cyA9IFtdO1xyXG4gICAgY29uc3QgYWxsRWxlbWVudHMgPSBwYXBlci5xdWVyeVNlbGVjdG9yQWxsKCcqJyk7XHJcblxyXG4gICAgY29uc3QgYWxsb3dlZENzc0NsYXNzZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gYWxsRWxlbWVudHNbaV07XHJcblxyXG4gICAgICAgIGNvbnN0IGNsYXNzZXNMaXN0ID0gZWxlbWVudC5jbGFzc0xpc3Q7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjbGFzc2VzTGlzdC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBhbGxvd2VkQ3NzQ2xhc3Nlcy5wdXNoKGNsYXNzZXNMaXN0W2pdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgY3NzQ2xhc3NlcztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBjc3NGaWxlID0gZG9jdW1lbnQuc3R5bGVTaGVldHNbaV07XHJcbiAgICAgICAgICAgIGNzc0NsYXNzZXMgPSBjc3NGaWxlLmNzc1J1bGVzIHx8IGNzc0ZpbGUucnVsZXM7XHJcbiAgICAgICAgICAgIGlmICghY3NzQ2xhc3NlcykgeyBjb250aW51ZTsgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgY29udGludWU7IH1cclxuXHJcbiAgICAgICAgY29uc3QgY3NzQ2xhc3NUZXh0ID0gW107XHJcblxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3NzQ2xhc3Nlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gY3NzQ2xhc3Nlc1tqXTtcclxuICAgICAgICAgICAgY29uc3QgZG9lc0NvbnRhaW5BbGxvd2VkQ2xhc3MgPSBjb250YWluc0FsbG93ZWRDbGFzcyhydWxlLnNlbGVjdG9yVGV4dCwgYWxsb3dlZENzc0NsYXNzZXMpO1xyXG4gICAgICAgICAgICBjb25zdCBhbGxvd2VkU2VsZWN0b3IgPSBFWENMVURFRF9TRUxFQ1RPUlMuaW5kZXhPZihydWxlLnNlbGVjdG9yVGV4dCkgPT09IC0xICYmIGRvZXNDb250YWluQWxsb3dlZENsYXNzO1xyXG4gICAgICAgICAgICBpZiAocnVsZSBpbnN0YW5jZW9mIENTU1N0eWxlUnVsZSAmJiBhbGxvd2VkU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGNzc0NsYXNzVGV4dC5wdXNoKHJ1bGUuY3NzVGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNzc1RleHRzLnB1c2goY3NzQ2xhc3NUZXh0LmpvaW4oJ1xcbicpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb250YWluc0FsbG93ZWRDbGFzcyAoY3NzU2VsZWN0b3IsIGFsbG93ZWRDc3NDbGFzc2VzKSB7XHJcbiAgICAgICAgaWYgKCFjc3NTZWxlY3RvcikgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxvd2VkQ3NzQ2xhc3Nlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY3NzU2VsZWN0b3IuaW5kZXhPZihhbGxvd2VkQ3NzQ2xhc3Nlc1tpXSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNzc1RleHRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaW1wbGVDbG9uZSAocGFwZXIpIHtcclxuICAgIGNvbnN0IHN2Z0Nsb25lID0gcGFwZXIuc3ZnLmNsb25lTm9kZSh0cnVlKTtcclxuICAgIHJldHVybiBzdmdDbG9uZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU1ZHQ29weSAocGFwZXIpIHtcclxuICAgIGNvbnN0IHN2Z0Nsb25lID0gcGFwZXIuc3ZnLmNsb25lTm9kZSh0cnVlKTtcclxuICAgIGNvbnN0IGNlbGxzID0gcGFwZXIubW9kZWwuZ2V0KCdjZWxscycpO1xyXG4gICAgcHJvY2Vzc05vZGVzKHN2Z0Nsb25lLnF1ZXJ5U2VsZWN0b3JBbGwoJ2cuZWxlbWVudCcpLCBjZWxsVmlldyA9PiB7XHJcbiAgICAgICAgY29uc3QgaWQgPSBjZWxsVmlldy5nZXRBdHRyaWJ1dGUoJ21vZGVsLWlkJyk7XHJcbiAgICAgICAgY29uc3QgaHRtbFZpZXcgPSBwYXBlci5lbC5xdWVyeVNlbGVjdG9yKGAuZGVyaXZhdGlvbi1ub2RlW2lkPScke2lkfSddYCk7XHJcbiAgICAgICAgaWYgKCFodG1sVmlldykgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgbGV0IGNvbnRlbnQ7XHJcbiAgICAgICAgY29uc3QgaXNJdElFMTEgPSBCb29sZWFuKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1RyaWRlbnQuKnJ2XFw6MTFcXC4vKSk7XHJcbiAgICAgICAgaWYgKGlzSXRJRTExKSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBwcm9jZXNzSFRNTChodG1sVmlldywgRVhDTFVERURfRUxFTUVOVFMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2ZvcmVpZ25PYmplY3QnKTtcclxuICAgICAgICAgICAgY29uc3QgY2VsbCA9IGNlbGxzLmdldChpZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbGxTaXplID0gY2VsbC5nZXQoJ3NpemUnKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGNlbGxTaXplLndpZHRoICsgRk9SRUlHTl9PQkpFQ1RfUEFERElORyk7XHJcbiAgICAgICAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBjZWxsU2l6ZS5oZWlnaHQgKyBGT1JFSUdOX09CSkVDVF9QQURESU5HKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGh0bWxDb250ZW50ID0gaHRtbFZpZXcuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgICAgICAgICBodG1sQ29udGVudC5zdHlsZS50cmFuc2Zvcm0gPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgYm9keSA9IGh0bWxWaWV3LnF1ZXJ5U2VsZWN0b3IoJy5kZXJpdmF0aW9uLW5vZGVfYm9keScpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdCb2RpZXMgPSBodG1sQ29udGVudC5xdWVyeVNlbGVjdG9yKCcuZGVyaXZhdGlvbi1ub2RlX2JvZHknKTtcclxuICAgICAgICAgICAgaWYgKGJvZHkuc2Nyb2xsVG9wICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdCb2RpZXMuZmlyc3RDaGlsZC5zdHlsZS5tYXJnaW5Ub3AgPSAoLWJvZHkuc2Nyb2xsVG9wKSArICdweCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChodG1sQ29udGVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjZWxsVmlldy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2VsbFZpZXcuZ2V0QXR0cmlidXRlKCdjbGFzcycpKTtcclxuXHJcbiAgICAgICAgY29uc3QgYW5jaG9yID0gY2VsbFZpZXcucXVlcnlTZWxlY3RvcignLmV4cG9ydC1hbmNob3InKTtcclxuICAgICAgICBhbmNob3IucmVtb3ZlQXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcclxuXHJcbiAgICAgICAgY29uc3Qgcm9vdCA9IGNlbGxWaWV3LnF1ZXJ5U2VsZWN0b3IoJy5ib2R5Jyk7XHJcbiAgICAgICAgYW5jaG9yLnJlbW92ZUNoaWxkKHJvb3QpO1xyXG4gICAgICAgIGFuY2hvci5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBzdmdDbG9uZTtcclxufVxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzSFRNTCAoaHRtbFZpZXcsIGV4Y2x1ZGVkRWxlbWVudHMpIHtcclxuICAgIGNvbnN0IGcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2cnKTtcclxuXHJcbiAgICBmdW5jdGlvbiByZWN1cnNpb24gKGh0bWxSb290KSB7XHJcbiAgICAgICAgaWYgKGh0bWxSb290IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGNoZWNrRWxlbWVudChodG1sUm9vdCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3JlY3QnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldFRvcCA9IGdldE9mZnNldFRvcChodG1sUm9vdCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gZ2V0T2Zmc2V0TGVmdChodG1sUm9vdCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGh0bWxSb290KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzdmdSZWN0LnNldEF0dHJpYnV0ZSgnY2xhc3NOYW1lJywgaHRtbFJvb3QuY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJywgc3R5bGUuYmFja2dyb3VuZENvbG9yKTtcclxuICAgICAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdzdHJva2UnLCBzdHlsZS5ib3JkZXJDb2xvcik7XHJcbiAgICAgICAgICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgc3R5bGUuYm9yZGVyV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCBvZmZzZXRMZWZ0KTtcclxuICAgICAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCd5Jywgb2Zmc2V0VG9wKTtcclxuICAgICAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHN0eWxlLndpZHRoKTtcclxuICAgICAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzdHlsZS5oZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGcuYXBwZW5kQ2hpbGQocmVjdCk7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzTm9kZXMoaHRtbFJvb3QuY2hpbGROb2RlcywgY2hpbGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2lvbihjaGlsZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoaHRtbFJvb3QgaW5zdGFuY2VvZiBUZXh0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gaHRtbFJvb3QudGV4dENvbnRlbnQudHJpbSgpO1xyXG4gICAgICAgICAgICBpZiAodGV4dENvbnRlbnQubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICd0ZXh0Jyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGh0bWxSb290LnBhcmVudE5vZGU7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRUb3AgPSBnZXRPZmZzZXRUb3AocGFyZW50KTtcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0TGVmdCA9IGdldE9mZnNldExlZnQocGFyZW50KTtcclxuICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpO1xyXG5cclxuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBzdHlsZS5jb2xvcik7XHJcbiAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnaGFuZ2luZycpO1xyXG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgneCcsIG9mZnNldExlZnQpO1xyXG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgneScsIG9mZnNldFRvcCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtYXhDaGFyTnVtYmVyID0gZ2V0TWF4Q2hhck51bWJlcihcclxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50LFxyXG4gICAgICAgICAgICAgICAgK3N0eWxlLndpZHRoLnN1YnN0cmluZygwLCBzdHlsZS53aWR0aC5sZW5ndGggLSAyKSxcclxuICAgICAgICAgICAgICAgIHN0eWxlLmZvbnRcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKG1heENoYXJOdW1iZXIgPT09IHRleHRDb250ZW50Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dC50ZXh0Q29udGVudCA9IHRleHRDb250ZW50O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgRUxJUFNJU19MRU5HVEggPSAyO1xyXG4gICAgICAgICAgICAgICAgdGV4dC50ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnN1YnN0cmluZygwLCBtYXhDaGFyTnVtYmVyIC0gRUxJUFNJU19MRU5HVEgpICsgJy4uLic7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGcuYXBwZW5kQ2hpbGQodGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrRWxlbWVudCAoZWxlbWVudCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhjbHVkZWRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBJRTExIGZpeFxyXG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gZWxlbWVudC5tYXRjaGVzID8gZWxlbWVudC5tYXRjaGVzIDogZWxlbWVudC5tc01hdGNoZXNTZWxlY3RvcjtcclxuICAgICAgICAgICAgaWYgKG1hdGNoZXMuYXBwbHkoZWxlbWVudCwgW2V4Y2x1ZGVkRWxlbWVudHNbaV1dKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldE9mZnNldFRvcCAoZWxlbWVudCkge1xyXG4gICAgICAgIGlmKGVsZW1lbnQuY2xhc3NOYW1lICE9PSAnZGVyaXZhdGlvbi1ub2RlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRUb3AgKyBlbGVtZW50LmNsaWVudFRvcCArIChlbGVtZW50Lm9mZnNldFBhcmVudCA/IGdldE9mZnNldFRvcChlbGVtZW50Lm9mZnNldFBhcmVudCkgOiAwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0T2Zmc2V0TGVmdCAoZWxlbWVudCkge1xyXG4gICAgICAgIGlmKGVsZW1lbnQuY2xhc3NOYW1lICE9PSAnZGVyaXZhdGlvbi1ub2RlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRMZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0ICsgKGVsZW1lbnQub2Zmc2V0UGFyZW50ID8gZ2V0T2Zmc2V0TGVmdChlbGVtZW50Lm9mZnNldFBhcmVudCkgOiAwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0TWF4Q2hhck51bWJlciAodGV4dCwgbWF4V2lkdGgsIGZvbnQpIHtcclxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIGN0eC5mb250ID0gZm9udDtcclxuXHJcbiAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xyXG4gICAgICAgIGlmICh0ZXh0V2lkdGggPD0gbWF4V2lkdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRleHQubGVuZ3RoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IEZJVF9DT1JSRUNUSU9OID0gMC44NTtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGV4dC5sZW5ndGggKiAobWF4V2lkdGggLyB0ZXh0V2lkdGgpICogRklUX0NPUlJFQ1RJT04pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWN1cnNpb24oaHRtbFZpZXcpO1xyXG5cclxuICAgIHJldHVybiBnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzTm9kZXMgKG5vZGVzLCBjYWxsYmFjaykge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNhbGxiYWNrKG5vZGVzW2ldKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvRGF0YVVSTCAocGFwZXIsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN2Z09wdGlvbnMgPSBfLmNsb25lKG9wdGlvbnMuc3ZnT3B0aW9ucyk7XHJcblxyXG4gICAgICAgIGNvbnN0IG9sZFRvU3ZnID0gcGFwZXIudG9TVkc7XHJcbiAgICAgICAgcGFwZXIudG9TVkcgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgZXhwb3J0VG9TVkcgKHBhcGVyLCBzdmdPcHRpb25zKS50aGVuKChzdmdTdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHN2Z1N0cmluZyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcGFwZXIudG9QTkcoZnVuY3Rpb24gKGltYWdlKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoaW1hZ2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBhcGVyLnRvU1ZHID0gb2xkVG9Tdmc7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZpdFJlY3RLZWVwaW5nQXNwZWN0UmF0aW8gKHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpIHtcclxuICAgIGlmICghdGFyZ2V0V2lkdGggJiYgIXRhcmdldEhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB7IHdpZHRoOiBzb3VyY2VXaWR0aCwgaGVpZ2h0OiBzb3VyY2VIZWlnaHQgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJhdGlvID0gc291cmNlV2lkdGggLyBzb3VyY2VIZWlnaHQ7XHJcbiAgICB0YXJnZXRXaWR0aCA9IHRhcmdldFdpZHRoIHx8ICh0YXJnZXRIZWlnaHQgKiByYXRpbyk7XHJcbiAgICB0YXJnZXRIZWlnaHQgPSB0YXJnZXRIZWlnaHQgfHwgKHRhcmdldFdpZHRoIC8gcmF0aW8pO1xyXG5cclxuICAgIGlmICh0YXJnZXRIZWlnaHQgKiByYXRpbyA8PSB0YXJnZXRXaWR0aCkge1xyXG4gICAgICAgIHJldHVybiB7IHdpZHRoOiB0YXJnZXRIZWlnaHQgKiByYXRpbywgaGVpZ2h0OiB0YXJnZXRIZWlnaHQgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHRhcmdldFdpZHRoLCBoZWlnaHQ6IHRhcmdldFdpZHRoIC8gcmF0aW8gfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZXhwb3J0VG9TVkc7XHJcbiIsImltcG9ydCAqIGFzIGpvaW50IGZyb20gJ3JhcHBpZCc7XHJcbmltcG9ydCB7XHJcbiAgICBsaW1pdFBvaW50UG9zaXRpb24sXHJcbiAgICBleHRlbmRCb3VuZHMsXHJcbiAgICBnbG9iYWxUb1NjYWxlZEJvdW5kcyxcclxuICAgIGdsb2JhbFRvU2NhbGVkU2l6ZSxcclxuICAgIHNjYWxlZFRvR2xvYmFsU2l6ZSxcclxuICAgIGdldEdsb2JhbE5vZGVQb3NpdGlvbixcclxuICAgIGdldFNjYWxlZE5vZGVQb3NpdGlvbixcclxuICAgIGdldExvY2FsTm9kZVBvc2l0aW9uLFxyXG4gICAgc2NhbGVkVG9HbG9iYWxQb2ludCxcclxuICAgIGdsb2JhbFRvU2NhbGVkUG9pbnQsXHJcbiAgICBsb2NhbFRvR2xvYmFsUG9pbnQsXHJcbiAgICBnZXRFbGVtZW50U2l6ZSxcclxufSBmcm9tICcuLi91dGlscy91dGlscyc7XHJcbmltcG9ydCB7IFpfSU5ERVhFUyB9IGZyb20gJy4vZ3JhcGhFbGVtZW50cy9lbGVtZW50cyc7XHJcblxyXG5jb25zdCBIT1JfTEFCRUxfUEFERElORyA9IDg7XHJcbmNvbnN0IFZFUlRfTEFCRUxfUEFERElORyA9IDY7XHJcbmNvbnN0IEZPTlRfU0laRSA9IDExO1xyXG5jb25zdCBERUZBVUxUX0ZSQU1FX1NJWkUgPSB7IHdpZHRoOiA1MCwgaGVpZ2h0OiA1MCB9O1xyXG5cclxuLyoqXHJcbiAqIEJvdW5kc1xyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCb3VuZHNcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFhcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblhcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFlcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbllcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHRcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3NcclxuICogVmlld0ZyYW1lIG9mIHRoZSBtYWluIHZpZXcgKFZpZXctMikuXHJcbiAqIFByb3ZpZGVzIHZpc2libGUgZWxlbWVudHMgdG8gdGhlIExpbmVhZ2VEaWFncmFtLlxyXG4gKiBCYXNlZCBvbiBqb2ludC5zaGFwZXMuYmFzaWMuUmVjdC5cclxuICpcclxuICogQ29uc3RydWN0b3IgcGFyYW1ldGVyczpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAcGFyYW0ge1xyXG4gKiAgZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lclxyXG4gKiAgaWQ6IHN0cmluZ1xyXG4gKiAgYmFja2dyb3VuZENvbG9yOiBzdHJpbmdcclxuICogIGJvcmRlckNvbG9yOiBzdHJpbmdcclxuICogIHNwYWNlU2hhcmU6IG51bWJlclxyXG4gKiB9IG9wdGlvbnNcclxuICogQHBhcmFtIHtQYXJhbWV0ZXJzfSBwYXJhbWV0ZXJzIC0gcGFyYW1ldGVycyBzZXRcclxuICpcclxuICogUHVibGljIHByb3BlcnRpZXM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogaWQ6IHN0cmluZ1xyXG4gKiBtb2RlbDogQHBhcmFtIG9wdGlvbnNcclxuICogY29uc3RQb3NpdGlvbjogUG9pbnRcclxuICogc2l6ZTogU2l6ZSAod2lkdGgsIGhlaWdodClcclxuICogbW92aW5nQnlJdHNlbGY6IGJvb2xlbmEgLSBpdCdzIGZsYWcgdG8gYmxvY2sgYSBtb3ZpbmdcclxuICpcclxuICogUHVibGljIG1ldGhvZHM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogcmVmcmVzaE5vZGVTdGF0ZTogKG5vZGU6IE5vZGUpID0+IHZvaWQ7XHJcbiAqIGdldE5vZGVzOiAoKSA9PiBOb2RlW107XHJcbiAqIHVwZGF0ZUJvdW5kczogKCkgPT4gdm9pZDtcclxuICogY2xlYXI6ICgpID0+IHZvaWQ7XHJcbiAqIGdldE5vZGVCb3VuZHM6ICgpID0+IEJvdW5kcztcclxuICogZ2V0Vmlld1BvcnRCb3VuZHM6ICgpID0+IEJvdW5kcztcclxuICogc2V0RGF0YTogKGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXIpID0+IHZvaWRcclxuICogZ2V0VmlzaWJsZUNlbGxzOiAoKSA9PiB7IG5vZGVzOiBOb2RlW10sIGxpbms6IExpbmtbXSB9O1xyXG4gKiBjYWxjdWxhdGVWaXNpYmxlQ2VsbHM6ICgpID0+IHZvaWQ7XHJcbiAqIHNldFBvc2l0aW9uOiAocG9zOiBQb2ludCkgPT4gdm9pZDtcclxuICogc2V0U2l6ZTogKHNpemU6IFNpemUpID0+IHZvaWQ7XHJcbiAqIHBvc2l0aW9uVmlld1BvcnQ6ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4gUG9pbnQ7XHJcbiAqIHJlc2V0U2l6ZTogKCkgPT4gdm9pZDtcclxuICogaGl0U2NhbGVkUG9pbnRUZXN0IChwb2ludDogUG9pbnQpID0+IGJvb2xlYW47XHJcbiAqIGhpdFRlc3QgKG5vZGU6IE5vZGUsIHBhcnRpYWxIaXQ6IGJvb2xlYW4pID0+IGJvb2xlYW47XHJcbiAqIG93bmVyVGVzdCAobm9kZTogTm9kZSkgPT4gYm9vbGVhbjtcclxuICogc2V0U2NhbGU6IChzY2FsZTogUG9pbnQpID0+IHZvaWQ7XHJcbiAqIGdldFNjYWxlOiAoKSA9PiBQb2ludDtcclxuICogc2V0RWxlbWVudFNpemU6IChzaXplOiBFbGVtZW50U2l6ZSkgPT4gdm9pZDtcclxuICogZ2V0RWxlbWVudFNpemU6ICgpID0+IEVsZW1lbnRTaXplO1xyXG4gKiBsaW1pdE5vZGVQb3NpdGlvbjogKG5vZGU6IE5vZGUpID0+IHZvaWQ7XHJcbiAqXHJcbiAqIEV2ZW50c1xyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBmaXJlcyBjaGFuZ2U6Y29ycmVjdFBvc3Rpb24gKGxpbWl0dGVkUG9pbnQ6IFBvaW50KVxyXG4gKiBAZmlyZXMgY2hhbmdlLXZpZXctcG9ydC1wb3NpdGlvbiAobmV3UG9zaXRpb246IFBvaW50KVxyXG4gKlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFZpZXdGcmFtZSAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgLy8gSW5pdFxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgc2VsZi5pZCA9IG9wdGlvbnMuaWQ7XHJcbiAgICBzZWxmLm1vZGVsID0gb3B0aW9ucztcclxuICAgIHNlbGYuY29uc3RQb3NpdGlvbiA9IHsgeDogMCwgeTogMH07XHJcblxyXG4gICAgc2VsZi5zaXplID0gREVGQVVMVF9GUkFNRV9TSVpFO1xyXG4gICAgc2VsZi5tb3ZpbmdCeUl0c2VsZiA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChvcHRpb25zLnNpbmdsZU1vZGUpIHtcclxuICAgICAgICBvcHRpb25zLmRhdGFDb250YWluZXIubm9kZXMuZm9yRWFjaChuID0+IG4udmlld0ZyYW1lT3duZXJJZCA9IHNlbGYuaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGYuc2VsZWN0ZWRFbGVtZW50O1xyXG5cclxuICAgIGxldCBfY2FjaGVkUmVzdWx0O1xyXG4gICAgbGV0IF9ub2RlQm91bmRzO1xyXG4gICAgbGV0IF92aWV3UG9ydFBvc2l0aW9uQm91bmRzO1xyXG4gICAgbGV0IF9kYXRhQ29udGFpbmVyID0gb3B0aW9ucy5kYXRhQ29udGFpbmVyO1xyXG4gICAgbGV0IF9zY2FsZTtcclxuICAgIGxldCBfdmlld1BvcnRQb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9OyAvLyBnbG9iYWwgY29vcmRpbmF0ZXNcclxuICAgIGxldCBfZGVmYXVsdEVsZW1lbnRTaXplID0gcGFyYW1ldGVycy5lbGVtZW50U2l6ZTtcclxuICAgIGxldCBfcmVmZXJlbmNlU2l6ZSA9IF9kZWZhdWx0RWxlbWVudFNpemU7XHJcbiAgICBsZXQgX3ZpZXdQb3J0Qm91bmRzO1xyXG5cclxuICAgIGNvbnN0IF9mcmFtZVBhZGRpbmcgPSBwYXJhbWV0ZXJzLmZyYW1lUGFkZGluZztcclxuICAgIGNvbnN0IGxhYmVsID0gam9pbnQudXRpbC5icmVha1RleHQob3B0aW9ucy5sYWJlbCwge1xyXG4gICAgICAgIHdpZHRoOiBzZWxmLnNpemUud2lkdGggLSBIT1JfTEFCRUxfUEFERElORyAqIDJcclxuICAgIH0pO1xyXG5cclxuICAgIGpvaW50LnNoYXBlcy5iYXNpYy5SZWN0LmFwcGx5KHNlbGYsIFt7XHJcbiAgICAgICAgaWQ6IG9wdGlvbnMuaWQsXHJcbiAgICAgICAgdHlwZTogJ3ZpZXdGcmFtZScsXHJcbiAgICAgICAgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LFxyXG4gICAgICAgIHNpemU6IHNlbGYuc2l6ZSxcclxuICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICByZWN0OiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcclxuXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBjbGFzczogJ2JvZHkgdmlldy1mcmFtZScsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogc2VsZi5zaXplLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzZWxmLnNpemUuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHBhcmFtZXRlcnMuZnJhbWVCb3JkZXJXaWR0aCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGV4dDoge1xyXG4gICAgICAgICAgICAgICAgJ3gtYWxpZ25tZW50JzogJ2xlZnQnLFxyXG4gICAgICAgICAgICAgICAgJ3RleHQtYW5jaG9yJzogJ2xlZnQnLFxyXG4gICAgICAgICAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogJ2JvbGQnLFxyXG4gICAgICAgICAgICAgICAgcmVmOiAncmVjdCcsXHJcbiAgICAgICAgICAgICAgICAncmVmLXgnOiBIT1JfTEFCRUxfUEFERElORyxcclxuICAgICAgICAgICAgICAgICdyZWYteSc6IFZFUlRfTEFCRUxfUEFERElORyArIEZPTlRfU0laRSxcclxuICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLmluZGV4T2YoJ1xcbicpID09PSAtMSA/IGxhYmVsIDogbGFiZWwuc3Vic3RyaW5nKDAsIGxhYmVsLmluZGV4T2YoJ1xcbicpKSArICcuLi4nLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogb3B0aW9ucy5ib3JkZXJDb2xvclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB6OiBaX0lOREVYRVMuVklFV19GUkFNRSxcclxuICAgIH1dKTtcclxuXHJcbiAgICBpZiAoc2VsZi5tb2RlbC53aWR0aCkgc2VsZi5tb2RlbC53aWR0aCA9IE1hdGguYWJzKE1hdGgubWF4KHNlbGYubW9kZWwud2lkdGgsIHBhcmFtZXRlcnMuZnJhbWVQYWRkaW5nLnggKiAyICsgMSkpO1xyXG4gICAgaWYgKHNlbGYubW9kZWwuaGVpZ2h0KSBzZWxmLm1vZGVsLmhlaWdodCA9IE1hdGguYWJzKE1hdGgubWF4KHNlbGYubW9kZWwuaGVpZ2h0LCBwYXJhbWV0ZXJzLmZyYW1lUGFkZGluZy55ICogMiArIDEpKTtcclxuXHJcbiAgICBzZWxmLm9uKCdjaGFuZ2U6cG9zaXRpb24nLCAoY2VsbCwgcG9zaXRpb24pID0+IHtcclxuICAgICAgICBpZiAoIXNlbGYubW92aW5nQnlJdHNlbGYpIHtcclxuICAgICAgICAgICAgc2VsZi5tb3ZpbmdCeUl0c2VsZiA9IHRydWU7XHJcbiAgICAgICAgICAgIHNlbGYucG9zaXRpb24oc2VsZi5jb25zdFBvc2l0aW9uLngsIHNlbGYuY29uc3RQb3NpdGlvbi55KTtcclxuICAgICAgICAgICAgc2VsZi5tb3ZpbmdCeUl0c2VsZiA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc2NhbGVkT2Zmc2V0ID0ge1xyXG4gICAgICAgICAgICAgICAgeDogc2VsZi5jb25zdFBvc2l0aW9uLnggLSBwb3NpdGlvbi54LFxyXG4gICAgICAgICAgICAgICAgeTogc2VsZi5jb25zdFBvc2l0aW9uLnkgLSBwb3NpdGlvbi55LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBnbG9iYWxPZmZzZXQgPSBzY2FsZWRUb0dsb2JhbFBvaW50KHNjYWxlZE9mZnNldCwgX3NjYWxlKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZpZXdQb3J0UG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBfdmlld1BvcnRQb3NpdGlvbi54ICsgZ2xvYmFsT2Zmc2V0LngsXHJcbiAgICAgICAgICAgICAgICB5OiBfdmlld1BvcnRQb3NpdGlvbi55ICsgZ2xvYmFsT2Zmc2V0LnksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignY2hhbmdlLXZpZXctcG9ydC1wb3NpdGlvbicsIG5ld1ZpZXdQb3J0UG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIF9pbml0KG9wdGlvbnMsIHBhcmFtZXRlcnMpO1xyXG5cclxuICAgIHNlbGYuc2V0KCdjb3JyZWN0UG9zdGlvbicsIG51bGwpO1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIFxyXG4gICAgLy8gQ2FsbEJhY2sgdG8gb3ZlcnJpZGVcclxuICAgIC8vIHNlbGYuX29uQ2hhbmdlQm91bmRzID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHBvc2l0aW9uIGFuZCBzaXplIG9mIHRoZSBub2RlLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAqL1xyXG4gICAgc2VsZi5yZWZyZXNoTm9kZVN0YXRlID0gX3JlZnJlc2hOb2RlU3RhdGU7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBsaXN0IG9mIG5vZGVzIHdoaWNoIHZpZXdGcmFtZSBvd25zLlxyXG4gICAgICogQHJldHVybnMge0FycmF5IG9mIE5vZGV9XHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXROb2RlcyA9IF9nZXROb2RlczsgXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNhY2x1bGF0ZSB2aWV3UG9ydCBib3VuZHNcclxuICAgICovXHJcbiAgICBzZWxmLnVwZGF0ZUJvdW5kcyA9IF91cGRhdGVCb3VuZHM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciBjYWNoZXMuXHJcbiAgICAqL1xyXG4gICAgc2VsZi5jbGVhciA9IF9jbGVhcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZpZXdGcmFtZSBwdWJsaWMgbW9kZWxcclxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IEJvdW5kc1xyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblhcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhYXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluWVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFlcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aFxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYm91bmRzIG9mIHZpZXdGcmFtZSBpbiBwYXBlciBjb29yZGluYXRlcyB3aXRob3V0IHBhZGRpbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7Qm91bmRzfVxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0Tm9kZUJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX25vZGVCb3VuZHM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBib3VuZHMgb2Ygdmlld0ZyYW1lIGluIHBhcGVyIGNvb3JkaW5hdGVzLlxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0Vmlld1BvcnRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF92aWV3UG9ydEJvdW5kcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGJvdW5kcyBvZiB2aWV3RnJhbWUgaW4gcGFwZXIgY29vcmRpbmF0ZXMuXHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRWaWV3UG9ydFBvc2l0aW9uQm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfdmlld1BvcnRQb3NpdGlvbkJvdW5kcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCB2aXNpYmxlIGluIHRoaXMgdmlld3BvcnQgY2VsbHMgKExpbmtzfE5vZGVzIGUudC5jLilcclxuICAgICAqIEByZXR1cm5zIHtcclxuICAgICAqICBub2RlczogTm9kZVtdLFxyXG4gICAgICogIGxpbmtzOiBMaW5rW10sXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0VmlzaWJsZUNlbGxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghX2NhY2hlZFJlc3VsdCkgc2VsZi5jYWxjdWxhdGVWaXNpYmxlQ2VsbHMoKTtcclxuICAgICAgICByZXR1cm4gX2NhY2hlZFJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgbGlzdCBvZiBhbGwgdmlzaWJsZSBpbiB0aGlzIHZpZXdwb3J0IGNlbGxzXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZVJlbmRlck9wdGlvbnN9IG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgc2VsZi5jYWxjdWxhdGVWaXNpYmxlQ2VsbHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIF9yZWZlcmVuY2VTaXplID0gX2NhbGN1bGF0ZVJlZmVyZW5jZU5vZGVTaXplKG9wdGlvbnMuZWxlbWVudFNpemUgfHwgX2RlZmF1bHRFbGVtZW50U2l6ZSk7XHJcbiAgICAgICAgX3ZpZXdQb3J0Qm91bmRzID0gX2dldFZpZXdQb3J0Qm91bmRzKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGdsb2JhbFNpemUgPSBzY2FsZWRUb0dsb2JhbFNpemUoc2VsZi5zaXplLCBfc2NhbGUpO1xyXG4gICAgICAgIGNvbnN0IGdsb2JhbFJlY3RhbmdsZSA9IHtcclxuICAgICAgICAgICAgeDogX3ZpZXdQb3J0UG9zaXRpb24ueCxcclxuICAgICAgICAgICAgeTogX3ZpZXdQb3J0UG9zaXRpb24ueSxcclxuICAgICAgICAgICAgd2lkdGg6IGdsb2JhbFNpemUud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogZ2xvYmFsU2l6ZS5oZWlnaHQsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50cyA9IF9kYXRhQ29udGFpbmVyLmdldEVsZW1lbnRzRm9yUmVjdGFuZ2xlKGdsb2JhbFJlY3RhbmdsZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZpc2libGVOb2RlTWFwID0ge307XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZU5vZGVzID0gYWN0aXZlRWxlbWVudHMubm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpc05vZGVWaXNpYmxlID0gX293bmVyVGVzdChub2RlKSAmJiBfaGl0VGVzdEJ5R2xvYmFsUG9zaXRpb24obm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChpc05vZGVWaXNpYmxlKSB2aXNpYmxlTm9kZU1hcFtub2RlLmlkXSA9IG5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBpc05vZGVWaXNpYmxlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2aXNpYmxlTm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgX3JlZnJlc2hOb2RlU3RhdGUobm9kZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9jYWNoZWRSZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIG5vZGVzOiB2aXNpYmxlTm9kZXMsXHJcbiAgICAgICAgICAgIGxpbmtzOiBhY3RpdmVFbGVtZW50cy5saW5rcyxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgcG9zaXRpb24gb2YgdGhlIHZpZXdGcmFtZSBvbiB0aGUgcGFwZXJcclxuICAgICAqIEByZXR1cm5zIHtcclxuICAgICAqICBub2RlczogTm9kZVtdLFxyXG4gICAgICogIGxpbmtzOiBMaW5rW10sXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAocG9zKSB7XHJcbiAgICAgICAgc2VsZi5tb3ZpbmdCeUl0c2VsZiA9IHRydWU7XHJcbiAgICAgICAgc2VsZi5jb25zdFBvc2l0aW9uID0gcG9zO1xyXG4gICAgICAgIHNlbGYucG9zaXRpb24oc2VsZi5jb25zdFBvc2l0aW9uLngsIHNlbGYuY29uc3RQb3NpdGlvbi55KTtcclxuICAgICAgICBzZWxmLm1vdmluZ0J5SXRzZWxmID0gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyBzaXplIG9mIHRoZSB2aWV3LXBvcnQtam9pbnRqcyBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIHtTaXplfSBzaXplXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlbWVtYmVyXHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0U2l6ZSA9IF9zZXRTaXplO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgc2V0cyBvZmZzZXQgZm9yIGFsbCBlbGVtZW50cyBpbnRvIHRoZSB2aWV3UG9ydC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZSAtIGRpc2FibGVzIHRoZSBsaW1pdFxyXG4gICAgICogQHJldHVybnMge1BvaW50fVxyXG4gICAgICovXHJcbiAgICBzZWxmLnBvc2l0aW9uVmlld1BvcnQgPSBfcG9zaXRpb25WaWV3UG9ydDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyBzaXplLlxyXG4gICAgICovXHJcbiAgICBzZWxmLnJlc2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLm1vZGVsLndpZHRoID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHNlbGYubW9kZWwuaGVpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHVzIHdoZXRoZXIgdGhlXHJcbiAgICAgKiBwb2ludCBpcyBpbiB0aGUgdmlld1BvcnQgb2YgVmlld0ZyYW1lIG9yIG5vdFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICovXHJcbiAgICBzZWxmLmhpdFNjYWxlZFBvaW50VGVzdCA9IF9oaXRTY2FsZWRQb2ludFRlc3Q7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB1cyB3aGV0aGVyIHRoZVxyXG4gICAgICogbm9kZSBpcyBpbiB0aGUgdmlld1BvcnQgb2YgVmlld0ZyYW1lIG9yIG5vdFxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICovXHJcbiAgICBzZWxmLmhpdFRlc3RCeVNjYWxlZFBvc2l0aW9uID0gX2hpdFRlc3RCeVNjYWxlZFBvc2l0aW9uO1xyXG5cclxuICAgIHNlbGYuaGl0VGVzdEJ5R2xvYmFsUG9zaXRpb24gPSBfaGl0QXJlYVRlc3RCeUdsb2JhbFBvc2l0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdXMgd2hldGhlciB0aGVcclxuICAgICAqIFZpZXdGcmFtZSBpcyBvd25lciBvZiB0aGUgcGFzc2VkIG5vZGUgb3Igbm90XHJcbiAgICAgKiBmdW5jdGlvbiBmb3Igb3ZlcnJpZGluZ1xyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICovXHJcbiAgICAvLyBzZWxmLl9vd25lclRlc3QgLSB0byBvdmVycmlkZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc2NhbGUgb2YgdGhlIHZpZXdGcmFtZS5cclxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHNjYWxlXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zZXRTY2FsZSA9IF9zZXRTY2FsZTtcclxuICAgIC8vIHNlbGYuX3NjYWxlV2lsbEFwcGxpZWQ7IC0gdG8gb3ZlcnJpZGVcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNjYWxlIG9mIHRoZSB2aWV3RnJhbWUuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0U2NhbGUgPSBfZ2V0U2NhbGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBkZWZhdWx0IGVsZW1lbnQgc2l6ZS5cclxuICAgICAqIEBwYXJhbSB7RWxlbWVudFNpemV9IGVsZW1lbnRTaXplXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zZXRFbGVtZW50U2l6ZSA9IGZ1bmN0aW9uIChlbGVtZW50U2l6ZSkge1xyXG4gICAgICAgIF9kZWZhdWx0RWxlbWVudFNpemUgPSBlbGVtZW50U2l6ZTtcclxuICAgICAgICBfdXBkYXRlQm91bmRzKCk7XHJcbiAgICAgICAgX2xpbWl0Vmlld1BvcnRQb3NpdGlvbigpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgZWxlbWVudCBzaXplLlxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0RWxlbWVudFNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0RWxlbWVudFNpemU7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYubGltaXROb2RlUG9zaXRpb24gPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IG5vZGVTY2FsZWRTaXplID0gbm9kZS5jYWxjdWxhdGVTaXplKF9yZWZlcmVuY2VTaXplKTsgLy8gc2NhbGVkXHJcbiAgICAgICAgY29uc3Qgc2NhbGVkVmlld1BvcnRCb3VuZHMgPSBnbG9iYWxUb1NjYWxlZEJvdW5kcyhfdmlld1BvcnRQb3NpdGlvbkJvdW5kcyk7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1pblNjYWxlZFBvc2l0aW9uID0gZ2V0U2NhbGVkTm9kZVBvc2l0aW9uKG5vZGUsIF9zY2FsZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgbGltaXRCeU1pbiA9IGxpbWl0UG9pbnRQb3NpdGlvbihub2RlTWluU2NhbGVkUG9zaXRpb24sIHNjYWxlZFZpZXdQb3J0Qm91bmRzKTtcclxuICAgICAgICBjb25zdCBub2RlTWF4U2NhbGVkUG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgIHg6IGxpbWl0QnlNaW4ueCArIG5vZGVTY2FsZWRTaXplLndpZHRoLFxyXG4gICAgICAgICAgICB5OiBsaW1pdEJ5TWluLnkgKyBub2RlU2NhbGVkU2l6ZS5oZWlnaHQsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBsaW1pdEJ5TWF4ID0gbGltaXRQb2ludFBvc2l0aW9uKG5vZGVNYXhTY2FsZWRQb3NpdGlvbiwgc2NhbGVkVmlld1BvcnRCb3VuZHMpO1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gc2NhbGVkVG9HbG9iYWxQb2ludChsaW1pdEJ5TWF4LCBfc2NhbGUpO1xyXG5cclxuICAgICAgICBub2RlLm1vZGVsLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9pbml0IChvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NhbGUpIHtcclxuICAgICAgICAgICAgX3NjYWxlID0gb3B0aW9ucy5zY2FsZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuX3NjYWxlV2lsbEFwcGxpZWQpIHtcclxuICAgICAgICAgICAgX3NjYWxlID0gc2VsZi5fc2NhbGVXaWxsQXBwbGllZChwYXJhbWV0ZXJzLmRlZmF1bHRTY2FsZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX3NjYWxlID0gcGFyYW1ldGVycy5kZWZhdWx0U2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLm5vZGVCb3VuZHMpIHtcclxuICAgICAgICAgICAgX25vZGVCb3VuZHMgPSBvcHRpb25zLm5vZGVCb3VuZHM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX25vZGVCb3VuZHMgPSBfY2FsY3VsYXRlQm91bmRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLnZpZXdQb3J0UG9zaXRpb24pIHtcclxuICAgICAgICAgICAgX3ZpZXdQb3J0UG9zaXRpb24gPSBvcHRpb25zLnZpZXdQb3J0UG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLnZpZXdQb3J0UG9zaXRpb25Cb3VuZHMpIHtcclxuICAgICAgICAgICAgX3ZpZXdQb3J0UG9zaXRpb25Cb3VuZHMgPSBvcHRpb25zLnZpZXdQb3J0UG9zaXRpb25Cb3VuZHM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX3ZpZXdQb3J0UG9zaXRpb25Cb3VuZHMgPSBfY2FsY3VsYXRlVmlld1BvcnRQb3NpdGlvbkJvdW5kcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdmlld1BvcnRCb3VuZHMgPSBfZ2V0Vmlld1BvcnRCb3VuZHMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHNjYWxlIG9mIHRoZSB2aWV3RnJhbWUuXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBzY2FsZVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9zZXRTY2FsZSAoc2NhbGUpIHtcclxuICAgICAgICBpZiAoc2VsZi5fc2NhbGVXaWxsQXBwbGllZCkge1xyXG4gICAgICAgICAgICBfc2NhbGUgPSBzZWxmLl9zY2FsZVdpbGxBcHBsaWVkKHNjYWxlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfc2NhbGUgPSBzY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3VwZGF0ZUJvdW5kcygpO1xyXG4gICAgICAgIF9saW1pdFZpZXdQb3J0UG9zaXRpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNjYWxlIG9mIHRoZSB2aWV3RnJhbWUuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRTY2FsZSAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfY2xlYXIgKCkge1xyXG4gICAgICAgIF9jYWNoZWRSZXN1bHQgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBzZXRzIG9mZnNldCBmb3IgYWxsIGVsZW1lbnRzIGludG8gdGhlIHZpZXdQb3J0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIC0gZGlzYWJsZXMgdGhlIGxpbWl0XHJcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9wb3NpdGlvblZpZXdQb3J0ICh4LCB5KSB7XHJcbiAgICAgICAgaWYgKHggIT09IHVuZGVmaW5lZCkgX3ZpZXdQb3J0UG9zaXRpb24ueCA9IHg7XHJcbiAgICAgICAgaWYgKHkgIT09IHVuZGVmaW5lZCkgX3ZpZXdQb3J0UG9zaXRpb24ueSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB7IHg6IF92aWV3UG9ydFBvc2l0aW9uLngsIHk6IF92aWV3UG9ydFBvc2l0aW9uLnkgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgbGlzdCBvZiBub2RlcyB3aGljaCB2aWV3RnJhbWUgb3ducy5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheSBvZiBOb2RlfVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXROb2RlcyAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9kYXRhQ29udGFpbmVyLm5vZGVzLmZpbHRlcihuID0+IF9vd25lclRlc3QobikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyBzaXplIG9mIHRoZSB2aWV3LXBvcnQtam9pbnRqcyBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIHtTaXplfSBzaXplXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlbWVtYmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9zZXRTaXplIChzaXplKSB7XHJcbiAgICAgICAgc2VsZi5tb3ZpbmdCeUl0c2VsZiA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIGl0J3MgYmVzdCBzb2x1dGlvbiB0byBmaXggdGhlIHN2ZyBleHBvcnRpbmdcclxuICAgICAgICAvLyBhbmQgZm9yIGJldHRlciBjb21wYXRpYmlsaXR5IElFMTFcclxuICAgICAgICBzZWxmLmF0dHIoe1xyXG4gICAgICAgICAgICAncmVjdCc6IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgIHNlbGYucmVzaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcclxuICAgICAgICBzZWxmLnNpemUgPSBzaXplO1xyXG4gICAgICAgIHNlbGYubW9kZWwud2lkdGggPSBzaXplLndpZHRoO1xyXG4gICAgICAgIHNlbGYubW9kZWwuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XHJcblxyXG4gICAgICAgIHNlbGYubW92aW5nQnlJdHNlbGYgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgY29uc3QgbGFiZWwgPSBqb2ludC51dGlsLmJyZWFrVGV4dChvcHRpb25zLmxhYmVsLCB7XHJcbiAgICAgICAgICAgIHdpZHRoOiBzZWxmLnNpemUud2lkdGggLSBIT1JfTEFCRUxfUEFERElORyAqIDJcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBjb21wbGV0ZUxhYmVsID0gbGFiZWwuaW5kZXhPZignXFxuJykgPT09IC0xID8gbGFiZWwgOiBsYWJlbC5zdWJzdHJpbmcoMCwgbGFiZWwuaW5kZXhPZignXFxuJykpICsgJy4uLic7XHJcbiAgICAgICAgc2VsZi5hdHRyKCd0ZXh0L3RleHQnLCBjb21wbGV0ZUxhYmVsKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiB0aGUgbm9kZS5cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfcmVmcmVzaE5vZGVTdGF0ZSAobm9kZSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGVQb3NpdGlvbiA9IGdldExvY2FsTm9kZVBvc2l0aW9uKG5vZGUsIF9zY2FsZSwgc2VsZik7XHJcbiAgICAgICAgbm9kZS5wb3NpdGlvbihub2RlUG9zaXRpb24ueCwgbm9kZVBvc2l0aW9uLnkpO1xyXG4gICAgICAgIG5vZGUuc2V0U2l6ZShfcmVmZXJlbmNlU2l6ZSk7XHJcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMuY2xpcE5vZGVzKSB7XHJcbiAgICAgICAgICAgIF9jbGlwTm9kZShub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3VwZGF0ZUJvdW5kcyAoKSB7XHJcbiAgICAgICAgX25vZGVCb3VuZHMgPSBfY2FsY3VsYXRlQm91bmRzKCk7XHJcbiAgICAgICAgX3ZpZXdQb3J0UG9zaXRpb25Cb3VuZHMgPSBfY2FsY3VsYXRlVmlld1BvcnRQb3NpdGlvbkJvdW5kcygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVjYWxjdWxhdGUgYm91bmRzIG9mIHZpZXcgcG9ydC5cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfY2FsY3VsYXRlQm91bmRzICgpIHtcclxuICAgICAgICBjb25zdCBib3VuZHMgPSB7XHJcbiAgICAgICAgICAgIG1pblg6IEluZmluaXR5LFxyXG4gICAgICAgICAgICBtYXhYOiAtSW5maW5pdHksXHJcbiAgICAgICAgICAgIG1pblk6IEluZmluaXR5LFxyXG4gICAgICAgICAgICBtYXhZOiAtSW5maW5pdHksXHJcbiAgICAgICAgICAgIHdpZHRoOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGhlaWdodDogdW5kZWZpbmVkLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gX2dldE5vZGVzKCk7XHJcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCAhPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IGdldEdsb2JhbE5vZGVQb3NpdGlvbihub2RlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBzY2FsZWRUb0dsb2JhbFNpemUobm9kZS5jYWxjdWxhdGVTaXplKF9yZWZlcmVuY2VTaXplKSwgX3NjYWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBib3VuZHMubWluWCA9IE1hdGgubWluKGJvdW5kcy5taW5YLCBwb3MueCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRzLm1pblggPT09IHBvcy54KSBib3VuZHMubWluWE5vZGUgPSBub2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIGJvdW5kcy5tYXhYID0gIE1hdGgubWF4KGJvdW5kcy5tYXhYLCBwb3MueCArIHNpemUud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kcy5tYXhYID09PSBwb3MueCArIHNpemUud2lkdGgpIGJvdW5kcy5tYXhYTm9kZSA9IG5vZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgYm91bmRzLm1pblkgPSBNYXRoLm1pbihib3VuZHMubWluWSwgcG9zLnkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kcy5taW5ZID09PSBwb3MueSkgYm91bmRzLm1pbllOb2RlID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgYm91bmRzLm1heFkgPSBNYXRoLm1heChib3VuZHMubWF4WSwgcG9zLnkgKyBzaXplLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRzLm1heFkgPT09IHBvcy55ICsgc2l6ZS5oZWlnaHQpIGJvdW5kcy5tYXhZTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBib3VuZHMud2lkdGggPSBib3VuZHMubWF4WCAtIGJvdW5kcy5taW5YO1xyXG4gICAgICAgICAgICBib3VuZHMuaGVpZ2h0ID0gYm91bmRzLm1heFkgLSBib3VuZHMubWluWTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBib3VuZHMubWluWCA9IDA7XHJcbiAgICAgICAgICAgIGJvdW5kcy5taW5ZID0gMDtcclxuICAgICAgICAgICAgYm91bmRzLm1heFggPSAwO1xyXG4gICAgICAgICAgICBib3VuZHMubWF4WSA9IDA7XHJcbiAgICAgICAgICAgIGJvdW5kcy53aWR0aCA9IDA7XHJcbiAgICAgICAgICAgIGJvdW5kcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYm91bmRzIG9mIHZpZXcgcG9ydC5cclxuICAgICAqIEByZXR1cm5zIHtcclxuICAgICAqICBtYXhYOiBudW1iZXJcclxuICAgICAqICBtaW5YOiBudW1iZXJcclxuICAgICAqICBtYXhZOiBudW1iZXJcclxuICAgICAqICBtaW5ZOiBudW1iZXJcclxuICAgICAqIH1cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfY2FsY3VsYXRlVmlld1BvcnRQb3NpdGlvbkJvdW5kcyAoKSB7XHJcbiAgICAgICAgaWYgKCFfbm9kZUJvdW5kcykgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgLy8gX2JvdW5kcyAtIGdsb2JhbCBjb29yZFxyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZUdsb2JhbFNpemUgPSBzY2FsZWRUb0dsb2JhbFNpemUoc2VsZi5zaXplLCBfc2NhbGUpO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kc1dpdGhQYWRkaW5nID0gZXh0ZW5kQm91bmRzKF9ub2RlQm91bmRzLCBfZnJhbWVQYWRkaW5nKTtcclxuXHJcbiAgICAgICAgY29uc3Qgdmlld1BvcnRCb3VuZHMgPSB7XHJcbiAgICAgICAgICAgIG1pblg6IGJvdW5kc1dpdGhQYWRkaW5nLm1pblgsXHJcbiAgICAgICAgICAgIG1heFg6IGJvdW5kc1dpdGhQYWRkaW5nLm1heFggLSB2aWV3RnJhbWVHbG9iYWxTaXplLndpZHRoLFxyXG4gICAgICAgICAgICBtaW5ZOiBib3VuZHNXaXRoUGFkZGluZy5taW5ZLFxyXG4gICAgICAgICAgICBtYXhZOiBib3VuZHNXaXRoUGFkZGluZy5tYXhZIC0gdmlld0ZyYW1lR2xvYmFsU2l6ZS5oZWlnaHQsXHJcbiAgICAgICAgICAgIHdpZHRoOiBib3VuZHNXaXRoUGFkZGluZy5tYXhYIC0gdmlld0ZyYW1lR2xvYmFsU2l6ZS53aWR0aCAtIGJvdW5kc1dpdGhQYWRkaW5nLm1pblgsXHJcbiAgICAgICAgICAgIGhlaWdodDogYm91bmRzV2l0aFBhZGRpbmcubWF4WSAtIHZpZXdGcmFtZUdsb2JhbFNpemUuaGVpZ2h0IC0gYm91bmRzV2l0aFBhZGRpbmcubWluWSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAodmlld1BvcnRCb3VuZHMud2lkdGggPCAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpZmZYID0gKHZpZXdGcmFtZUdsb2JhbFNpemUud2lkdGggLSBib3VuZHNXaXRoUGFkZGluZy53aWR0aCkgLyAyO1xyXG4gICAgICAgICAgICB2aWV3UG9ydEJvdW5kcy5taW5YID0gYm91bmRzV2l0aFBhZGRpbmcubWluWCAtIGRpZmZYO1xyXG4gICAgICAgICAgICB2aWV3UG9ydEJvdW5kcy5tYXhYID0gdmlld1BvcnRCb3VuZHMubWluWDtcclxuICAgICAgICAgICAgdmlld1BvcnRCb3VuZHMud2lkdGggPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHZpZXdQb3J0Qm91bmRzLmhlaWdodCA8IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZGlmZlkgPSAodmlld0ZyYW1lR2xvYmFsU2l6ZS5oZWlnaHQgLSBib3VuZHNXaXRoUGFkZGluZy5oZWlnaHQpIC8gMjtcclxuICAgICAgICAgICAgdmlld1BvcnRCb3VuZHMubWluWSA9IGJvdW5kc1dpdGhQYWRkaW5nLm1pblkgLSBkaWZmWTtcclxuICAgICAgICAgICAgdmlld1BvcnRCb3VuZHMubWF4WSA9IHZpZXdQb3J0Qm91bmRzLm1pblk7XHJcbiAgICAgICAgICAgIHZpZXdQb3J0Qm91bmRzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdmlld1BvcnRCb3VuZHM7XHJcbiAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBib3VuZHMgb2YgdmlldyBwb3J0LlxyXG4gICAgICogQHJldHVybnMge1xyXG4gICAgICogIG1heFg6IG51bWJlclxyXG4gICAgICogIG1pblg6IG51bWJlclxyXG4gICAgICogIG1heFk6IG51bWJlclxyXG4gICAgICogIG1pblk6IG51bWJlclxyXG4gICAgICogfVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRWaWV3UG9ydEJvdW5kcyAoKSB7XHJcbiAgICAgICAgY29uc3QgZ2xvYmFsVmlld1BvcnRTaXplID0gc2NhbGVkVG9HbG9iYWxTaXplKHNlbGYuc2l6ZSwgX3NjYWxlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtaW5YOiBfdmlld1BvcnRQb3NpdGlvbi54LFxyXG4gICAgICAgICAgICBtYXhYOiBfdmlld1BvcnRQb3NpdGlvbi54ICsgZ2xvYmFsVmlld1BvcnRTaXplLndpZHRoLFxyXG4gICAgICAgICAgICBtaW5ZOiBfdmlld1BvcnRQb3NpdGlvbi55LFxyXG4gICAgICAgICAgICBtYXhZOiBfdmlld1BvcnRQb3NpdGlvbi55ICsgZ2xvYmFsVmlld1BvcnRTaXplLmhlaWdodCxcclxuICAgICAgICAgICAgd2lkdGg6IF92aWV3UG9ydFBvc2l0aW9uLnggKyBnbG9iYWxWaWV3UG9ydFNpemUud2lkdGggLSBfdmlld1BvcnRQb3NpdGlvbi54LFxyXG4gICAgICAgICAgICBoZWlnaHQ6IF92aWV3UG9ydFBvc2l0aW9uLnkgKyBnbG9iYWxWaWV3UG9ydFNpemUuaGVpZ2h0IC0gX3ZpZXdQb3J0UG9zaXRpb24ueSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGltaXRzIHBvc2l0aW9uIG9mIHRoZSB2aWV3IHBvcnQuXHJcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2xpbWl0Vmlld1BvcnRQb3NpdGlvbiAoKSB7XHJcbiAgICAgICAgX3ZpZXdQb3J0UG9zaXRpb24gPSBsaW1pdFBvaW50UG9zaXRpb24oX3ZpZXdQb3J0UG9zaXRpb24sIF92aWV3UG9ydFBvc2l0aW9uQm91bmRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHVzIHdoZXRoZXIgYSBOb2RlIGZhbGwgaW50byB0aGUgdmlld3BvcnQgb3Igbm8uXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFydGlhbEhpdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2hpdFRlc3RCeUdsb2JhbFBvc2l0aW9uIChub2RlLCBwYXJ0aWFsSGl0KSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZVBvc2l0aW9uID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKG5vZGUpO1xyXG5cclxuICAgICAgICBjb25zdCBub2RlU2NhbGVkU2l6ZSA9IG5vZGUuY2FsY3VsYXRlU2l6ZShfcmVmZXJlbmNlU2l6ZSk7XHJcbiAgICAgICAgY29uc3Qgbm9kZVNpemUgPSBzY2FsZWRUb0dsb2JhbFNpemUobm9kZVNjYWxlZFNpemUsIF9zY2FsZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHAxID0gbm9kZVBvc2l0aW9uO1xyXG4gICAgICAgIGNvbnN0IHAyID0geyB4OiBub2RlUG9zaXRpb24ueCArIG5vZGVTaXplLndpZHRoLCB5OiBub2RlUG9zaXRpb24ueSB9O1xyXG4gICAgICAgIGNvbnN0IHAzID0geyB4OiBub2RlUG9zaXRpb24ueCwgeTogbm9kZVBvc2l0aW9uLnkgKyBub2RlU2l6ZS5oZWlnaHQgfTtcclxuICAgICAgICBjb25zdCBwNCA9IHsgeDogbm9kZVBvc2l0aW9uLnggKyBub2RlU2l6ZS53aWR0aCwgeTogbm9kZVBvc2l0aW9uLnkgKyBub2RlU2l6ZS5oZWlnaHQgfTtcclxuXHJcbiAgICAgICAgY29uc3QgaGl0UDEgPSBfaGl0R2xvYmFsUG9pbnRUZXN0KHAxKTtcclxuICAgICAgICBjb25zdCBoaXRQMiA9IF9oaXRHbG9iYWxQb2ludFRlc3QocDIpO1xyXG4gICAgICAgIGNvbnN0IGhpdFAzID0gX2hpdEdsb2JhbFBvaW50VGVzdChwMyk7XHJcbiAgICAgICAgY29uc3QgaGl0UDQgPSBfaGl0R2xvYmFsUG9pbnRUZXN0KHA0KTtcclxuXHJcbiAgICAgICAgY29uc3QgZnVsbEhpdCA9IGhpdFAxICYmIGhpdFAyICYmIGhpdFAzICYmIGhpdFA0O1xyXG4gICAgICAgIGNvbnN0IGJvcmRlckhpdCA9IGhpdFAxIHx8IGhpdFAyIHx8IGhpdFAzIHx8IGhpdFA0O1xyXG5cclxuICAgICAgICBpZiAocGFyYW1ldGVycy5jbGlwTm9kZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJvcmRlckhpdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gKHBhcnRpYWxIaXQgJiYgYm9yZGVySGl0KSB8fCAoIXBhcnRpYWxIaXQgJiYgZnVsbEhpdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9oaXRBcmVhVGVzdEJ5R2xvYmFsUG9zaXRpb24gKG5vZGUsIHZpZXdGcmFtZSkge1xyXG4gICAgICAgIGNvbnN0IHNjYWxlZFBvc2l0aW9uID0gbm9kZS5wb3NpdGlvbigpO1xyXG4gICAgICAgIGNvbnN0IG5vZGVQb3NpdGlvbiA9IGxvY2FsVG9HbG9iYWxQb2ludChzY2FsZWRQb3NpdGlvbiwgX3NjYWxlLCB2aWV3RnJhbWUgfHwgc2VsZik7XHJcblxyXG4gICAgICAgIGNvbnN0IG5vZGVTY2FsZWRTaXplID0gbm9kZS5jYWxjdWxhdGVTaXplKF9yZWZlcmVuY2VTaXplKTtcclxuICAgICAgICBjb25zdCBub2RlU2l6ZSA9IHNjYWxlZFRvR2xvYmFsU2l6ZShub2RlU2NhbGVkU2l6ZSwgX3NjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3QgcDEgPSBub2RlUG9zaXRpb247XHJcbiAgICAgICAgY29uc3QgcDIgPSB7IHg6IG5vZGVQb3NpdGlvbi54ICsgbm9kZVNpemUud2lkdGgsIHk6IG5vZGVQb3NpdGlvbi55IH07XHJcbiAgICAgICAgY29uc3QgcDMgPSB7IHg6IG5vZGVQb3NpdGlvbi54LCB5OiBub2RlUG9zaXRpb24ueSArIG5vZGVTaXplLmhlaWdodCB9O1xyXG4gICAgICAgIGNvbnN0IHA0ID0geyB4OiBub2RlUG9zaXRpb24ueCArIG5vZGVTaXplLndpZHRoLCB5OiBub2RlUG9zaXRpb24ueSArIG5vZGVTaXplLmhlaWdodCB9O1xyXG5cclxuICAgICAgICBjb25zdCBoaXRQMSA9IF9oaXRBcmVhR2xvYmFsUG9pbnRUZXN0KHAxKTtcclxuICAgICAgICBjb25zdCBoaXRQMiA9IF9oaXRBcmVhR2xvYmFsUG9pbnRUZXN0KHAyKTtcclxuICAgICAgICBjb25zdCBoaXRQMyA9IF9oaXRBcmVhR2xvYmFsUG9pbnRUZXN0KHAzKTtcclxuICAgICAgICBjb25zdCBoaXRQNCA9IF9oaXRBcmVhR2xvYmFsUG9pbnRUZXN0KHA0KTtcclxuXHJcbiAgICAgICAgY29uc3QgYm9yZGVySGl0ID0gaGl0UDEgfHwgaGl0UDIgfHwgaGl0UDMgfHwgaGl0UDQ7XHJcblxyXG4gICAgICAgIHJldHVybiBib3JkZXJIaXQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2hpdFRlc3RCeVNjYWxlZFBvc2l0aW9uIChub2RlKSB7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVkUG9zaXRpb24gPSBub2RlLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcDEgPSBzY2FsZWRQb3NpdGlvbjtcclxuICAgICAgICBjb25zdCBwMiA9IHsgeDogc2NhbGVkUG9zaXRpb24ueCArbm9kZS5zaXplLndpZHRoLCB5OiBzY2FsZWRQb3NpdGlvbi55IH07XHJcbiAgICAgICAgY29uc3QgcDMgPSB7IHg6IHNjYWxlZFBvc2l0aW9uLngsIHk6IHNjYWxlZFBvc2l0aW9uLnkgKyBub2RlLnNpemUuaGVpZ2h0IH07XHJcbiAgICAgICAgY29uc3QgcDQgPSB7IHg6IHNjYWxlZFBvc2l0aW9uLnggKyBub2RlLnNpemUud2lkdGgsIHk6IHNjYWxlZFBvc2l0aW9uLnkgKyBub2RlLnNpemUuaGVpZ2h0IH07XHJcblxyXG4gICAgICAgIGNvbnN0IGhpdFAxID0gX2hpdFNjYWxlZFBvaW50VGVzdChwMSk7XHJcbiAgICAgICAgY29uc3QgaGl0UDIgPSBfaGl0U2NhbGVkUG9pbnRUZXN0KHAyKTtcclxuICAgICAgICBjb25zdCBoaXRQMyA9IF9oaXRTY2FsZWRQb2ludFRlc3QocDMpO1xyXG4gICAgICAgIGNvbnN0IGhpdFA0ID0gX2hpdFNjYWxlZFBvaW50VGVzdChwNCk7XHJcblxyXG4gICAgICAgIHJldHVybiAoaGl0UDEgfHwgaGl0UDIgfHwgaGl0UDMgfHwgaGl0UDQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9oaXRHbG9iYWxQb2ludFRlc3QgKHApIHtcclxuICAgICAgICByZXR1cm4gX3ZpZXdQb3J0Qm91bmRzLm1pblggPD0gcC54ICYmIHAueCA8PSBfdmlld1BvcnRCb3VuZHMubWF4WCAgJiZcclxuICAgICAgICAgICAgICAgX3ZpZXdQb3J0Qm91bmRzLm1pblkgPD0gcC55ICYmIHAueSA8PSBfdmlld1BvcnRCb3VuZHMubWF4WTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfaGl0QXJlYUdsb2JhbFBvaW50VGVzdCAocCkge1xyXG4gICAgICAgIHJldHVybiBfbm9kZUJvdW5kcy5taW5YIDw9IHAueCAmJiBwLnggPD0gX25vZGVCb3VuZHMubWF4WCAgJiZcclxuICAgICAgICAgICAgICAgX25vZGVCb3VuZHMubWluWSA8PSBwLnkgJiYgcC55IDw9IF9ub2RlQm91bmRzLm1heFk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2hpdFNjYWxlZFBvaW50VGVzdCAocCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmLmNvbnN0UG9zaXRpb24ueCA8PSBwLnggJiZcclxuICAgICAgICAgICAgc2VsZi5jb25zdFBvc2l0aW9uLnggKyBzZWxmLnNpemUud2lkdGggPj0gcC54ICYmXHJcbiAgICAgICAgICAgIHNlbGYuY29uc3RQb3NpdGlvbi55IDw9IHAueSAmJlxyXG4gICAgICAgICAgICBzZWxmLmNvbnN0UG9zaXRpb24ueSArIHNlbGYuc2l6ZS5oZWlnaHQgPj0gcC55O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9vd25lclRlc3QgKG5vZGUpIHtcclxuICAgICAgICBpZiAoc2VsZi5fb3duZXJUZXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9vd25lclRlc3Qobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGN1c3RvbWVPd25lciA9IG5vZGUudmlld0ZyYW1lT3duZXJJZDtcclxuICAgICAgICBjb25zdCBvd25lcklzTWUgPSBub2RlLnZpZXdGcmFtZU93bmVySWQgPT09IHNlbGYuaWQ7XHJcbiAgICAgICAgY29uc3QgbWVJc05hdGl2ZU93bmVyID0gc2VsZi5pZCA9PT0gbm9kZS5tb2RlbC52aWV3RnJhbWU7XHJcbiAgICAgICAgcmV0dXJuIChjdXN0b21lT3duZXIgJiYgb3duZXJJc01lKSB8fCAobWVJc05hdGl2ZU93bmVyICYmICFjdXN0b21lT3duZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjbGlwIHBvaW50LCB3aGljaFxyXG4gICAgICogdGVsbHMgdXMgaG93IGZhciB0aGUgbm9kZSBnbyBvdXQgb2YgdGhlIGJvcmRlciBvZiB2aWV3RnJhbWUuXHJcbiAgICAgKiBBbmQgYWZ0ZXIgY2FsY3VsYXRpb24gdGhlIGZ1bmN0aW9uIHBhc3MgdGhpcyBwb2ludCBpbnRvIHRoZSBub2RlLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NsaXBOb2RlIChub2RlKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZVBvc2l0aW9uID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKG5vZGUpO1xyXG4gICAgICAgIGNvbnN0IG5vZGVTY2FsZWRTaXplID0gbm9kZS5jYWxjdWxhdGVTaXplKF9yZWZlcmVuY2VTaXplKTtcclxuICAgICAgICBjb25zdCBub2RlU2l6ZSA9IHNjYWxlZFRvR2xvYmFsU2l6ZShub2RlU2NhbGVkU2l6ZSwgX3NjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3QgcDEgPSBub2RlUG9zaXRpb247XHJcbiAgICAgICAgY29uc3QgcDIgPSB7IHg6IG5vZGVQb3NpdGlvbi54ICsgbm9kZVNpemUud2lkdGgsIHk6IG5vZGVQb3NpdGlvbi55IH07XHJcbiAgICAgICAgY29uc3QgcDMgPSB7IHg6IG5vZGVQb3NpdGlvbi54LCB5OiBub2RlUG9zaXRpb24ueSArIG5vZGVTaXplLmhlaWdodCB9O1xyXG4gICAgICAgIGNvbnN0IHA0ID0geyB4OiBub2RlUG9zaXRpb24ueCArIG5vZGVTaXplLndpZHRoLCB5OiBub2RlUG9zaXRpb24ueSArIG5vZGVTaXplLmhlaWdodCB9O1xyXG5cclxuICAgICAgICBjb25zdCBnbG9iYWxPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICAgICAgbGV0IG8gPSBnZXRQb2ludE9mZnNldChwMSk7XHJcbiAgICAgICAgZ2xvYmFsT2Zmc2V0LnggPSBNYXRoLmFicyhvLngpID4gTWF0aC5hYnMoZ2xvYmFsT2Zmc2V0LngpID8gby54IDogZ2xvYmFsT2Zmc2V0Lng7XHJcbiAgICAgICAgZ2xvYmFsT2Zmc2V0LnkgPSBNYXRoLmFicyhvLnkpID4gTWF0aC5hYnMoZ2xvYmFsT2Zmc2V0LnkpID8gby55IDogZ2xvYmFsT2Zmc2V0Lnk7XHJcblxyXG4gICAgICAgIG8gPSBnZXRQb2ludE9mZnNldChwMik7XHJcbiAgICAgICAgZ2xvYmFsT2Zmc2V0LnggPSBNYXRoLmFicyhvLngpID4gTWF0aC5hYnMoZ2xvYmFsT2Zmc2V0LngpID8gby54IDogZ2xvYmFsT2Zmc2V0Lng7XHJcbiAgICAgICAgZ2xvYmFsT2Zmc2V0LnkgPSBNYXRoLmFicyhvLnkpID4gTWF0aC5hYnMoZ2xvYmFsT2Zmc2V0LnkpID8gby55IDogZ2xvYmFsT2Zmc2V0Lnk7XHJcblxyXG4gICAgICAgIG8gPSBnZXRQb2ludE9mZnNldChwMyk7XHJcbiAgICAgICAgZ2xvYmFsT2Zmc2V0LnggPSBNYXRoLmFicyhvLngpID4gTWF0aC5hYnMoZ2xvYmFsT2Zmc2V0LngpID8gby54IDogZ2xvYmFsT2Zmc2V0Lng7XHJcbiAgICAgICAgZ2xvYmFsT2Zmc2V0LnkgPSBNYXRoLmFicyhvLnkpID4gTWF0aC5hYnMoZ2xvYmFsT2Zmc2V0LnkpID8gby55IDogZ2xvYmFsT2Zmc2V0Lnk7XHJcblxyXG4gICAgICAgIG8gPSBnZXRQb2ludE9mZnNldChwNCk7XHJcbiAgICAgICAgZ2xvYmFsT2Zmc2V0LnggPSBNYXRoLmFicyhvLngpID4gTWF0aC5hYnMoZ2xvYmFsT2Zmc2V0LngpID8gby54IDogZ2xvYmFsT2Zmc2V0Lng7XHJcbiAgICAgICAgZ2xvYmFsT2Zmc2V0LnkgPSBNYXRoLmFicyhvLnkpID4gTWF0aC5hYnMoZ2xvYmFsT2Zmc2V0LnkpID8gby55IDogZ2xvYmFsT2Zmc2V0Lnk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlZE9mZnNldCA9IGdsb2JhbFRvU2NhbGVkUG9pbnQoZ2xvYmFsT2Zmc2V0LCBfc2NhbGUpO1xyXG4gICAgICAgIG5vZGUuc2V0Q2xpcHBpbmcoc2NhbGVkT2Zmc2V0KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0UG9pbnRPZmZzZXQgKHApIHtcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgICAgIGlmIChfdmlld1BvcnRCb3VuZHMubWluWCA+IHAueCkge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0LnggPSBfdmlld1BvcnRCb3VuZHMubWluWCAtIHAueDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChfdmlld1BvcnRCb3VuZHMubWF4WCA8IHAueCkge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0LnggPSBfdmlld1BvcnRCb3VuZHMubWF4WCAtIHAueDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX3ZpZXdQb3J0Qm91bmRzLm1pblkgPiBwLnkpIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldC55ID0gX3ZpZXdQb3J0Qm91bmRzLm1pblkgLSBwLnk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3ZpZXdQb3J0Qm91bmRzLm1heFkgPCBwLnkpIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldC55ID0gX3ZpZXdQb3J0Qm91bmRzLm1heFkgLSBwLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGN1cnJlbnQgc2l6ZSBmb3Igbm9kZSB3aXRoIGNvbnNpZGVyaW5nIHNjYWxlLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAgKiBAcmV0dXJucyB7U2l6ZX1cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfY2FsY3VsYXRlUmVmZXJlbmNlTm9kZVNpemUgKGVsZW1lbnRTaXplKSB7XHJcbiAgICAgICAgY29uc3QgbWluU2NhbGUgPSBNYXRoLm1pbihfc2NhbGUueCwgX3NjYWxlLnkpO1xyXG4gICAgICAgIGNvbnN0IHNjYWxlZEVsZW1lbnRTaXplID0gZ2xvYmFsVG9TY2FsZWRTaXplKGVsZW1lbnRTaXplLCB7XHJcbiAgICAgICAgICAgIHg6IG1pblNjYWxlLCB5OiBtaW5TY2FsZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBjb25zdCBzY2FsZWRFbGVtZW50U2l6ZSA9IGdsb2JhbFRvU2NhbGVkU2l6ZShlbGVtZW50U2l6ZSwgX3NjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3QgbWF4Qm91bmRlZFdpZHRoID0gc2VsZi5zaXplLndpZHRoIC0gcGFyYW1ldGVycy5mcmFtZVBhZGRpbmcueDtcclxuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IChtYXhCb3VuZGVkV2lkdGggPj0gZWxlbWVudFNpemUubWluV2lkdGggLyAzID8gbWF4Qm91bmRlZFdpZHRoIDogc2VsZi5zaXplLndpZHRoKTtcclxuXHJcbiAgICAgICAgY29uc3QgbWF4Qm91bmRlZEhlaWdodCA9IHNlbGYuc2l6ZS5oZWlnaHQgLSBwYXJhbWV0ZXJzLmZyYW1lUGFkZGluZy55O1xyXG4gICAgICAgIGNvbnN0IG1heEhlaWdodCA9IChtYXhCb3VuZGVkSGVpZ2h0ID49IGVsZW1lbnRTaXplLm1pbkhlaWdodCA/IG1heEJvdW5kZWRIZWlnaHQgOiBzZWxmLnNpemUuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlU2l6ZSA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNpemUubWluV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oc2NhbGVkRWxlbWVudFNpemUud2lkdGgsIGVsZW1lbnRTaXplLm1heFdpZHRoKSxcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCxcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1pbihcclxuICAgICAgICAgICAgICAgIE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTaXplLm1pbkhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihzY2FsZWRFbGVtZW50U2l6ZS5oZWlnaHQsIGVsZW1lbnRTaXplLm1heEhlaWdodCksXHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0LFxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICAgICBtYXhXaWR0aDogbWF4V2lkdGgsXHJcbiAgICAgICAgICAgIG1heEhlaWdodDogbWF4SGVpZ2h0LFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiByZWZlcmVuY2VTaXplO1xyXG4gICAgfVxyXG59XHJcblZpZXdGcmFtZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LnNoYXBlcy5iYXNpYy5SZWN0LnByb3RvdHlwZSk7XHJcbmV4cG9ydCBkZWZhdWx0IFZpZXdGcmFtZTtcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3NcclxuICogSXQncyBzcGVjaWFsIHZpZXdGcmFtZSB0byBzaG93IGFsbCBOb2RlcyBzZWxlY3RlZCBub2Rlcy5cclxuICogQWxsIG5vZGVzIGFyZSBwYXNzZWQgd2l0aCBvcHRpb25zIGZvciBwYXJlbnQgY2xhc3MuXHJcbiAqIEBhdWdtZW50cyBWaWV3RnJhbWUuXHJcbiAqIEFuZCB0aGlzIGNsYXNzIGhhcyB0aGUgc2FtZSBtZXRob2RzLCBmaWVsZHMgYW5kIHBhcmFtZXRlcnMgYXMgVmlld0ZyYW1lLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE92ZXJWaWV3RnJhbWUgKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgbGV0IF9yYXRpb01vZGlmeWVyID0gMTtcclxuXHJcbiAgICBzZWxmLl9vd25lclRlc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuX3NjYWxlV2lsbEFwcGxpZWQgPSBmdW5jdGlvbiAoc2NhbGUpIHtcclxuICAgICAgICBpZiAoX3JhdGlvTW9kaWZ5ZXIgPCAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiBzY2FsZS54LFxyXG4gICAgICAgICAgICAgICAgeTogc2NhbGUueCAqIF9yYXRpb01vZGlmeWVyLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiBzY2FsZS55IC8gX3JhdGlvTW9kaWZ5ZXIsXHJcbiAgICAgICAgICAgICAgICB5OiBzY2FsZS55LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgVmlld0ZyYW1lLmFwcGx5KHNlbGYsIFtvcHRpb25zLCBwYXJhbWV0ZXJzXSk7XHJcbiAgICBfaW5pdCgpO1xyXG5cclxuICAgIGZ1bmN0aW9uIF9pbml0ICgpIHtcclxuICAgICAgICBjb25zdCBwYXBlclNpemUgPSBnZXRFbGVtZW50U2l6ZShwYXJhbWV0ZXJzLmdyYXBoUGxhY2UpO1xyXG4gICAgICAgIGNvbnN0IG5vZGVCb3VuZHMgPSBzZWxmLmdldE5vZGVCb3VuZHMoKTtcclxuXHJcbiAgICAgICAgY29uc3Qgd2lkdGhJc1NjYWxhYmxlID0gbm9kZUJvdW5kcy53aWR0aCAmJiBub2RlQm91bmRzLm1pblhOb2RlICE9PSBub2RlQm91bmRzLm1heFhOb2RlO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodElzU2NhbGFibGUgPSBub2RlQm91bmRzLmhlaWdodCAmJiBub2RlQm91bmRzLm1pbllOb2RlICE9PSBub2RlQm91bmRzLm1heFlOb2RlO1xyXG4gICAgICAgIGlmICh3aWR0aElzU2NhbGFibGUgJiYgaGVpZ2h0SXNTY2FsYWJsZSkge1xyXG4gICAgICAgICAgICBjb25zdCB4UmF0aW8gPSBwYXBlclNpemUud2lkdGggLyAobm9kZUJvdW5kcy53aWR0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHlSYXRpbyA9IHBhcGVyU2l6ZS5oZWlnaHQgLyAobm9kZUJvdW5kcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHhSYXRpbyAhPT0geVJhdGlvKSB7XHJcbiAgICAgICAgICAgICAgICBfcmF0aW9Nb2RpZnllciA9IHlSYXRpbyAvIHhSYXRpbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5PdmVyVmlld0ZyYW1lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVmlld0ZyYW1lLnByb3RvdHlwZSk7IiwiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5cclxuaW1wb3J0IHsgVmlld0ZyYW1lLCBPdmVyVmlld0ZyYW1lIH0gZnJvbSAnLi92aWV3RnJhbWUnO1xyXG5pbXBvcnQgeyBOb2RlLCBUZXJtaW5hdGlvbk5vZGUsIFRlcm1pbmF0aW9uTGluaywgQXNwZWN0TGluaywgTGluayB9IGZyb20gJy4vZ3JhcGhFbGVtZW50cy9lbGVtZW50cyc7XHJcbmltcG9ydCBTdWJzY3JpYmFibGUgZnJvbSAnLi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGUnO1xyXG5pbXBvcnQge1xyXG4gICAgZ2V0Q3Jvc1BvaW50LCBnZXRWaWV3RnJhbWVJZEZvck5vZGUsXHJcbn0gZnJvbSAnLi4vdXRpbHMvbGluZWFnZURpYWdyYW1VdGlscyc7XHJcbmltcG9ydCB7IGFycmF5VG9NYXAsIGxpbWl0UG9pbnRQb3NpdGlvbiwgZ2V0U2NhbGVkTm9kZVBvc2l0aW9uLCBnZXRMb2NhbE5vZGVQb3NpdGlvbiwgc2NhbGVkVG9HbG9iYWxTaXplIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQgeyBnZXRCYXNlRWxlbWVudCB9IGZyb20gJy4uL3V0aWxzL2RhdGFVdGlscyc7XHJcblxyXG5leHBvcnQgY29uc3QgRElTVEFOQ0VfQkVUV0VFTl9GUkFNRVMgPSAyMDtcclxuZXhwb3J0IGNvbnN0IEZSQU1FX09VVF9NQVJHSU4gPSAyMDtcclxuXHJcbi8qKlxyXG4gKiBWaWV3TWFuYWdlciBvcHRpb25zLlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3TWFuZ2VyT3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge0RhdGFDb250YWluZXJ9IGRhdGFDb250YWluZXJcclxuICogQHByb3BlcnR5IHtWaWV3RnJhbWVQdWJsaWNNb2RlbFtdfSB2aWV3RnJhbWVzXHJcbiovXHJcblxyXG4vKipcclxuICogTWFuYWdlIFZpZXdGcmFtZXMgYW5kIGNvbGxlY3QgZGF0YVxyXG4gKiBmcm9tIHRoZW0gdG8gcmV0dXJuIHRvIHRoZSBsaW5lYWdlRGlhZ3JhbSByZW5kZXJcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtWaWV3TWFuZ2VyT3B0aW9uc30gb3B0aW9ucyBcclxuICogQHBhcmFtIHtQYXJhbWV0ZXJzfSBwYXJhbWV0ZXJzIFxyXG4gKiBAZmlyZXMgY2hhbmdlLXZpZXctcG9ydC1wb3NpdGlvblxyXG4gKiBQdWJsaWMgbWV0aG9kczpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBwcmVwYXJlUmVuZGVyRGF0YTogKHJlbmRlck9wdGlvbnMpID0+IChOb2RlfExpbmt8Vmlld0ZyYW1lKVtdXHJcbiAqIGdldFZpZXdGcmFtZUZvck5vZGU6ICgpID0+IFZpZXdGcmFtZVB1YmxpY01vZGVsO1xyXG4gKiBnZXRWaWVGcmFtZUZvck5vZGVCeVBvc2l0aW9uOiAobm9kZSkgPT4gVmlld0ZyYW1lUHVibGljTW9kZWw7XHJcbiAqIGdldFZpZXdGcmFtZUJ5SWQ6ICgpID0+IFZpZXdGcmFtZVB1YmxpY01vZGVsO1xyXG4gKiBnZXRPdmVyVmlld0ZyYW1lOiAoKSA9PiBWaWV3RnJhbWVQdWJsaWNNb2RlbDtcclxuICogZnVsbFNjcmVlbk1vZGU6ICgpID0+IGJvb2xlYW47XHJcbiAqIGdldFZpZXdGcmFtZXM6ICgpID0+IFZpZXdGcmFtZVB1YmxpY01vZGVsW107XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gVmlld01hbmFnZXIgKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcclxuICAgIFN1YnNjcmliYWJsZS5hcHBseSh0aGlzKTsgICAvLyBtYWtlIHRoaXMgY2xhc3MgU3Vic2NyaWJhYmxlXHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIFxyXG4gICAgY29uc3QgX3Rlcm1pbmF0aW9uTm9kZVNpemUgPSBwYXJhbWV0ZXJzLnRlcm1pbmF0aW9uTm9kZVNpemU7XHJcblxyXG4gICAgbGV0IF90ZXJtaW5hdGlvbkNlbGxDYWNoZSA9IHt9O1xyXG4gICAgbGV0IF9hc3BlY3RMaW5rc0NhaGUgPSB7fTtcclxuICAgIGxldCBfcmVuZGVyT3B0aW9ucyA9IHt9O1xyXG4gICAgbGV0IF92aWV3RnJhbWVzTWFwID0ge307XHJcbiAgICBsZXQgX3N0YXRlID0ge307XHJcbiAgICBsZXQgX2RhdGFDb250YWluZXI7XHJcbiAgICBsZXQgX292ZXJWaWV3RnJhbWU7XHJcbiAgICBsZXQgX3ZpZXdGcmFtZXM7XHJcbiAgICBsZXQgX2FsbEZyYW1lcztcclxuXHJcbiAgICBsZXQgX2Z1bGxTY3JlZW5Nb2RlOyAgLy8gY2hhbmdlYWJsZVxyXG5cclxuICAgIF9pbml0KG9wdGlvbnMsIHBhcmFtZXRlcnMpO1xyXG4gICAgXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXBlciByZW5kZXIgb3B0aW9ucy5cclxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFBhcGVyUmVuZGVyT3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IG9yaWVudGF0aW9uOiBfb3JpZW50YXRpb24sXHJcbiAgICAgKiBAcHJvcGVydHkgd2lkdGg6IF9wYXBlci5lbC5jbGllbnRXaWR0aCxcclxuICAgICAqIEBwcm9wZXJ0eSBoZWlnaHQ6IF9wYXBlci5lbC5jbGllbnRIZWlnaHQsXHJcbiAgICAgKiBAcHJvcGVydHkgc2NhbGU6IF9zY2FsZSxcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbGVtZW50IHJlbmRlciBvcHRpb25zLlxyXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gRWxlbWVudFJlbmRlck9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7RWxlbWVudFNpemV9IGVsZW1lbnRTaXplXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVyIG9wdGlvbnMuXHJcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBSZW5kZXJPcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge1ZpZXdGcmFtZVB1YmxpY01vZGVsW119IHZpZXdGcmFtZXNcclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZnVsbFNjcmVlbk1vZGVcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIChOb2RlfExpbmspPn0gcGF0aFxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgKE5vZGV8TGluayk+fSBtYXNrXHJcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHVwZGF0ZUJvdW5kc1xyXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBxdWlja1VwZGF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtQYXBlclJlbmRlck9wdGlvbnN9IHBhcGVyT3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtFbGVtZW50UmVuZGVyT3B0aW9uc30gZWxlbWVudE9wdGlvbnNcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAxLiBUYWtlcyByZW5kZXIgZGF0YSBmcm9tIHRoZSBWaWV3RnJhbWVzLFxyXG4gICAgICogMi4gVXBkYXRlcyBWaWV3RnJhbWVzIHN0YXRlXHJcbiAgICAgKiAzLiBDaGFuZ2VzIHNpemUgYW5kIHNjYWxlIG9mIHZpZXdGcmFtZXNcclxuICAgICAqIDQuIFVwZGF0ZXMgaGlnaGxpZ2h0aW5nXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlck9wdGlvbnN9IHJlbmRlck9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHsoTm9kZXxMaW5rfFZpZXdGcmFtZSlbXX1cclxuICAgICAqL1xyXG4gICAgc2VsZi5wcmVwYXJlUmVuZGVyRGF0YSA9IGZ1bmN0aW9uIChyZW5kZXJPcHRpb25zKSB7XHJcbiAgICAgICAgX3VwZGF0ZVZpZXdGcmFtZXMocmVuZGVyT3B0aW9ucyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgdmlzaWJsZVZpZXdGcmFtZXMgPSBfZ2V0VmlzaWJsZVZpZXdGcmFtZXMoKTtcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWVSZXN1bHRzID0gdmlzaWJsZVZpZXdGcmFtZXMubWFwKHZmID0+IHZmLmdldFZpc2libGVDZWxscygpKTtcclxuICAgICAgICBjb25zdCByZW5kZXJSZXN1bHRzID0gX2NhbGN1bGF0ZVJlbmRlckRhdGEodmlld0ZyYW1lUmVzdWx0cywgcmVuZGVyT3B0aW9ucyk7XHJcbiAgICAgICAgX3NldEhpZ2hsaWdodGluZyhyZW5kZXJSZXN1bHRzLCByZW5kZXJPcHRpb25zKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZpc2libGVWaWV3RnJhbWVzLmNvbmNhdChyZW5kZXJSZXN1bHRzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIFZpZXdGcmFtZSBmb3IgdGhlIG5vZGUgd2hpY2ggY3VycmVudGx5IHJlbmRlcnMgdGhpcyBub2RlLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lUHVibGljTW9kZWx9XHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRWaWV3RnJhbWVGb3JOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gX2dldFZpZXdGcmFtZVB1YmxpY01vZGVsKF9nZXRWaWV3RnJhbWVGb3JOb2RlKG5vZGUpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIFZpZXdGcmFtZSB3aGljaCBjdXJyZW50bHkgb3ducyB0aGlzIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVQdWJsaWNNb2RlbH1cclxuICAgICovXHJcbiAgICBzZWxmLmdldFZpZXdGcmFtZU93bmVyID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWVJZCA9IGdldFZpZXdGcmFtZUlkRm9yTm9kZShub2RlKTtcclxuICAgICAgICByZXR1cm4gX2dldFZpZXdGcmFtZVB1YmxpY01vZGVsKF92aWV3RnJhbWVzTWFwW3ZpZXdGcmFtZUlkXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBWaWV3RnJhbWUgZm9yIHRoZSBub2RlIGJ5IGhpcyBwb3NpdGlvbi5cclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVB1YmxpY01vZGVsIHwgdW5kZWZpbmVkfVxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0VmllRnJhbWVGb3JOb2RlQnlQb3NpdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgaWYgKF9mdWxsU2NyZWVuTW9kZSkgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgY29uc3QgdmlzaWJsZUZyYW1lcyA9IF9nZXRWaXNpYmxlVmlld0ZyYW1lcygpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaWJsZUZyYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB2ZiA9IHZpc2libGVGcmFtZXNbaV07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAodmYuaGl0VGVzdEJ5U2NhbGVkUG9zaXRpb24obm9kZSkpIHJldHVybiBfZ2V0Vmlld0ZyYW1lUHVibGljTW9kZWwodmYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgVmlld0ZyYW1lIGZvciB0aGUgbm9kZSBieSBoaXMgcG9zaXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVB1YmxpY01vZGVsfVxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0VmllRnJhbWVCeVNjcmVlblBvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZUZyYW1lcyA9IF9nZXRWaXNpYmxlVmlld0ZyYW1lcygpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaWJsZUZyYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB2ZiA9IHZpc2libGVGcmFtZXNbaV07XHJcbiAgICAgICAgICAgIGlmICh2Zi5oaXRTY2FsZWRQb2ludFRlc3QocG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFZpZXdGcmFtZVB1YmxpY01vZGVsKHZmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc3RvcmVzIGRlZmF1bHQgc2l6ZSBvZiBWaWV3RnJhbWVzXHJcbiAgICAgKi9cclxuICAgIHNlbGYucmVzZXRGcmFtZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfdmlld0ZyYW1lcy5mb3JFYWNoKHZmID0+IHtcclxuICAgICAgICAgICAgdmYucmVzZXRTaXplKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBWaWV3RnJhbWUgYnkgaWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVB1YmxpY01vZGVsIHwgdW5kZWZpbmVkfVxyXG4gICAgICovXHJcbiAgICBzZWxmLmdldFZpZXdGcmFtZUJ5SWQgPSBmdW5jdGlvbiAodmlld0ZyYW1lSWQpIHtcclxuICAgICAgICByZXR1cm4gX2dldFZpZXdGcmFtZVB1YmxpY01vZGVsKF92aWV3RnJhbWVzTWFwW3ZpZXdGcmFtZUlkXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBPdmVyVmlld0ZyYW1lXHJcbiAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lUHVibGljTW9kZWx9XHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0T3ZlclZpZXdGcmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2dldFZpZXdGcmFtZVB1YmxpY01vZGVsKF9vdmVyVmlld0ZyYW1lKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB1cyB3aGV0aGVyIG92ZXJWaWV3IGlzIGFjdGl2ZSBvciBub3RcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBzZWxmLmlzRnVsbFNjcmVlbk1vZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9mdWxsU2NyZWVuTW9kZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCBWaWV3RnJhbWVzXHJcbiAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lUHVibGljTW9kZWxbXX1cclxuICAgICovXHJcbiAgICBzZWxmLmdldFZpZXdGcmFtZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9hbGxGcmFtZXMubWFwKHZmID0+IF9nZXRWaWV3RnJhbWVQdWJsaWNNb2RlbCh2ZikpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZpZXdGcmFtZSBwdWJsaWMgbW9kZWxcclxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFZpZXdGcmFtZVB1YmxpY01vZGVsXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBJZGVudGlmeWVyXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWwgLSBMYWJlbCBpbiB0aGUgdG9wLXJpZ2h0IGNvcm5lclxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGJhY2tncm91bmRDb2xvciAtIEJhY2dyb3VuZCBjb2xvclxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGJvcmRlckNvbG9yIC0gQm9yZGVyIGNvbG9yXHJcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGFjdGl2ZSAtIElzIG9uIHRoZSBzY3JlZW5cclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXhwYW5kZWQgLSBJcyBleHBhbmRlZFxyXG4gICAgICogQHByb3BlcnR5IHtQb2ludH0gcG9zaXRpb24gLSBSZWFsIHBvc2l0aW9uIG9uIHRoZSBwYXBlclxyXG4gICAgICogQHByb3BlcnR5IHtQb2ludH0gdmlld1BvcnRQb3NpdGlvbiAtIFBvc2l0aW9uIG9mIHRoZSB2aWV3UG9ydFxyXG4gICAgICogQHByb3BlcnR5IHtCb3VuZHN9IGJvdW5kcyAtIFJlYWwgdmlzdWFsIGJvdW5kcyBvZiBhY3RpdmUgem9uZSBvZiB2aWV3RnJhbWUgKFpvbmUgYXJvdW5kIG5vZGVzKVxyXG4gICAgICogQHByb3BlcnR5IHtTaXplfSBzaXplIC0gUmVhbCBzaXplIG9mIHZpZXdGcmFtZVxyXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBjdXN0b21lU2l6ZWQgLSBUZWxscyB1cyB3aGV0aGVyIHNpemUgd2FzIGNoYW5nZWQgYnkgdXNlciBvciBub3RcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm91bmRzfSB2aWV3UG9ydFBvc2l0aW9uQm91bmRzIC0gTWluIG1heCB2YWx1ZXMgb2YgdGhlIHBvc2l0aW9uIG9mIHRoZSB2aWV3UG9ydFxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNwYWNlU2hhcmUgLSByZWxhdGl2ZSBzaXplIG9mIHZpZXcgZnJhbWUgKGhvcml6b250YWwvdmVydGljYWwgZGVwZW5kcyBvbiBvcmllbnRhdGlvbilcclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdXBkYXRlQm91bmRzIC0gRmxhZyB0byBwYXNzIGludG8gdGhlIHJlbmRlciBwaXBsaW5lXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lfSB2aWV3RnJhbWVcclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVQdWJsaWNNb2RlbH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldFZpZXdGcmFtZVB1YmxpY01vZGVsICh2aWV3RnJhbWUpIHtcclxuICAgICAgICBpZiAoIXZpZXdGcmFtZSkgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IGN1c3RvbWVTaXplZCA9IHZpZXdGcmFtZS5tb2RlbC53aWR0aCB8fCB2aWV3RnJhbWUubW9kZWwuaGVpZ2h0O1xyXG5cclxuICAgICAgICBjb25zdCBpc0FjdGl2ZSA9IHZpZXdGcmFtZSA9PT0gX292ZXJWaWV3RnJhbWUgP1xyXG4gICAgICAgICAgICBfZnVsbFNjcmVlbk1vZGUgOiBfZnVsbFNjcmVlbk1vZGUgP1xyXG4gICAgICAgICAgICBmYWxzZSA6IF9zdGF0ZVt2aWV3RnJhbWUubW9kZWwuaWRdO1xyXG5cclxuICAgICAgICBjb25zdCBpc0V4cGFuZGVkID0gdmlld0ZyYW1lID09PSBfb3ZlclZpZXdGcmFtZSA/XHJcbiAgICAgICAgICAgIF9mdWxsU2NyZWVuTW9kZSA6IF9zdGF0ZVt2aWV3RnJhbWUubW9kZWwuaWRdO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogdmlld0ZyYW1lLm1vZGVsLmlkLFxyXG4gICAgICAgICAgICBsYWJlbDogdmlld0ZyYW1lLm1vZGVsLmxhYmVsLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHZpZXdGcmFtZS5tb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiB2aWV3RnJhbWUubW9kZWwuYm9yZGVyQ29sb3IsXHJcbiAgICAgICAgICAgIGFjdGl2ZTogaXNBY3RpdmUsXHJcbiAgICAgICAgICAgIGV4cGFuZGVkOiBpc0V4cGFuZGVkLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogdmlld0ZyYW1lLnBvc2l0aW9uKCksIC8vIGxvY2FsXHJcbiAgICAgICAgICAgIHZpZXdQb3J0UG9zaXRpb246IHZpZXdGcmFtZS5wb3NpdGlvblZpZXdQb3J0KCksIC8vIGdsb2JhbFxyXG4gICAgICAgICAgICB2aWV3UG9ydFBvc2l0aW9uQm91bmRzOiB2aWV3RnJhbWUuZ2V0Vmlld1BvcnRQb3NpdGlvbkJvdW5kcygpLCAvLyBnbG9iYWxcclxuICAgICAgICAgICAgdmlld1BvcnRCb3VuZHM6IHZpZXdGcmFtZS5nZXRWaWV3UG9ydEJvdW5kcygpLCAvLyBnbG9iYWxcclxuICAgICAgICAgICAgbm9kZUJvdW5kczogdmlld0ZyYW1lLmdldE5vZGVCb3VuZHMoKSwgLy8gZ2xvYmFsXHJcbiAgICAgICAgICAgIHNpemU6IHsgd2lkdGg6IHZpZXdGcmFtZS5zaXplLndpZHRoLCBoZWlnaHQ6IHZpZXdGcmFtZS5zaXplLmhlaWdodCB9LCAvLyBsb2NhbFxyXG4gICAgICAgICAgICBjdXN0b21lU2l6ZWQ6IGN1c3RvbWVTaXplZCxcclxuICAgICAgICAgICAgc3BhY2VTaGFyZTogdmlld0ZyYW1lLm1vZGVsLnNwYWNlU2hhcmUsXHJcbiAgICAgICAgICAgIHVwZGF0ZUJvdW5kczogZmFsc2UsXHJcbiAgICAgICAgICAgIGlzT3ZlclZpZXc6IHZpZXdGcmFtZSA9PT0gX292ZXJWaWV3RnJhbWUsXHJcbiAgICAgICAgICAgIHNjYWxlOiB2aWV3RnJhbWUuZ2V0U2NhbGUoKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBkYXRhIG1vZGVsXHJcbiAgICAgKiBAcGFyYW0ge0RhdGFDb250YWluZXJ9IGRhdGFDb250YWluZXIgLSBkYXRhIGZvciB0aGUgZ3JhcGhcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfaW5pdCAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgICAgIF9kYXRhQ29udGFpbmVyID0gb3B0aW9ucy5kYXRhQ29udGFpbmVyO1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0ge307XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBPdmVyVmlldyBmcmFtZVxyXG4gICAgICAgIF9vdmVyVmlld0ZyYW1lID0gbmV3IE92ZXJWaWV3RnJhbWUoe1xyXG4gICAgICAgICAgICBpZDogJ292ZXJWaWV3RnJhbWUnLFxyXG4gICAgICAgICAgICBsYWJlbDogJ092ZXJ2aWV3JyxcclxuICAgICAgICAgICAgZGF0YUNvbnRhaW5lcjogX2RhdGFDb250YWluZXIsXHJcbiAgICAgICAgICAgIHJlc3VycmVjdEVsZW1lbnRzOiB0cnVlLFxyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyMyM2IwZjQnLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjRmNGZmJyxcclxuICAgICAgICAgICAgc3BhY2VTaGFyZTogMSxcclxuICAgICAgICB9LCBwYXJhbWV0ZXJzKTtcclxuICAgICAgICBtYXBbX292ZXJWaWV3RnJhbWUuaWRdID0gX292ZXJWaWV3RnJhbWU7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBsaXN0IG9mIFZpZXdGcmFtZXNcclxuICAgICAgICBfdmlld0ZyYW1lcyA9IG9wdGlvbnMudmlld0ZyYW1lcy5tYXAobW9kZWwgPT4ge1xyXG4gICAgICAgICAgICBzdGF0ZVttb2RlbC5pZF0gPSBtb2RlbC5leHBhbmRlZDtcclxuICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lT3B0aW9ucyA9IF8uY2xvbmVEZWVwKG1vZGVsKTtcclxuICAgICAgICAgICAgdmlld0ZyYW1lT3B0aW9ucy5kYXRhQ29udGFpbmVyID0gb3B0aW9ucy5kYXRhQ29udGFpbmVyO1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3RnJhbWUgPSBuZXcgVmlld0ZyYW1lKHZpZXdGcmFtZU9wdGlvbnMsIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICBtYXBbdmlld0ZyYW1lLmlkXSA9IHZpZXdGcmFtZTtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdGcmFtZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBfYWxsRnJhbWVzID0gX3ZpZXdGcmFtZXMuY29uY2F0KF9vdmVyVmlld0ZyYW1lKTtcclxuXHJcbiAgICAgICAgX3N0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgX3ZpZXdGcmFtZXNNYXAgPSBtYXA7XHJcbiAgICAgICAgX2Z1bGxTY3JlZW5Nb2RlID0gb3B0aW9ucy5mdWxsU2NyZWVuTW9kZTtcclxuXHJcbiAgICAgICAgX3N1YnNjcmliZU9uVmlld0ZyYW1lRXZlbnRzKF9hbGxGcmFtZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBzdGF0ZXMgb2Ygdmlld0ZyYW1lcyB1c2luZyByZW5kZXJPcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlck9wdGlvbnN9IHJlbmRlck9wdGlvbnNcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlVmlld0ZyYW1lcyAocmVuZGVyT3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcGVyT3B0aW9ucyA9IHJlbmRlck9wdGlvbnMucGFwZXJPcHRpb25zO1xyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzUGFwZXJPcHRpb25zID0gX3JlbmRlck9wdGlvbnMucGFwZXJPcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZU9wdGlvbnMgPSBhcnJheVRvTWFwKHJlbmRlck9wdGlvbnMudmlld0ZyYW1lcyB8fCBbXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGlzU2NhbGVDaGFuZ2VkID0gKCFwcmV2aW91c1BhcGVyT3B0aW9ucy5zY2FsZSkgfHwgcHJldmlvdXNQYXBlck9wdGlvbnMuc2NhbGUueCAhPT0gbmV3UGFwZXJPcHRpb25zLnNjYWxlLnggfHxcclxuICAgICAgICAgICAgcHJldmlvdXNQYXBlck9wdGlvbnMuc2NhbGUueSAhPT0gbmV3UGFwZXJPcHRpb25zLnNjYWxlLnk7XHJcbiAgICAgICAgY29uc3QgaXNQYXBlclNpemVDaGFuZ2VkID0gcHJldmlvdXNQYXBlck9wdGlvbnMud2lkdGggIT09IG5ld1BhcGVyT3B0aW9ucy53aWR0aCB8fFxyXG4gICAgICAgICAgICBwcmV2aW91c1BhcGVyT3B0aW9ucy5oZWlnaHQgIT09IG5ld1BhcGVyT3B0aW9ucy5oZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgaXNPcmllbnRhdGlvbkNoYW5nZWQgPSBwcmV2aW91c1BhcGVyT3B0aW9ucy5vcmllbnRhdGlvbiAhPT0gbmV3UGFwZXJPcHRpb25zLm9yaWVudGF0aW9uO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IG9sZEVsZW1lbnRTaXplID0gKF9yZW5kZXJPcHRpb25zLmVsZW1lbnRPcHRpb25zIHx8IHt9KS5lbGVtZW50U2l6ZTtcclxuICAgICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHJlbmRlck9wdGlvbnMuZWxlbWVudE9wdGlvbnMuZWxlbWVudFNpemU7XHJcbiAgICAgICAgY29uc3QgaXNFbGVtZW50U2l6ZUNoYW5nZWQgPSBlbGVtZW50U2l6ZSAmJiAoXHJcbiAgICAgICAgICAgICghb2xkRWxlbWVudFNpemUpIHx8XHJcbiAgICAgICAgICAgIGVsZW1lbnRTaXplLndpZHRoICE9PSBvbGRFbGVtZW50U2l6ZS53aWR0aCB8fFxyXG4gICAgICAgICAgICBlbGVtZW50U2l6ZS5oZWlnaHQgIT09IG9sZEVsZW1lbnRTaXplLmhlaWdodCB8fFxyXG4gICAgICAgICAgICBlbGVtZW50U2l6ZS5taW5XaWR0aCAhPT0gb2xkRWxlbWVudFNpemUubWluV2lkdGggfHxcclxuICAgICAgICAgICAgZWxlbWVudFNpemUubWluSGVpZ2h0ICE9PSBvbGRFbGVtZW50U2l6ZS5taW5IZWlnaHQgfHxcclxuICAgICAgICAgICAgZWxlbWVudFNpemUubWF4V2lkdGggIT09IG9sZEVsZW1lbnRTaXplLm1heFdpZHRoIHx8XHJcbiAgICAgICAgICAgIGVsZW1lbnRTaXplLm1heEhlaWdodCAhPT0gb2xkRWxlbWVudFNpemUubWF4SGVpZ2h0XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgZnVsbFNjcmVlbk1vZGVDaGFuZ2VkID0gcmVuZGVyT3B0aW9ucy5mdWxsU2NyZWVuTW9kZSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyT3B0aW9ucy5mdWxsU2NyZWVuTW9kZSAhPT0gX2Z1bGxTY3JlZW5Nb2RlO1xyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZXNTdGF0ZUNoYW5nZWQgPSBfdXBkYXRlVmlld0ZyYW1lVmlzaWJpbGl0eSh2aWV3RnJhbWVPcHRpb25zKSAmJiAoIV9mdWxsU2NyZWVuTW9kZSkgfHwgZnVsbFNjcmVlbk1vZGVDaGFuZ2VkO1xyXG5cclxuXHJcbiAgICAgICAgaWYgKGZ1bGxTY3JlZW5Nb2RlQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICBfZnVsbFNjcmVlbk1vZGUgPSByZW5kZXJPcHRpb25zLmZ1bGxTY3JlZW5Nb2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcGFwZXJPcHRpb25zQ2hhbmdlZCA9XHJcbiAgICAgICAgICAgIHJlbmRlck9wdGlvbnMudXBkYXRlQm91bmRzIHx8XHJcbiAgICAgICAgICAgIGlzUGFwZXJTaXplQ2hhbmdlZCB8fFxyXG4gICAgICAgICAgICBpc09yaWVudGF0aW9uQ2hhbmdlZCB8fFxyXG4gICAgICAgICAgICBpc1NjYWxlQ2hhbmdlZCB8fFxyXG4gICAgICAgICAgICB2aWV3RnJhbWVzU3RhdGVDaGFuZ2VkO1xyXG4gICAgICAgIGNvbnN0IHJlc2l6ZVZpZXdGcmFtZXMgPSBpc1BhcGVyU2l6ZUNoYW5nZWQgfHwgaXNPcmllbnRhdGlvbkNoYW5nZWQgfHwgdmlld0ZyYW1lc1N0YXRlQ2hhbmdlZDtcclxuXHJcbiAgICAgICAgaWYgKGlzRWxlbWVudFNpemVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIF9zZXRFbGVtZW50c1NpemUoZWxlbWVudFNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzaXplVmlld0ZyYW1lcykge1xyXG4gICAgICAgICAgICBfcmVzaXplVmlld0ZyYW1lcyhuZXdQYXBlck9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNTY2FsZUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgX3NjYWxlVmlld0ZyYW1lcyhuZXdQYXBlck9wdGlvbnMuc2NhbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFwZXJPcHRpb25zQ2hhbmdlZCB8fCBpc0VsZW1lbnRTaXplQ2hhbmdlZCB8fCBpc1NjYWxlQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICBfcmVmcmVzaFZpZXdGcmFtZXNCb3VuZHMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9hbGxGcmFtZXMuZm9yRWFjaCh2aWV3RnJhbWUgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVjYWxjdWxhdGVWaXNpYmxlRWxlbWVudHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Vmlld0ZyYW1lRGF0YSA9IHZpZXdGcmFtZU9wdGlvbnNbdmlld0ZyYW1lLmlkXTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChuZXdWaWV3RnJhbWVEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRWaWV3RnJhbWVEYXRhID0gX2dldFZpZXdGcmFtZVB1YmxpY01vZGVsKHZpZXdGcmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlQm91bmRzID0gbmV3Vmlld0ZyYW1lRGF0YS51cGRhdGVCb3VuZHM7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0UG9zaXRpb25DaGFuZ2VkID0gbmV3Vmlld0ZyYW1lRGF0YS52aWV3UG9ydFBvc2l0aW9uICYmIChcclxuICAgICAgICAgICAgICAgICAgICBuZXdWaWV3RnJhbWVEYXRhLnZpZXdQb3J0UG9zaXRpb24ueCAhPT0gb2xkVmlld0ZyYW1lRGF0YS52aWV3UG9ydFBvc2l0aW9uLnggfHxcclxuICAgICAgICAgICAgICAgICAgICBuZXdWaWV3RnJhbWVEYXRhLnZpZXdQb3J0UG9zaXRpb24ueSAhPT0gb2xkVmlld0ZyYW1lRGF0YS52aWV3UG9ydFBvc2l0aW9uLnlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplQ2hhbmdlZCA9IG5ld1ZpZXdGcmFtZURhdGEuc2l6ZSAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Vmlld0ZyYW1lRGF0YS5zaXplLndpZHRoICE9PSBvbGRWaWV3RnJhbWVEYXRhLnNpemUud2lkdGggfHxcclxuICAgICAgICAgICAgICAgICAgICBuZXdWaWV3RnJhbWVEYXRhLnNpemUuaGVpZ2h0ICE9PSBvbGRWaWV3RnJhbWVEYXRhLnNpemUuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gbmV3Vmlld0ZyYW1lRGF0YS5wb3NpdGlvbiAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Vmlld0ZyYW1lRGF0YS5wb3NpdGlvbi54ICE9PSBvbGRWaWV3RnJhbWVEYXRhLnBvc2l0aW9uLnggfHxcclxuICAgICAgICAgICAgICAgICAgICBuZXdWaWV3RnJhbWVEYXRhLnBvc2l0aW9uLnkgIT09IG9sZFZpZXdGcmFtZURhdGEucG9zaXRpb24ueVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZUNoYW5nZWQgJiYgIXJlc2l6ZVZpZXdGcmFtZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3RnJhbWUuc2V0U2l6ZShuZXdWaWV3RnJhbWVEYXRhLnNpemUsIG5ld1ZpZXdGcmFtZURhdGEuY3VzdG9tZVNpemVkKTtcclxuICAgICAgICAgICAgICAgICAgICByZWNhbGN1bGF0ZVZpc2libGVFbGVtZW50cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uQ2hhbmdlZCAmJiAhcmVzaXplVmlld0ZyYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdGcmFtZS5zZXRQb3NpdGlvbihuZXdWaWV3RnJhbWVEYXRhLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlQm91bmRzIHx8IHNpemVDaGFuZ2VkICYmICFyZXNpemVWaWV3RnJhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld0ZyYW1lLnVwZGF0ZUJvdW5kcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY2FsY3VsYXRlVmlzaWJsZUVsZW1lbnRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocG9ydFBvc2l0aW9uQ2hhbmdlZCAmJiAhcmVzaXplVmlld0ZyYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdGcmFtZS5wb3NpdGlvblZpZXdQb3J0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWaWV3RnJhbWVEYXRhLnZpZXdQb3J0UG9zaXRpb24ueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Vmlld0ZyYW1lRGF0YS52aWV3UG9ydFBvc2l0aW9uLnksXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICByZWNhbGN1bGF0ZVZpc2libGVFbGVtZW50cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaXNFeHBhbmRlZCA9IF9zdGF0ZVt2aWV3RnJhbWUuaWRdIHx8IHZpZXdGcmFtZSA9PT0gX292ZXJWaWV3RnJhbWUgJiYgX2Z1bGxTY3JlZW5Nb2RlO1xyXG4gICAgICAgICAgICBjb25zdCByZWNhbGN1bGF0ZUNvbnRlbnQgPSBpc0V4cGFuZGVkICYmIChcclxuICAgICAgICAgICAgICAgIHJlY2FsY3VsYXRlVmlzaWJsZUVsZW1lbnRzIHx8IHBhcGVyT3B0aW9uc0NoYW5nZWQgfHwgaXNFbGVtZW50U2l6ZUNoYW5nZWRcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKHJlY2FsY3VsYXRlQ29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lLmNhbGN1bGF0ZVZpc2libGVDZWxscygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9yZW5kZXJPcHRpb25zID0gcmVuZGVyT3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgc3RhdGUgb2Ygdmlld0ZyYW1lcyAodmlzaWJsZS9pbnZpc2libGUpXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZVB1YmxpY01vZGVsW119IHZpZXdGcmFtZU9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3VwZGF0ZVZpZXdGcmFtZVZpc2liaWxpdHkgKHZpZXdGcmFtZU9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgYXRMZWFzdE9uZVZpc2liaWxpdHlDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgX3ZpZXdGcmFtZXMuZm9yRWFjaCh2aWV3RnJhbWUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdWaWV3RnJhbWVEYXRhID0gdmlld0ZyYW1lT3B0aW9uc1t2aWV3RnJhbWUuaWRdO1xyXG4gICAgICAgICAgICBpZiAobmV3Vmlld0ZyYW1lRGF0YSAmJiBuZXdWaWV3RnJhbWVEYXRhLmV4cGFuZGVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpc2liaWxpdGlDaGFuZ2VkID0gbmV3Vmlld0ZyYW1lRGF0YS5leHBhbmRlZCAhPT0gX3N0YXRlW3ZpZXdGcmFtZS5pZF07XHJcbiAgICAgICAgICAgICAgICBfc3RhdGVbdmlld0ZyYW1lLmlkXSA9IG5ld1ZpZXdGcmFtZURhdGEuZXhwYW5kZWQ7XHJcbiAgICAgICAgICAgICAgICBhdExlYXN0T25lVmlzaWJpbGl0eUNoYW5nZWQgPSBhdExlYXN0T25lVmlzaWJpbGl0eUNoYW5nZWQgfHwgdmlzaWJpbGl0aUNoYW5nZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXRMZWFzdE9uZVZpc2liaWxpdHlDaGFuZ2VkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyBkZWZhdWx0IGVsZW1lbnQgc2l6ZSBmb3IgYWxsIFZpZXdGcmFtZXNcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudFNpemV9IGVsZW1lbnRTaXplIFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfc2V0RWxlbWVudHNTaXplIChlbGVtZW50U2l6ZSkge1xyXG4gICAgICAgIF9hbGxGcmFtZXMuZm9yRWFjaCh2ZiA9PiB7XHJcbiAgICAgICAgICAgIHZmLnNldEVsZW1lbnRTaXplKGVsZW1lbnRTaXplKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY2FsY3VsYXRlcyBib3VuZHMgZm9yIGFsbCBWaWV3RnJhbWVzXHJcbiAgICAgKiBhbmQgYWxsaWduIFZpZXdGcmFtZXNcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfcmVmcmVzaFZpZXdGcmFtZXNCb3VuZHMgKCkge1xyXG4gICAgICAgIF9hbGxGcmFtZXMuZm9yRWFjaCh2ZiA9PiB7XHJcbiAgICAgICAgICAgIHZmLnVwZGF0ZUJvdW5kcygpO1xyXG4gICAgICAgICAgICB2Zi5wb3NpdGlvblZpZXdQb3J0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGFuZCBsaW1pdHMgdmFsdWUgb2YgdGhlIHNjYWxlIGZvciB0aGUgZ3JhcGguXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3NjYWxlVmlld0ZyYW1lcyAoc2NhbGUpIHtcclxuICAgICAgICBpZiAoc2NhbGUpIHtcclxuICAgICAgICAgICAgX2FsbEZyYW1lcy5mb3JFYWNoKHZmID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFNjYWxlID0gdmYuZ2V0U2NhbGUoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IHZmLnBvc2l0aW9uVmlld1BvcnQoKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmYuc2V0U2NhbGUoc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U2NhbGUgPSB2Zi5nZXRTY2FsZSgpOyAvLyBvdmVyVmlld0ZyYW1lIGNoYW5nZXMgc2NhbGUgYmVmb3JlIGFwcGx5XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVkU2l6ZSA9IHZmLmdldCgnc2l6ZScpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkU2l6ZSA9IHNjYWxlZFRvR2xvYmFsU2l6ZShzY2FsZWRTaXplLCBvbGRTY2FsZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTaXplID0gc2NhbGVkVG9HbG9iYWxTaXplKHNjYWxlZFNpemUsIG5ld1NjYWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJDZW50ZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogcG9zLnggKyBvbGRTaXplLndpZHRoIC8gMixcclxuICAgICAgICAgICAgICAgICAgICB5OiBwb3MueSArIG9sZFNpemUuaGVpZ2h0IC8gMixcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmYucG9zaXRpb25WaWV3UG9ydChcclxuICAgICAgICAgICAgICAgICAgICBjdXJDZW50ZXIueCAtIG5ld1NpemUud2lkdGggLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1ckNlbnRlci55IC0gbmV3U2l6ZS5oZWlnaHQgLyAyLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaCBWaWV3RnJhbWVzOlxyXG4gICAgICogQWRqdXN0IHZpZXdGcmFtZXMgc2l6ZSB0byBhIHBhcGVyXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZVNjYWxlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9yZXNpemVWaWV3RnJhbWVzIChvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZUZyYW1lcyA9IF9nZXRWaXNpYmxlVmlld0ZyYW1lcygpO1xyXG4gICAgICAgIGNvbnN0IHZmTnVtYmVyID0gdmlzaWJsZUZyYW1lcy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsT3JpZW50YXRlZCA9XHJcbiAgICAgICAgICAgIG9wdGlvbnMub3JpZW50YXRpb24gPT09ICdsZWZ0LXRvLXJpZ2h0JyB8fCBvcHRpb25zLm9yaWVudGF0aW9uID09PSAncmlnaHQtdG8tbGVmdCc7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLndpZHRoID09PSAwIHx8IG9wdGlvbnMuaGVpZ2h0ID09PSAwIHx8IHZmTnVtYmVyIDw9IDApIHJldHVybjtcclxuICAgICAgICBsZXQgdG90YWxTaGFyZSA9IDA7XHJcbiAgICAgICAgdmlzaWJsZUZyYW1lcy5mb3JFYWNoICh2ZiA9PiB7XHJcbiAgICAgICAgICAgIHRvdGFsU2hhcmUgKz0gdmYubW9kZWwuc3BhY2VTaGFyZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBvcHRpb25zLndpZHRoIC0gRlJBTUVfT1VUX01BUkdJTiAqIDI7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgLSBGUkFNRV9PVVRfTUFSR0lOICogMjtcclxuXHJcbiAgICAgICAgY29uc3QgY3V0ZWRXaWR0aCA9IHdpZHRoICAtIERJU1RBTkNFX0JFVFdFRU5fRlJBTUVTICogKHZmTnVtYmVyIC0gMSk7XHJcbiAgICAgICAgY29uc3QgY3V0ZWRIZWlnaHQgPSBoZWlnaHQgIC0gRElTVEFOQ0VfQkVUV0VFTl9GUkFNRVMgKiAodmZOdW1iZXIgLSAxKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2VnbWVudFdpZHRoICA9IGN1dGVkV2lkdGggIC8gdG90YWxTaGFyZTtcclxuICAgICAgICBjb25zdCBzZWdtZW50SGVpZ2h0ID0gY3V0ZWRIZWlnaHQgLyB0b3RhbFNoYXJlO1xyXG5cclxuICAgICAgICBsZXQgc2NhbGUgPSAxO1xyXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xyXG4gICAgICAgIGxldCBmcmVlTGVuZ3RoID0gMDtcclxuICAgICAgICB2aXNpYmxlRnJhbWVzLmZvckVhY2ggKHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc0hvcml6b250YWxPcmllbnRhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmlld0ZyYW1lLm1vZGVsLndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoICs9IHZpZXdGcmFtZS5tb2RlbC53aWR0aDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJlZUxlbmd0aCArPSBzZWdtZW50V2lkdGggKiAodmlld0ZyYW1lLm1vZGVsLnNwYWNlU2hhcmUgfHwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmlld0ZyYW1lLm1vZGVsLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSB2aWV3RnJhbWUubW9kZWwuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmcmVlTGVuZ3RoICs9IHNlZ21lbnRIZWlnaHQgKiAodmlld0ZyYW1lLm1vZGVsLnNwYWNlU2hhcmUgfHwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoaXNIb3Jpem9udGFsT3JpZW50YXRlZCkge1xyXG4gICAgICAgICAgICBzY2FsZSA9IChjdXRlZFdpZHRoIC0gZnJlZUxlbmd0aCkgLyBsZW5ndGg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2NhbGUgPSAoY3V0ZWRIZWlnaHQgLSBmcmVlTGVuZ3RoKSAvIGxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjdXJQb2ludCA9IHsgeDogRlJBTUVfT1VUX01BUkdJTiwgeTogRlJBTUVfT1VUX01BUkdJTiB9O1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ3RvcC10by1ib3R0b20nKSB7XHJcblxyXG4gICAgICAgICAgICB2aXNpYmxlRnJhbWVzLmZvckVhY2ggKHZmID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh2Zi5tb2RlbC53aWR0aCkgdmYubW9kZWwud2lkdGggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodmYubW9kZWwuaGVpZ2h0KSB2Zi5tb2RlbC5oZWlnaHQgKj0gc2NhbGU7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgTUlOSU1BTF9WRl9TSVpFID0geyB3aWR0aDogMSwgaGVpZ2h0OiAxIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1heCh3aWR0aCwgTUlOSU1BTF9WRl9TSVpFLndpZHRoKSxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2Zi5tb2RlbC5oZWlnaHQgPyB2Zi5tb2RlbC5oZWlnaHQgOiBzZWdtZW50SGVpZ2h0ICogKHZmLm1vZGVsLnNwYWNlU2hhcmUgfHwgMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1JTklNQUxfVkZfU0laRS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdmYuc2V0UG9zaXRpb24oY3VyUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgdmYuc2V0U2l6ZShzaXplKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjdXJQb2ludCA9IHsgeDogRlJBTUVfT1VUX01BUkdJTiwgeTogY3VyUG9pbnQueSArIHNpemUuaGVpZ2h0ICsgRElTVEFOQ0VfQkVUV0VFTl9GUkFNRVMgfTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdmlzaWJsZUZyYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmYgPSB2aXNpYmxlRnJhbWVzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2Zi5tb2RlbC53aWR0aCkgdmYubW9kZWwud2lkdGggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodmYubW9kZWwuaGVpZ2h0KSB2Zi5tb2RlbC5oZWlnaHQgKj0gc2NhbGU7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB2Zi5tb2RlbC5oZWlnaHQgPyB2Zi5tb2RlbC5oZWlnaHQgOiBzZWdtZW50SGVpZ2h0ICogKHZmLm1vZGVsLnNwYWNlU2hhcmUgfHwgMSlcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdmYuc2V0UG9zaXRpb24oY3VyUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgdmYuc2V0U2l6ZShzaXplKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjdXJQb2ludCA9IHsgeDogRlJBTUVfT1VUX01BUkdJTiwgeTogY3VyUG9pbnQueSArIHNpemUuaGVpZ2h0ICsgRElTVEFOQ0VfQkVUV0VFTl9GUkFNRVMgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMub3JpZW50YXRpb24gPT09ICdyaWdodC10by1sZWZ0Jykge1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHZpc2libGVGcmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZmID0gdmlzaWJsZUZyYW1lc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodmYubW9kZWwud2lkdGgpIHZmLm1vZGVsLndpZHRoICo9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZmLm1vZGVsLmhlaWdodCkgdmYubW9kZWwuaGVpZ2h0ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHZmLm1vZGVsLndpZHRoID8gdmYubW9kZWwud2lkdGggOiBzZWdtZW50V2lkdGggKiAodmYubW9kZWwuc3BhY2VTaGFyZSB8fCAxKSxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICB2Zi5zZXRQb3NpdGlvbihjdXJQb2ludCk7XHJcbiAgICAgICAgICAgICAgICB2Zi5zZXRTaXplKHNpemUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1clBvaW50ID0geyB4OiBjdXJQb2ludC54ICsgc2l6ZS53aWR0aCArIERJU1RBTkNFX0JFVFdFRU5fRlJBTUVTLCB5OiBGUkFNRV9PVVRfTUFSR0lOIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHsgLy8gaG9yaXpvbnRhbFxyXG5cclxuICAgICAgICAgICAgdmlzaWJsZUZyYW1lcy5mb3JFYWNoICh2ZiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmYubW9kZWwud2lkdGgpIHZmLm1vZGVsLndpZHRoICo9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZmLm1vZGVsLmhlaWdodCkgdmYubW9kZWwuaGVpZ2h0ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHZmLm1vZGVsLndpZHRoID8gdmYubW9kZWwud2lkdGggOiBzZWdtZW50V2lkdGggKiAodmYubW9kZWwuc3BhY2VTaGFyZSB8fCAxKSxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICB2Zi5zZXRQb3NpdGlvbihjdXJQb2ludCk7XHJcbiAgICAgICAgICAgICAgICB2Zi5zZXRTaXplKHNpemUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1clBvaW50ID0geyB4OiBjdXJQb2ludC54ICsgc2l6ZS53aWR0aCArIERJU1RBTkNFX0JFVFdFRU5fRlJBTUVTLCB5OiBGUkFNRV9PVVRfTUFSR0lOIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmlzaWJsZUZyYW1lcy5mb3JFYWNoKHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgICAgIHZpZXdGcmFtZS51cGRhdGVCb3VuZHMoKTtcclxuICAgICAgICAgICAgLy8gV2Ugd2FudCBub3QgdG8gYmUgaW4gdGhlIGVtcHR5IHNwYWNlIGFmdGVyIHJlc2l6aW5nIGJ1dCBzb213aGVyZSBuZWFyIHRoZSBub2Rlcy5cclxuICAgICAgICAgICAgY29uc3Qgdmlld1BvcnRQb3NpdGlvbkJvdW5kcyA9IHZpZXdGcmFtZS5nZXRWaWV3UG9ydFBvc2l0aW9uQm91bmRzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGVDZWxscyA9IHZpZXdGcmFtZS5nZXRWaXNpYmxlQ2VsbHMoKTtcclxuICAgICAgICAgICAgaWYgKCF2aXNpYmxlQ2VsbHMgfHwgdmlzaWJsZUNlbGxzLm5vZGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5vZGVzID0gIHZpZXdGcmFtZS5nZXROb2RlcygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlVG9Gb2N1cyA9IG5vZGVzW01hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIChub2Rlcy5sZW5ndGggLSAxKSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVTY2FsZWRQb3MgPSBnZXRTY2FsZWROb2RlUG9zaXRpb24obm9kZVRvRm9jdXMsIG9wdGlvbnMuc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBub2RlU2NhbGVkUG9zLnggLSAodmlld0ZyYW1lLnNpemUud2lkdGggLSBub2RlVG9Gb2N1cy5zaXplLndpZHRoKSAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IG5vZGVTY2FsZWRQb3MueSAtICh2aWV3RnJhbWUuc2l6ZS5oZWlnaHQgLSBub2RlVG9Gb2N1cy5zaXplLmhlaWdodCkgLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGltaXRlZFBvaW50ID0gbGltaXRQb2ludFBvc2l0aW9uKG5ld1Bvc2l0aW9uLCB2aWV3UG9ydFBvc2l0aW9uQm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3RnJhbWUucG9zaXRpb25WaWV3UG9ydChsaW1pdGVkUG9pbnQueCwgbGltaXRlZFBvaW50LnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbWl0ZWRQb2ludCA9IGxpbWl0UG9pbnRQb3NpdGlvbih2aWV3RnJhbWUucG9zaXRpb25WaWV3UG9ydCgpLCB2aWV3UG9ydFBvc2l0aW9uQm91bmRzKTtcclxuICAgICAgICAgICAgdmlld0ZyYW1lLnBvc2l0aW9uVmlld1BvcnQobGltaXRlZFBvaW50LngsIGxpbWl0ZWRQb2ludC55KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBkYXRhIChDZWxscykgZnJvbSBWaWV3RnJhbWVzLFxyXG4gICAgICogcHJvY2Vzc2VzIGl0IChhZGQgdGVybWluYXRpb24gYW5kIGFzcGVjdCBlbGVtZW50cylcclxuICAgICAqIGFuZCByZXR1cm5zIHRvIHRoZSByZW5kZXIgcGlwbGluZVxyXG4gICAgICogQHJldHVybnMgeyhMaW5rfE5vZGV8VGVybWluYXRpb25Ob2RlfFRlcm1pbmF0aW9uTGlua3xBc3BlY3RMaW5rKVtdfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfY2FsY3VsYXRlUmVuZGVyRGF0YSAodmlld0ZyYW1lUmVzdWx0cywgcmVuZGVyT3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gW107XHJcbiAgICAgICAgY29uc3QgbGlua3MgPSBbXTtcclxuICAgICAgICBjb25zdCBiYWRMaW5rcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHZpc2libGVOb2RlTWFwID0ge307ICAgICAgIFxyXG5cclxuICAgICAgICB2aWV3RnJhbWVSZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHJlc3VsdC5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICB2aXNpYmxlTm9kZU1hcFtub2RlLmlkXSA9IG5vZGU7XHJcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZpZXdGcmFtZVJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4gcmVzdWx0LmxpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2aXNpYmxlTm9kZU1hcFtsaW5rLm1vZGVsLnNvdXJjZV0gJiYgdmlzaWJsZU5vZGVNYXBbbGluay5tb2RlbC50YXJnZXRdKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlbmRlck9wdGlvbnMucXVpY2tVcGRhdGUpIGxpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmlzaWJsZU5vZGVNYXBbbGluay5tb2RlbC5zb3VyY2VdIHx8IHZpc2libGVOb2RlTWFwW2xpbmsubW9kZWwudGFyZ2V0XSkge1xyXG4gICAgICAgICAgICAgICAgYmFkTGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgY29uc3QgdGVybWluYXRpb25DZWxsTWFwID0ge307XHJcbiAgICAgICAgY29uc3QgdGVybWluYXRpb25Ob2RlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHRlcm1pbmF0aW9uTGlua3MgPSBbXTtcclxuICAgICAgICBpZiAocmVuZGVyT3B0aW9ucy5zZWxlY3RlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IF9nZXRTZWxlY3RlZE5vZGVzKHJlbmRlck9wdGlvbnMuc2VsZWN0ZWRFbGVtZW50KTtcclxuICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKHNlbGVjdGVkTm9kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hdGlvbk9yaWdpbnMgPSBfZ2V0VGVybWluYXRpb25PcmlnaW5zKHNlbGVjdGVkTm9kZSwgdmlzaWJsZU5vZGVNYXAsIGJhZExpbmtzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZSA9IF9nZXRWaWV3RnJhbWVGb3JOb2RlKHNlbGVjdGVkTm9kZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHZpZXdGcmFtZSAmJiAoX3N0YXRlW3ZpZXdGcmFtZS5pZF0gfHwgX2Z1bGxTY3JlZW5Nb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uT3JpZ2lucy5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlQ2FjaGVJZCA9IG5vZGUuaWQgKyAnX2F0XycgKyB2aWV3RnJhbWUuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtaW5hdGlvbk5vZGUgPSBfdGVybWluYXRpb25DZWxsQ2FjaGVbbm9kZUNhY2hlSWRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVybWluYXRpb25Ob2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvbk5vZGUuc2V0KCdkcmFnZ2VkJywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25Ob2RlID0gbmV3IFRlcm1pbmF0aW9uTm9kZSAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBwYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvbkNlbGxNYXBbbm9kZUNhY2hlSWRdID0gdGVybWluYXRpb25Ob2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IF9nZXRUZXJtaW5hdGlvbk5vZGVQb3NpdGlvbih0ZXJtaW5hdGlvbk5vZGUsIHZpZXdGcmFtZSwgcmVuZGVyT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uTm9kZS5wb3NpdGlvbihwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25Ob2Rlcy5wdXNoKHRlcm1pbmF0aW9uTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZW5kZXJPcHRpb25zLnF1aWNrVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uT3JpZ2lucy5saW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlua0NhY2hlSWQgPSBsaW5rLmlkICsgJ19hdF8nICsgdmlld0ZyYW1lLmlkOyAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VDYWNoZUlkID0gbGluay5tb2RlbC5zb3VyY2UgKyAnX2F0XycgKyB2aWV3RnJhbWUuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRDYWNoZUlkID0gbGluay5tb2RlbC50YXJnZXQgKyAnX2F0XycgKyB2aWV3RnJhbWUuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGVybWluYXRpb25MaW5rID0gX3Rlcm1pbmF0aW9uQ2VsbENhY2hlW2xpbmtDYWNoZUlkXSB8fCBuZXcgVGVybWluYXRpb25MaW5rICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluazogbGluayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHRlcm1pbmF0aW9uQ2VsbE1hcFtzb3VyY2VDYWNoZUlkXSB8fCB2aXNpYmxlTm9kZU1hcFtsaW5rLm1vZGVsLnNvdXJjZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0ZXJtaW5hdGlvbkNlbGxNYXBbdGFyZ2V0Q2FjaGVJZF0gfHwgdmlzaWJsZU5vZGVNYXBbbGluay5tb2RlbC50YXJnZXRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvbkNlbGxNYXBbbGlua0NhY2hlSWRdID0gdGVybWluYXRpb25MaW5rO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25MaW5rcy5wdXNoKHRlcm1pbmF0aW9uTGluayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBsaW5rID0gcmVuZGVyT3B0aW9ucy5zZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZFRlcm1pbmF0aW9uTGlua3MgPSBsaW5rIGluc3RhbmNlb2YgTGluayAmJiAoXHJcbiAgICAgICAgICAgICAgICAhKHZpc2libGVOb2RlTWFwW2xpbmsubW9kZWwuc291cmNlXSB8fCB2aXNpYmxlTm9kZU1hcFtsaW5rLm1vZGVsLnRhcmdldF0pIHx8XHJcbiAgICAgICAgICAgICAgICByZW5kZXJPcHRpb25zLnF1aWNrVXBkYXRlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmIChhZGRUZXJtaW5hdGlvbkxpbmtzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlTWFwID0gX2RhdGFDb250YWluZXIubWFwcy5ub2RlTWFwO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VWaWV3RnJhbWUgPSBfZ2V0Vmlld0ZyYW1lRm9yTm9kZShub2RlTWFwW2xpbmsubW9kZWwuc291cmNlXSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRWaWV3RnJhbWUgPSBfZ2V0Vmlld0ZyYW1lRm9yTm9kZShub2RlTWFwW2xpbmsubW9kZWwudGFyZ2V0XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVZpZXdGcmFtZSAmJiB0YXJnZXRWaWV3RnJhbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VWaWV3RnJhbWVJZCA9IHNvdXJjZVZpZXdGcmFtZS5pZDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRWaWV3RnJhbWVJZCA9IHRhcmdldFZpZXdGcmFtZS5pZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlQ2FjaGVJZCA9IGxpbmsubW9kZWwuc291cmNlICsgJ19hdF8nICsgc291cmNlVmlld0ZyYW1lSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q2FjaGVJZCA9IGxpbmsubW9kZWwudGFyZ2V0ICsgJ19hdF8nICsgdGFyZ2V0Vmlld0ZyYW1lSWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHRlcm1pbmF0aW9uQ2VsbE1hcFtzb3VyY2VDYWNoZUlkXSB8fCB2aXNpYmxlTm9kZU1hcFtsaW5rLm1vZGVsLnNvdXJjZV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGVybWluYXRpb25DZWxsTWFwW3RhcmdldENhY2hlSWRdIHx8IHZpc2libGVOb2RlTWFwW2xpbmsubW9kZWwudGFyZ2V0XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlua0NhY2hlSWQgPSBzb3VyY2UuaWQgKyAnfiN+JyArIHRhcmdldC5pZDsgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtaW5hdGlvbkxpbmsgPSBfdGVybWluYXRpb25DZWxsQ2FjaGVbbGlua0NhY2hlSWRdIHx8IG5ldyBUZXJtaW5hdGlvbkxpbmsgKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluazogbGluayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uQ2VsbE1hcFtsaW5rQ2FjaGVJZF0gPSB0ZXJtaW5hdGlvbkxpbms7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25MaW5rcy5wdXNoKHRlcm1pbmF0aW9uTGluayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX3Rlcm1pbmF0aW9uQ2VsbENhY2hlID0gdGVybWluYXRpb25DZWxsTWFwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHZpc2libGVOb2RlcyA9IG5vZGVzLmNvbmNhdCh0ZXJtaW5hdGlvbk5vZGVzKTtcclxuICAgICAgICBjb25zdCBhc3BlY3RMaW5rcyA9IHJlbmRlck9wdGlvbnMucXVpY2tVcGRhdGUgPyBbXSA6IF9jYWxjdWxhdGVBc3BlY3RMaW5rcyh2aXNpYmxlTm9kZXMpO1xyXG4gICAgICAgIGNvbnN0IHZpc2libGVMaW5rcyA9IGxpbmtzLmNvbmNhdCh0ZXJtaW5hdGlvbkxpbmtzKS5jb25jYXQoYXNwZWN0TGlua3MpO1xyXG5cclxuICAgICAgICByZXR1cm4gdmlzaWJsZU5vZGVzLmNvbmNhdCh2aXNpYmxlTGlua3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIExpbmsgaXMgc2VsZWN0ZWQgdGhlbiB3ZSByZXByZXNlbnRcclxuICAgICAqIGl0IGFzIHR3byBzZWxlY3RlZCBub2Rlc1xyXG4gICAgICogQHBhcmFtIHtOb2RlfExpbmt9IHNlbGVjdGVkRWxlbWVudFxyXG4gICAgICogQHJldHVybnMge05vZGVbXX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldFNlbGVjdGVkTm9kZXMgKHNlbGVjdGVkRWxlbWVudCkge1xyXG4gICAgICAgIGNvbnN0IG5vZGVNYXAgPSBfZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXA7XHJcbiAgICAgICAgY29uc3QgaXNOb2RlID0gc2VsZWN0ZWRFbGVtZW50IGluc3RhbmNlb2YgTm9kZTtcclxuICAgICAgICByZXR1cm4gaXNOb2RlID8gW3NlbGVjdGVkRWxlbWVudF0gOiBbXHJcbiAgICAgICAgICAgIG5vZGVNYXBbc2VsZWN0ZWRFbGVtZW50Lm1vZGVsLnNvdXJjZV0sXHJcbiAgICAgICAgICAgIG5vZGVNYXBbc2VsZWN0ZWRFbGVtZW50Lm1vZGVsLnRhcmdldF0sXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBMaW5rIGlzIHNlbGVjdGVkIHRoZW4gd2UgcmVwcmVzZW50XHJcbiAgICAgKiBpdCBhcyB0d28gc2VsZWN0ZWQgbm9kZXNcclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gc2VsZWN0ZWROb2RlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBOb2RlPn0gdmlzaWJsZU5vZGVNYXAgLSBWaXNpYmxlIG5vZGVzXHJcbiAgICAgKiBAcGFyYW0ge0xpbmtbXX0gYmFkTGlua3MgLSBMaW5rcyB3aGljaCBoYXZlIGVpdGhlciBzb3VyY2UgZWl0aGVyIHRhcmdldCBpcyBub3QgdmlzaWJsZVxyXG4gICAgICogQHJldHVybnMge05vZGVbXSwgTGlua1tdfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0VGVybWluYXRpb25PcmlnaW5zIChzZWxlY3RlZE5vZGUsIHZpc2libGVOb2RlTWFwLCBiYWRMaW5rcykge1xyXG4gICAgICAgIGNvbnN0IHRlcm1pbmF0aW9uT3JpZ2luTm9kZXMgPSBbXTtcclxuICAgICAgICBjb25zdCB0ZXJtaW5hdGlvbk9yaWdpbkxpbmtzID0gW107XHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkQ2VsbElkcyA9IHt9O1xyXG4gICAgICAgIGNvbnN0IG5vZGVNYXAgPSBfZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXA7XHJcblxyXG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWROb2RlVmlzaWJsZSA9IHZpc2libGVOb2RlTWFwW3NlbGVjdGVkTm9kZS5pZF07XHJcbiAgICAgICAgaWYgKGlzU2VsZWN0ZWROb2RlVmlzaWJsZSkge1xyXG4gICAgICAgICAgICBiYWRMaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwcm9jZXNzZWRDZWxsSWRzW2xpbmsuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkQ2VsbElkc1tsaW5rLmlkXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNMaW5rQ29ubmVjdGVkVG9TZWxlY3RlZE5vZGUgPSBsaW5rLm1vZGVsLnNvdXJjZSA9PT0gc2VsZWN0ZWROb2RlLmlkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rLm1vZGVsLnRhcmdldCA9PT0gc2VsZWN0ZWROb2RlLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmF0aW9uc0hhdmVWaWV3RnJhbWVzID0gbGluay5tb2RlbC5zb3VyY2UgPT09IHNlbGVjdGVkTm9kZS5pZCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZ2V0Vmlld0ZyYW1lRm9yTm9kZShub2RlTWFwW2xpbmsubW9kZWwudGFyZ2V0XSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2dldFZpZXdGcmFtZUZvck5vZGUobm9kZU1hcFtsaW5rLm1vZGVsLnNvdXJjZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0xpbmtDb25uZWN0ZWRUb1NlbGVjdGVkTm9kZSAmJiB0ZXJtaW5hdGlvbnNIYXZlVmlld0ZyYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvbk9yaWdpbkxpbmtzLnB1c2gobGluayk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VJc250VmlzaWJsZSA9ICF2aXNpYmxlTm9kZU1hcFtsaW5rLm1vZGVsLnNvdXJjZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VJc250VmlzaWJsZSAmJiAhcHJvY2Vzc2VkQ2VsbElkc1tsaW5rLm1vZGVsLnNvdXJjZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZENlbGxJZHNbbGluay5tb2RlbC5zb3VyY2VdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uT3JpZ2luTm9kZXMucHVzaChub2RlTWFwW2xpbmsubW9kZWwuc291cmNlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldElzbnRWaXNpYmxlID0gIXZpc2libGVOb2RlTWFwW2xpbmsubW9kZWwudGFyZ2V0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldElzbnRWaXNpYmxlICYmICFwcm9jZXNzZWRDZWxsSWRzW2xpbmsubW9kZWwudGFyZ2V0XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkQ2VsbElkc1tsaW5rLm1vZGVsLnRhcmdldF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25PcmlnaW5Ob2Rlcy5wdXNoKG5vZGVNYXBbbGluay5tb2RlbC50YXJnZXRdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGVybWluYXRpb25PcmlnaW5Ob2Rlcy5wdXNoKHNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgIGJhZExpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByb2Nlc3NlZENlbGxJZHNbbGluay5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRDZWxsSWRzW2xpbmsuaWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0xpbmtDb25uZWN0ZWRUb1NlbGVjdGVkTm9kZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsubW9kZWwuc291cmNlID09PSBzZWxlY3RlZE5vZGUuaWQgfHwgbGluay5tb2RlbC50YXJnZXQgPT09IHNlbGVjdGVkTm9kZS5pZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMaW5rQ29ubmVjdGVkVG9TZWxlY3RlZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25PcmlnaW5MaW5rcy5wdXNoKGxpbmspO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBub2RlczogdGVybWluYXRpb25PcmlnaW5Ob2RlcyxcclxuICAgICAgICAgICAgbGlua3M6IHRlcm1pbmF0aW9uT3JpZ2luTGlua3MsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgcG9zaXRpb24gZm9yIHRoZSB0ZXJtaW5hdGlvbiBub2RlLlxyXG4gICAgICogQHBhcmFtIHtUZXJtaW5hdGlvbk5vZGV9IHRlcm1pbmF0aW9uTm9kZVxyXG4gICAgICogQHBhcmFtIHtWaWV3RnJhbWV9IHZpZXdGcmFtZVxyXG4gICAgICogQHBhcmFtIHtSZW5kZXJPcHRpb259IHJlbmRlck9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHtQb2ludH1cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0VGVybWluYXRpb25Ob2RlUG9zaXRpb24gKHRlcm1pbmF0aW9uTm9kZSwgdmlld0ZyYW1lLCByZW5kZXJPcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxOb2RlID0gdGVybWluYXRpb25Ob2RlLm9yaWdpbmFsTm9kZTtcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWVTaXplID0gdmlld0ZyYW1lLnNpemU7IC8vIGxvY2FsIHNpemVcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWVQb3NpdGlvbiA9IHZpZXdGcmFtZS5wb3NpdGlvbigpOyAvLyBsb2NhbCBwb3NpdGlvblxyXG4gICAgICAgIGNvbnN0IG5vZGVTaXplID0gb3JpZ2luYWxOb2RlLnNpemU7IC8vIGxvY2FsIHNpemVcclxuXHJcbiAgICAgICAgY29uc3QgdG9wTGVmdCA9IHZpZXdGcmFtZVBvc2l0aW9uO1xyXG4gICAgICAgIGNvbnN0IHRvcFJpZ2h0ID0geyB4OiB2aWV3RnJhbWVQb3NpdGlvbi54ICsgdmlld0ZyYW1lU2l6ZS53aWR0aCwgeTogdmlld0ZyYW1lUG9zaXRpb24ueSB9O1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbUxlZnQgPSB7IHg6IHZpZXdGcmFtZVBvc2l0aW9uLngsIHk6IHZpZXdGcmFtZVBvc2l0aW9uLnkgKyB2aWV3RnJhbWVTaXplLmhlaWdodCB9O1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0geyB4OiB2aWV3RnJhbWVQb3NpdGlvbi54ICsgdmlld0ZyYW1lU2l6ZS53aWR0aCwgeTogdmlld0ZyYW1lUG9zaXRpb24ueSArIHZpZXdGcmFtZVNpemUuaGVpZ2h0IH07XHJcblxyXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0aW9uUG9pbnRzID0gZ2V0Q2FsY3VsYXRpb25Qb2ludHMoKTtcclxuICAgICAgICBjb25zdCBzb3VyY2VQb2ludCA9IGNhbGN1bGF0aW9uUG9pbnRzLnNvdXJjZVBvaW50O1xyXG4gICAgICAgIGNvbnN0IHRlcm1pbmF0aW9uUG9pbnQgPSBjYWxjdWxhdGlvblBvaW50cy50ZXJtaW5hdGlvblBvaW50O1xyXG5cclxuICAgICAgICAvLyBjaG9vc2UgYSBzaWRlIGZvciB0ZXJtaW5hdGlvbiBub2RlXHJcblxyXG4gICAgICAgIGxldCBjcm9zc1BvaW50ID0gZ2V0Q3Jvc1BvaW50KHNvdXJjZVBvaW50LCB0ZXJtaW5hdGlvblBvaW50LCB0b3BMZWZ0LCBib3R0b21MZWZ0KTsgLy8gbGVmdFxyXG4gICAgXHJcbiAgICAgICAgaWYgKCFjcm9zc1BvaW50KSB7XHJcbiAgICAgICAgICAgIGNyb3NzUG9pbnQgPSBnZXRDcm9zUG9pbnQoc291cmNlUG9pbnQsIHRlcm1pbmF0aW9uUG9pbnQsIHRvcExlZnQsIHRvcFJpZ2h0KTsgLy8gdG9wXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY3Jvc3NQb2ludCkge1xyXG4gICAgICAgICAgICBjcm9zc1BvaW50ID0gZ2V0Q3Jvc1BvaW50KHNvdXJjZVBvaW50LCB0ZXJtaW5hdGlvblBvaW50LCB0b3BSaWdodCwgYm90dG9tUmlnaHQpOyAvLyByaWdodFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWNyb3NzUG9pbnQpIHtcclxuICAgICAgICAgICAgY3Jvc3NQb2ludCA9IGdldENyb3NQb2ludChzb3VyY2VQb2ludCwgdGVybWluYXRpb25Qb2ludCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQpOyAvLyBib3R0b21cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGNyb3NzUG9pbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IGNyb3NzUG9pbnQueCAtIF90ZXJtaW5hdGlvbk5vZGVTaXplLndpZHRoIC8gMixcclxuICAgICAgICAgICAgICAgIHk6IGNyb3NzUG9pbnQueSAtIF90ZXJtaW5hdGlvbk5vZGVTaXplLmhlaWdodCAvIDIsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHRlcm1pbmF0aW9uUG9pbnQueCArIG5vZGVTaXplLndpZHRoIC8gMiwgdmlld0ZyYW1lUG9zaXRpb24ueCksXHJcbiAgICAgICAgICAgICAgICAgICAgdmlld0ZyYW1lUG9zaXRpb24ueCArIHZpZXdGcmFtZVNpemUud2lkdGhcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICB5OiBNYXRoLm1pbihcclxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCh0ZXJtaW5hdGlvblBvaW50LnkgKyBub2RlU2l6ZS5oZWlnaHQgLyAyLCB2aWV3RnJhbWVQb3NpdGlvbi55KSxcclxuICAgICAgICAgICAgICAgICAgICB2aWV3RnJhbWVQb3NpdGlvbi55ICsgdmlld0ZyYW1lU2l6ZS5oZWlnaHRcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRDYWxjdWxhdGlvblBvaW50cyAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVBvaW50ID0ge1xyXG4gICAgICAgICAgICAgICAgeDogdmlld0ZyYW1lUG9zaXRpb24ueCArIHZpZXdGcmFtZVNpemUud2lkdGggLyAyLFxyXG4gICAgICAgICAgICAgICAgeTogdmlld0ZyYW1lUG9zaXRpb24ueSArIHZpZXdGcmFtZVNpemUuaGVpZ2h0IC8gMixcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG93bmVyVmlld0ZyYW1lID0gX2dldFZpZXdGcmFtZUZvck5vZGUob3JpZ2luYWxOb2RlKTtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZVBvc2l0aW9uID0gZ2V0TG9jYWxOb2RlUG9zaXRpb24ob3JpZ2luYWxOb2RlLCByZW5kZXJPcHRpb25zLnBhcGVyT3B0aW9ucy5zY2FsZSwgb3duZXJWaWV3RnJhbWUpO1xyXG4gICAgICAgICAgICBjb25zdCB0ZXJtaW5hdGlvblBvaW50ID0ge1xyXG4gICAgICAgICAgICAgICAgeDogbm9kZVBvc2l0aW9uLnggKyBub2RlU2l6ZS53aWR0aCAvIDIsXHJcbiAgICAgICAgICAgICAgICB5OiBub2RlUG9zaXRpb24ueSArIG5vZGVTaXplLmhlaWdodCAvIDIsXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwb2ludElzSW5UaGVGcmFtZSA9IHZpZXdGcmFtZS5oaXRTY2FsZWRQb2ludFRlc3QodGVybWluYXRpb25Qb2ludCk7XHJcbiAgICAgICAgICAgIGlmIChwb2ludElzSW5UaGVGcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdFRvTGVmdCA9IHRlcm1pbmF0aW9uUG9pbnQueCAtIHZpZXdGcmFtZVBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0VG9Ub3AgPSB0ZXJtaW5hdGlvblBvaW50LnkgLSB2aWV3RnJhbWVQb3NpdGlvbi55O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdFRvUmlnaHQgPSB2aWV3RnJhbWVQb3NpdGlvbi54ICsgdmlld0ZyYW1lU2l6ZS53aWR0aCAtIHRlcm1pbmF0aW9uUG9pbnQueDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RUb0JvdHRvbSA9IHZpZXdGcmFtZVBvc2l0aW9uLnkgKyB2aWV3RnJhbWVTaXplLmhlaWdodCAtIHRlcm1pbmF0aW9uUG9pbnQueTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgbGV0IG1pbiA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICAgICAgW2Rpc3RUb0xlZnQsIGRpc3RUb1RvcCwgZGlzdFRvUmlnaHQsIGRpc3RUb0JvdHRvbV0uZm9yRWFjaChkaXN0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGRpc3QpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gZGlzdFRvTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uUG9pbnQueCAtPSBtaW47IFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtaW4gPT09IGRpc3RUb1JpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25Qb2ludC54ICs9IG1pbjsgXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1pbiA9PT0gZGlzdFRvVG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25Qb2ludC55IC09IG1pbjsgXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uUG9pbnQueSArPSBtaW47IFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTb21ldGltZSBpdCdzIGNvbmZ1c2luZyBmb3IgdXNlcnMgd2hlblxyXG4gICAgICAgICAgICAvLyBub2RlcyBhcmUgaW4gdGhlIGxlZnRWaWV3RnJhbWUgYnV0IHRlcm1pbmF0aW9uIG5vZGVzIGdvZXMgdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAgIGlmIChvd25lclZpZXdGcmFtZS5pZCAhPT0gdmlld0ZyYW1lLmlkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpZHMgPSBfYWxsRnJhbWVzLm1hcCh2ZiA9PiB2Zi5pZCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3RnJhbWVJbmRleCA9IGlkcy5pbmRleE9mKHZpZXdGcmFtZS5pZCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvd25lclZpZXdGcmFtZUluZGV4ID0gaWRzLmluZGV4T2Yob3duZXJWaWV3RnJhbWUuaWQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZW50YXRpb24gPSByZW5kZXJPcHRpb25zLnBhcGVyT3B0aW9ucy5vcmllbnRhdGlvbjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbE9yaWVudGF0ZWQgPSBvcmllbnRhdGlvbiA9PT0gJ2xlZnQtdG8tcmlnaHQnIHx8IG9yaWVudGF0aW9uID09PSAncmlnaHQtdG8tbGVmdCc7XHJcbiAgICAgICAgICAgICAgICBpZiAodmlld0ZyYW1lSW5kZXggPCBvd25lclZpZXdGcmFtZUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbE9yaWVudGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25Qb2ludC54ID0gYm90dG9tUmlnaHQueDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvblBvaW50LnkgPSBib3R0b21SaWdodC55O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbE9yaWVudGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25Qb2ludC54ID0gdG9wTGVmdC54O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uUG9pbnQueSA9IHRvcExlZnQueTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2VQb2ludDogc291cmNlUG9pbnQsXHJcbiAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvblBvaW50OiB0ZXJtaW5hdGlvblBvaW50LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgKG9yIGdldCBmcm9tIGNhY2hlKSBhc3BlY3QgbGlua3NcclxuICAgICAqIEBwYXJhbSB7Tm9kZVtdfSBub2RlcyAtIHZpc2libGUgbm9kZXNcclxuICAgICAqIEByZXR1cm5zIHtBc3BlY3RMaW5rW119XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NhbGN1bGF0ZUFzcGVjdExpbmtzIChub2Rlcykge1xyXG4gICAgICAgIGNvbnN0IGFzcGVjdExpbmtzQ2FjaGUgPSB7fTtcclxuICAgICAgICBjb25zdCBub2RlTWFwID0gYXJyYXlUb01hcChub2Rlcyk7XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYXNwZWN0cyA9IGdldEJhc2VFbGVtZW50KG5vZGUpLmFzcGVjdHM7XHJcbiAgICAgICAgICAgIGFzcGVjdHMuZm9yRWFjaChhc3BlY3QgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmlzaWJsZVRlcm1pbmF0aW9ucyA9IGFzcGVjdC50ZXJtaW5hdGlvbk5vZGVzLmZpbHRlcih0biA9PiBub2RlTWFwW3RuLmlkXSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhdExlYXN0T25lVGVybWluYXRpb24gPSB2aXNpYmxlVGVybWluYXRpb25zLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhc3BlY3RXaWxsT25UaGVQYXBlciA9ICBub2RlTWFwW2FzcGVjdC5pZF0gfHwgYXRMZWFzdE9uZVRlcm1pbmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lT3duZXIgPSBfZ2V0Vmlld0ZyYW1lRm9yTm9kZShhc3BlY3QpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lT3duZXJJc1Zpc2libGUgPSBfc3RhdGVbdmlld0ZyYW1lT3duZXIuaWRdIHx8IF9mdWxsU2NyZWVuTW9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChhc3BlY3RXaWxsT25UaGVQYXBlciAmJiB2aWV3RnJhbWVPd25lcklzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzcGVjdEluc3RhbmNlcyA9IG5vZGVNYXBbYXNwZWN0LmlkXSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2FzcGVjdF0gOiB2aXNpYmxlVGVybWluYXRpb25zO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhc3BlY3RJbnN0YW5jZXMuZm9yRWFjaChhc3BlY3RJbnN0YW5jZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZExpbmsgPSBnZXRGcm9tQ2FoZShub2RlLCBhc3BlY3RJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzcGVjdExpbmsgPSBjYWNoZWRMaW5rIHx8IGNyZWF0ZUFzcGVjdExpbmsobm9kZSwgYXNwZWN0SW5zdGFuY2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYXNwZWN0TGlua3NDYWNoZVthc3BlY3RMaW5rLmlkXSA9IGFzcGVjdExpbms7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIF9hc3BlY3RMaW5rc0NhaGUgPSBhc3BlY3RMaW5rc0NhY2hlO1xyXG4gICAgICAgIGNvbnN0IGFzcGVjdExpbmtzID0gT2JqZWN0LmtleXMoYXNwZWN0TGlua3NDYWNoZSkubWFwKGlkID0+IF9hc3BlY3RMaW5rc0NhaGVbaWRdKTtcclxuICAgICAgICByZXR1cm4gYXNwZWN0TGlua3M7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUFzcGVjdExpbmsgKG5vZGUsIGFzcGVjdCkge1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IG5vZGUuaWQgKyAnfiN+JyArIGFzcGVjdC5pZDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXNwZWN0TGluayh7XHJcbiAgICAgICAgICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGUsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGFzcGVjdCxcclxuICAgICAgICAgICAgfSwgcGFyYW1ldGVycyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRGcm9tQ2FoZSAobm9kZSwgYXNwZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gbm9kZS5pZCArICd+I34nICsgYXNwZWN0LmlkO1xyXG4gICAgICAgICAgICBjb25zdCByZXZlcnNlSWQgPSBhc3BlY3QuaWQgKyAnfiN+JyArIG5vZGUuaWQ7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBsaW5rRnJvbUxvY2FsID0gYXNwZWN0TGlua3NDYWNoZVtpZF0gfHwgYXNwZWN0TGlua3NDYWNoZVtyZXZlcnNlSWRdO1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rRnJvbUdsb2JhbCA9IF9hc3BlY3RMaW5rc0NhaGVbaWRdIHx8IF9hc3BlY3RMaW5rc0NhaGVbcmV2ZXJzZUlkXTtcclxuICAgICAgICAgICAgcmV0dXJuIGxpbmtGcm9tTG9jYWwgfHwgbGlua0Zyb21HbG9iYWw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyBoaWdobGlnaHRpbmcgb2YgdGhlIGVsZW1lbnRzXHJcbiAgICAgKiBAcGFyYW0geyhOb2RlfExpbmt8VGVybWluYXRpb25Ob2RlfFRlcm1pbmF0aW9uTGluaylbXX0gY2VsbHNcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyT3B0aW9ufSByZW5kZXJPcHRpb25zXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3NldEhpZ2hsaWdodGluZyAoY2VsbHMsIHJlbmRlck9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBwYXRoID0gcmVuZGVyT3B0aW9ucy5wYXRoO1xyXG4gICAgICAgIGNvbnN0IG1hc2sgPSByZW5kZXJPcHRpb25zLm1hc2s7XHJcblxyXG4gICAgICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhc2VDZWxsID0gZ2V0QmFzZUVsZW1lbnQoY2VsbCk7XHJcbiAgICAgICAgICAgIGlmIChtYXNrICYmIGJhc2VDZWxsICE9PSByZW5kZXJPcHRpb25zLnNlbGVjdGVkRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hc2tbYmFzZUNlbGwuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZUNlbGwuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlQ2VsbC5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJhc2VDZWxsID09PSByZW5kZXJPcHRpb25zLnNlbGVjdGVkRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgYmFzZUNlbGwuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGF0aCAmJiAhcGF0aFtiYXNlQ2VsbC5pZF0pIHtcclxuICAgICAgICAgICAgICAgIGJhc2VDZWxsLmJsdXJlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlQ2VsbC51bmJsdXJlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgbGlzdCBvZiB2aXNpYmxlIHZpZXdGcmFtZXNcclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVbXX1cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0VmlzaWJsZVZpZXdGcmFtZXMgKCkge1xyXG4gICAgICAgIHJldHVybiBfZnVsbFNjcmVlbk1vZGUgPyBbX292ZXJWaWV3RnJhbWVdIDogX3ZpZXdGcmFtZXMuZmlsdGVyKHZmID0+IF9zdGF0ZVt2Zi5pZF0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB2aWV3RnJhbWUgZm9yIHRoZSBub2RlLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lIHwgdW5kZWZpbmVkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0Vmlld0ZyYW1lRm9yTm9kZSAobm9kZSkge1xyXG4gICAgICAgIGlmIChfZnVsbFNjcmVlbk1vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9vdmVyVmlld0ZyYW1lO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZUlkID0gZ2V0Vmlld0ZyYW1lSWRGb3JOb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3ZpZXdGcmFtZXNNYXBbdmlld0ZyYW1lSWRdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXMgb24gdmlld0ZyYW1lIGV2ZW50c1xyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9zdWJzY3JpYmVPblZpZXdGcmFtZUV2ZW50cyAoKSB7XHJcbiAgICAgICAgX2FsbEZyYW1lcy5mb3JFYWNoKHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgICAgIHZpZXdGcmFtZS5vbignY2hhbmdlLXZpZXctcG9ydC1wb3NpdGlvbicsIChuZXdWaWV3UG9ydFBvc2l0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmlld0ZyYW1lLm1vdmluZ0J5SXRzZWxmKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lUHVibGljTW9kZWwgPSBfZ2V0Vmlld0ZyYW1lUHVibGljTW9kZWwodmlld0ZyYW1lKTtcclxuICAgICAgICAgICAgICAgIHZpZXdGcmFtZVB1YmxpY01vZGVsLnZpZXdQb3J0UG9zaXRpb24gPSBuZXdWaWV3UG9ydFBvc2l0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignY2hhbmdlLXZpZXctcG9ydC1wb3NpdGlvbicsIHZpZXdGcmFtZVB1YmxpY01vZGVsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFZpZXdNYW5hZ2VyO1xyXG4iLCJpbXBvcnQgKiBhcyBjb2xhIGZyb20gJ3dlYmNvbGEnO1xyXG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCBTYW5rZXkgZnJvbSAnLi9zYW5rZXknO1xyXG5pbXBvcnQgeyBhcnJheVRvTWFwLCBnZXRFbGVtZW50U2l6ZSwgZ2V0R2xvYmFsTm9kZVBvc2l0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQge1xyXG4gICAgY29udmVydE5hdGl2ZVRvTGF5b3V0TW9kZWxzLFxyXG4gICAgY29udmVydExHRWxlbWVudHNUb0xheW91dE1vZGVscyxcclxufSBmcm9tICcuLi91dGlscy9sYXlvdXRVdGlscyc7XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHt7XHJcbiAqICBzZWxlY3RlZE5vZGU6IE5vZGUsXHJcbiAqICByZWxhdGl2ZUxpbmtzOiBMaW5rW10sXHJcbiAqICByZWxhdGl2ZU5vZGVzOiBOb2RlW10sXHJcbiAqIH19IG9wdGlvbnMgXHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIHBhcmFtZXRlcnMgc2V0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZU9wZXJhdGlvbiAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2NhbGUgPSBvcHRpb25zLnNjYWxlO1xyXG5cclxuICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24ob3B0aW9ucy5zZWxlY3RlZE5vZGUpO1xyXG4gICAgY29uc3QgY29tYmluZWROb2RlcyA9IFtvcHRpb25zLnNlbGVjdGVkTm9kZV0uY29uY2F0KG9wdGlvbnMucmVsYXRpdmVOb2Rlcyk7XHJcblxyXG4gICAgY29uc3QgZWxlbWVudHMgPSBjb252ZXJ0TEdFbGVtZW50c1RvTGF5b3V0TW9kZWxzKGNvbWJpbmVkTm9kZXMsIG9wdGlvbnMucmVsYXRpdmVMaW5rcywge1xyXG4gICAgICAgIHNjYWxlOiBzY2FsZSxcclxuICAgIH0pO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBlbGVtZW50cy5ub2RlcztcclxuICAgIGNvbnN0IGxpbmtzID0gZWxlbWVudHMubGlua3M7XHJcbiAgICBjb25zdCBzZWxlY3RlZExheW91dE5vZGUgPSBub2Rlc1swXTtcclxuXHJcbiAgICBjb25zdCBsYXlvdXRPcHRpb25zID0ge1xyXG4gICAgICAgIG5vZGVzOiBub2RlcyxcclxuICAgICAgICBsaW5rczogbGlua3MsXHJcbiAgICAgICAgc3RlcDogcGFyYW1ldGVycy5sYXlvdXRTdGVwLFxyXG4gICAgICAgIGVsZW1lbnQ6IHBhcmFtZXRlcnMuZWxlbWVudFNpemUsXHJcbiAgICAgICAgaXRlcmF0aW9uczogcGFyYW1ldGVycy5sYXlvdXRJdGVyYXRpb25zLFxyXG4gICAgfTtcclxuICAgIHRxRm9yY2VMYXlvdXQobGF5b3V0T3B0aW9ucyk7XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0ge307XHJcbiAgICBub2Rlcy5mb3JFYWNoKGxheW91dE5vZGUgPT4ge1xyXG4gICAgICAgIGlmIChsYXlvdXROb2RlICE9PSBzZWxlY3RlZExheW91dE5vZGUpIHtcclxuICAgICAgICAgICAgbGF5b3V0Tm9kZS54ID0gc3RhcnRQb3NpdGlvbi54ICsgKGxheW91dE5vZGUueCAtIHNlbGVjdGVkTGF5b3V0Tm9kZS54KTtcclxuICAgICAgICAgICAgbGF5b3V0Tm9kZS55ID0gc3RhcnRQb3NpdGlvbi55ICsgKGxheW91dE5vZGUueSAtIHNlbGVjdGVkTGF5b3V0Tm9kZS55KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0W2xheW91dE5vZGUub3JpZ2luYWxOb2RlLmlkXSA9IHtcclxuICAgICAgICAgICAgeDogbGF5b3V0Tm9kZS54LFxyXG4gICAgICAgICAgICB5OiBsYXlvdXROb2RlLnksXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZSBcclxuICogXHJcbiAqIENhbGN1bGF0ZXMgcG9zaXRpb25zIGZvciBub2Rlcy5cclxuICogQHBhcmFtIHtBcnJheX0gbm9kZU1vZGVscyAtIGxpc3Qgb2YgdGhlIG5hdGl2ZSBub2Rlc1xyXG4gKiBAcGFyYW0ge0FycmF5fSBuYXRpdmVMaW5rcyAtIGxpc3Qgb2YgdGhlIG5hdGl2ZSBsaW5rc1xyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSBwYXJhbWV0ZXJzIHNldFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRvTGF5b3V0IChub2RlTW9kZWxzLCBsaW5rTW9kZWxzLCB2aWV3RnJhbWVzLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBpZiAoIXBhcmFtZXRlcnMpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBlbGVtZW50cyA9IGNvbnZlcnROYXRpdmVUb0xheW91dE1vZGVscyhub2RlTW9kZWxzLCBsaW5rTW9kZWxzLCBwYXJhbWV0ZXJzKTtcclxuICAgIGNvbnN0IG5vZGVzID0gZWxlbWVudHMubm9kZXM7XHJcbiAgICBjb25zdCBsaW5rcyA9IGVsZW1lbnRzLmxpbmtzO1xyXG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uID09PSAncmlnaHQtdG8tbGVmdCcgfHwgcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uID09PSAnbGVmdC10by1yaWdodCc7XHJcbiAgICBcclxuICAgIHJlbW92ZUN5Y2xlcyhub2RlcywgbGlua3MpO1xyXG4gICAgXHJcbiAgICBjb25zdCBncm91cHMgPSBicmVha0J5R3JvdXBzKG5vZGVzLCBsaW5rcywgdmlld0ZyYW1lcywgcGFyYW1ldGVycyk7XHJcblxyXG4gICAgY29uc3QgbGF5b3V0T3B0aW9ucyA9IHtcclxuICAgICAgICBncm91cHM6IGdyb3VwcyxcclxuICAgICAgICBub2Rlczogbm9kZXMsXHJcbiAgICAgICAgbGlua3M6IGxpbmtzLFxyXG4gICAgICAgIGlzSG9yaXpvbnRhbDogaXNIb3Jpem9udGFsLFxyXG4gICAgICAgIHN0ZXA6IHBhcmFtZXRlcnMubGF5b3V0U3RlcCxcclxuICAgICAgICBlbGVtZW50OiBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplLFxyXG4gICAgICAgIGl0ZXJhdGlvbnM6IHBhcmFtZXRlcnMubGF5b3V0SXRlcmF0aW9ucyxcclxuICAgIH07XHJcbiAgICBcclxuICAgIGlmIChwYXJhbWV0ZXJzLmxheW91dEFsZ29yaXRobSA9PT0gJ2Zsb3ctZGlyZWN0ZWQnKSB7XHJcbiAgICAgICAgdHFGbG93TGF5b3V0KGxheW91dE9wdGlvbnMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0cVNhbmtleUxheW91dChsYXlvdXRPcHRpb25zKTtcclxuICAgIH1cclxuICAgIGFwcGx5TGF5b3V0KCk7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGFwcGx5TGF5b3V0ICgpIHtcclxuICAgICAgICAvLyBDYWxjdWxhdGluZyBtaW4gcG9pbnRzXHJcbiAgICAgICAgbGV0IG1pblggPSBJbmZpbml0eSwgbWluWSA9IEluZmluaXR5O1xyXG4gICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBub2RlLngpO1xyXG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgbm9kZS55KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IG1heFggPSBub2Rlcy5sZW5ndGggPiAwID8gLUluZmluaXR5IDogMDtcclxuICAgICAgICBjb25zdCBjYW52YXNQYWRkaW5nID0gXHJcbiAgICAgICAgICAgIE1hdGgubWF4KHBhcmFtZXRlcnMuZWxlbWVudFNpemUud2lkdGgsIHBhcmFtZXRlcnMuZWxlbWVudFNpemUuaGVpZ2h0KSAqIDIgKiBwYXJhbWV0ZXJzLnNjYWxlQm91bmRzLm1heDtcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBub2RlLm9yaWdpbmFsTm9kZS5wb3NpdGlvbi54ID0gbm9kZS54IC0gbWluWCArIGNhbnZhc1BhZGRpbmc7XHJcbiAgICAgICAgICAgIG5vZGUub3JpZ2luYWxOb2RlLnBvc2l0aW9uLnkgPSBub2RlLnkgLSBtaW5ZICsgY2FudmFzUGFkZGluZztcclxuICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIG5vZGUub3JpZ2luYWxOb2RlLnBvc2l0aW9uLngpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAocGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uID09PSAncmlnaHQtdG8tbGVmdCcgfHwgcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uID09PSAnYm90dG9tLXRvLXRvcCcpIHtcclxuICAgICAgICAgICAgbm9kZU1vZGVscy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5wb3NpdGlvbi54ID0gbWF4WCAtIG5vZGUucG9zaXRpb24ueDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICBub2RlTW9kZWxzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gbm9kZS5wb3NpdGlvbi54O1xyXG4gICAgICAgICAgICAgICAgbm9kZS5wb3NpdGlvbi54ID0gbm9kZS5wb3NpdGlvbi55O1xyXG4gICAgICAgICAgICAgICAgbm9kZS5wb3NpdGlvbi55ID0geDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBub2RlTW9kZWxzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIG5vZGUuZGVmYXVsdFBvc2l0aW9uID0gXy5jbG9uZShub2RlLnBvc2l0aW9uKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUN5Y2xlcyAobm9kZXMsIGxpbmtzKSB7XHJcbiAgICBub2Rlcy5mb3JFYWNoKG4gPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlcGVhdE1hcCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGxpbmtzVG9SZW1vdmUgPSBbXTtcclxuXHJcbiAgICAgICAgcmVjdXJzaW9uKG4pO1xyXG5cclxuICAgICAgICBsaW5rc1RvUmVtb3ZlLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIGxpbmtzLnNwbGljZShsaW5rcy5pbmRleE9mKGxpbmspLCAxKTtcclxuICAgICAgICAgICAgbGluay50YXJnZXQuc291cmNlTGlua3Muc3BsaWNlKGxpbmsudGFyZ2V0LnNvdXJjZUxpbmtzLmluZGV4T2YobGluayksIDEpO1xyXG4gICAgICAgICAgICBsaW5rLnNvdXJjZS50YXJnZXRMaW5rcy5zcGxpY2UobGluay5zb3VyY2UudGFyZ2V0TGlua3MuaW5kZXhPZihsaW5rKSwgMSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlY3Vyc2lvbiAobm9kZSkge1xyXG4gICAgICAgICAgICByZXBlYXRNYXBbbm9kZS5pZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICBub2RlLnRhcmdldExpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlcGVhdE1hcFtsaW5rLnRhcmdldC5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZWN1cnNpb24gKGxpbmsudGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlua3NUb1JlbW92ZS5wdXNoKGxpbmspO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmVwZWF0TWFwW25vZGUuaWRdID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJyZWFrQnlHcm91cHMgKG5vZGVzLCBsaW5rcywgdmlld0ZyYW1lcywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgbm9kZU1hcCA9IGFycmF5VG9NYXAobm9kZXMpO1xyXG4gICAgY29uc3QgZ3JvdXBzID0ge307XHJcbiAgICBjb25zdCBwYXBlclNpemUgPSBnZXRFbGVtZW50U2l6ZShwYXJhbWV0ZXJzLmdyYXBoUGxhY2UpO1xyXG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uID09PSAnbGVmdC10by1yaWdodCcgfHwgcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uID09PSAncmlnaHQtdG8tbGVmdCc7XHJcbiAgICBjb25zdCB0b3RhbFNoYXJlID0gdmlld0ZyYW1lcy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCB2aWV3RnJhbWUpID0+IHtcclxuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3IgKyB2aWV3RnJhbWUuc3BhY2VTaGFyZTtcclxuICAgIH0sIDApO1xyXG4gICAgdmlld0ZyYW1lcy5mb3JFYWNoKHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgaWYgKCFncm91cHNbdmlld0ZyYW1lLmlkXSkgZ3JvdXBzW3ZpZXdGcmFtZS5pZF0gPSB7XHJcbiAgICAgICAgICAgIGlkOiB2aWV3RnJhbWUuaWQsXHJcbiAgICAgICAgICAgIHByZWZmZXJlZFNpemU6IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBpc0hvcml6b250YWwgP1xyXG4gICAgICAgICAgICAgICAgICAgIChwYXBlclNpemUud2lkdGggLyB0b3RhbFNoYXJlKSAqIHZpZXdGcmFtZS5zcGFjZVNoYXJlIDpcclxuICAgICAgICAgICAgICAgICAgICAocGFwZXJTaXplLmhlaWdodCAvIHRvdGFsU2hhcmUpICogdmlld0ZyYW1lLnNwYWNlU2hhcmUsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGlzSG9yaXpvbnRhbCA/IHBhcGVyU2l6ZS5oZWlnaHQgOiBwYXBlclNpemUud2lkdGgsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG5vZGVzOiBbXSxcclxuICAgICAgICAgICAgbGlua3M6IFtdLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IGxhc3ROb2RlcyA9IFtdO1xyXG4gICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLnZpZXdGcmFtZSA9PT0gdmlld0ZyYW1lLmlkKSB7XHJcbiAgICAgICAgICAgICAgICBncm91cHNbdmlld0ZyYW1lLmlkXS5ub2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGFzdE5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBub2RlcyA9IGxhc3ROb2RlcztcclxuXHJcbiAgICAgICAgY29uc3QgbGFzdExpbmtzID0gW107XHJcbiAgICAgICAgbGlua3MuZm9yRWFjaChsID0+IHtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgbm9kZU1hcFtsLnNvdXJjZS5pZF0udmlld0ZyYW1lID09PSB2aWV3RnJhbWUuaWQgJiZcclxuICAgICAgICAgICAgICAgIG5vZGVNYXBbbC50YXJnZXQuaWRdLnZpZXdGcmFtZSA9PT0gdmlld0ZyYW1lLmlkXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXBzW3ZpZXdGcmFtZS5pZF0ubGlua3MucHVzaChsKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgICAgIG5vZGVNYXBbbC5zb3VyY2UuaWRdLnZpZXdGcmFtZSAhPT0gdmlld0ZyYW1lLmlkICYmXHJcbiAgICAgICAgICAgICAgICBub2RlTWFwW2wudGFyZ2V0LmlkXS52aWV3RnJhbWUgIT09IHZpZXdGcmFtZS5pZFxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGxhc3RMaW5rcy5wdXNoKGwpOyBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxpbmtzID0gbGFzdExpbmtzO1xyXG4gICAgfSk7XHJcbiAgICBncm91cHNbJ3Vua25vd24nXSA9IHsgaWQ6ICd1bmtub3duJywgbm9kZXM6IG5vZGVzLCBsaW5rczogbGlua3MgfTtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhncm91cHMpLm1hcChrZXkgPT4gZ3JvdXBzW2tleV0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cVNhbmtleUxheW91dCAob3B0aW9ucykge1xyXG4gICAgY29uc3Qgc3RlcCA9IChcclxuICAgICAgICBvcHRpb25zLmlzSG9yaXpvbnRhbCA/XHJcbiAgICAgICAgW29wdGlvbnMuc3RlcC54IHx8IDEwMCwgb3B0aW9ucy5zdGVwLnkgfHwgMTVdIDpcclxuICAgICAgICBbb3B0aW9ucy5zdGVwLnkgfHwgMTUsIG9wdGlvbnMuc3RlcC54IHx8IDEwMF1cclxuICAgICk7XHJcbiAgICBvcHRpb25zLnN0ZXAgPSBvcHRpb25zLnN0ZXAgfHwge307XHJcbiAgICBTYW5rZXkoKS5zdGVwKHN0ZXApXHJcbiAgICAubm9kZVdpZHRoKG9wdGlvbnMuZWxlbWVudC53aWR0aClcclxuICAgIC5ub2RlSGVpZ2h0KG9wdGlvbnMuZWxlbWVudC5oZWlnaHQpXHJcbiAgICAubm9kZXMob3B0aW9ucy5ub2RlcylcclxuICAgIC5saW5rcyhvcHRpb25zLmxpbmtzKVxyXG4gICAgLmdyb3VwcyhvcHRpb25zLmdyb3VwcylcclxuICAgIC5sYXlvdXQob3B0aW9ucy5pdGVyYXRpb25zKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHFGbG93TGF5b3V0IChvcHRpb25zKSB7XHJcbiAgICB0cVNhbmtleUxheW91dChvcHRpb25zKTtcclxuXHJcbiAgICBjb25zdCBsYXlvdXQgPSBuZXcgY29sYS5MYXlvdXQoKVxyXG4gICAgICAgIC5ub2RlcyhvcHRpb25zLm5vZGVzKVxyXG4gICAgICAgIC5saW5rcyhvcHRpb25zLmxpbmtzKVxyXG4gICAgICAgIC5jb252ZXJnZW5jZVRocmVzaG9sZCgxZS05KVxyXG4gICAgICAgIC5qYWNjYXJkTGlua0xlbmd0aHMob3B0aW9ucy5zdGVwLnggKiAyIHx8IDQwMClcclxuICAgICAgICAuZmxvd0xheW91dCgneCcsIG9wdGlvbnMuc3RlcC54ICogMnx8IDQwMClcclxuICAgICAgICAuYXZvaWRPdmVybGFwcyh0cnVlKVxyXG4gICAgICAgIC5oYW5kbGVEaXNjb25uZWN0ZWQodHJ1ZSk7XHJcbiAgICBsYXlvdXQuc3RhcnQoMTAwLCAwLCA1MCwgdW5kZWZpbmVkLCBmYWxzZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRxRm9yY2VMYXlvdXQgKG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGxheW91dCA9IG5ldyBjb2xhLkxheW91dCgpXHJcbiAgICAgICAgLm5vZGVzKG9wdGlvbnMubm9kZXMpXHJcbiAgICAgICAgLmxpbmtzKG9wdGlvbnMubGlua3MpXHJcbiAgICAgICAgLmNvbnZlcmdlbmNlVGhyZXNob2xkKDFlLTkpXHJcbiAgICAgICAgLmphY2NhcmRMaW5rTGVuZ3RocyhvcHRpb25zLnN0ZXAueCAqIDEuNSB8fCAzNTApXHJcbiAgICAgICAgLmF2b2lkT3ZlcmxhcHModHJ1ZSlcclxuICAgICAgICAuaGFuZGxlRGlzY29ubmVjdGVkKHRydWUpO1xyXG4gICAgbGF5b3V0LnN0YXJ0KDEwMCwgMCwgNTAsIHVuZGVmaW5lZCwgZmFsc2UpO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzL2xheW91dFV0aWxzJztcclxuXHJcbnZhciBTYW5rZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2Fua2V5ID0ge30sXHJcbiAgICAgICAgbm9kZVdpZHRoID0gMjQsXHJcbiAgICAgICAgbm9kZUhlaWdodCA9IDgsXHJcbiAgICAgICAgc2l6ZSA9IFsxLCAxXSxcclxuICAgICAgICBzdGVwID0gWzEwMCwgMzBdLFxyXG4gICAgICAgIG5vZGVzID0gW10sXHJcbiAgICAgICAgZ3JvdXBzID0gW10sXHJcbiAgICAgICAgbGlua3MgPSBbXTtcclxuXHJcbiAgICBzYW5rZXkubm9kZVdpZHRoID0gZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlV2lkdGg7XHJcbiAgICAgICAgbm9kZVdpZHRoID0gK187XHJcbiAgICAgICAgcmV0dXJuIHNhbmtleTtcclxuICAgIH07XHJcblxyXG4gICAgc2Fua2V5Lm5vZGVIZWlnaHQgPSBmdW5jdGlvbiAoXykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVIZWlnaHQ7XHJcbiAgICAgICAgbm9kZUhlaWdodCA9ICtfO1xyXG4gICAgICAgIHJldHVybiBzYW5rZXk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNhbmtleS5ub2RlcyA9IGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9kZXM7XHJcbiAgICAgICAgbm9kZXMgPSBfO1xyXG4gICAgICAgIHJldHVybiBzYW5rZXk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNhbmtleS5ncm91cHMgPSBmdW5jdGlvbiAoXykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyb3VwcztcclxuICAgICAgICBncm91cHMgPSBfO1xyXG4gICAgICAgIHJldHVybiBzYW5rZXk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNhbmtleS5saW5rcyA9IGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGlua3M7XHJcbiAgICAgICAgbGlua3MgPSBfO1xyXG4gICAgICAgIHJldHVybiBzYW5rZXk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNhbmtleS5zdGVwID0gZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdGVwO1xyXG4gICAgICAgIHN0ZXAgPSBfO1xyXG4gICAgICAgIHJldHVybiBzYW5rZXk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNhbmtleS5sYXlvdXQgPSBmdW5jdGlvbiAoaXRlcmF0aW9ucykge1xyXG4gICAgICAgIGNvbXB1dGVOb2RlTGlua3MoKTtcclxuICAgICAgICBjb21wdXRlTm9kZVZhbHVlcygpO1xyXG4gICAgICAgIGNvbXB1dGVOb2RlQnJlYWR0aHMoKTtcclxuICAgICAgICBjb21wdXRlTm9kZURlcHRocyhpdGVyYXRpb25zKTtcclxuICAgICAgICBjb21wdXRlTGlua0RlcHRocygpO1xyXG4gICAgICAgIHJldHVybiBzYW5rZXk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNhbmtleS5yZWxheW91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb21wdXRlTGlua0RlcHRocygpO1xyXG4gICAgICAgIHJldHVybiBzYW5rZXk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNhbmtleS5saW5rID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjdXJ2YXR1cmUgPSAuNTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbGluayAoZCkge1xyXG4gICAgICAgICAgICB2YXIgeDAgPSBkLnNvdXJjZS54ICsgZC5zb3VyY2UuZHgsXHJcbiAgICAgICAgICAgICAgICB4MSA9IGQudGFyZ2V0LngsXHJcbiAgICAgICAgICAgICAgICB4aSA9IHV0aWxzLmludGVycG9sYXRlTnVtYmVyKHgwLCB4MSksXHJcbiAgICAgICAgICAgICAgICB4MiA9IHhpKGN1cnZhdHVyZSksXHJcbiAgICAgICAgICAgICAgICB4MyA9IHhpKDEgLSBjdXJ2YXR1cmUpLFxyXG4gICAgICAgICAgICAgICAgeTAgPSBkLnNvdXJjZS55ICsgZC5zeSArIGQuZHkgLyAyLFxyXG4gICAgICAgICAgICAgICAgeTEgPSBkLnRhcmdldC55ICsgZC50eSArIGQuZHkgLyAyO1xyXG4gICAgICAgICAgICByZXR1cm4gJ00nICsgeDAgKyAnLCcgKyB5MCArXHJcbiAgICAgICAgICAgICAgICAnQycgKyB4MiArICcsJyArIHkwICtcclxuICAgICAgICAgICAgICAgICcgJyArIHgzICsgJywnICsgeTEgK1xyXG4gICAgICAgICAgICAgICAgJyAnICsgeDEgKyAnLCcgKyB5MTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxpbmsuY3VydmF0dXJlID0gZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY3VydmF0dXJlO1xyXG4gICAgICAgICAgICBjdXJ2YXR1cmUgPSArXztcclxuICAgICAgICAgICAgcmV0dXJuIGxpbms7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxpbms7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFBvcHVsYXRlIHRoZSBzb3VyY2VMaW5rcyBhbmQgdGFyZ2V0TGlua3MgZm9yIGVhY2ggbm9kZS5cclxuICAgIC8vIEFsc28sIGlmIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBhcmUgbm90IG9iamVjdHMsIGFzc3VtZSB0aGV5IGFyZSBpbmRpY2VzLlxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZU5vZGVMaW5rcyAoKSB7XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLnNvdXJjZUxpbmtzID0gW107XHJcbiAgICAgICAgICAgIG5vZGUudGFyZ2V0TGlua3MgPSBbXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBsaW5rLnNvdXJjZSxcclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IGxpbmsudGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ251bWJlcicpIHNvdXJjZSA9IGxpbmsuc291cmNlID0gbm9kZXNbbGluay5zb3VyY2VdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ251bWJlcicpIHRhcmdldCA9IGxpbmsudGFyZ2V0ID0gbm9kZXNbbGluay50YXJnZXRdO1xyXG4gICAgICAgICAgICBzb3VyY2Uuc291cmNlTGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICAgICAgdGFyZ2V0LnRhcmdldExpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29tcHV0ZSB0aGUgdmFsdWUgKHNpemUpIG9mIGVhY2ggbm9kZSBieSBzdW1taW5nIHRoZSBhc3NvY2lhdGVkIGxpbmtzLlxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZU5vZGVWYWx1ZXMgKCkge1xyXG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgICAgdXRpbHMuc3VtKG5vZGUuc291cmNlTGlua3MsIHZhbHVlKSxcclxuICAgICAgICAgICAgICAgIHV0aWxzLnN1bShub2RlLnRhcmdldExpbmtzLCB2YWx1ZSlcclxuICAgICAgICAgICAgKSB8fCAxO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEl0ZXJhdGl2ZWx5IGFzc2lnbiB0aGUgYnJlYWR0aCAoeC1wb3NpdGlvbikgZm9yIGVhY2ggbm9kZS5cclxuICAgIC8vIE5vZGVzIGFyZSBhc3NpZ25lZCB0aGUgbWF4aW11bSBicmVhZHRoIG9mIGluY29taW5nIG5laWdoYm9ycyBwbHVzIG9uZTtcclxuICAgIC8vIG5vZGVzIHdpdGggbm8gaW5jb21pbmcgbGlua3MgYXJlIGFzc2lnbmVkIGJyZWFkdGggemVybywgd2hpbGVcclxuICAgIC8vIG5vZGVzIHdpdGggbm8gb3V0Z29pbmcgbGlua3MgYXJlIGFzc2lnbmVkIHRoZSBtYXhpbXVtIGJyZWFkdGguXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTm9kZUJyZWFkdGhzICgpIHtcclxuICAgICAgICBncm91cHMuZm9yRWFjaChncm91cCA9PiB7XHJcbiAgICAgICAgICAgIGxldCByZW1haW5pbmdOb2RlcyA9IGdyb3VwLm5vZGVzO1xyXG4gICAgICAgICAgICBsZXQgbmV4dE5vZGVzO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmVtYWluaW5nTm9kZXMuc29ydCgobjEsIG4yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBnZXRMaW5rcyhuMi50YXJnZXRMaW5rcykubGVuZ3RoIC0gZ2V0TGlua3MobjEudGFyZ2V0TGlua3MpLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TGlua3MobjIuc291cmNlTGlua3MpLmxlbmd0aCAtIGdldExpbmtzKG4xLnNvdXJjZUxpbmtzKS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgbGV0IHggPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydFggPSB4O1xyXG4gICAgICAgICAgICB3aGlsZSAocmVtYWluaW5nTm9kZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbmV4dE5vZGVzID0gW107XHJcbiAgICAgICAgICAgICAgICByZW1haW5pbmdOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS54ID0geDtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmR4ID0gbm9kZVdpZHRoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBnZXRMaW5rcyhub2RlLnNvdXJjZUxpbmtzKS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Tm9kZXMuaW5kZXhPZihsaW5rLnRhcmdldCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZXMucHVzaChsaW5rLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nTm9kZXMgPSBuZXh0Tm9kZXM7XHJcbiAgICAgICAgICAgICAgICArK3g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ3JvdXAuYnJlYWR0aCA9IHggLSBzdGFydFg7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRMaW5rcyAobGlua3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsaW5rcy5maWx0ZXIobCA9PiBncm91cC5saW5rcy5pbmRleE9mKGwpICE9PSAtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gbGV0IG1heEsgPSAxO1xyXG4gICAgICAgIC8vIGdyb3Vwcy5mb3JFYWNoKGdyb3VwID0+IHtcclxuICAgICAgICAvLyAgICAgaWYgKGdyb3VwLnByZWZmZXJlZFNpemUpIHtcclxuICAgICAgICAvLyAgICAgICAgIG1heEsgPSBNYXRoLm1heChtYXhLLCBjYWxjdWxhdGVHcm91cFdpZHRoKGdyb3VwKSAvIGdyb3VwLnByZWZmZXJlZFNpemUud2lkdGgpO1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IGN1clhQb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgZ3JvdXBzLmZvckVhY2goZ3JvdXAgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZ3JvdXBTaXplID0gY2FsY3VsYXRlR3JvdXBXaWR0aChncm91cCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoZ3JvdXAucHJlZmZlcmVkU2l6ZSAmJiBncm91cC5icmVhZHRoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXBTaXplID0gTWF0aC5tYXgoZ3JvdXBTaXplLCBncm91cC5wcmVmZmVyZWRTaXplLndpZHRoIC8qICogbWF4SyAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qga3ggPSBncm91cC5icmVhZHRoID4gMSA/IGdyb3VwU2l6ZSAvIChncm91cC5icmVhZHRoIC0gMSkgOiAwO1xyXG4gICAgICAgICAgICBncm91cC5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgbm9kZS54ID0gY3VyWFBvc2l0aW9uICsgbm9kZS54ICoga3g7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjdXJYUG9zaXRpb24gKz0gZ3JvdXBTaXplICsgc3RlcFswXSArIG5vZGVXaWR0aDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY2FsY3VsYXRlR3JvdXBXaWR0aCAoZ3JvdXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIChncm91cC5icmVhZHRoIC0gMSkgKiAoc3RlcFswXSArIG5vZGVXaWR0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGZ1bmN0aW9uIHNjYWxlTm9kZUJyZWFkdGhzIChub2Rlcywga3gpIHtcclxuICAgIC8vICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAvLyAgICAgICAgIG5vZGUueCAqPSBreDtcclxuICAgIC8vICAgICB9KTtcclxuICAgIC8vIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlSGVpZ2h0IChub2Rlc0J5QnJlYWR0aCkge1xyXG4gICAgICAgIHZhciBtYXhDb2x1bW5IZWlnaHQgPSAwO1xyXG4gICAgICAgIG5vZGVzQnlCcmVhZHRoLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzKSB7XHJcbiAgICAgICAgICAgIG1heENvbHVtbkhlaWdodCA9IE1hdGgubWF4KG1heENvbHVtbkhlaWdodCwgbm9kZXMubGVuZ3RoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzaXplWzFdID0gKG1heENvbHVtbkhlaWdodCkgKiBub2RlSGVpZ2h0ICsgKG1heENvbHVtbkhlaWdodCAtIDEpICogc3RlcFsxXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTm9kZURlcHRocyAoaXRlcmF0aW9ucykge1xyXG4gICAgICAgIHZhciBub2Rlc0J5QnJlYWR0aCA9IHV0aWxzLm5lc3QoKVxyXG4gICAgICAgICAgICAua2V5KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC54O1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc29ydEtleXMoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmVudHJpZXMobm9kZXMpXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLnZhbHVlcztcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbXB1dGVIZWlnaHQobm9kZXNCeUJyZWFkdGgpO1xyXG5cclxuICAgICAgICBpbml0aWFsaXplTm9kZURlcHRoKCk7XHJcbiAgICAgICAgcmVzb2x2ZUNvbGxpc2lvbnMoKTtcclxuICAgICAgICBmb3IgKHZhciBhbHBoYSA9IDE7IGl0ZXJhdGlvbnMgPiAwOyAtLWl0ZXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgcmVsYXhSaWdodFRvTGVmdChhbHBoYSAqPSAuOTkpO1xyXG4gICAgICAgICAgICByZXNvbHZlQ29sbGlzaW9ucygpO1xyXG4gICAgICAgICAgICByZWxheExlZnRUb1JpZ2h0KGFscGhhKTtcclxuICAgICAgICAgICAgcmVzb2x2ZUNvbGxpc2lvbnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmxvb3JUb01vZHVsZSgpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbml0aWFsaXplTm9kZURlcHRoICgpIHtcclxuICAgICAgICAgICAgdmFyIGt5ID0gdXRpbHMubWluKG5vZGVzQnlCcmVhZHRoLCBmdW5jdGlvbiAobm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoc2l6ZVsxXSAtIChub2Rlcy5sZW5ndGggLSAxKSAqIG5vZGVIZWlnaHQpIC8gdXRpbHMuc3VtKG5vZGVzLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgbm9kZXNCeUJyZWFkdGguZm9yRWFjaChmdW5jdGlvbiAobm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnkgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZHkgPSBub2RlLnZhbHVlICoga3k7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5rLmR5ID0gbGluay52YWx1ZSAqIGt5O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbGF4TGVmdFRvUmlnaHQgKGFscGhhKSB7XHJcbiAgICAgICAgICAgIG5vZGVzQnlCcmVhZHRoLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudGFyZ2V0TGlua3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gdXRpbHMuc3VtKG5vZGUudGFyZ2V0TGlua3MsIHdlaWdodGVkU291cmNlKSAvIHV0aWxzLnN1bShub2RlLnRhcmdldExpbmtzLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUueSArPSAoeSAtIGNlbnRlcihub2RlKSkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiB3ZWlnaHRlZFNvdXJjZSAobGluaykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbnRlcihsaW5rLnNvdXJjZSkgKiBsaW5rLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWxheFJpZ2h0VG9MZWZ0IChhbHBoYSkge1xyXG4gICAgICAgICAgICBub2Rlc0J5QnJlYWR0aC5zbGljZSgpLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnNvdXJjZUxpbmtzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IHV0aWxzLnN1bShub2RlLnNvdXJjZUxpbmtzLCB3ZWlnaHRlZFRhcmdldCkgLyB1dGlscy5zdW0obm9kZS5zb3VyY2VMaW5rcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnkgKz0gKHkgLSBjZW50ZXIobm9kZSkpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gd2VpZ2h0ZWRUYXJnZXQgKGxpbmspIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXIobGluay50YXJnZXQpICogbGluay52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZmxvb3JUb01vZHVsZSAoKSB7XHJcbiAgICAgICAgICAgIG5vZGVzQnlCcmVhZHRoLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZU1hcCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxTdGVwID0gKHN0ZXBbMV0gKyBub2RlSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeSA9IG5vZGUueSAtIG5vZGUueSAlIChmdWxsU3RlcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBsYWNlTWFwW3ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gZnVsbFN0ZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUueSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VNYXBbeV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZUNvbGxpc2lvbnMgKCkge1xyXG4gICAgICAgICAgICBub2Rlc0J5QnJlYWR0aC5mb3JFYWNoKGZ1bmN0aW9uIChub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZHksXHJcbiAgICAgICAgICAgICAgICAgICAgeTAgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQdXNoIGFueSBvdmVybGFwcGluZyBub2RlcyBkb3duLlxyXG4gICAgICAgICAgICAgICAgbm9kZXMuc29ydChhc2NlbmRpbmdEZXB0aCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGR5ID0geTAgLSBub2RlLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR5ID4gMCkgbm9kZS55ICs9IGR5O1xyXG4gICAgICAgICAgICAgICAgICAgIHkwID0gbm9kZS55ICsgbm9kZS5keSArIG5vZGVIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJvdHRvbW1vc3Qgbm9kZSBnb2VzIG91dHNpZGUgdGhlIGJvdW5kcywgcHVzaCBpdCBiYWNrIHVwLlxyXG4gICAgICAgICAgICAgICAgZHkgPSB5MCAtIG5vZGVIZWlnaHQgLSBzaXplWzFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGR5ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHkwID0gbm9kZS55IC09IGR5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBQdXNoIGFueSBvdmVybGFwcGluZyBub2RlcyBiYWNrIHVwLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IG4gLSAyOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5ID0gbm9kZS55ICsgbm9kZS5keSArIG5vZGVIZWlnaHQgLSB5MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR5ID4gMCkgbm9kZS55IC09IGR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IG5vZGUueTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYXNjZW5kaW5nRGVwdGggKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEueSAtIGIueTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUxpbmtEZXB0aHMgKCkge1xyXG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZS5zb3VyY2VMaW5rcy5zb3J0KGFzY2VuZGluZ1RhcmdldERlcHRoKTtcclxuICAgICAgICAgICAgbm9kZS50YXJnZXRMaW5rcy5zb3J0KGFzY2VuZGluZ1NvdXJjZURlcHRoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBzeSA9IDAsXHJcbiAgICAgICAgICAgICAgICB0eSA9IDA7XHJcbiAgICAgICAgICAgIG5vZGUuc291cmNlTGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xyXG4gICAgICAgICAgICAgICAgbGluay5zeSA9IHN5O1xyXG4gICAgICAgICAgICAgICAgc3kgKz0gbGluay5keTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG5vZGUudGFyZ2V0TGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xyXG4gICAgICAgICAgICAgICAgbGluay50eSA9IHR5O1xyXG4gICAgICAgICAgICAgICAgdHkgKz0gbGluay5keTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFzY2VuZGluZ1NvdXJjZURlcHRoIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnNvdXJjZS55IC0gYi5zb3VyY2UueTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFzY2VuZGluZ1RhcmdldERlcHRoIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnRhcmdldC55IC0gYi50YXJnZXQueTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2VudGVyIChub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUueSArIG5vZGUuZHkgLyAyO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHZhbHVlIChsaW5rKSB7XHJcbiAgICAgICAgcmV0dXJuIGxpbmsudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNhbmtleTtcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBTYW5rZXk7IiwiaW1wb3J0IFRRR3JhbVVJIGZyb20gJ3Zpc3VhbGl6YXRpb25zLWxpYnJhcnknO1xyXG5pbXBvcnQgKiBhcyBqb2ludCBmcm9tICdyYXBwaWQnO1xyXG5pbXBvcnQgKiBhcyBsYXlvdXQgZnJvbSAnLi9sYXlvdXQvbGF5b3V0JztcclxuaW1wb3J0ICogYXMgZ3JhcGhFbGVtZW50cyBmcm9tICcuL2pvaW50Vmlld3MvZ3JhcGhFbGVtZW50cy9lbGVtZW50cyc7XHJcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IExpbmVhZ2VEaWFncmFtIGZyb20gJy4vam9pbnRWaWV3cy9saW5lYWdlRGlhZ3JhbSc7XHJcbmltcG9ydCBEZXJpdmF0aW9uTWFwIGZyb20gJy4vam9pbnRWaWV3cy9kZXJpdmF0aW9uTWFwL2Rlcml2YXRpb25NYXAnO1xyXG5pbXBvcnQgR3JhcGhNYXAgZnJvbSAnLi9zaWdtYVZpZXdzL2dyYXBoTWFwJztcclxuaW1wb3J0IEJpcmRFeWUgZnJvbSAnLi9zaWdtYVZpZXdzL2JpcmRFeWUnO1xyXG5pbXBvcnQgRGF0YUNvbnRhaW5lciBmcm9tICcuL2RhdGEvZGF0YUNvbnRhaW5lcic7XHJcbmltcG9ydCBTdGF0ZVN0b3JhZ2UgZnJvbSAnLi9zdGF0ZVN0b3JhZ2UnO1xyXG5pbXBvcnQgU3Vic2NyaWJhYmxlIGZyb20gJy4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGUnO1xyXG5pbXBvcnQge1xyXG4gICAgREVGQVVMVF9MSU5LX1NUWUxFLFxyXG4gICAgRkVFRF9QSVBFX0xJTktfU1RZTEUsXHJcbiAgICBERUZBVUxUX0dST1VQX0xJTktfU1RZTEUsXHJcbn0gZnJvbSAnLi9kYXRhL3Jlc291cmNlUHJvdmlkZXInO1xyXG5pbXBvcnQge1xyXG4gICAgY3JlYXRlSm9pbnROb2RlcyxcclxuICAgIGNyZWF0ZUpvaW50TGlua3MsXHJcbiAgICBnZXRCYXNlRWxlbWVudCxcclxuICAgIGNoZWNrTGdSYXdEYXRhLFxyXG4gICAgZGVmZW5pdGlvblRvUHVibGljTW9kZWwsXHJcbn0gZnJvbSAnLi91dGlscy9kYXRhVXRpbHMnO1xyXG5pbXBvcnQgeyBwcm9jZXNzRGF0YSwgY3JlYXRlQXNwZWN0UmVsYXRpb25zIH0gZnJvbSAnLi9kYXRhL2RhdGFQcm9jZXNzaW5nJztcclxuaW1wb3J0IHsgZ2V0RGVmYXVsdFBhcmFtZXRlcnNTZXQgYXMgZ2V0RGVyaXZhdGlvbk1hcFBhcmFtZXRlclNldCB9IGZyb20gJy4vam9pbnRWaWV3cy9kZXJpdmF0aW9uTWFwL2Rlcml2YXRpb25NYXAnO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHdoaWNoIHByb3ZpZGVzIGRhdGEgZm9yIHRoZSBMaW5lYWdlR3JhbS5cclxuICogQGludGVyZmFjZSBEYXRhUHJvdmlkZXJcclxuICovXHJcblxyXG4vKipcclxuICogVGhlIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgbm9kZXMgYW5kIGxpbmsgbW9kZWxzIGZvciB0aGUgZ3JhcGguXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAbmFtZSBEYXRhUHJvdmlkZXIjZmV0Y2hEYXRhXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXROb2RlSWRcclxuICogQHBhcmFtIHtzdHJpbmd9IHZpZXdGcmFtZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbGluZWFnZUdyYW1WaWV3Q2xhc3NcclxuICogQHBhcmFtIHtzdHJpbmd9IGRpYWdyYW1UeXBlXHJcbiAgIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcclxuICogQHJldHVybnMge1Byb21pc2U8U2VydmVyRGF0YT59IFByb21pc2Ugd2hpY2ggcHJvdmlkZXMgZ3JhcGggZGF0YS5cclxuICovXHJcblxyXG4gLyoqXHJcbiAqIFRoZSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIG5vZGVzIGFuZCBsaW5rIG1vZGVscyBmb3IgdGhlIGdyYXBoLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQG5hbWUgRGF0YVByb3ZpZGVyI2dldFZpZXdGcmFtZXNcclxuICogQHBhcmFtIHtzdHJpbmd9IHJlc291cmNlXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPFZpZXdGcmFtZURlZmluaXRpb25bXT59IFByb21pc2Ugd2hpY2ggcHJvdmlkZXMgZ3JhcGggZGF0YS5cclxuICovXHJcblxyXG4gLyoqXHJcbiAqIFRoZSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIG5vZGVzIGFuZCBsaW5rIG1vZGVscyBmb3IgdGhlIGdyYXBoLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQG5hbWUgRGF0YVByb3ZpZGVyI2dldFZpZXdDbGFzc0ZvclJlc291cmNlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXNvdXJjZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx7ZGF0YVByb3ZpZGVyOiBzdHJpbmd9Pn0gUHJvbWlzZSB3aGljaCBwcm92aWRlcyBncmFwaCBkYXRhLlxyXG4gKi9cclxuXHJcbiAvKipcclxuICogVGhlIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgbm9kZXMgYW5kIGxpbmsgbW9kZWxzIGZvciB0aGUgZ3JhcGguXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAbmFtZSBEYXRhUHJvdmlkZXIjcmVsYXRpb25JbmZvXHJcbiAqIEBwYXJhbSB7TGlua30gcmVsYXRpb25cclxuICogQHJldHVybnMge1Byb21pc2U8RGVyaXZhdGlvbk1hcERhdGE+fSBQcm9taXNlIHdoaWNoIHByb3ZpZGVzIGdyYXBoIGRhdGEuXHJcbiAqL1xyXG5cclxuIC8qKlxyXG4gKiBSZXByZXNlbnRzIGEgbm9kZSBtb2RlbCB3aGljaCBpcyBleHRlbmRlZCBieSBkaWFncmFtVHlwZSBmaWVsZFxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQdWJsaWNOb2RlTW9kZWxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYWJlbFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVzb3VyY2VcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlc291cmNlVHlwZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGlhZ3JhbVR5cGVcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVJZFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmlld0ZyYW1lXHJcbiAqIEBwcm9wZXJ0eSB7YW55fSBkYXRhXHJcbiovXHJcblxyXG4gLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBsaW5rIG1vZGVsIHdoaWNoIGlzIGV4dGVuZGVkIGJ5IGRpYWdyYW1UeXBlIGZpZWxkXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFB1YmxpY0xpbmtNb2RlbFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWRcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGFyZ2V0XHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkaWFncmFtVHlwZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGlua1R5cGVcclxuICogQHByb3BlcnR5IHthbnl9IGRhdGFcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgZGF0YVByb3ZpZGVyIHJlc3BvbnNlIHdoaWNoIGluY2x1ZGVzXHJcbiAqIGxpbmtzIGFuZCBub2RlcyBmb3IgdGhlIExpbmVhZ2VHcmFtXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlcnZlckRhdGFcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRpYWdyYW1UeXBlXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmb2N1c05vZGUgLSBJUkkgb2YgZm9jdXNOb2RlXHJcbiAqIEBwcm9wZXJ0eSB7TGlua01vZGVsW119IGxpbmtzIC0gTGluayBtb2RlbHNcclxuICogQHByb3BlcnR5IHtOb2RlTW9kZWxbXX0gbm9kZXMgLSBOb2RlIG1vZGVsc1xyXG4qL1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBzdGF0ZVxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBIaXN0b3J5U3RhdGVcclxuICogQHByb3BlcnR5IHtMaW5rW119IGxpbmtzIC0gTGlua3NcclxuICogQHByb3BlcnR5IHtOb2RlW119IG5vZGVzIC0gTm9kZXNcclxuICogQHByb3BlcnR5IHtWaWV3RnJhbWVEZWZpbml0aW9uW119IHZpZXdGcmFtZXNcclxuICogQHByb3BlcnR5IHtOb2RlfSBmb2N1c05vZGUgLSBGb2N1cyBub2RlIGZvciB0aGUgc3RhdGVcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBTaXplXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNpemVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIC0gV2lkdGhcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodFxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIFBvaW50XHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBvaW50XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IC0gWFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0geSAtIFlcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBWaWV3IGZyYW1lIGRlZmluaXRpb24sXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFZpZXdGcmFtZURlZmluaXRpb25cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVmlldyBmcmFtZSBpZGVudGlmeWVyXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYWJlbCAtIFRpdGxlIG9mIHRoZSB2aWV3IGZyYW1lLFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYm9yZGVyQ29sb3IgLSBDb2xvciBvZiB0aGUgYm9yZGVyXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBiYWNrZ3JvdW5kQ29sb3IgLSBDb2xvciBvZiB0aGUgYmFja2dyb3VuZFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3BhY2VTaGFyZSAtIEhvdyBtdWNoIHRoZSB2aWV3IGZyYW1lIHdpbGwgdGFrZVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvbGxhcHNlZCAtIERlZmluZSBkZWZhdWx0IHN0YXRlXHJcbiAqIGZyb20gd2hvbGUgc3BhY2Ugb2YgdGhlIGdyYXBoIChZb3UgY2FuIHRha2UgaXQgYXMgcGVyc2VudHMgb3IgZmxleCBncm93KVxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIExpbmsgdG9vbCBidXR0b24gZGVmaW5pdGlvblxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMaW5rVG9vbEJ1dHRvblxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaW1hZ2UgLSBwYXRoIHRvIGltYWdlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0XHJcbiovXHJcblxyXG4vKipcclxuICogTGluayBzdHlsZSBkZWZpbml0aW9uXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExpbmtTdHlsZURlZmluaXRpb25cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNzc0NsYXNzIC0gQ1NTIGNsYXNzIHdoaWNoIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIHN2ZyBjb21wb25lbnRcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxpbmVUeXBlIC0gJ3NvbGlkJyBvciAnZGFzaGVkJ1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29sb3IgLSBDb2xvciBvZiB0aGUgbGluZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGhpY2tuZXNzXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGFzQXJyb3cgLSBUZWxscyB1cyB3aGV0aGVyIGxpbmUgaGFzIGEgdGVybWluYXRpb24gYXJyb3cgb3Igbm90XHJcbiAqIEBwcm9wZXJ0eSB7TGlua1Rvb2xCdXR0b259IHRvb2xCdXR0b25cclxuKi9cclxuXHJcbi8qKlxyXG4gKiBTaXplIG9mIHRoZSBub2RlcyBvZiB0aGUgZ3JhcGggKG1heGltdW0sIG1pbmltdW0sIGRlZmF1bHQpXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEVsZW1lbnRTaXplXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAtIERlZmF1bHQgd2lkdGggb2YgdGhlIG5vZGVzXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBEZWZhdWx0IGhlaWdodCBvZiB0aGUgbm9kZXNcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbldpZHRoIC0gTWluaW11bSB3aWR0aCBvZiB0aGUgbm9kZXNcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFdpZHRoIC0gTWF4aW11bSB3aWR0aCBvZiB0aGUgbm9kZXNcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbkhlaWdodCAtIE1pbmltdW0gaGVpZ2h0IG9mIHRoZSBub2Rlc1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4SGVpZ2h0IC0gTWF4aW11bSBoZWlnaHQgb2YgdGhlIG5vZGVzXHJcbiovXHJcblxyXG4vKipcclxuICogU2NhbGUgYm91bmRzLlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTY2FsZUJvdW5kc1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBJbiBmYWN0IHRoZSBvYmplY3QgaXMgYSBtYXAgYmV0d2VlbiBjb2xvcnMgYW5kIGtleXMgKGlkcykgb2YgZWxlbWVudHMsXHJcbiAqIGJ1dCB0aGVyZSBhcmUgbnVtYmVyIG9mIGRlZmF1bHQgY29sb3Iga2V5cy5cclxuICogQHR5cGVkZWYge09iamVjdC48c3RyaW5nLCBzdHJpbmc+fSBDb2xvcnNcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRlcm1pbmF0aW9uVGV4dCAtIENvbG9yIG9mIHRoZSB0ZXh0IG9uIHRlcm1pbmF0aW9uIG5vZGVzXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0ZXh0IC0gQ29sb3Igb2YgdGhlIHRleHQgb24gdGhlIGdyYXBoJ3Mgbm9kZXMsXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1bmtub3duIC0gQ29sb3IgZm9yIG5vZGVzIHdob3NlIGlkIGlzIHVua25vd25cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlZmF1bHQgLSBEZWZhdWx0IGNvbG9yIGZvciBub2Rlc1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2VsZWN0ZWQgLSBDb2xvciBvZiBlbGVtZW50cyB3aGljaCBhcmUgc2VsZWN0ZWRcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJsdXJlZCAtIENvbG9yIGZvciBibHVyZWQgZWxlbWVudHNcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxpbmsgLSBDb2xvciBmb3IgbGlua3NcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRlcm1pbmF0aW9uTGluayAtIENvbG9yIGZvciB0ZXJtaW5hdGlvbiBsaW5rc1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXNwZWN0TGluayAtIENvbG9yIGZvciBhc3BlY3QgbGlua3NcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBUb29sIGJ1dHRvbi5cclxuICogQHR5cGVkZWYge09iamVjdH0gTGlua1Rvb2xCdXR0b25cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGltYWdlIC0gc3JjIG9yIHhocmVmIGZvciB0b29sIGJ1dHRvblxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBidXR0b24gd2lkdGhcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhlaWdodCAtIGJ1dHRvbiBoZWlnaHRcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IHBhcmFtZXRlcnMgc2V0IGZvciBMaW5lYWdlR3JhbS4gWW91IGNhbiBwYXNzIGFueSBvZiB0aGVzZSBwYXJhbWV0ZXJzIGludG8gdGhlIGNvbnN0cnVjdG9yIGR1cmluZyB0aGUgTGluZWFnZUdyYW0gaW5pdGlhbGl6YXRpb24uXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhcmFtZXRlcnNcclxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IGdyYXBoUGxhY2UgLSBJZGVudGlmaWVyIG9mIHRoZSByb290IGh0bWwgZWxlbWVudCBmb3IgYmluZGluZyBncmFwaCBvciBqdXN0IHJvb3QgSFRNTEVsZW1lbnRcclxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IG1hcFJvb3RIdG1sIC0gSWRlbnRpZmllciBvZiB0aGUgcm9vdCBodG1sIGVsZW1lbnQgZm9yIGJpbmRpbmcgbWFwIG9yIGp1c3Qgcm9vdCBodG1sIGVsZW1lbnRcclxuICogQHByb3BlcnR5IHtEYXRhUHJvdmlkZXJ9IGRhdGFQcm92aWRlciAtIEZ1bmN0aW9uIHRoYXQgcmVzaWV2ZXMgYW5kIHJldHVybnMgZGF0YSBmb3IgdGhlIGdyYXBoXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmb2N1c05vZGUgLSBGb2N1cyBub2RlIGlkXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGxhdW5jaEV4dGVybmFsIC0gSXQgY2FuIGJlIGNhbGxlZCBpbiBvcmRlciB0byBnZXQgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBzb21lIGVsZW1lbnQgaW4gZGVyaXZhdGlvbiBtYXAgYW5kIGluIG1haW4gY2xhc3MuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7RWxlbWVudFNpemV9IGVsZW1lbnRTaXplIC0gU2l6ZSBvZiB0aGUgbm9kZXMgb2YgdGhlIGdyYXBoXHJcbiAqIEBwcm9wZXJ0eSB7RWxlbWVudFNpemV9IG92ZXJWaWV3RWxlbWVudFNpemUgLSBTaXplIG9mIHRoZSBub2RlcyBvZiB0aGUgZ3JhcGggaW4gT3ZlclZpZXdGcmFtZVxyXG4gKlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGF5b3V0U3RlcCAtIERpc3RhbmNlIGJldHdlZW4gZWxlbWVudHMgb2YgdGhlIGdyYXBoXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXlvdXRJdGVyYXRpb25zIC0gSG93IG11Y2ggaXRlcmF0aW9ucyB3aWxsIGJlIGRvbmUgZHVyaW5nIHRoZSBsYXlvdXQgYWxnb3JpdGhtXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXRCZXR3ZWVuR3JvdXBzIC0gQWRkaXRpb25hbCBvZmZzZXQgYmV0d2VlbiBncm91cHMgb2Ygbm9kZXMgKHZpZXdGcmFtZSBncm91cHMpXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Q29sb3JzfSBjb2xvcnMgLSBDb2xvciBtYXBcclxuICpcclxuICogQHByb3BlcnR5IHtib29sZWFufSBhbmltYXRpb24gLSBJZiBpdCdzIHRydWUsIHRoZSBhbmltYXRpb24gaXMgYWxsb3dlZC4gQnkgZGVmYXVsdCAtIHRydWVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heEZyYW1lUmF0ZSAtIE1heGltdW0gc3BlZWQgb2YgYW5pbWF0aW9uLiBCeSBkZWZhdWwgLSA1MCBmcmFtZXMgcGVyIHNlY29uZFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluRnJhbWVSYXRlIC0gTWluaW11bSBzcGVlZCBvZiBhbmltYXRpb24uIEJ5IGRlZmF1bCAtIDEwIGZyYW1lcyBwZXIgc2Vjb25kXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhbmltYXRpb25TdGVwIC0gSG93IGZhciB2aWV3RnJhbWUgcG9zaXRpb24gaXMgY2hhbmdpbmcgcGVyIGFuaW1hdGlvbiBmcmFtZVxyXG4gKlxyXG4gKiBAcHJvcGVydHkge1ZpZXdGcmFtZURlZmluaXRpb25bXX0gLSBWaWV3IGZyYW1lcyBkZWZpbml0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZnVsbFNjcmVlbk1vZGUgLSBEZWZpbmVzIHdoZXRoZXIgd2Ugd2FudCB0byBvcGVuIExHIGluIGZ1bGwtc2NyZWVuLW1vZGUgb3IgaW4gdGhlIHJlZ3VsYXIgbW9kZVxyXG4gKlxyXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBzdHJpbmc+fSBpbWFnZXMgLSBNYXAgYmV0d2VlbiBub2RlIHR5cGVzIGFuZCBpbWFnZSB1cmxzLlxyXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBzdHJpbmc+fSBpY29ucyAtIE1hcCBiZXR3ZWVuIG5vZGUgdHlwZXMgYW5kIGljb25zIChjc3MpLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVzb3VyY2VQYXRoIC0gUHJlZml4IGZvciByZXNvdXJjZXMgbGlrZSBpbWFnZXMgKG9wdGlvbmFsKVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHVzZVBPU1RFeGVjdXRvciAtIHRvIG1ha2UgYWJsZSB1c2UgcG9zdCByZXF1ZXN0cyBmb3Igc3BhcnFsUHJvdmlkZXJcclxuICogQHByb3BlcnR5IHtQb2ludH0gZnJhbWVQYWRkaW5nIC0gVmlld1BvcnRzIGVuYWJsZWQgYXJlYSBleHBhbmRlZCBieSB0aGlzIHZhbHVlXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2xpcE5vZGVzIC0gVGVsbHMgdXMgZG8gb3Igbm90IGNsaXBwaW5nIG5vZGVzIGJ5IHZpZXdGcmFtZXNcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZyYW1lQm9yZGVyV2lkdGggLSBXaWR0aCBvZiB0aGUgZnJhbWUgYm9yZGVyXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvd0NvbGxhcHNlZEZyYW1lcyAtIFRlbGxzIHdoZXRoZXIgaGlkZSBvciBzaG93IGNvbGxhcHNlZCB2aWV3RnJtYWVzIGluIHRoZSBib3R0b20gb2YgdGhlIGdyYXBoLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge1BvaW50fSBkZWZhdWx0U2NhbGVcclxuICogQHByb3BlcnR5IHtTY2FsZUJvdW5kc30gc2NhbGVCb3VuZHMgLSBDb250YWlucyBtaW5pbWFsKG1pbikgYW5kIG1heGltdW0obWF4KSB2YWx1ZXMgb2YgdGhlIHNjYWxlLlxyXG4gKiBAcHJvcGVydHkge1NjYWxlQm91bmRzfSBvdmVyVmlld1NjYWxlQm91bmRzIC0gQ29udGFpbnMgbWluaW1hbChtaW4pIGFuZCBtYXhpbXVtKG1heCkgdmFsdWVzIG9mIHRoZSBzY2FsZSBmb3IgT3ZlclZpZXdGcmFtZS5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjYWxlU3RlcCAtIEhvdyBtdWNoIHNjYWxlIGNoYW5nZXMgcGVyIHN0ZXAuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7U2l6ZX0gdGVybWluYXRpb25Ob2RlU2l6ZSAtIFNpemUgb2YgdGhlIHRlcm1pbmF0aW9uIG5vZGVzXHJcbiAqIEBwcm9wZXJ0eSB7U2l6ZX0gZGF0YVpvbmVTaXplIC0gU2l6ZSBvZiB6b25lcyBpbiBkYXRhIGNvbnRhaW5lci4gWm9uZXMgYXJlIGdyb3VwaW5nIGFuZCBzb3J0aW5nIGluIHNwZWNpYWwgYXJlYXMgdG8gaW1wbGVtZW50IGJpbmFyeSBzZWFyY2hpbmdcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHpvbmVzSW5Hcm91cCAtIEdyb3VwaW5nIGRhdGEgem9uZXMgaW4gYmlnZ2VyIGdyb3VwcyBieSBncm91cHMgb2YgKGZvciBleGFtcGxlKSBmb3VyXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsaW5rUm91dGluZyAtIExpbmtzIHJvdXRpbmcgKGJhc2VkIG9uIGpvaW50anMgcm91dGluZ3M6IG1ldHJvL25vcm1hbC9tYW5oYXR0YW4vb3J0aG9nb25hbClcclxuICpcclxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgTGlua1N0eWxlRGVmaW5pdGlvbj59IGxpbmtTdHlsZXMgLSBNYXAgYmV0d2VlbiB0aGUgbGlua1R5cGVzIGFuZCBMaW5rU3R5bGVzLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZ3JhcGhPcmllbnRhdGlvbiAtIE9yaWVudGF0aW9uIG9mIHRoZSBncmFwaC4gQ2FuIGJlOiAnbGVmdC10by1yaWdodCcsICdyaWdodC10by1sZWZ0JywgJ3RvcC10by1ib3R0b20nLCAnYm90dG9tLXRvLXRvcCdcclxuICogQHByb3BlcnR5IHtEZXJpdmF0aW9uTWFwUGFyYW1ldGVyc30gZGVyaXZhdGlvbk1hcCAtIHBhcmFtZXRlcnMgc2V0IGZvciBEZXJpdmF0aW9uTWFwXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIGJvb2xlYW4+fSBtYXNrIC0gbWFwIG9mIGVsZW1lbnRzLiBFbGVtZW50cyBpbiB0aGUgbWFzayB3aWxsIGJlIGhpZGRlblxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlcnJvckNhbGxCYWNrIC0gaXQgaXMgY2FsbGVkIGluIHJlc3BvbnNlIHRvIHdhcm5pbmdzIGFuZCBlcnJvcnNcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGRlZmF1bHQgc2V0IG9mIHBhcmFtZXRlcnNcclxuICogQHJldHVybnMge1BhcmFtZXRlcnN9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFBhcmFtZXRlcnNTZXQgKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAvLyBpbml0aWFsaXphdGlvblxyXG4gICAgICAgIGdyYXBoUGxhY2U6IHVuZGVmaW5lZCwgLy8gSWRlbnRpZmllciBvZiB0aGUgcm9vdCBodG1sIGVsZW1lbnQgZm9yIGJpbmRpbmcgZ3JhcGhcclxuICAgICAgICBtYXBSb290SHRtbDogdW5kZWZpbmVkLCAgICAgLy8gSWRlbnRpZmllciBvZiB0aGUgcm9vdCBodG1sIGVsZW1lbnQgZm9yIGJpbmRpbmcgbWFwIG9yIGp1c3Qgcm9vdCBIVE1MRWxlbWVudFxyXG4gICAgICAgIGRhdGFQcm92aWRlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgIGZvY3VzTm9kZTogdW5kZWZpbmVkLFxyXG5cclxuICAgICAgICAvLyBFbGVtZW50c1xyXG4gICAgICAgIGVsZW1lbnRTaXplOiB7IHdpZHRoOiAxMjAsIGhlaWdodDogMTIwLCBtaW5XaWR0aDogNDUsIG1heFdpZHRoOiA1NTAsIG1pbkhlaWdodDogNDUsIG1heEhlaWdodDogNTUwIH0sIC8vIGRlZmF1bHQgZWxlbWVudCBzaXplXHJcbiAgICAgICAgb3ZlclZpZXdFbGVtZW50U2l6ZTogeyB3aWR0aDogMTIwLCBoZWlnaHQ6IDEyMCwgbWluV2lkdGg6IDUsIG1heFdpZHRoOiA1NTAsIG1pbkhlaWdodDogNSwgbWF4SGVpZ2h0OiA1NTAgfSwgLy8gZGVmYXVsdCBlbGVtZW50IHNpemUgZm9yIHRoZSBPdmVyVmlld0ZyYW1lXHJcblxyXG4gICAgICAgIC8vIExheW91dFxyXG4gICAgICAgIGxheW91dFN0ZXA6IHsgeDogMjAwLCB5OiAxMDAgfSwgLy8gRGlzdGFuY2UgYmV0d2VlbiBlbGVtZW50cyBvZiB0aGUgZ3JhcGhcclxuICAgICAgICBsYXlvdXRJdGVyYXRpb25zOiAzMiwgLy8gSG93IG11Y2ggaXRlcmF0aW9ucyB3aWxsIGhhdmUgYmVlbiBkb25lIGR1cmluZyB0aGUgbGF5b3V0IGFsZ29yaXRobVxyXG4gICAgICAgIG9mZnNldEJldHdlZW5Hcm91cHM6IDE1MCwgLy8gQWRkaXRpb25hbCBvZmZzZXQgYmV0d2VlbiBncm91cHMgb2Ygbm9kZXMgKHZpZXdGcmFtZSBncm91cHMpXHJcblxyXG4gICAgICAgIC8vIENvbG9yIHNjaGVtZVxyXG4gICAgICAgIGNvbG9yczogeyAvLyBjb2xvciBtYXBcclxuICAgICAgICAgICAgJ2VkZzpEYXRhYmFzZUNvbHVtbic6ICcjMjNiMGY0JyxcclxuICAgICAgICAgICAgJ2VkZzpTb2Z0d2FyZVByb2dyYW0nOiAnZ3JlZW4nLFxyXG4gICAgICAgICAgICAnaHR0cDovL2VkZy50b3BicmFpZC5zb2x1dGlvbnMvbW9kZWwvU29mdHdhcmVQcm9ncmFtJzogJ2dyZWVuJyxcclxuICAgICAgICAgICAgJ2h0dHA6Ly9lZGcudG9wYnJhaWQuc29sdXRpb25zL21vZGVsL1JlcG9ydCc6ICcjMjNiMGY0JyxcclxuICAgICAgICAgICAgJ2h0dHA6Ly9lZGcudG9wYnJhaWQuc29sdXRpb25zL21vZGVsL1JlcG9ydENvbHVtbic6ICcjZmY3NDEwJyxcclxuXHJcbiAgICAgICAgICAgICd0ZXJtaW5hdGlvblRleHQnOiAnd2hpdGUnLFxyXG4gICAgICAgICAgICAndGV4dCc6ICdibGFjaycsXHJcbiAgICAgICAgICAgICd1bmtub3duJzogJ2JsYWNrJyxcclxuICAgICAgICAgICAgJ2RlZmF1bHQnOiAnYmxhY2snLFxyXG4gICAgICAgICAgICAnc2VsZWN0ZWQnOiAncmVkJyxcclxuICAgICAgICAgICAgJ2JsdXJlZCc6ICdyZ2JhKDEwMCwgMTAwLCAxMDAsIDAuMyknLFxyXG4gICAgICAgICAgICAndGVybWluYXRpb25MaW5rJzogJyM5MDk0YTgnLFxyXG4gICAgICAgICAgICAnYXNwZWN0TGluayc6ICdyZ2JhKDAsIDI1NSwgMCwgMC41KScsXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gQW5pbWF0aW9uXHJcbiAgICAgICAgYW5pbWF0aW9uOiB0cnVlLCAvLyBzd2l0aGMgb2ZmL29uIHRoZSBhbmltYXRpb25cclxuICAgICAgICBtYXhGcmFtZVJhdGU6IDUwLFxyXG4gICAgICAgIG1pbkZyYW1lUmF0ZTogMTAsXHJcbiAgICAgICAgYW5pbWF0aW9uU3RlcDogNjAsXHJcblxyXG4gICAgICAgIC8vIFZpZXcgZnJhbWVzIGRlZmluaXRpb25cclxuICAgICAgICBmdWxsU2NyZWVuTW9kZTogdHJ1ZSwgLy8gRGVmaW5lcyB3aGV0aGVyIHdlIHdhbnQgdG8gb3BlbiBMRyBpbiBmdWxsLXNjcmVlbi1tb2RlIG9yIGluIHRoZSByZWd1bGFyIG1vZGVcclxuICAgICAgICB2aWV3RnJhbWVzOiBbXHJcbiAgICAgICAgICAgIC8vIHtcclxuICAgICAgICAgICAgLy8gICAgIGlkOiAnZnVsbFBhbmVsJywgLy8gaWRlbnRpZmllciBvZiB0aGUgZnJhbWUgbXVzdCBiZSB1bmlxdWVcclxuICAgICAgICAgICAgLy8gICAgIGxhYmVsOiAnQWxsJywgICAvLyBsYWJlbCBpbiB0aGUgcmlnaHQtdG9wIGNvcm5lclxyXG4gICAgICAgICAgICAvLyAgICAgYm9yZGVyQ29sb3I6ICcjMjNiMGY0JyxcclxuICAgICAgICAgICAgLy8gICAgIGJhY2tncm91bmRDb2xvcjogJyNmNGY0ZmYnLFxyXG4gICAgICAgICAgICAvLyAgICAgLy8gSXQgdGVsbHMgaG93IG11Y2ggc3BhY2Ugd2lsbCB0YWtlcyB0aGlzIGZyYW1lIG9uIHRoZSBwYXBlci5cclxuICAgICAgICAgICAgLy8gICAgIC8vIHxbMV1bIDIgXVsgIDMgICBdfCBvclxyXG4gICAgICAgICAgICAvLyAgICAgLy8gfFsgIDUwICBdWyAgNTAgIF18IG9yXHJcbiAgICAgICAgICAgIC8vICAgICAvLyB8WzEwXVsxMF1bMTBdWzEwXXxcclxuICAgICAgICAgICAgLy8gICAgIHNwYWNlU2hhcmU6IDEsXHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICBdLFxyXG5cclxuICAgICAgICAvLyBJbWFnZXMgZm9yIHR5cGVzXHJcbiAgICAgICAgaW1hZ2VzOiB7ICAgLy8gbWFwIG9mIGltYWdlcyBmb3IgdHlwZXMgb2YgZWxlbWVudHNcclxuICAgICAgICAgICAgJ2VkZzpEYXRhYmFzZUNvbHVtbic6ICdzcmMvcmVzb3VyY2VzL2ltYWdlcy90YWJsZS5wbmcnLFxyXG4gICAgICAgICAgICAnZWRnOlRhYmxlJzogJ3NyYy9yZXNvdXJjZXMvaW1hZ2VzL3RhYmxlLnBuZycsXHJcbiAgICAgICAgICAgICdlZGc6U29mdHdhcmVQcm9ncmFtJzogJ3NyYy9yZXNvdXJjZXMvaW1hZ2VzL2FwcC5wbmcnLFxyXG4gICAgICAgICAgICAnaHR0cDovL2VkZy50b3BicmFpZC5zb2x1dGlvbnMvbW9kZWwvU29mdHdhcmVQcm9ncmFtJzogJ3NyYy9yZXNvdXJjZXMvaW1hZ2VzL2FwcC5wbmcnLFxyXG4gICAgICAgICAgICAnZWRnOkxpbmVhZ2VNb2RlbCc6ICdzcmMvcmVzb3VyY2VzL2ltYWdlcy9mb3JtLnBuZycsXHJcbiAgICAgICAgICAgICdlZGc6U2NoZWR1bGUnOiAnc3JjL3Jlc291cmNlcy9pbWFnZXMvY29sdW1uLnBuZycsXHJcbiAgICAgICAgICAgIC8vICdsaW5rLW9wdGlvbnMnOiAnc3JjL3Jlc291cmNlcy9pbWFnZXMvZGVyaXZhdGlvbi1tYXAucG5nJyxcclxuICAgICAgICAgICAgLy8gJ2ZlZWQtcGlwZSc6ICdzcmMvcmVzb3VyY2VzL2ltYWdlcy9mZWVkLXBpcGUucG5nJyxcclxuICAgICAgICAgICAgJ3Vua25vd24nOiAnc3JjL3Jlc291cmNlcy9pbWFnZXMvdW5rbm93bi5wbmcnLCAvLyBJdCB3aWxsIHdvcmsgb25seSBmb3IgdW5rbm93biB0eXBlc1xyXG4gICAgICAgIH0sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB5b3Ugd2FudCBjaGFuZ2UgaXQgZm9yIGxvc3QgaW1hZ2VzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB5b3Ugc2hvdWxkIGNoYW5nZSBpdCBpbiB0aGUgYm90dG9tIG9mICcuL2pvaW50Vmlld3MvZ3JhcGhFbGVtZW50cy5qcydcclxuXHJcbiAgICAgICAgcmVzb3VyY2VQYXRoOiAnJywgLy8gcHJlZml4IGZvciByZXNvdXJjZXMgbGlrZSBpbWFnZXMgKG9wdGlvbmFsKVxyXG4gICAgICAgIGxhdW5jaEV4dGVybmFsOiBudWxsLCAvL29wdGlvbmFsXHJcbiAgICAgICAgdXNlUE9TVEV4ZWN1dG9yOiBmYWxzZSwgLy8gdG8gbWFrZSBhYmxlIHVzZSBwb3N0IHJlcXVlc3RzIGZvciBzcGFycWxQcm92aWRlclxyXG5cclxuICAgICAgICAvLyBCZSBjYXJlZnVsISBJZiB5b3Ugd2FudCB0byBjaGFuZ2UgaXQsIHlvdSBzaG91bGQgcmVtZW1iZXIgYWJvdXQgY3NzICgudHFfbGluZWFnZV91aSBlLnQuYy4pXHJcbiAgICAgICAgZnJhbWVQYWRkaW5nOiB7IHg6IDU1LCB5OiA1NSB9LCAvLyB2aWV3UG9ydHMgZW5hYmxlZCBhcmVhIGV4cGFuZGVkIGJ5IHRoaXMgdmFsdWVcclxuXHJcbiAgICAgICAgY2xpcE5vZGVzOiBmYWxzZSwgLy8gdGVsbHMgdXMgZG8gb3Igbm90IGNsaXBwaW5nIG5vZGVzIGJ5IHZpZXdGcmFtZXMuXHJcbiAgICAgICAgZnJhbWVCb3JkZXJXaWR0aDogMywgLy8gc3R5bGluZ1xyXG5cclxuICAgICAgICBzaG93Q29sbGFwc2VkRnJhbWVzOiBmYWxzZSxcclxuXHJcbiAgICAgICAgZGVmYXVsdFNjYWxlOiB7IHg6IDEuMCwgeTogMS4wIH0sIC8vIEl0J3MgbmVjZXNzYXJ5IGZvciBjYWxjdWxhdGlvbnNcclxuICAgICAgICBzY2FsZUJvdW5kczogeyBtaW46IDAuNywgbWF4OiAxLjUgfSxcclxuICAgICAgICBvdmVyVmlld1NjYWxlQm91bmRzOiB7IG1pbjogMC4wMSwgbWF4OiAxNSB9LCAvLyBzY2FsZSBib3VuZHMgZm9yIG92ZXJWaWV3IGZyYW1lXHJcbiAgICAgICAgc2NhbGVTdGVwOiAwLjEsIC8vIHN0ZXAgb2Ygc2NhbGUgY2hhbmdpbmdcclxuXHJcbiAgICAgICAgdGVybWluYXRpb25Ob2RlU2l6ZTogeyB3aWR0aDogMzAsIGhlaWdodDogMzAgfSwgLy8gc2l6ZSBvZiB0aGUgdGVybWluYXRpb24gbm9kZXNcclxuICAgICAgICBkYXRhWm9uZVNpemU6IHsgd2lkdGg6IDgwMCwgaGVpZ2h0OiA2MDAgfSwgICAgICAvLyBzaXplIG9mIHpvbmVzIGluIGRhdGEgY29udGFpbmVyLiBab25lcyBhcmUgZ3JvdXBpbmcgYW5kIHNvcnRpbmcgaW4gc3BlY2lhbCBhcmVhcyB0byBpbXBsZW1lbnQgYmluYXJ5IHNlYXJjaGluZ1xyXG4gICAgICAgIHpvbmVzSW5Hcm91cDogNCwgIC8vIGdyb3VwaW5nIGRhdGEgem9uZXMgaW4gYmlnZ2VyIGdyb3VwcyBieSBncm91cHMgb2YgKGZvciBleGFtcGxlKSBmb3VyXHJcbiAgICAgICAgbGlua1JvdXRpbmc6ICdtZXRybycsIC8vIGxpbmtzIHJvdXRpbmcgKGJhc2VkIG9uIGpvaW50anMgcm91dGluZ3M6IG1ldHJvL25vcm1hbC9tYW5oYXR0YW4vb3J0aG9nb25hbClcclxuXHJcbiAgICAgICAgbGlua1N0eWxlczoge1xyXG4gICAgICAgICAgICAnZGVmYXVsdC1saW5rLXN0eWxlJzogREVGQVVMVF9MSU5LX1NUWUxFLFxyXG4gICAgICAgICAgICAnZmVlZHBpcGUnOiBGRUVEX1BJUEVfTElOS19TVFlMRSxcclxuICAgICAgICAgICAgJ3RxLWxnLWdyb3VwJzogREVGQVVMVF9HUk9VUF9MSU5LX1NUWUxFLFxyXG4gICAgICAgICAgICAvLyBFeGFtcGxlOlxyXG4gICAgICAgICAgICAvLyAnZmVlZHBpcGUnOiB7XHJcbiAgICAgICAgICAgIC8vICAgICBjc3NDbGFzczogJ2xpbmVhZ2UtZ3JhbS1mZWVkLXBpcGUtbGluaycsXHJcbiAgICAgICAgICAgIC8vICAgICBsaW5lVHlwZTogJ3NvbGlkJywgLy8gJ2Rhc2hlZCdcclxuICAgICAgICAgICAgLy8gICAgIGNvbG9yOiAnIzNjNDI2MCcsXHJcbiAgICAgICAgICAgIC8vICAgICB0b29sQnV0dG9uOiB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgaW1hZ2U6ICdzcmMvcmVzb3VyY2VzL2ltYWdlcy9mZWVkLXBpcGUucG5nJyxcclxuICAgICAgICAgICAgLy8gICAgICAgICB3aWR0aDogMzAsXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgaGVpZ2h0OiAzMCxcclxuICAgICAgICAgICAgLy8gICAgICAgICBhbHdheXNWaXNpYmxlOiB0cnVlLCBcclxuICAgICAgICAgICAgLy8gICAgIH0sXHJcbiAgICAgICAgICAgIC8vICAgICB0aGlja25lc3M6IDMsXHJcbiAgICAgICAgICAgIC8vICAgICBoYXNBcnJvdzogdHJ1ZSxcclxuICAgICAgICAgICAgLy8gfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpYWdyYW1UeXBlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgZ3JhcGhPcmllbnRhdGlvbjogJ2xlZnQtdG8tcmlnaHQnLCAvLyBDYW4gYmU6ICdsZWZ0LXRvLXJpZ2h0JywgJ3JpZ2h0LXRvLWxlZnQnLCAndG9wLXRvLWJvdHRvbScsICdib3R0b20tdG8tdG9wJ1xyXG4gICAgICAgIGxheW91dEFsZ29yaXRobTogJ3NhbmtleScsIC8vIENhbiBiZTogJ3NhbmtleScsICdmbG93LWRpcmVjdGVkJ1xyXG4gICAgICAgIGRlcml2YXRpb25NYXA6IGdldERlcml2YXRpb25NYXBQYXJhbWV0ZXJTZXQoKSxcclxuICAgICAgICBtYXNrOiB1bmRlZmluZWQsIC8vIE1hcCBvZiBlbGVtZW50cy4gRWxlbWVudHMgaW4gdGhlIG1hc2sgd2lsbCBiZSBoaWRkZW5cclxuXHJcbiAgICAgICAgZXJyb3JDYWxsQmFjazogdW5kZWZpbmVkLCAvLyBJdCBpcyBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gd2FybmluZ3MgYW5kIGVycm9yc1xyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBtYWluIGNsYXNzIG9mIHRoZSBsaWJyYXJ5LCB0aGF0IG1hbmFnZSBhbGwgdmlld3MgYW5kIGRhdGEuXHJcbiAqIENyZWF0ZXMgdHdvIHZpZXcgb24gdGhlIGluaXRpYWxpemF0aW9uIHN0YWdlLiBUaGUgZmlyc3QgdmlldyBpcyBhIExpbmVhZ2UgZGlhZ3JhbSB2aWV3LlxyXG4gKiBUaGUgc2Vjb25kIHZpZXcgaXMgYSBCaXJkIEV5ZSB2aWV3LiBBbHNvIHRoZSBtYXAgY2FuIGJlIHBsYWNlZCBvbiB0aGUgcGFnZSBpZiB0aGUgbWFwUm9vdEh0bWxJZFxyXG4gKiB3YXMgc3BlY2lmaWVkIGluIHRoZSBwYXNzZWQgcGFyYW1ldGVycy5cclxuICogQGNsYXNzXHJcbiAqIEBhdWdtZW50cyBTdWJzY3JpYmFibGVcclxuICogQHBhcmFtIHtQYXJhbWV0ZXJzfSBwYXJhbWV0ZXJzIC0gUGFyYW1ldGVycyBzZXRcclxuICpcclxuICogQGZpcmVzIHNlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZFxyXG4gKiBAZmlyZXMgaGlzdG9yeS1zdGF0ZS1jaGFuZ2VkXHJcbiAqIEBmaXJlcyBmb2N1cy1ub2RlLWNoYW5nZWRcclxuICogQGZpcmVzIGN1cnJlbnQtdmlldy1jaGFuZ2VkXHJcbiAqIEBmaXJlcyBzY2FsZS12YWx1ZS1jaGFuZ2VkXHJcbiAqIEBmaXJlcyBkaWFncmFtLXN0YXRlLWNoYW5nZWRcclxuICogQGZpcmVzIHZpZXctZnJhbWUtc3RhdGUtY2hhbmdlZFxyXG4gKiBAZmlyZXMgZGVyaXZhdGlvbi1tYXAtc3RhdGUtY2hhbmdlZFxyXG4gKiBAZmlyZXMgZGVyaXZhdGlvbi1tYXAtc3RhdGUtaW5pdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIExpbmVhZ2VHcmFtIChwYXJhbWV0ZXJzKSB7XHJcbiAgICAvLyBFdmVudHNcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVsZW1lbnQgc2VsZWN0ZWQgZXZlbnQgLSBmaXJlcyB3aGVuIG9iamVjdCBjaGFuZ2VzIGVsZW1lbnQgc2VsZWN0aW9uXHJcbiAgICAgKiBTZWxlY3RlZCBlbGVtZW50IGlzIHJldHVybmVkIGFzIGEgcGFyYW1ldGVyIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBldmVudCBzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWRcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge1B1YmxpY05vZGVNb2RlbHxQdWJsaWNMaW5rTW9kZWx8dW5kZWZpbmVkfSBlbGVtZW50IC0gU2VsZWN0ZWRFbGVtZW50XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgZmlyZXMgd2hlbiBuZXcgZWxlbWVudCBpcyBzZWxlY3RlZCBhcyBmb2N1c05vZGUuXHJcbiAgICAgKiBAZXZlbnQgZm9jdXMtbm9kZS1jaGFuZ2VkXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtQdWJsaWNOb2RlTW9kZWx9IGVsZW1lbnQgLSBGb2N1c05vZGUgbW9kZWxcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWaWV3IHN3aXRjaGVkIGV2ZW50IC0gZmlyZXMgd2hlbiBjdXJyZW50IHZpZXcgaXMgY2hhbmdlZFxyXG4gICAgICogVmlldyBpZCBpcyByZXR1cm5lZCBhcyBhIHBhcmFtZXRlciBvZiB0aGUgZXZlbnRcclxuICAgICAqIEBldmVudCBjdXJyZW50LXZpZXctY2hhbmdlZFxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2aWV3SWQgLSBTZWxlY3RlZFZpZXcgY2FuIHRha2UgdGhlIGZvbGxvd2luZyB2YWx1ZXM6ICdsaW5lYWdlRGlhZ3JhbScsICdiaXJkRXllJyBvciAnbm9uZSdcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsZSBjaGFuZ2VkIGV2ZW50IC0gZmlyZXMgd2hlbiBzY2FsZSB2YWx1ZSBvZiB0aGUgTGluZWFnZSBEaWFncmFtIHZpZXcgaXMgY2hhbmdlZC5cclxuICAgICAqIFtOZXcgc2NhbGUgdmFsdWVde0BsaW5rIFNjYWxlfSBpcyByZXR1cm5lZCBhcyBhIHBhcmFtZXRlciBvZiB0aGUgZXZlbnRcclxuICAgICAqIEBldmVudCBzY2FsZS12YWx1ZS1jaGFuZ2VkXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtTY2FsZX0gc2NhbGUgLSBOZXcgc2NhbGUgb2JqZWN0LlxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXRlIGNoYW5nZWQgZXZlbnQgLSBmaXJlcyB3aGVuIExpbmVhZ2VHcmFtIHN0YXRlIGlzIGNoYW5nZWQuXHJcbiAgICAgKiBFLmcuIGZyb20gYSBmZXRjaGluZyBzdGF0ZSB0byBhIHJlbmRlcmluZyBzdGF0ZS5cclxuICAgICAqIFRoZSBzdGF0ZSBzdHJpbmcgaWRlbnRpZmllciBpcyByZXR1cm5lZCBhcyBhIHBhcmFtZXRlciBvZiB0aGUgZXZlbnRcclxuICAgICAqIEBldmVudCBkaWFncmFtLXN0YXRlLWNoYW5nZWRcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGUgLSBQYXJhbWV0ZXIgY2FuIHRha2UgdGhlIGZvbGxvd2luZyB2YWx1ZXM6ICdmZXRjaGluZycgfCAncmVuZGVyaW5nJyB8ICdjb21wbGV0ZWQnIHwgJ2Vycm9yJ1xyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0IGZpcmVzIHdoZW4gdXNlciBpcyBuYXZpZ2F0aW5nIGFsb25nIHRoZSBoaXN0b3J5LlxyXG4gICAgICogQGV2ZW50IGhpc3Rvcnktc3RhdGUtY2hhbmdlZFxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7SGlzdG9yeVN0YXRlW119IHN0YXRlcyAtIExpc3Qgb2Ygc3RhdGVzXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY3VycmVudEluZGV4IC0gb3JkZXIgbnVtYmVyIG9mIHRoZSBjdXJyZW50IHN0YXRlIGluIHRoZSBsaXN0XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmlldyBmcmFtZSBzdGF0ZSBjaGFuZ2VkIC0gZmlyZXMgd2hlbiB0aGUgVmlldyBmcmFtZSBpcyBiZWluZyBjb2xsYXBzZWQgb3IgZXhwYW5kZWQuXHJcbiAgICAgKiBAZXZlbnQgdmlldy1mcmFtZS1zdGF0ZS1jaGFuZ2VkXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gaWQgb2YgdGhlIGNoYW5nZWQgVmlld0ZyYW1lXHJcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHZhbHVlIC0gdHJ1ZSAtIGV4cGFuZGVkLCBmYWxzZSAtIGNvbGxhcHNlZFxyXG4gICAgKi9cclxuXHJcbiAgICAvLyBJbml0XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7ICAgLy8gbWFrZSB0aGlzIGNsYXNzIFN1YnNjcmliYWJsZVxyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzOyAvLyBTYXZlIHBvaW50ZXIgdG8gYSBjb250ZXh0XHJcblxyXG4gICAgbGV0IF9zdGF0ZSA9ICdpbml0aWFsJztcclxuICAgIGxldCBfc2VsZWN0ZWRFbGVtZW50ID0gbnVsbDtcclxuICAgIGxldCBfZm9jdXNFbGVtZW50O1xyXG4gICAgbGV0IF9jdXJyZW50VmlldyA9ICdsaW5lYWdlRGlhZ3JhbSc7ICAgIC8vIFNldCB0aGUgbGluZWFnZURpYWdyYW0gdmlldyBhcyBhIGN1cnJlbnQgdmlld1xyXG5cclxuXHJcbiAgICBjb25zdCBkZWZhdWx0UGFyYW1ldGVyU2V0ID0gZ2V0RGVmYXVsdFBhcmFtZXRlcnNTZXQoKTsgLy8gR2V0aW5nIGRlZmF1bHQgcGFyYW1ldGVycyBzZXRcclxuICAgIC8vIElmIHRoZSBwYXJhbWV0ZXIgc2V0IGluY2x1ZGVzIHZpZXdGcmFtZXMgZGVmaW5pdGlvbiwgY2xlYXIgdGhlIHZpZXdGcmFtZXMgZGVmaW5pdGlvbiBpbiB0aGUgZGVmYXVsdCBzZXQgZm9yIGEgY29ycmVjdCBtZXJnaW5nXHJcbiAgICAvLyAoV2UgZG9uJ3Qgd2FudCB0byBnZXQgZXh0cmEgdmlld0ZyYW1lcyBmcm9tIHRoZSBkZWZhdWx0IHNldC4pXHJcbiAgICBpZiAocGFyYW1ldGVycyAmJiBwYXJhbWV0ZXJzLnZpZXdGcmFtZXMgJiYgcGFyYW1ldGVycy52aWV3RnJhbWVzLmxlbmd0aCA+IDApIGRlZmF1bHRQYXJhbWV0ZXJTZXQudmlld0ZyYW1lcyA9IHVuZGVmaW5lZDtcclxuICAgIC8vIE1lcmdpbmcgZGVmYXVsdCBwYXJhbWV0ZXJzIHNldCBhbmQgY3VzdG9tZSBwYXJhbWV0ZXJzIHNldFxyXG4gICAgY29uc3QgX3BhcmFtZXRlcnMgPSAgXy5tZXJnZShkZWZhdWx0UGFyYW1ldGVyU2V0LCBwYXJhbWV0ZXJzKTtcclxuXHJcbiAgICBjb25zdCBfZXJyb3JDYWxsYmFjayA9IChlKSA9PiB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBfcGFyYW1ldGVycy5lcnJvckNhbGxiYWNrICYmXHJcbiAgICAgICAgICAgIF9wYXJhbWV0ZXJzLmVycm9yQ2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvblxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHR5cGVvZiBlID09PSAnc3RyaW5nJyA/IG5ldyBFcnJvcihlKSA6IGU7XHJcbiAgICAgICAgICAgIF9wYXJhbWV0ZXJzLmVycm9yQ2FsbGJhY2suY2FsbCh0aGlzLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBJZiB0aGUgZ3JhcGhQbGFjZSBpcyB1bmRlZmluZWQgd2Ugc3RvcCB0aGUgd29ya2luZyBwcm9jZXNzLlxyXG4gICAgaWYgKCFwYXJhbWV0ZXJzLmdyYXBoUGxhY2UpIHRocm93IG5ldyBFcnJvcignVGhlIGdyYXBoIHBsYWNlIGlzblxcJ3Qgc3BlY2lmaWVkJyk7XHJcbiAgICBsZXQgZ3JhcGhQbGFjZUh0bWw7XHJcbiAgICBpZiAodHlwZW9mIHBhcmFtZXRlcnMuZ3JhcGhQbGFjZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBncmFwaFBsYWNlSHRtbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBhcmFtZXRlcnMuZ3JhcGhQbGFjZSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbWV0ZXJzLmdyYXBoUGxhY2UgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgZ3JhcGhQbGFjZUh0bWwgPSBwYXJhbWV0ZXJzLmdyYXBoUGxhY2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGdyYXBoIHBsYWNlIGlzblxcJ3Qgc3BlY2lmaWVkIG9yIHNwZWNpZGVkIGluY29ycmVjdGx5Jyk7XHJcbiAgICB9XHJcbiAgICAvLyBDcmVhdGluZyBodG1sIG1hcmt1cC5cclxuICAgIGNvbnN0IF9iYXNlID0gX2NyZWF0ZUJhc2UoZ3JhcGhQbGFjZUh0bWwpO1xyXG4gICAgY29uc3QgX2RhdGFQcm92aWRlciA9IF9wYXJhbWV0ZXJzLmRhdGFQcm92aWRlcjtcclxuICAgIGNvbnN0IF9zdGF0ZVN0b3JhZ2UgPSBuZXcgU3RhdGVTdG9yYWdlKF9wYXJhbWV0ZXJzKTtcclxuICAgIGNvbnN0IF9wcm9ncmVzc1NjcmVlbiA9IG5ldyBUUUdyYW1VSS5Qcm9ncmVzc1NjcmVlbih7XHJcbiAgICAgICAgYmFzZUVsZW1lbnQ6IF9iYXNlLmNvbnRhaW5lcixcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENyZWF0aW5nIHRoZSBkYXRhIGNvbnRhaW5lci5cclxuICAgIGxldCBfZGF0YUNvbnRhaW5lcjtcclxuXHJcbiAgICBsZXQgX2xpbmVhZ2VEaWFncmFtOyAvLyBMaW5lYWdlIGRpYWdyYW0gdmlld1xyXG4gICAgbGV0IF9iaXJkRXllOyAvLyBCaXJkRXllIGJpZXdcclxuICAgIGxldCBfZGVyaXZhdGlvbk1hcDtcclxuICAgIGxldCBfZ3JhcGhNYXA7IC8vIGRlZmluZSB2YXJpYWJsZVxyXG4gICAgbGV0IF9kZXJpdmF0aW9uTWFwUGFuZWw7XHJcblxyXG4gICAgbGV0IF9kaWFncmFtVHlwZSA9IF9wYXJhbWV0ZXJzLmRpYWdyYW1UeXBlO1xyXG5cclxuICAgIHNlbGYubGF1bmNoRXh0ZXJuYWwgPSBfcGFyYW1ldGVycy5sYXVuY2hFeHRlcm5hbDtcclxuXHJcbiAgICBfY3JlYXRlQ29tcG9uZW50cygpO1xyXG5cclxuICAgIF9mZXRjaERpYWdyYW0oe1xyXG4gICAgICAgIGZvY3VzTm9kZUlkOiBfcGFyYW1ldGVycy5mb2N1c05vZGUsXHJcbiAgICAgICAgdmlld0ZyYW1lczogX3BhcmFtZXRlcnMudmlld0ZyYW1lcyxcclxuICAgICAgICBsaW5lYWdlR3JhbVZpZXdDbGFzczogX3BhcmFtZXRlcnMubGluZWFnZUdyYW1WaWV3Q2xhc3MsXHJcbiAgICAgICAgZGlhZ3JhbVR5cGU6IF9kaWFncmFtVHlwZSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY292ZXJzIG5vZGVzIHBvc2l0aW9ucyB0byB0aGUgaW5pdGlhbC5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLnJlc2V0TGF5b3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnJlc2V0TGF5b3V0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gU2NhbGVcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW4gLSBUaGUgbWluaW11bSB2YWx1ZVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heCAtIFRoZSBtYXhpbXVtIHZhbHVlXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY3VyIC0gVGhlIGN1cnJlbnQgdmFsdWVcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHNjYWxlIG9mIHRoZSBtYWluIHZpZXcgYnkgdGhlIHN0ZXAgKGRlZmF1bDogKyswLjEpLlxyXG4gICAgICogQHJldHVybnMge1NjYWxlfVxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuem9vbUluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS56b29tSW4oKTtcclxuICAgICAgICAgICAgaWYgKF9ncmFwaE1hcCkgX2dyYXBoTWFwLnJlZHJhdyh7IHZpZXdGcmFtZXM6IF9saW5lYWdlRGlhZ3JhbS5nZXRWaWV3RnJhbWVzKCkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1pbjogX3BhcmFtZXRlcnMuc2NhbGVCb3VuZHMubWluLFxyXG4gICAgICAgICAgICBtYXg6IF9wYXJhbWV0ZXJzLnNjYWxlQm91bmRzLm1heCxcclxuICAgICAgICAgICAgY3VyOiBfc3RhdGUgPT09ICdjb21wbGV0ZWQnID8gX2xpbmVhZ2VEaWFncmFtLnNjYWxlKCkgOiBfcGFyYW1ldGVycy5kZWZhdWx0U2NhbGUsXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHNjYWxlIG9mIHRoZSBtYWluIHZpZXcgdG8gYmUgYWJsZSB0byBmaXQgd2hvbGUgZGlhZ3JhbSBpbiB0aGUgc2NyZWVuLlxyXG4gICAgICogQHJldHVybnMge1NjYWxlfVxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuem9vbVRvRml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgIF96b29tVG9GaXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWluOiBfcGFyYW1ldGVycy5zY2FsZUJvdW5kcy5taW4sXHJcbiAgICAgICAgICAgIG1heDogX3BhcmFtZXRlcnMuc2NhbGVCb3VuZHMubWF4LFxyXG4gICAgICAgICAgICBjdXI6IF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcgPyBfbGluZWFnZURpYWdyYW0uc2NhbGUoKSA6IF9wYXJhbWV0ZXJzLmRlZmF1bHRTY2FsZSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgY3VycmVudCB2aWV3IGlkXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IGN1cnJlbnRWaWV3SWQgLSdsaW5lYWdlRGlhZ3JhbScgfCAnYmlyZEV5ZScgfCAnbm9uZSdcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLmdldEN1cnJlbnRWaWV3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfY3VycmVudFZpZXc7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBjdXJyZW50IHN0YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzdGF0ZSAtICdmZXRjaGluZycgfCAnYWN0aXZlJyB8ICdjb21wbGV0ZWQnIHwgJ2Vycm9yJ1xyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdGF0ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHNjYWxlIG9mIHRoZSBtYWluIHZpZXcgYnkgdGhlIHN0ZXAgKGRlZmF1bDogLS0wLjEpLlxyXG4gICAgICogQHJldHVybnMge1NjYWxlfVxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuem9vbU91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX3N0YXRlID09PSAnY29tcGxldGVkJykge1xyXG4gICAgICAgICAgICBfbGluZWFnZURpYWdyYW0uem9vbU91dCgpO1xyXG4gICAgICAgICAgICBpZiAoX2dyYXBoTWFwKSBfZ3JhcGhNYXAucmVkcmF3KHsgdmlld0ZyYW1lczogX2xpbmVhZ2VEaWFncmFtLmdldFZpZXdGcmFtZXMoKSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWluOiBfcGFyYW1ldGVycy5zY2FsZUJvdW5kcy5taW4sXHJcbiAgICAgICAgICAgIG1heDogX3BhcmFtZXRlcnMuc2NhbGVCb3VuZHMubWF4LFxyXG4gICAgICAgICAgICBjdXI6IF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcgPyBfbGluZWFnZURpYWdyYW0uc2NhbGUoKSA6IF9wYXJhbWV0ZXJzLmRlZmF1bHRTY2FsZSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgc2NhbGUgb2YgdGhlIG1haW4gTGluZWFnZSBEaWFncmFtIHZpZXcuXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBzY2FsZVxyXG4gICAgICogQHJldHVybnMge1NjYWxlfVxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuem9vbSA9IGZ1bmN0aW9uIHpvb20gKHNjYWxlKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgaWYgKHNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICBfbGluZWFnZURpYWdyYW0uc2NhbGUoc2NhbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS5yZWRyYXcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWluOiBfcGFyYW1ldGVycy5zY2FsZUJvdW5kcy5taW4sXHJcbiAgICAgICAgICAgIG1heDogX3BhcmFtZXRlcnMuc2NhbGVCb3VuZHMubWF4LFxyXG4gICAgICAgICAgICBjdXI6IF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcgPyBfbGluZWFnZURpYWdyYW0uc2NhbGUoKSA6IF9wYXJhbWV0ZXJzLmRlZmF1bHRTY2FsZSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9iamVjdCB3aGljaCBwYXNzZWQgaW50byB0aGUgZXhwb3J0IGZ1bmN0aW9uIGluIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBFeHBvcnRQYXJhbXNcclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGZpbGUgbmFtZVxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgLSAocG5nL3N2ZylcclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2aWV3IC0gQmlyZEV5ZSAvIGxpbmVhZ2VHcmFtXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwb3J0cyB0aGUgZ3JhcGggaW4gYSBwbmcgb3Igc3ZnIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0ge0V4cG9ydFBhcmFtc30gb3B0aW9uc1xyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5leHBvcnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIG9wdGlvbnMudmlldyA9IG9wdGlvbnMudmlldyB8fCBfY3VycmVudFZpZXc7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudmlldyA9PT0gJ2xpbmVhZ2VEaWFncmFtJykge1xyXG4gICAgICAgICAgICBfbGluZWFnZURpYWdyYW0uZXhwb3J0KHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IG9wdGlvbnMudHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnZpZXcgPT09ICdiaXJkRXllJykge1xyXG4gICAgICAgICAgICBfYmlyZEV5ZS5leHBvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MgcHJpbnQgZGlhbG9nLlxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5wcmludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX2N1cnJlbnRWaWV3ID09PSAnbGluZWFnZURpYWdyYW0nKSB7XHJcbiAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS5wcmludCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoX2N1cnJlbnRWaWV3ID09PSAnYmlyZEV5ZScpIHtcclxuICAgICAgICAgICAgX2JpcmRFeWUucHJpbnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwYW5kcyBhbGwgbm9kZXNcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuZXhwYW5kQWxsTm9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBfZGF0YUNvbnRhaW5lci5ub2RlcztcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUuc2V0KCdleHBhbmRlZCcsIHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChfY3VycmVudFZpZXcgPT09ICdsaW5lYWdlRGlhZ3JhbScpIHtcclxuICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGFwc2VzIGFsbCBub2Rlc1xyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5jb2xsYXBzZUFsbE5vZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gX2RhdGFDb250YWluZXIubm9kZXM7XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLnNldCgnZXhwYW5kZWQnLCBmYWxzZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKF9jdXJyZW50VmlldyA9PT0gJ2xpbmVhZ2VEaWFncmFtJykge1xyXG4gICAgICAgICAgICBfbGluZWFnZURpYWdyYW0ucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgbWFwLCB1c2luZyBodG1sIGVsZW1lbnQgd2l0aCBzcGVjaWZpZWQgSUQgYXMgYSByb290IGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MRWxlbWVudH0gbWFwUm9vdEh0bWwgLSBJRCBvZiByb290IGVsZW1lbnQgb3IgSFRNTEVsZW1lbnRcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLnNldFJvb3RIdG1sRm9yTWFwID0gZnVuY3Rpb24gKG1hcFJvb3RIdG1sKSB7XHJcbiAgICAgICAgY29uc3QgbWFwSFRNTEVsZW1lbnQgPSBfZ2V0TWFwSFRNTChtYXBSb290SHRtbCk7XHJcbiAgICAgICAgX3BhcmFtZXRlcnMubWFwUm9vdEh0bWwgPSBtYXBSb290SHRtbDtcclxuICAgICAgICBfYmFzZS5tYXBIVE1MRWxlbWVudCA9IG1hcEhUTUxFbGVtZW50O1xyXG5cclxuICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICBfdXBkYXRlTWFwKF9kYXRhQ29udGFpbmVyLCBfbGluZWFnZURpYWdyYW0uZ2V0Vmlld0ZyYW1lcygpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBjaGFuZ2VzIGxheW91dCBhbGdvcml0aG0gZm9yIHRoZSBncmFwaC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmllbnRhdGlvbiAtIFZhbHVlczogJ3NhbmtleScsICdmbG93LWRpcmVjdGVkJ1xyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0TGF5b3V0QWxnb3JpdGhtID0gZnVuY3Rpb24gKGFsZ29yaXRobUlkKSB7XHJcbiAgICAgICAgaWYgKGFsZ29yaXRobUlkID09PSAnc2Fua2V5JyB8fCBhbGdvcml0aG1JZCA9PT0gJ2Zsb3ctZGlyZWN0ZWQnKSB7XHJcbiAgICAgICAgICAgIF9wYXJhbWV0ZXJzLmxheW91dEFsZ29yaXRobSA9IGFsZ29yaXRobUlkO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBfZGF0YUNvbnRhaW5lci5ub2Rlcy5tYXAobiA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IG4ubW9kZWw7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbW9kZWwuZGVmYXVsdFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgbW9kZWwudmlld0ZyYW1lT3duZXJJZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IF9kYXRhQ29udGFpbmVyLmxpbmtzLm1hcChsID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGwubW9kZWwuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsLm1vZGVsLnNvdXJjZVR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBsLm1vZGVsLnRhcmdldFR5cGUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZXMgPSBfbGluZWFnZURpYWdyYW0uZ2V0Vmlld0ZyYW1lcygpO1xyXG5cclxuICAgICAgICAgICAgbGF5b3V0LmRvTGF5b3V0KFxyXG4gICAgICAgICAgICAgICAgbm9kZXMsXHJcbiAgICAgICAgICAgICAgICBsaW5rcyxcclxuICAgICAgICAgICAgICAgIHZpZXdGcmFtZXMsXHJcbiAgICAgICAgICAgICAgICBfcGFyYW1ldGVycyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgX2RhdGFDb250YWluZXIucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICBfbGluZWFnZURpYWdyYW0ucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICBfYmlyZEV5ZS5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIGlmIChfZ3JhcGhNYXApIF9ncmFwaE1hcC5yZWRyYXcoe1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lczogX2xpbmVhZ2VEaWFncmFtLmdldFZpZXdGcmFtZXMoKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgbGF5b3V0IGFsZ29yaXRobSB3aGljaCBpcyBjdXJyZW50bHkgdXNlZCBmb3IgZGlhZ3JhbS5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcm91dGluZzogbWV0cm8vbm9ybWFsL21hbmhhdHRhblxyXG4gICAgICovXHJcbiAgICBzZWxmLmdldExheW91dEFsZ29yaXRobSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3BhcmFtZXRlcnMubGF5b3V0QWxnb3JpdGhtO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0IGNoYW5nZXMgb3JpZW50YXRpb24gb2YgdGhlIGdyYXBoXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZW50YXRpb24gLSBWYWx1ZXM6ICdsZWZ0LXRvLXJpZ2h0JywgJ3JpZ2h0LXRvLWxlZnQnLCAndG9wLXRvLWJvdHRvbScsICdib3R0b20tdG8tdG9wJ1xyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbiAob3JpZW50YXRpb24pIHtcclxuICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAob3JpZW50YXRpb24gJiYgKFxyXG4gICAgICAgICAgICBvcmllbnRhdGlvbiA9PT0gJ2xlZnQtdG8tcmlnaHQnIHx8XHJcbiAgICAgICAgICAgIG9yaWVudGF0aW9uID09PSAncmlnaHQtdG8tbGVmdCcgfHxcclxuICAgICAgICAgICAgb3JpZW50YXRpb24gPT09ICd0b3AtdG8tYm90dG9tJyB8fFxyXG4gICAgICAgICAgICBvcmllbnRhdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnXHJcbiAgICAgICAgKSkge1xyXG4gICAgICAgICAgICBfcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XHJcblxyXG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IF9kYXRhQ29udGFpbmVyLm5vZGVzLm1hcChuID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gbi5tb2RlbDtcclxuICAgICAgICAgICAgICAgIG1vZGVsLmRlZmF1bHRfeCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIG1vZGVsLmRlZmF1bHRfeSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIG1vZGVsLnZpZXdGcmFtZU93bmVySWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgbi5zZXRPcmllbnRhdGlvbihvcmllbnRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IF9kYXRhQ29udGFpbmVyLmxpbmtzLm1hcChsaW5rID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGxpbmsubW9kZWwuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsaW5rLm1vZGVsLnNvdXJjZVR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBsaW5rLm1vZGVsLnRhcmdldFR5cGUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZXMgPSBfbGluZWFnZURpYWdyYW0uZ2V0Vmlld0ZyYW1lcygpO1xyXG5cclxuICAgICAgICAgICAgbGF5b3V0LmRvTGF5b3V0KFxyXG4gICAgICAgICAgICAgICAgbm9kZXMsXHJcbiAgICAgICAgICAgICAgICBsaW5rcyxcclxuICAgICAgICAgICAgICAgIHZpZXdGcmFtZXMsXHJcbiAgICAgICAgICAgICAgICBfcGFyYW1ldGVycyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgX2RhdGFDb250YWluZXIucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICBfbGluZWFnZURpYWdyYW0uc2V0T3JpZW50YXRpb24ob3JpZW50YXRpb24pO1xyXG4gICAgICAgICAgICBfYmlyZEV5ZS5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIGlmIChfZ3JhcGhNYXApIF9ncmFwaE1hcC5yZWZyZXNoKHtcclxuICAgICAgICAgICAgICAgIHZpZXdGcmFtZXM6IF9saW5lYWdlRGlhZ3JhbS5nZXRWaWV3RnJhbWVzKCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCByZXR1cm5zIG9yaWVudGF0aW9uIG9mIHRoZSBncmFwaFxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBvcmVpbnRhdGlvbiAtIFZhbHVlczogJ2xlZnQtdG8tcmlnaHQnLCAncmlnaHQtdG8tbGVmdCcsICd0b3AtdG8tYm90dG9tJywgJ2JvdHRvbS10by10b3AnXHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9wYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb247XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIExpbmVhZ2VHcmFtIC0gcmVmcmVzaGVzIGFsbCB2aWV3cyBhbmQgYWRqdXN0IHNpemUgb2YgdGhlIGNhbnZhcy5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCAtICdsaW5lYWdlRGlhZ3JhbScgfCAnYmlyZEV5ZScgfCAnZ3JhcGhNYXAnXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYucmVmcmVzaCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoX2N1cnJlbnRWaWV3ID09PSAnbGluZWFnZURpYWdyYW0nKSB7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gJ2xpbmVhZ2VEaWFncmFtJykgX2xpbmVhZ2VEaWFncmFtLnJlZHJhdygpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gJ2JpcmRFeWUnKSBfYmlyZEV5ZS5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfZ3JhcGhNYXAgJiYgKCF0YXJnZXQgfHwgdGFyZ2V0ID09PSAnZ3JhcGhNYXAnKSkgX2dyYXBoTWFwLnJlZnJlc2goe1xyXG4gICAgICAgICAgICB2aWV3RnJhbWVzOiBfbGluZWFnZURpYWdyYW0uZ2V0Vmlld0ZyYW1lcygpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZpZXdGcm1hZXMgcHVibGljIGRhdGFcclxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFZpZXdGcmFtZVB1YmxpY01vZGVsXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBJZGVudGlmaWVyXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWwgLSBUZXh0IGxhYmVsXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gYm9yZGVyQ29sb3IgLSBDU1MgYm9yZGVyIGNvbG9yXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gYmFja2dyb3VuZENvbG9yIC0gQ1NTIGJhY2dyb3VuZCBjb2xvclxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBWaWV3RnJhbWVzIHN0YXRlcy5cclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVQdWJsaWNNb2RlbFtdfSBzdGF0ZXMgLSBrZXkgLT4gaWQsIHZhbHVlIC0+IHRydWUgLSBleHBhbmRlZCwgZmFsc2UgLSBjb2xsYXBzZWRcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLmdldFZpZXdGcmFtZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybiBbXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9saW5lYWdlRGlhZ3JhbS5nZXRWaWV3RnJhbWVzKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBvbmUgVmlld0ZyYW1lIGJ5IGlkXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3RnJhbWVJZFxyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVB1YmxpY01vZGVsfVxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0Vmlld0ZyYW1lQnlJZCA9IGZ1bmN0aW9uICh2aWV3RnJhbWVJZCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICByZXR1cm4gX2xpbmVhZ2VEaWFncmFtLmdldFZpZXdGcmFtZUJ5SWQodmlld0ZyYW1lSWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgb25lIFZpZXdGcmFtZSBieSBpZFxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lUHVibGljTW9kZWx9XHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRPdmVyVmlld0ZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICByZXR1cm4gX2xpbmVhZ2VEaWFncmFtLmdldE92ZXJWaWV3RnJhbWUoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsYXBzZSB0aGUgVmlld0ZyYW1lIHdpdGggc3BlY2lmaWVkIElkLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZpZXdGcmFtZUlkIC0gaWQgb2YgdGhlIHRhcmdldCBWaWV3RnJhbWVcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLmNvbGxhcHNlVmlld0ZyYW1lID0gZnVuY3Rpb24gKHZpZXdGcmFtZUlkKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuICAgICAgICBfbGluZWFnZURpYWdyYW0uY2xvc2VWaWV3RnJhbWUodmlld0ZyYW1lSWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4cGFuZCBWaWV3RnJhbWUgd2l0aCBzcGVjaWZpZWQgSWQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmlld0ZyYW1lSWQgLSBpZCBvZiB0aGUgdGFyZ2V0IFZpZXdGcmFtZVxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuZXhwYW5kVmlld0ZyYW1lID0gZnVuY3Rpb24gKHZpZXdGcmFtZUlkKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuICAgICAgICBfbGluZWFnZURpYWdyYW0ub3BlblZpZXdGcmFtZSh2aWV3RnJhbWVJZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGFwc2VzL0V4cGFuZHMgT3ZlclZpZXdGcmFtZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuc2V0RnVsbFNjcmVlbk1vZGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbS5zZXRGdWxsU2NyZWVuTW9kZSh2YWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGFwc2VzL0V4cGFuZHMgT3ZlclZpZXdGcmFtZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuaXNGdWxsU2NyZWVuTW9kZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuIF9wYXJhbWV0ZXJzLmZ1bGxTY3JlZW5Nb2RlO1xyXG4gICAgICAgIHJldHVybiBfbGluZWFnZURpYWdyYW0uaXNGdWxsU2NyZWVuTW9kZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdyb3VwcyByZWxhdGl2ZSB0byBzZWxlY3RlZCBub2RlXHJcbiAgICAgKiBub2RlcyBhcm91bmQgIHRoZSBzZWxlY3RlZCBub2RlIGFuZCBoaWdobGlnaHQgdGhlbS5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuY29tYmluZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfbGluZWFnZURpYWdyYW0uY29tYmluZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIGVsZW1lbnRzIGJ5IGlkKHMpIGFuZCBzZXRzIGl0IGFzIHNlbGVjdGVkLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gaWQxIC0gU2VsZWN0ZWQgZWxlbWVudCBpZCBvciBzb3VyY2UgZWxlbWVudCBpZCBvZiB0aGUgbGlua1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkMiAtIFRhcmdldCBlbGVtZW50IGlkXHJcbiAgICAgKiBAcmV0dXJucyB7Tm9kZXxMaW5rfSAtIFNlbGVjdGVkIGVsZW1lbnRcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLnNldFNlbGVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uIChpZDEsIGlkMikge1xyXG4gICAgICAgIGlmIChpZDEgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoaWQxICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkRWxlbWVudCA9IF9nZXRFbGVtZW50QnlJZChpZDEsIGlkMik7XHJcbiAgICAgICAgICAgIF9zZXRTZWxlY3RlZEVsZW1lbnQoc2VsZWN0ZWRFbGVtZW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfc2V0U2VsZWN0ZWRFbGVtZW50KG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWJ1aWxkcyBkaWFncmFtbSB3aXRoIG5ldyBmb2N1cyBub2RlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9jdXNOb2RlIC0gRm9jdXMgbm9kZSBpZFxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0Rm9jdXNOb2RlID0gZnVuY3Rpb24gKGZvY3VzTm9kZUlkKSB7XHJcbiAgICAgICAgY29uc3QgZm9jdXNOb2RlID0gX2dldEVsZW1lbnRCeUlkKGZvY3VzTm9kZUlkKTtcclxuXHJcbiAgICAgICAgaWYgKCEoZm9jdXNOb2RlIGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5Ob2RlKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbmNvcnJlY3QgdmFsdWUgb2YgZWxlbWVudCcpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfc3RhdGVTdG9yYWdlLnVwZGF0ZVN0YXRlKF9nZXRIaXN0b3J5U3RhdGUoKSk7XHJcbiAgICAgICAgX3NldERpYWdyYW1TdGF0ZSgnZmV0Y2hpbmcnKTtcclxuXHJcbiAgICAgICAgX2ZldGNoRGlhZ3JhbSh7XHJcbiAgICAgICAgICAgIGZvY3VzTm9kZUlkOiBmb2N1c05vZGUubW9kZWwucmVzb3VyY2UsXHJcbiAgICAgICAgICAgIHZpZXdGcmFtZTogZm9jdXNOb2RlLm1vZGVsLnZpZXdGcmFtZSxcclxuICAgICAgICAgICAgb2Zmc2V0OiAoZm9jdXNOb2RlLm1vZGVsLmhhc093blByb3BlcnR5KCdvZmZzZXQnKSA/IGZvY3VzTm9kZS5tb2RlbC5vZmZzZXQgOiBudWxsKSxcclxuICAgICAgICAgICAgZGlhZ3JhbVR5cGU6IF9kaWFncmFtVHlwZSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0byBwcmV2aW91cyBzZWxlY3RlZCBub2RlIChSZXN0b3JlcyBwcmV2aW91cyBkaWFncmFtKVxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYudW5kb1N0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdGF0ZVN0b3JhZ2UudXBkYXRlU3RhdGUoX2dldEhpc3RvcnlTdGF0ZSgpKTtcclxuICAgICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gX3N0YXRlU3RvcmFnZS51bmRvU3RhdGUoKTtcclxuICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSkgX2xvYWRTdGF0ZShwcmV2aW91c1N0YXRlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRvIG5leHQgc2VsZWN0ZWQgbm9kZVxyXG4gICAgICogKE5vZGUgd2hpY2ggaGFkIGJlZW4gc2VsZWN0ZWQgYmVmb3JlIHRoZSBzdGF0ZSB3YXMgcmVzdG9yZWQpXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5yZWRvU3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N0YXRlU3RvcmFnZS51cGRhdGVTdGF0ZShfZ2V0SGlzdG9yeVN0YXRlKCkpO1xyXG4gICAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IF9zdGF0ZVN0b3JhZ2UucmVkb1N0YXRlKCk7XHJcbiAgICAgICAgaWYgKG5leHRTdGF0ZSkgX2xvYWRTdGF0ZShuZXh0U3RhdGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgcHVibGljIG1vZGVsIG9mIHNlbGVjdGVkIGVsZW1lbnRcclxuICAgICAqIEByZXR1cm5zIHtQdWJsaWNMaW5rTW9kZWx8UHVibGljTm9kZU1vZGVsfSBzZWxlY3RlZEVsZW1lbnRcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLmdldFNlbGVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2dldE1vZGVsKF9zZWxlY3RlZEVsZW1lbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgcHVibGljIG1vZGVsIG9mIGZvY3VzIGVsZW1lbnQuXHJcbiAgICAgKiBFbGVtZW50IHdoaWNoIHdhcyB1c2VkIHRvIGJ1aWxkIGRpYWdyYW0gYXJvdW5kXHJcbiAgICAgKiBAcmV0dXJucyB7UHVibGljTGlua01vZGVsfFB1YmxpY05vZGVNb2RlbH0gZm9jdXNFbGVtZW50XHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5nZXRGb2N1c0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9nZXRNb2RlbChfZm9jdXNFbGVtZW50KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgZGVyaXZhdGlvbiBtYXAuXHJcbiAgICAqIEByZXR1cm5zIHtEZXJpdmF0aW9uTWFwfSBkZXJ2aWF0aW9uTWFwXHJcbiAgICAqIEBtZW1iZXJvZiBsaW5lYWdlR3JhbVxyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXREZXJpdmF0aW9uTWFwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZGVyaXZhdGlvbk1hcDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5nZXROb2RlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuIFtdO1xyXG4gICAgICAgIHJldHVybiBfZGF0YUNvbnRhaW5lci5ub2Rlcy5tYXAobiA9PiBfZ2V0TW9kZWwobikpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldExpbmtzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm4gW107XHJcbiAgICAgICAgcmV0dXJuIF9kYXRhQ29udGFpbmVyLmxpbmtzLm1hcChsID0+IF9nZXRNb2RlbChsKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR3JhcGhzIHB1YmxpYyBtYXBzXHJcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQdWJsaWNHcmFwaE1hcHNcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIFB1YmxpY05vZGVNb2RlbD59IG5vZGVNYXBcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIFB1YmxpY0xpbmtNb2RlbD59IGxpbmtNYXBcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIFB1YmxpY0xpbmtNb2RlbD59IHNvdXJjZU1hcFxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgUHVibGljTGlua01vZGVsPn0gdGFyZ2V0TWFwXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR3JhcGggbW9kZWxcclxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFB1YmxpY0dyYXBoTW9kZWxcclxuICAgICAqIEBwcm9wZXJ0eSB7UHVibGljTm9kZU1vZGVsW119IG5vZGVzXHJcbiAgICAgKiBAcHJvcGVydHkge1B1YmxpY0xpbmtNb2RlbFtdfSBsaW5rc1xyXG4gICAgICogQHByb3BlcnR5IHtQdWJsaWNHcmFwaE1hcHN9IG1hcHNcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZGF0YSBtb2RlbCBvZiBMaW5lYWdHcmFtLlxyXG4gICAgICogQHJldHVybnMge1B1YmxpY0dyYXBoTW9kZWx9XHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5nZXRHcmFwaE1vZGVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm4ge307XHJcblxyXG4gICAgICAgIGNvbnN0IGdyYXBoTW9kZWwgPSB7XHJcbiAgICAgICAgICAgIG5vZGVzOiBfZGF0YUNvbnRhaW5lci5ub2Rlcy5tYXAobiA9PiBfZ2V0TW9kZWwobikpLFxyXG4gICAgICAgICAgICBsaW5rczogX2RhdGFDb250YWluZXIubGlua3MubWFwKGwgPT4gX2dldE1vZGVsKGwpKSxcclxuICAgICAgICAgICAgbWFwczoge1xyXG4gICAgICAgICAgICAgICAgbm9kZU1hcDoge30sXHJcbiAgICAgICAgICAgICAgICBsaW5rTWFwOiB7fSxcclxuICAgICAgICAgICAgICAgIHNvdXJjZU1hcDoge30sXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRNYXA6IHt9LFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZ3JhcGhNb2RlbC5ub2Rlcy5mb3JFYWNoKG5vZGVNb2RlbCA9PiB7XHJcbiAgICAgICAgICAgIGdyYXBoTW9kZWwubWFwcy5ub2RlTWFwW25vZGVNb2RlbC5pZF0gPSBub2RlTW9kZWw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZ3JhcGhNb2RlbC5saW5rcy5mb3JFYWNoKGxpbmtNb2RlbCA9PiB7XHJcbiAgICAgICAgICAgIGdyYXBoTW9kZWwubWFwcy5saW5rTWFwW2xpbmtNb2RlbC5pZF0gPSBsaW5rTW9kZWw7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWdyYXBoTW9kZWwubWFwcy5zb3VyY2VNYXBbbGlua01vZGVsLnRhcmdldF0pIHtcclxuICAgICAgICAgICAgICAgIGdyYXBoTW9kZWwubWFwcy5zb3VyY2VNYXBbbGlua01vZGVsLnRhcmdldF0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWdyYXBoTW9kZWwubWFwcy50YXJnZXRNYXBbbGlua01vZGVsLnNvdXJjZV0pIHtcclxuICAgICAgICAgICAgICAgIGdyYXBoTW9kZWwubWFwcy50YXJnZXRNYXBbbGlua01vZGVsLnNvdXJjZV0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ3JhcGhNb2RlbC5tYXBzLnNvdXJjZU1hcFtsaW5rTW9kZWwudGFyZ2V0XS5wdXNoKGxpbmtNb2RlbCk7XHJcbiAgICAgICAgICAgIGdyYXBoTW9kZWwubWFwcy50YXJnZXRNYXBbbGlua01vZGVsLnNvdXJjZV0ucHVzaChsaW5rTW9kZWwpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gZ3JhcGhNb2RlbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGN1cnJlbnQgdmlldy4gTWV0aG9kIHRha2VzIHN0cmluZyBpZGVudGlmaWVyIG9mIHRoZSB2aWV3IGFzIGEgcGFyYW1ldGVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gLSB2aWV3SWQgY2FuIGJlICdsaW5lYWdlRGlhZ3JhbScgb3IgJ2JpcmRFeWUnIG9yICdub25lJ1xyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0Q3VycmVudFZpZXcgPSBmdW5jdGlvbiAodmlld0lkKSB7XHJcbiAgICAgICAgaWYgKHZpZXdJZCA9PT0gJ2xpbmVhZ2VEaWFncmFtJykge1xyXG4gICAgICAgICAgICBfc2hvd0pvaW50R3JhcGgoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHZpZXdJZCA9PT0gJ2JpcmRFeWUnKSB7XHJcbiAgICAgICAgICAgIF9zaG93U2lnbWFHcmFwaCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodmlld0lkID09PSAnbm9uZScpICB7XHJcbiAgICAgICAgICAgIF9oaWRlVmlld3MoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgc2VsZi5zZXRDdXJyZW50VmlldyhfY3VycmVudFZpZXcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBsaW5rcyByb3V0aW5nIHdoaWNoIGlzIGJhc2VkXHJcbiAgICAgKiBvbiBqb2ludGpzIHJvdXRpbmdzOiBtZXRybyB8IG5vcm1hbCB8IG1hbmhhdHRhbiB8IG9ydGhvZ29uYWxcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByb3V0aW5nSWQgLSBtZXRybyB8IG5vcm1hbCB8IG1hbmhhdHRhbiB8IG9ydGhvZ29uYWxcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLnNldFJvdXRpbmcgPSBmdW5jdGlvbiAocm91dGluZ0lkKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnNldFJvdXRpbmcocm91dGluZ0lkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyByb3V0aW5nIHdoaWNoIGlzIGN1cnJlbnRseSBhcHBsaWVkIGZvciBhbGwgbGlua3MuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHJvdXRpbmc6IG1ldHJvIHwgbm9ybWFsIHwgbWFuaGF0dGFuIHwgb3J0aG9nb25hbFxyXG4gICAgICovXHJcbiAgICBzZWxmLmdldFJvdXRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9saW5lYWdlRGlhZ3JhbS5nZXRSb3V0aW5nKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMubGlua1JvdXRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdmFsdWUgb2YgdGhlIHBhcmFtZXRlciB3aGljaCB0ZWxscyB1cyB3aGV0ZXIgd2Ugc2hvdWxkXHJcbiAgICAgKiB0cmltIG5vZGVzIGJ5IHRoZSBib3JkZXJzIG9yIG5vdC5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjbGlwcGluZ1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLnNldENsaXBwaW5nID0gZnVuY3Rpb24gKGNsaXBwaW5nKSB7XHJcbiAgICAgICAgX3BhcmFtZXRlcnMuY2xpcE5vZGVzID0gY2xpcHBpbmc7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnJlZHJhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIgd2hpY2ggdGVsbHMgdXMgd2hldGVyIHdlXHJcbiAgICAgKiB0cmltIG5vZGVzIGJ5IHRoZSBib3JkZXJzIG9yIG5vdC5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGNsaXBwaW5nXHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0Q2xpcHBpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9wYXJhbWV0ZXJzLmNsaXBOb2RlcztcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5zZXRNYXNrID0gZnVuY3Rpb24gKHB1YmxpY01hc2spIHtcclxuICAgICAgICBjb25zdCBpZE1hcCA9IF9kYXRhQ29udGFpbmVyLm1hcHMuaWRNYXA7XHJcbiAgICAgICAgY29uc3QgbWFzayA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHB1YmxpY01hc2spLmZvckVhY2goaWQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkaWFncmFtSWQgPSBpZE1hcFtpZF07XHJcbiAgICAgICAgICAgIG1hc2tbZGlhZ3JhbUlkXSA9IHB1YmxpY01hc2tbaWRdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbS5zZXRNYXNrKG1hc2spO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldE1hc2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgbWFzayA9IF9saW5lYWdlRGlhZ3JhbS5nZXRNYXNrKCk7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IF9kYXRhQ29udGFpbmVyLm1hcHMubm9kZU1hcDtcclxuICAgICAgICBjb25zdCBsaW5rTWFwID0gX2RhdGFDb250YWluZXIubWFwcy5saW5rTWFwO1xyXG4gICAgICAgIGNvbnN0IHB1YmxpY01hc2sgPSB7fTtcclxuICAgICAgICBpZiAobWFzaykge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhtYXNrKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFza1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IF9nZXRNb2RlbChub2RlTWFwW2tleV0gfHwgbGlua01hcFtrZXldKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJsaWNNYXNrW2VsZW1lbnQuaWRdID0gZWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHVibGljTWFzaztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaGVzIGRpYWdyYW0gdXNpbmcgcGFzc2VkIG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7e1xyXG4gICAgICogICAgICBmb2N1c05vZGVJZDogc3RyaW5nLFxyXG4gICAgICogICAgICB2aWV3RnJhbWVzOiBWaWV3RnJhbWVEZWZpbml0aW9uW10sXHJcbiAgICAgKiAgICAgIHZpZXdGcmFtZTogc3RyaW5nXHJcbiAgICAgKiAgICAgIGxpbmVhZ2VHcmFtVmlld0NsYXNzOiBzdHJpbmcsXHJcbiAgICAgKiAgICAgIGRpYWdyYW1UeXBlOiBzdHJpbmcsXHJcbiAgICAgKiB9fVxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZmV0Y2hEaWFncmFtIChvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZUlkID0gb3B0aW9ucy5mb2N1c05vZGVJZDtcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWUgPSBvcHRpb25zLnZpZXdGcmFtZTtcclxuICAgICAgICBjb25zdCBkaWFncmFtVHlwZSA9IG9wdGlvbnMuZGlhZ3JhbVR5cGU7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ29mZnNldCcpID8gIG9wdGlvbnMub2Zmc2V0IDogbnVsbCk7XHJcblxyXG4gICAgICAgIC8vIFN3aXRjaCB0aGUgbG9hZGluZyBpbmRpY2F0b3IgaW4gc3RhdGUgJ2ZldGNoaW5nJ1xyXG4gICAgICAgIC8vIFJlcXVlc3QgZGF0YSB0aHJvdWdoIGRhdGEgcHJvdmlkZXJcclxuICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdmZXRjaGluZycpO1xyXG4gICAgICAgIGlmICghX2RhdGFQcm92aWRlcikge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAnRGF0YSBwcm92aWRlciBpcyBub3Qgc3BlY2lmaWVkISc7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIF9zZXREaWFncmFtU3RhdGUoJ2Vycm9yJywgZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICAgICAgX2Vycm9yQ2FsbGJhY2soZXJyb3IpO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfZGF0YVByb3ZpZGVyLmZldGNoRGF0YSkge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAnRGF0YSBwcm92aWRlciBoYXMgaW5jb3JyZWN0IGludGVyZmFjZSEgKFRoZXJlIGlzIG5vIFxcJ2ZldGNoRGF0YVxcJyBtZXRob2QpJztcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICAgICAgX3NldERpYWdyYW1TdGF0ZSgnZXJyb3InLCBlcnJvck1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBfZXJyb3JDYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgdmlld0ZyYW1lc1Byb21pc2UgPSBvcHRpb25zLnZpZXdGcmFtZXMgJiYgb3B0aW9ucy52aWV3RnJhbWVzLmxlbmd0aCA+IDAgP1xyXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoeyBmcmFtZXM6IG9wdGlvbnMudmlld0ZyYW1lcyB9KSA6XHJcbiAgICAgICAgICAgIF9kYXRhUHJvdmlkZXIuZ2V0Vmlld0ZyYW1lcyh0YXJnZXROb2RlSWQpO1xyXG4gICAgICAgIGNvbnN0IHZpZXdDbGFzc1Byb21pc2UgPSBvcHRpb25zLmxpbmVhZ2VHcmFtVmlld0NsYXNzID9cclxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMubGluZWFnZUdyYW1WaWV3Q2xhc3MpIDpcclxuICAgICAgICAgICAgX2RhdGFQcm92aWRlci5nZXRWaWV3Q2xhc3NGb3JSZXNvdXJjZSh0YXJnZXROb2RlSWQpO1xyXG5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3ZpZXdGcmFtZXNQcm9taXNlLCB2aWV3Q2xhc3NQcm9taXNlXSkudGhlbih2YWx1ZXMgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3RnJhbWVzID0gdmFsdWVzWzBdLmZyYW1lcztcclxuICAgICAgICAgICAgY29uc3Qgdmlld0NsYXNzID0gdmFsdWVzWzFdLmRhdGFQcm92aWRlcjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBfZGF0YVByb3ZpZGVyLmZldGNoRGF0YSh7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXROb2RlSWQ6IHRhcmdldE5vZGVJZCxcclxuICAgICAgICAgICAgICAgIHZpZXdGcmFtZTogdmlld0ZyYW1lLFxyXG4gICAgICAgICAgICAgICAgbGluZWFnZUdyYW1WaWV3Q2xhc3M6IHZpZXdDbGFzcyxcclxuICAgICAgICAgICAgICAgIGRpYWdyYW1UeXBlOiBkaWFncmFtVHlwZSxcclxuICAgICAgICAgICAgICAgIG9mZnNldDpvZmZzZXRcclxuICAgICAgICAgICAgfSkudGhlbihyYXdEYXRhID0+IHtcclxuICAgICAgICAgICAgICAgIF9zZXREaWFncmFtU3RhdGUoJ3JlbmRlcmluZycpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNoZWNrTGdSYXdEYXRhKHJhd0RhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFDb250YWluZXIgPSBfY3JlYXRlRGF0YUNvbnRhaW5lcihyYXdEYXRhLCB2aWV3RnJhbWVzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZURlZmluaXRpb25zID0gZmlsdGVyVmlld0ZyYW1lTGlzdCh2aWV3RnJhbWVzLCBkYXRhQ29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHB1YmxpY1ZpZXdGcmFtZU1vZGVscyA9IHZpZXdGcmFtZURlZmluaXRpb25zLm1hcChkID0+XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmZW5pdGlvblRvUHVibGljTW9kZWwoZCwgX2xpbmVhZ2VEaWFncmFtLmlzRnVsbFNjcmVlbk1vZGUoKSlcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgX3VwZGF0ZUNvbXBvbmVudHMoZGF0YUNvbnRhaW5lciwgcHVibGljVmlld0ZyYW1lTW9kZWxzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfZGlhZ3JhbVR5cGUgPSByYXdEYXRhLmRpYWdyYW1UeXBlO1xyXG4gICAgICAgICAgICAgICAgX2RhdGFDb250YWluZXIgPSBkYXRhQ29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgX3N0YXRlU3RvcmFnZS5wdXNoU3RhdGUoX2dldEhpc3RvcnlTdGF0ZSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmb2N1c05vZGVJZCA9IHJhd0RhdGEuZm9jdXNOb2RlIHx8IChyYXdEYXRhLm5vZGVzWzBdID8gcmF3RGF0YS5ub2Rlc1swXS5pZCA6IGZvY3VzTm9kZUlkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZvY3VzRWxlbWVudCA9IF9nZXRFbGVtZW50QnlJZChmb2N1c05vZGVJZCk7XHJcbiAgICAgICAgICAgICAgICBfZm9jdXNFbGVtZW50ID0gZm9jdXNFbGVtZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIF9zZXRTZWxlY3RlZEVsZW1lbnQoZm9jdXNFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIF9zZXREaWFncmFtU3RhdGUoJ2NvbXBsZXRlZCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignZm9jdXMtbm9kZS1jaGFuZ2VkJywgX2dldE1vZGVsKGZvY3VzRWxlbWVudCkpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdoaXN0b3J5LXN0YXRlLWNoYW5nZWQnLCBfc3RhdGVTdG9yYWdlLmdldEhpc3RvcnkoKSk7XHJcblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0eXBlb2YgZSA9PT0gJ3N0cmluZycgPyBuZXcgRXJyb3IoZSkgOiBlO1xyXG5cclxuICAgICAgICAgICAgX3NldERpYWdyYW1TdGF0ZSgnZXJyb3InLCBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgX2Vycm9yQ2FsbGJhY2soZXJyb3IpO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvci5zdGFjayk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgZW1wdHkgdmlld0ZyYW1lc1xyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtWaWV3RnJhbWVEZWZpbml0aW9uW119IHZpZXdGcmFtZXNcclxuICAgICAgICAgKiBAcGFyYW0ge0RhdGFDb250YWluZXJ9IGRhdGFDb250YWluZXJcclxuICAgICAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lW119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gZmlsdGVyVmlld0ZyYW1lTGlzdCAodmlld0ZyYW1lcywgZGF0YUNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICBjb25zdCBhY3RpdmVWaWV3RnJhbWVzID0ge307XHJcbiAgICAgICAgICAgIGRhdGFDb250YWluZXIubm9kZXMuZm9yRWFjaChuID0+IHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZVZpZXdGcmFtZXNbbi5tb2RlbC52aWV3RnJhbWVdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZpZXdGcmFtZXMuZmlsdGVyKHZmID0+IGFjdGl2ZVZpZXdGcmFtZXNbdmYuaWRdKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEZpbmRzIGVsZW1lbnRzIGJ5IGlkKHMpLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkMSAtIFNlbGVjdGVkIGVsZW1lbnQgaWQgb3Igc291cmNlIGVsZW1lbnQgaWQgb2YgdGhlIGxpbmtcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZDIgLSBUYXJnZXQgZWxlbWVudCBpZFxyXG4gICAgICogQHJldHVybnMge05vZGV8TGlua30gLSBTZWxlY3RlZCBlbGVtZW50XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldEVsZW1lbnRCeUlkIChpZDEsIGlkMikge1xyXG4gICAgICAgIGlmICghaWQyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gX2RhdGFDb250YWluZXIubm9kZXMuY29uY2F0KF9kYXRhQ29udGFpbmVyLmxpbmtzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzW2ldLm1vZGVsLnJlc291cmNlID09PSBpZDEgfHwgZWxlbWVudHNbaV0ubW9kZWwuaWQgPT09IGlkMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVNYXAgPSBfZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXA7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gX2RhdGFDb250YWluZXIubGlua3M7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IG5vZGVNYXBbbGlua3NbaV0ubW9kZWwuc291cmNlXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG5vZGVNYXBbbGlua3NbaV0ubW9kZWwudGFyZ2V0XTtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UucmVzb3VyY2UgPT09IGlkMSAmJiB0YXJnZXQucmVzb3VyY2UgPT09IGlkMiB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZS5yZXNvdXJjZSA9PT0gaWQyICYmIHRhcmdldC5yZXNvdXJjZSA9PT0gaWQxIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLmlkID09PSBpZDEgJiYgdGFyZ2V0LmlkID09PSBpZDIgfHxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UuaWQgPT09IGlkMiAmJiB0YXJnZXQuaWQgPT09IGlkMVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmtzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQ2hlY2tzIHBhc3NlZCBlbGVtZW50IGFuZCBzZXQgaXQgYXMgYSBzZWxlY3RlZC4gUmVmcmVzaGVzIHRoaXMgdmFsdWUgZm9yIHRoZSB2aWV3cy5cclxuICAgICAqIEBwYXJhbSB7Tm9kZXxMaW5rfSAtIFNlbGVjdGVkIGVsZW1lbnRcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfc2V0U2VsZWN0ZWRFbGVtZW50IChzZWxlY3RlZEVsZW1lbnQpIHtcclxuICAgICAgICAvLyBJdCBzaG91ZGxuJ3QgYmUgdW5kZWZpbmVkLCBidXQgaXQgY2FuIGJlIG51bGxcclxuICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0luY29ycmVjdCB2YWx1ZSBvZiBzZWxlY3RlZCBlbGVtZW50Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoX2dyYXBoTWFwKSBfZ3JhcGhNYXAuc2V0U2VsZWN0ZWRFbGVtZW50KHNlbGVjdGVkRWxlbWVudCk7XHJcbiAgICAgICAgaWYgKF9jdXJyZW50VmlldyA9PT0gJ2xpbmVhZ2VEaWFncmFtJykgX2xpbmVhZ2VEaWFncmFtLnNldFNlbGVjdGVkRWxlbWVudChzZWxlY3RlZEVsZW1lbnQsIHRydWUpO1xyXG4gICAgICAgIGlmIChfY3VycmVudFZpZXcgPT09ICdiaXJkRXllJykgX2JpcmRFeWUuc2V0U2VsZWN0ZWRFbGVtZW50KHNlbGVjdGVkRWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogUmV0dXJucyBjdXJyZW50IHN0YXRlLlxyXG4gICAgICogQHJldHVybnMge0hpc3RvcnlTdGF0ZX0gY3VycmVudCBzdGF0ZVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRIaXN0b3J5U3RhdGUgKCkge1xyXG4gICAgICAgIGNvbnN0IG92ZXJWaWV3RnJhbWUgPSBfbGluZWFnZURpYWdyYW0uZ2V0T3ZlclZpZXdGcmFtZSgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5vZGVzOiBfZGF0YUNvbnRhaW5lci5ub2RlcyxcclxuICAgICAgICAgICAgbGlua3M6IF9kYXRhQ29udGFpbmVyLmxpbmtzLFxyXG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQ6IF9mb2N1c0VsZW1lbnQsXHJcbiAgICAgICAgICAgIHZpZXdGcmFtZXM6IF9saW5lYWdlRGlhZ3JhbS5nZXRWaWV3RnJhbWVzKCkuZmlsdGVyKHZmID0+IHZmLmlkICE9PSBvdmVyVmlld0ZyYW1lLmlkKSxcclxuICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50OiBfc2VsZWN0ZWRFbGVtZW50LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogUmVzdG9yZXMgZGlhZ3JhbSB1c2luZyB0aGUgcGFzc2VkIHN0YXRlLlxyXG4gICAgICogQHBhcmFtIHtIaXN0b3J5U3RhdGV9IHN0YXRlIC0gdGFyZ2V0IHN0YXRlXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2xvYWRTdGF0ZSAoc3RhdGUpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdyZW5kZXJpbmcnKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhQ29udGFpbmVyID0gbmV3IERhdGFDb250YWluZXIoe1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzOiBzdGF0ZS5ub2RlcyxcclxuICAgICAgICAgICAgICAgICAgICBsaW5rczogc3RhdGUubGlua3MsXHJcbiAgICAgICAgICAgICAgICB9LCBfcGFyYW1ldGVycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgX3VwZGF0ZUNvbXBvbmVudHMoZGF0YUNvbnRhaW5lciwgc3RhdGUudmlld0ZyYW1lcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgX2RhdGFDb250YWluZXIgPSBkYXRhQ29udGFpbmVyO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRUb1NlbGVjdCA9IHN0YXRlLnNlbGVjdGVkRWxlbWVudCA9PT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5mb2N1c0VsZW1lbnQgOiBzdGF0ZS5zZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBfZm9jdXNFbGVtZW50ID0gc3RhdGUuZm9jdXNFbGVtZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIF9zZWxlY3RlZEVsZW1lbnQgPSBlbGVtZW50VG9TZWxlY3Q7XHJcbiAgICAgICAgICAgICAgICBfc2V0U2VsZWN0ZWRFbGVtZW50KGVsZW1lbnRUb1NlbGVjdCk7XHJcbiAgICAgICAgICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdjb21wbGV0ZWQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2ZvY3VzLW5vZGUtY2hhbmdlZCcsIF9nZXRNb2RlbChzdGF0ZS5mb2N1c0VsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignaGlzdG9yeS1zdGF0ZS1jaGFuZ2VkJywgX3N0YXRlU3RvcmFnZS5nZXRIaXN0b3J5KCkpO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdlcnJvcicpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvci5zdGFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQ2hhbmdlcyBzY2FsZSBvZiB0aGUgbWFpbiB2aWV3IHRvIGJlIGFibGUgdG8gZml0IHdob2xlIGRpYWdyYW0gaW4gdGhlIHNjcmVlbi5cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfem9vbVRvRml0ICgpIHtcclxuICAgICAgICBfbGluZWFnZURpYWdyYW0uem9vbVRvRml0KCk7XHJcbiAgICAgICAgaWYgKF9ncmFwaE1hcCkgX2dyYXBoTWFwLnJlZHJhdyh7XHJcbiAgICAgICAgICAgIHZpZXdGcmFtZXM6IF9saW5lYWdlRGlhZ3JhbS5nZXRWaWV3RnJhbWVzKCksXHJcbiAgICAgICAgICAgIHNjYWxlOiBfbGluZWFnZURpYWdyYW0uc2NhbGUoKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBDcmVhdGVzIGRhdGFDb250YWluZXIgKGRpYWdyYW0gbW9kZWwpIHVzaW5nIHBhc3NlZCByYXcgZGF0YS5cclxuICAgICAqIEBwYXJhbSB7U2VydmVyRGF0YX0gcmF3RGF0YSAtIGRhdGFcclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lRGVmaW5pdGlvbltdfSB2aWV3RnJhbWVzIC0gVmlldyBmcmFtZSBkZWZlbml0aW9uc1xyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jcmVhdGVEYXRhQ29udGFpbmVyIChyYXdEYXRhLCB2aWV3RnJhbWVzKSB7XHJcbiAgICAgICAgLy8gaWYgd2UgZG9uJ3QgZ2V0IGFueSBkYXRhLCB3ZSBjcmVhdGUgYW4gZW1wdHkgZGF0YXRcclxuICAgICAgICBpZiAoIXJhd0RhdGEpIHJhd0RhdGEgPSB7IG5vZGVzOiBbXSwgbGlua3M6IFtdIH07XHJcbiAgICAgICAgaWYgKCFyYXdEYXRhLm5vZGVzKSByYXdEYXRhLm5vZGVzID0gW107XHJcbiAgICAgICAgaWYgKCFyYXdEYXRhLmxpbmtzKSByYXdEYXRhLmxpbmtzID0gW107XHJcblxyXG4gICAgICAgIC8vIFRoZSBmdW5jdGlvbiBmaWx0ZXJzIHRoZSBkYXRhLCBzZXRzIGF1dGhvcml0aWVzIGFuZCBjb2xsYXBzZXMgbGlua3MuXHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHByb2Nlc3NEYXRhKHJhd0RhdGEpO1xyXG4gICAgICAgIC8vIEZpbmQgYW5kIHNldCBwbGFjZSBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBkYXRhIHNldFxyXG4gICAgICAgIGxheW91dC5kb0xheW91dChcclxuICAgICAgICAgICAgZGF0YS5ub2RlcyxcclxuICAgICAgICAgICAgZGF0YS5saW5rcyxcclxuICAgICAgICAgICAgdmlld0ZyYW1lcyxcclxuICAgICAgICAgICAgX3BhcmFtZXRlcnMsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gVGhpcyB0d28gbGluZXMgY3JlYXRlIG5vZGVzIGFuZCBsaW5rcyBmcm9tIGRhdGEgbW9kZWxzXHJcbiAgICAgICAgY29uc3Qgam9pbnROb2RlcyA9IGNyZWF0ZUpvaW50Tm9kZXMoZGF0YS5ub2RlcywgX3BhcmFtZXRlcnMpO1xyXG4gICAgICAgIGNvbnN0IGpvaW50TGlua3MgPSBjcmVhdGVKb2ludExpbmtzKGRhdGEubGlua3MsIGpvaW50Tm9kZXMsICBfcGFyYW1ldGVycyk7XHJcblxyXG4gICAgICAgIGNyZWF0ZUFzcGVjdFJlbGF0aW9ucyhqb2ludE5vZGVzKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGRhdGEgY29udGFpbmVyIGJ5IG5ldyBub2RlcyBhbmQgbGlua3NcclxuICAgICAgICByZXR1cm4gbmV3IERhdGFDb250YWluZXIoe1xyXG4gICAgICAgICAgICBub2Rlczogam9pbnROb2RlcyxcclxuICAgICAgICAgICAgbGlua3M6IGpvaW50TGlua3MsXHJcbiAgICAgICAgfSwgX3BhcmFtZXRlcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgKG9yIHJlZnJlc2hlcyBpZiBub3QgdGhlIGZpcnN0IHRpbWUpXHJcbiAgICAgKiB0aGUgTGluZWFnZUdyYW0gLSBDcmVhdGVzIChSZWZyZXNoZXMpIHRoZSBtYWluIHZpZXdzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUNvbXBvbmVudHMgKCkge1xyXG4gICAgICAgIGNvbnN0IGVtcHR5RGF0YUNvbnRhaW5lciA9IG5ldyBEYXRhQ29udGFpbmVyICh7XHJcbiAgICAgICAgICAgIG5vZGVzOiBbXSxcclxuICAgICAgICAgICAgbGlua3M6IFtdLFxyXG4gICAgICAgIH0sIF9wYXJhbWV0ZXJzKTtcclxuICAgICAgICBjb25zdCBlbXB0eUxpc3QgPSBbXTtcclxuICAgICAgICAvLyBDcmVhdGVzIHRoZSBmaXJzdCB2aWV3IC0gTGluZWFnZURpYWdyYW1cclxuICAgICAgICBfY3JlYXRlTGluZWFnZURpYWdyYW0oZW1wdHlEYXRhQ29udGFpbmVyLCBlbXB0eUxpc3QpO1xyXG4gICAgICAgIC8vIENyZWF0ZXMgYSBzaWdtYSBncmFwaCBtYXAgb24gdGhlIHByaXZhdGUgcm9vdC5cclxuICAgICAgICAvLyBfY3JlYXRlTWFwKGVtcHR5RGF0YUNvbnRhaW5lciwgZW1wdHlMaXN0KTtcclxuICAgICAgICAvLyBDcmVhdGVzIHRoZSBzZWNvbmQgdmlldyAtIEJpcmRFeWUgKEhpc3RvcmljYWxseSAtIFNpZ21hUGF0aFZpZXcpXHJcbiAgICAgICAgX2NyZWF0ZUJpcmRFeWUoZW1wdHlEYXRhQ29udGFpbmVyKTtcclxuICAgICAgICBfY3JlYXRlRGVyaXZhdGlvbk1hcChfZGF0YVByb3ZpZGVyKTtcclxuXHJcbiAgICAgICAgX2FkZEhvdmVySGFuZGxlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyAob3IgcmVmcmVzaGVzIGlmIG5vdCB0aGUgZmlyc3QgdGltZSlcclxuICAgICAqIHRoZSBMaW5lYWdlR3JhbSAtIENyZWF0ZXMgKFJlZnJlc2hlcykgdGhlIG1haW4gdmlld3MuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlQ29tcG9uZW50cyAoZGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lcykge1xyXG4gICAgICAgIC8vIFVwZGF0ZXMgdGhlIGZpcnN0IHZpZXcgLSBMaW5lYWdlRGlhZ3JhbVxyXG4gICAgICAgIF91cGRhdGVMaW5lYWdlRGlhZ3JhbShkYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzKTtcclxuICAgICAgICAvLyBVcGRhdGVzIGEgc2lnbWEgZ3JhcGggbWFwIG9uIHRoZSBwcml2YXRlIHJvb3QuXHJcbiAgICAgICAgX3VwZGF0ZU1hcChkYXRhQ29udGFpbmVyLCBfbGluZWFnZURpYWdyYW0uZ2V0Vmlld0ZyYW1lcygpKTtcclxuICAgICAgICAvLyBVcGRhdGVzIHRoZSBzZWNvbmQgdmlldyAtIEJpcmRFeWUgKEhpc3RvcmljYWxseSAtIFNpZ21hUGF0aFZpZXcpXHJcbiAgICAgICAgX3VwZGF0ZUJpcmRFeWUoZGF0YUNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgIF96b29tVG9GaXQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbm5lciBmdW5jdGlvbnNcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGZ1bmN0aW9uIF9jcmVhdGVMaW5lYWdlRGlhZ3JhbSAoZGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lcykge1xyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbSA9IG5ldyBMaW5lYWdlRGlhZ3JhbSh7XHJcbiAgICAgICAgICAgIGdyYXBoUGxhY2U6IF9iYXNlLmxpbmVhZ2VEaWFncmFtLFxyXG4gICAgICAgICAgICBkYXRhQ29udGFpbmVyOiBkYXRhQ29udGFpbmVyLFxyXG4gICAgICAgICAgICB2aWV3RnJhbWVzOiB2aWV3RnJhbWVzLFxyXG4gICAgICAgICAgICBmdWxsU2NyZWVuTW9kZTogX3BhcmFtZXRlcnMuZnVsbFNjcmVlbk1vZGUsXHJcbiAgICAgICAgfSwgX3BhcmFtZXRlcnMpO1xyXG5cclxuICAgICAgICBfbGluZWFnZURpYWdyYW0ub24oJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIChldmVudE9iamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9jdXJyZW50VmlldyA9PT0gJ2xpbmVhZ2VEaWFncmFtJyAmJiBfc3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2dyYXBoTWFwKSBfZ3JhcGhNYXAuc2V0U2VsZWN0ZWRFbGVtZW50KGV2ZW50T2JqZWN0KTtcclxuICAgICAgICAgICAgICAgIF9zZWxlY3RlZEVsZW1lbnQgPSBnZXRCYXNlRWxlbWVudChldmVudE9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIF9nZXRNb2RlbChfc2VsZWN0ZWRFbGVtZW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLm9uKCdzY2FsZS1jaGFuZ2VkJywgKG5ld1NjYWxlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoX2dyYXBoTWFwKSBfZ3JhcGhNYXAucmVkcmF3KHtcclxuICAgICAgICAgICAgICAgIHZpZXdGcmFtZXM6IF9saW5lYWdlRGlhZ3JhbS5nZXRWaWV3RnJhbWVzKCksXHJcbiAgICAgICAgICAgICAgICBzY2FsZTogbmV3U2NhbGVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2NhbGUtdmFsdWUtY2hhbmdlZCcsIHtcclxuICAgICAgICAgICAgICAgIG1pbjogX3BhcmFtZXRlcnMuc2NhbGVCb3VuZHMubWluLFxyXG4gICAgICAgICAgICAgICAgbWF4OiBfcGFyYW1ldGVycy5zY2FsZUJvdW5kcy5tYXgsXHJcbiAgICAgICAgICAgICAgICBjdXI6IF9saW5lYWdlRGlhZ3JhbS5zY2FsZSgpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLm9uKCd2aWV3LWZyYW1lcy1zdGF0ZS1jaGFuZ2VkJywgKHZpZXdGcmFtZXMpID0+IHtcclxuICAgICAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChfZ3JhcGhNYXApIHtcclxuICAgICAgICAgICAgICAgIF9ncmFwaE1hcC5yZWRyYXcoeyB2aWV3RnJhbWVzOiB2aWV3RnJhbWVzIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcigndmlldy1mcmFtZS1zdGF0ZS1jaGFuZ2VkJywgdmlld0ZyYW1lcyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbS5vbigndmlldy1mcmFtZXMtc2l6ZS1vci1wb3NpdGlvbi1jaGFuZ2VkJywgKHZpZXdGcmFtZXMpID0+IHtcclxuICAgICAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChfZ3JhcGhNYXApIHtcclxuICAgICAgICAgICAgICAgIF9ncmFwaE1hcC5yZWRyYXcoeyB2aWV3RnJhbWVzOiB2aWV3RnJhbWVzIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbS5vbignbm9kZXMtcG9zaXRpb24tY2hhbmdlZCcsICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChfZ3JhcGhNYXApIHtcclxuICAgICAgICAgICAgICAgIF9ncmFwaE1hcC5yZWRyYXcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfYmlyZEV5ZS5yZWRyYXcoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbS5vbignY2VsbC1kb3VibGUtY2xpY2snLCAoZXZlbnRPYmplY3QpID0+IHtcclxuICAgICAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChfY3VycmVudFZpZXcgPT09ICdsaW5lYWdlRGlhZ3JhbScpIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudE9iamVjdCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuTGluayB8fCBldmVudE9iamVjdCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuVGVybWluYXRpb25MaW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnNldFNlbGVjdGVkRWxlbWVudChldmVudE9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluayA9IGV2ZW50T2JqZWN0Lm9yaWdpbmFsTGluayB8fCBldmVudE9iamVjdDtcclxuICAgICAgICAgICAgICAgICAgICBfc2hvd0Rlcml2YXRpb25NYXAobGluayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLm9uKCdsaW5rLW9wdGlvbnMtY2xpY2snLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBldmVudC5saW5rO1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rVHlwZSA9IGV2ZW50LmxpbmtUeXBlO1xyXG4gICAgICAgICAgICBpZiAoX2N1cnJlbnRWaWV3ID09PSAnbGluZWFnZURpYWdyYW0nKSB7XHJcbiAgICAgICAgICAgICAgICBfc2hvd0Rlcml2YXRpb25NYXAobGluaywgbGlua1R5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3VwZGF0ZUxpbmVhZ2VEaWFncmFtIChkYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzKSB7XHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnNldERhdGEoZGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lcyk7XHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnNjYWxlKF9wYXJhbWV0ZXJzLmRlZmF1bHRTY2FsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2FkZEhvdmVySGFuZGxlciAoKSB7XHJcbiAgICAgICAgLy8gSW5pdCB0aGUgdG9vbHRpcCB0b29sIGZvciB0ZXJtaW50YXRpb24gbm9kZXMuXHJcbiAgICAgICAgbmV3IGpvaW50LnVpLlRvb2x0aXAoe1xyXG4gICAgICAgICAgICByb290VGFyZ2V0OiBkb2N1bWVudC5ib2R5LFxyXG4gICAgICAgICAgICB0YXJnZXQ6ICcudGVybWluYXRpb24tbm9kZScsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ2F1dG8nLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiAxNSxcclxuICAgICAgICAgICAgY29udGVudDogKGNlbGwgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RleHQnKVswXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cmlidXRlcy50b29sdGlwLnZhbHVlO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbmV3IGpvaW50LnVpLlRvb2x0aXAoe1xyXG4gICAgICAgICAgICByb290VGFyZ2V0OiBkb2N1bWVudC5ib2R5LFxyXG4gICAgICAgICAgICB0YXJnZXQ6ICcudHEtbGctc2hvcnQtbGFiZWwnLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246ICdhdXRvJyxcclxuICAgICAgICAgICAgcGFkZGluZzogMTUsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IChjZWxsID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjZWxsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0ZXh0JylbMF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHJpYnV0ZXMudG9vbHRpcC52YWx1ZTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZURlcml2YXRpb25NYXAgKGRhdGFQcm92aWRlcikge1xyXG4gICAgICAgIF9kZXJpdmF0aW9uTWFwUGFuZWwgPSBuZXcgVFFHcmFtVUkuRmx5aW5nUGFuZWwoe1xyXG4gICAgICAgICAgICBiYXNlRWxlbWVudDogX2Jhc2UuZGVyaXZhdGlvbk1hcCxcclxuICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcclxuICAgICAgICAgICAgaGVhZGVyOiAnRGVyaXZhdGlvbiBNYXAnLFxyXG4gICAgICAgICAgICBlbXB0eUJvZHk6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaXplOiB7IHdpZHRoOiAnY2FsYygxMDAlIC0gMjAwcHgpJywgaGVpZ2h0OiAnY2FsYygxMDAlIC0gMjAwcHgpJ30sXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6ICcxMDBweCcsIHk6ICcxMDBweCd9LFxyXG4gICAgICAgICAgICBib2R5OiAnJyxcclxuICAgICAgICAgICAgcmVzaXphYmxlOiB0cnVlLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfZGVyaXZhdGlvbk1hcFBhbmVsLm9uKCdzaXplLWNoYW5nZWQnLCAoKSA9PiBfZGVyaXZhdGlvbk1hcC5yZXNldEZvY3VzKCkpO1xyXG5cclxuICAgICAgICBfZGVyaXZhdGlvbk1hcCA9IG5ldyBEZXJpdmF0aW9uTWFwKHtcclxuICAgICAgICAgICAgcm9vdEVsZW1lbnQ6IF9kZXJpdmF0aW9uTWFwUGFuZWwucm9vdEh0bWwucXVlcnlTZWxlY3RvcignLnRxLXVpLWJvZHlfY29udGFpbmVyJyksXHJcbiAgICAgICAgICAgIGRhdGFQcm92aWRlcjogZGF0YVByb3ZpZGVyXHJcbiAgICAgICAgfSwgX3BhcmFtZXRlcnMuZGVyaXZhdGlvbk1hcCk7XHJcblxyXG4gICAgICAgIHNlbGYudHJpZ2dlcignZGVyaXZhdGlvbi1tYXAtc3RhdGUtY2hhbmdlZCcpO1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcignZGVyaXZhdGlvbi1tYXAtc3RhdGUtaW5pdCcsX2Rlcml2YXRpb25NYXApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9jcmVhdGVCaXJkRXllIChkYXRhQ29udGFpbmVyKSB7XHJcbiAgICAgICAgX2JpcmRFeWUgPSBuZXcgQmlyZEV5ZSh7XHJcbiAgICAgICAgICAgIGVsOiBfYmFzZS5zaWdtYUdyYXBoLFxyXG4gICAgICAgICAgICBzY2FsZTogX2xpbmVhZ2VEaWFncmFtLnNjYWxlKCksXHJcbiAgICAgICAgICAgIGRhdGFDb250YWluZXI6IGRhdGFDb250YWluZXIsXHJcbiAgICAgICAgfSwgX3BhcmFtZXRlcnMpO1xyXG5cclxuICAgICAgICBfYmlyZEV5ZS5vbignc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkJywgKGV2ZW50T2JqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoX2N1cnJlbnRWaWV3ID09PSAnYmlyZEV5ZScpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfZ3JhcGhNYXApIF9ncmFwaE1hcC5zZXRTZWxlY3RlZEVsZW1lbnQoZXZlbnRPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgX3NlbGVjdGVkRWxlbWVudCA9IGdldEJhc2VFbGVtZW50KGV2ZW50T2JqZWN0KTtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkJywgX2dldE1vZGVsKF9zZWxlY3RlZEVsZW1lbnQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfYmlyZEV5ZS5vbignY2VsbC1kb3VibGUtY2xpY2snLCAoZXZlbnRPYmplY3QpID0+IHtcclxuICAgICAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChfY3VycmVudFZpZXcgPT09ICdiaXJkRXllJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50T2JqZWN0IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5MaW5rIHx8IGV2ZW50T2JqZWN0IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5UZXJtaW5hdGlvbkxpbmspIHtcclxuICAgICAgICAgICAgICAgICAgICBfYmlyZEV5ZS5zZXRTZWxlY3RlZEVsZW1lbnQoZXZlbnRPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gZXZlbnRPYmplY3Qub3JpZ2luYWxMaW5rIHx8IGV2ZW50T2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIF9zaG93RGVyaXZhdGlvbk1hcChsaW5rcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlQmlyZEV5ZSAoZGF0YUNvbnRhaW5lcikge1xyXG4gICAgICAgIF9iaXJkRXllLnNldERhdGEoZGF0YUNvbnRhaW5lcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBtYXAgSWYgbm90IGNyZWF0ZWQuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtEYXRhQ29udGFpbmVyfSBkYXRhQ29udGFpbmVyXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZVB1YmxpY01vZGVsW119IHZpZXdGcmFtZXNcclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVbXX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZU1hcCAoZGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lcykge1xyXG4gICAgICAgIGlmIChfYmFzZS5tYXBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgICAgICBfZ3JhcGhNYXAgPSAgbmV3IEdyYXBoTWFwKHtcclxuICAgICAgICAgICAgICAgIGVsOiBfYmFzZS5tYXBIVE1MRWxlbWVudCxcclxuICAgICAgICAgICAgICAgIHNjYWxlOiBfbGluZWFnZURpYWdyYW0uc2NhbGUoKSxcclxuICAgICAgICAgICAgICAgIHZpZXdGcmFtZXM6IHZpZXdGcmFtZXMsXHJcbiAgICAgICAgICAgICAgICBkYXRhQ29udGFpbmVyOiBkYXRhQ29udGFpbmVyLFxyXG4gICAgICAgICAgICB9LCBfcGFyYW1ldGVycyk7XHJcblxyXG4gICAgICAgICAgICBfZ3JhcGhNYXAub24oJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIChub2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfY3VycmVudFZpZXcgPT09ICdsaW5lYWdlRGlhZ3JhbScpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlSXNJbnZpc2libGUgPSBfbGluZWFnZURpYWdyYW0uZ2V0VmlzaWJsZU5vZGVzKCkuaW5kZXhPZihub2RlKSA9PT0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnNldFNlbGVjdGVkRWxlbWVudChub2RlLCBub2RlSXNJbnZpc2libGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKF9jdXJyZW50VmlldyA9PT0gJ2JpcmRFeWUnKSBfYmlyZEV5ZS5zZXRTZWxlY3RlZEVsZW1lbnQobm9kZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgX3NlbGVjdGVkRWxlbWVudCA9IGdldEJhc2VFbGVtZW50KG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWQnLCBfZ2V0TW9kZWwoX3NlbGVjdGVkRWxlbWVudCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIF9ncmFwaE1hcC5vbigndmlldy1mcmFtZXMtcG9zaXRpb24tY2hhbmdlZCcsICh2aWV3RnJhbWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2aWV3RnJhbWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICByZWN1cnNpb24odmlld0ZyYW1lc1tpbmRleCsrXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVjdXJzaW9uICh2aWV3RnJhbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfbGluZWFnZURpYWdyYW0ucG9zaXRpb25WaWV3UG9ydChcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld0ZyYW1lLCB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbiwgX3BhcmFtZXRlcnMuYW5pbWF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlld0ZyYW1lW2luZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2lvbih2aWV3RnJhbWVzW2luZGV4KytdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIF9ncmFwaE1hcDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIG1hcC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0RhdGFDb250YWluZXJ9IGRhdGFDb250YWluZXJcclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lUHVibGljTW9kZWxbXX0gdmlld0ZyYW1lc1xyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVtdfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlTWFwIChkYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzKSB7XHJcbiAgICAgICAgaWYgKF9ncmFwaE1hcCkge1xyXG4gICAgICAgICAgICBfZ3JhcGhNYXAuc2V0RGF0YShkYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfY3JlYXRlTWFwKGRhdGFDb250YWluZXIsIHZpZXdGcmFtZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0xpbmt8Tm9kZXxUZXJtaW5hdGlvbkxpbmt8VGVybWluYXRpb25Ob2RlfSBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJucyB7UHVibGljTm9kZU1vZGVsfFB1YmxpY0xpbmtNb2RlbH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldE1vZGVsIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRNb2RlbCA9IF8uY2xvbmVEZWVwKGVsZW1lbnQubW9kZWwpO1xyXG4gICAgICAgIGVsZW1lbnRNb2RlbC5ibHVyZWQgPSBCb29sZWFuKGVsZW1lbnQuZ2V0KCdibHVyZWQnKSk7XHJcbiAgICAgICAgZWxlbWVudE1vZGVsLmhpZ2hsaWdodGVkID0gQm9vbGVhbihlbGVtZW50LmdldCgnaGlnaGxpZ2h0ZWQnKSk7XHJcblxyXG4gICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5Ob2RlKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnRNb2RlbC5kaWFncmFtVHlwZSA9ICdub2RlJztcclxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLkxpbmspIHtcclxuICAgICAgICAgICAgZWxlbWVudE1vZGVsLnNvdXJjZSA9IGVsZW1lbnRNb2RlbC5zb3VyY2VUeXBlO1xyXG4gICAgICAgICAgICBlbGVtZW50TW9kZWwudGFyZ2V0ID0gZWxlbWVudE1vZGVsLnRhcmdldFR5cGU7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50TW9kZWwuc291cmNlVHlwZTtcclxuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRNb2RlbC50YXJnZXRUeXBlO1xyXG4gICAgICAgICAgICBlbGVtZW50TW9kZWwuZGlhZ3JhbVR5cGUgPSAnbGluayc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbGVtZW50TW9kZWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBkZXJpdmF0aW9uIG1hcCB3aW5kb3cuXHJcbiAgICAgKiBAcGFyYW0ge0xpbmt9IGxpbmtcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5rVHlwZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3Nob3dEZXJpdmF0aW9uTWFwIChsaW5rLCBsaW5rVHlwZSkge1xyXG4gICAgICAgIGlmIChsaW5rIGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5MaW5rKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVNYXAgPSBfZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXA7XHJcbiAgICAgICAgICAgIF9kZXJpdmF0aW9uTWFwLm9wZW5XaXRoUmVsYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgc291cmNlOiBub2RlTWFwW2xpbmsubW9kZWwuc291cmNlXS5tb2RlbCxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZU1hcFtsaW5rLm1vZGVsLnRhcmdldF0ubW9kZWwsXHJcbiAgICAgICAgICAgICAgICBsaW5rVHlwZTogbGlua1R5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBfZGVyaXZhdGlvbk1hcFBhbmVsLnNob3coKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHN0YXRlIG9mIGluZGljYXRvclxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZSAtIGZldGNoaW5nIHwgcmVuZGVyaW5nIHwgY29tcGxldGVkIHwgZXJyb3JcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gQ3VzdG9tIG1lc3NhZ2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3NldERpYWdyYW1TdGF0ZSAoc3RhdGUsIG1lc3NhZ2UpIHtcclxuICAgICAgICBfc3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZmV0Y2hpbmcnKSB7XHJcbiAgICAgICAgICAgIF9wcm9ncmVzc1NjcmVlbi5zZXRTdGF0ZSgnYWN0aXZlJywgbWVzc2FnZSB8fCAnRmV0Y2hpbmcgZGF0YScpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdyZW5kZXJpbmcnKSB7XHJcbiAgICAgICAgICAgIF9wcm9ncmVzc1NjcmVlbi5zZXRTdGF0ZSgnYWN0aXZlJywgbWVzc2FnZSB8fCAnUmVuZGVyaW5nIGdyYXBoJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgX3Byb2dyZXNzU2NyZWVuLnNldFN0YXRlKCdjb21wbGV0ZWQnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnZXJyb3InKSB7XHJcbiAgICAgICAgICAgIF9wcm9ncmVzc1NjcmVlbi5zZXRTdGF0ZSgnZXJyb3InLCBtZXNzYWdlIHx8ICdFcnJvciBoYXMgb2NjdXJyZWQhJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbGYudHJpZ2dlcignZGlhZ3JhbS1zdGF0ZS1jaGFuZ2VkJywgc3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBodG1sIG1hcmt1cC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBodG1sTm9kZSAtIFJvb3Qgbm9kZSBmb3IgbWFya3VwXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsIEhUTUxFbGVtZW50Pn0gLSBNYXAgb2YgaHRtbCBlbGVtZW50c1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfY3JlYXRlQmFzZSAoaHRtbE5vZGUpIHtcclxuICAgICAgICBodG1sTm9kZS5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICBodG1sTm9kZS50YWJJbmRleCA9IDE7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgICAgICBiYXNlRGl2LmNsYXNzTmFtZSA9ICd0cV9saW5lYWdlJztcclxuICAgICAgICBiYXNlRGl2LmlkID0gJ3RxX2xpbmVhZ2UnO1xyXG4gICAgICAgIGh0bWxOb2RlLmFwcGVuZENoaWxkKGJhc2VEaXYpO1xyXG5cclxuICAgICAgICBjb25zdCBsaW5lYWdlRGlhZ3JhbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgICAgIGxpbmVhZ2VEaWFncmFtLmNsYXNzTmFtZSA9ICd0cV9saW5lYWdlX19ncmFwaCc7XHJcbiAgICAgICAgbGluZWFnZURpYWdyYW0uaWQgPSAndHFfbGluZWFnZS1ncmFwaCc7XHJcbiAgICAgICAgYmFzZURpdi5hcHBlbmRDaGlsZChsaW5lYWdlRGlhZ3JhbSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNpZ21hR3JhcGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgICAgICBzaWdtYUdyYXBoLmNsYXNzTmFtZSA9ICd0cV9saW5lYWdlX19zaWdtYV9ncmFwaCc7XHJcbiAgICAgICAgc2lnbWFHcmFwaC5pZCA9ICd0cV9saW5lYWdlLXNpZ21hLWdyYXBoJztcclxuICAgICAgICBiYXNlRGl2LmFwcGVuZENoaWxkKHNpZ21hR3JhcGgpO1xyXG5cclxuICAgICAgICBjb25zdCBkZXJpdmF0aW9uTWFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgYmFzZURpdi5hcHBlbmRDaGlsZChkZXJpdmF0aW9uTWFwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29udGFpbmVyOiBodG1sTm9kZSxcclxuICAgICAgICAgICAgYmFzZURpdjogYmFzZURpdixcclxuICAgICAgICAgICAgbGluZWFnZURpYWdyYW06IGxpbmVhZ2VEaWFncmFtLFxyXG4gICAgICAgICAgICBzaWdtYUdyYXBoOiBzaWdtYUdyYXBoLFxyXG4gICAgICAgICAgICBkZXJpdmF0aW9uTWFwOiBkZXJpdmF0aW9uTWFwLFxyXG4gICAgICAgICAgICBtYXBIVE1MRWxlbWVudDogX2dldE1hcEhUTUwoX3BhcmFtZXRlcnMubWFwUm9vdEh0bWwpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQ3JlYXRlcyBodG1sIG1hcmt1cCBmb3IgbWFwLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTEVsZW1lbnR9IG1hcFJvb3RIdG1sIC0gSUQgb2Ygcm9vdCBlbGVtZW50IG9yIEhUTUxFbGVtZW50XHJcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRNYXBIVE1MIChtYXBSb290SHRtbCkge1xyXG4gICAgICAgIGxldCBtYXBSb290SHRtbEh0bWw7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBSb290SHRtbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbWFwUm9vdEh0bWxIdG1sID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWFwUm9vdEh0bWwpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hcFJvb3RIdG1sID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBtYXBSb290SHRtbEh0bWwgPSBtYXBSb290SHRtbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbWFwSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKG1hcFJvb3RIdG1sSHRtbCkgeyAvLyBjaGVjayBlbGVtZW50XHJcbiAgICAgICAgICAgIC8vIENsZWFyIGEgY29udGVudCBvZiB0aGUgbWFwIHJvb3QgaHRtbCBlbGVtZW50XHJcbiAgICAgICAgICAgIG1hcFJvb3RIdG1sSHRtbC5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcHJpdmF0ZSByb290IGZvciBtYXAgaW50byB0aGUgcHVibGljIHJvb3QuXHJcbiAgICAgICAgICAgIC8vIChVc2VyIGNhbiBjaGFuZ2Ugc3R5bGUgb2YgcHVibGljIHJvb3QpXHJcbiAgICAgICAgICAgIG1hcEhUTUxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgICAgIG1hcEhUTUxFbGVtZW50LmNsYXNzTmFtZSA9ICd0cS1sZ19fbWFwJztcclxuICAgICAgICAgICAgbWFwUm9vdEh0bWxIdG1sLmFwcGVuZENoaWxkKG1hcEhUTUxFbGVtZW50KTsgLy8gYWRkaW5nIHRoZSBwcml2YXRlIHJvb3QgaW50byB0aGUgcHVibGljXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXBIVE1MRWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBNYWtlcyB0aGUgdmlldy0xIHZpc2libGUgYW5kIHRoZSB2aWV3LTIgaW52aXNpYmxlLlxyXG4gICAgICogQGZpcmVzIGN1cnJlbnQtdmlldy1jaGFuZ2VkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9zaG93U2lnbWFHcmFwaCAoKSB7XHJcbiAgICAgICAgX2Jhc2Uuc2lnbWFHcmFwaC5zdHlsZS5vcGFjaXR5ID0gMTtcclxuICAgICAgICBfYmFzZS5zaWdtYUdyYXBoLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYXV0byc7XHJcblxyXG4gICAgICAgIF9iYXNlLmxpbmVhZ2VEaWFncmFtLnN0eWxlLm9wYWNpdHkgPSAwO1xyXG4gICAgICAgIF9iYXNlLmxpbmVhZ2VEaWFncmFtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XHJcblxyXG4gICAgICAgIGlmIChfc3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgIGlmIChfY3VycmVudFZpZXcgIT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgX2JpcmRFeWUuc2V0U2VsZWN0ZWRFbGVtZW50KF9saW5lYWdlRGlhZ3JhbS5nZXRTZWxlY3RlZEVsZW1lbnQoKSk7XHJcbiAgICAgICAgICAgICAgICBfYmlyZEV5ZS5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfbGluZWFnZURpYWdyYW0ucmVzaXplKCk7XHJcbiAgICAgICAgICAgICAgICBfYmlyZEV5ZS5zaWdtYUdyYXBoLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX2N1cnJlbnRWaWV3ID0gJ2JpcmRFeWUnO1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcignY3VycmVudC12aWV3LWNoYW5nZWQnLCBfY3VycmVudFZpZXcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIE1ha2VzIHRoZSB2aWV3LTIgdmlzaWJsZSBhbmQgdGhlIHZpZXctMSBpbnZpc2libGUuXHJcbiAgICAgKiBAZmlyZXMgY3VycmVudC12aWV3LWNoYW5nZWRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3Nob3dKb2ludEdyYXBoICgpIHtcclxuICAgICAgICBfYmFzZS5zaWdtYUdyYXBoLnN0eWxlLm9wYWNpdHkgPSAwO1xyXG4gICAgICAgIF9iYXNlLnNpZ21hR3JhcGguc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcclxuXHJcbiAgICAgICAgX2Jhc2UubGluZWFnZURpYWdyYW0uc3R5bGUub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgX2Jhc2UubGluZWFnZURpYWdyYW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcclxuXHJcbiAgICAgICAgaWYgKF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgaWYgKF9jdXJyZW50VmlldyAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2JpcmRFeWUuc2VsZWN0ZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlzaWJsZU5vZGVzID0gX2xpbmVhZ2VEaWFncmFtLmdldFZpc2libGVOb2RlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzU2VsZWN0ZWROb2RlID0gX2JpcmRFeWUuc2VsZWN0ZWRFbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVJc0ludmlzaWJsZSA9IHZpc2libGVOb2Rlcy5pbmRleE9mKF9iaXJkRXllLnNlbGVjdGVkRWxlbWVudCkgPT09IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzU2VsZWN0ZWRMaW5rID0gX2JpcmRFeWUuc2VsZWN0ZWRFbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5MaW5rO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbE9mVGhlRW5kc0lzSW52aXNpYmxlID0gdmlzaWJsZU5vZGVzLmluZGV4T2YoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kYXRhQ29udGFpbmVyLm1hcHMubm9kZU1hcFtfYmlyZEV5ZS5zZWxlY3RlZEVsZW1lbnQubW9kZWwuc291cmNlXVxyXG4gICAgICAgICAgICAgICAgICAgICkgPT09IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvY3VzT24gPSBpc1NlbGVjdGVkTm9kZSAmJiBub2RlSXNJbnZpc2libGUgfHwgaXNTZWxlY3RlZExpbmsgJiYgYWxsT2ZUaGVFbmRzSXNJbnZpc2libGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS5zZXRTZWxlY3RlZEVsZW1lbnQoX2JpcmRFeWUuc2VsZWN0ZWRFbGVtZW50LCBmb2N1c09uKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnJlZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnJlc2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnJlZHJhdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfY3VycmVudFZpZXcgPSAnbGluZWFnZURpYWdyYW0nO1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcignY3VycmVudC12aWV3LWNoYW5nZWQnLCBfY3VycmVudFZpZXcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIE1ha2VzIHRoZSB2aWV3LTIgYW5kIHRoZSB2aWV3LTEgaW52aXNpYmxlLlxyXG4gICAgICogQGZpcmVzIGN1cnJlbnQtdmlldy1jaGFuZ2VkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9oaWRlVmlld3MgKCkge1xyXG4gICAgICAgIC8vIF9iYXNlLmNvbnRhaW5lci5jbGFzc05hbWUgPSAndHFfbGluZWFnZV9kaXNhYmxlJztcclxuICAgICAgICBfYmFzZS5zaWdtYUdyYXBoLnN0eWxlLm9wYWNpdHkgPSAwO1xyXG4gICAgICAgIF9iYXNlLnNpZ21hR3JhcGguc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcclxuICAgICAgICBfYmFzZS5saW5lYWdlRGlhZ3JhbS5zdHlsZS5vcGFjaXR5ID0gMDtcclxuICAgICAgICBfYmFzZS5saW5lYWdlRGlhZ3JhbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xyXG5cclxuICAgICAgICBfY3VycmVudFZpZXcgPSAnbm9uZSc7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdjdXJyZW50LXZpZXctY2hhbmdlZCcsIF9jdXJyZW50Vmlldyk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgTGluZWFnZUdyYW07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuaW1wb3J0ICogYXMgTGluZWFnZUdyYW0gZnJvbSAnLi9saW5lYWdlR3JhbSc7XHJcbmltcG9ydCBEZWZhdWx0RGF0YVByb3ZpZGVyIGZyb20gJy4vZGF0YS9kZWZhdWx0RGF0YVByb3ZpZGVyJztcclxuaW1wb3J0IEluZm9QYW5lbCBmcm9tICcuL2h0bWxVSS9pbmZvUGFuZWwnO1xyXG5pbXBvcnQgT3B0aW9uc1BhbmVsIGZyb20gJy4vaHRtbFVJL29wdGlvbnNQYW5lbCc7XHJcbmltcG9ydCBNYXAgZnJvbSAnLi9odG1sVUkvbWFwJztcclxuaW1wb3J0IERlZmF1bHRVSSBmcm9tICcuL2h0bWxVSS9kZWZhdWx0VUknO1xyXG5pbXBvcnQgeyBEZXJpdmF0aW9uTWFwIH0gZnJvbSAnLi9qb2ludFZpZXdzL2Rlcml2YXRpb25NYXAvZGVyaXZhdGlvbk1hcCc7XHJcbnJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcclxucmVxdWlyZSgnd2hhdHdnLWZldGNoJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIExpbmVhZ2VHcmFtOiBMaW5lYWdlR3JhbS5MaW5lYWdlR3JhbSxcclxuICAgIGdldERlZmF1bHRQYXJhbWV0ZXJzU2V0OiBMaW5lYWdlR3JhbS5nZXREZWZhdWx0UGFyYW1ldGVyc1NldCxcclxuICAgIERlZmF1bHREYXRhUHJvdmlkZXI6IERlZmF1bHREYXRhUHJvdmlkZXIsXHJcbiAgICBEZXJpdmF0aW9uTWFwOiBEZXJpdmF0aW9uTWFwLFxyXG4gICAgdWlVdGlsczoge1xyXG4gICAgICAgIERlZmF1bHRVSTogRGVmYXVsdFVJLFxyXG4gICAgICAgIE1hcDogTWFwLFxyXG4gICAgICAgIEluZm9QYW5lbDogSW5mb1BhbmVsLFxyXG4gICAgICAgIE9wdGlvbnNQYW5lbDogT3B0aW9uc1BhbmVsLFxyXG4gICAgfSxcclxufTsiLCJpbXBvcnQgU2lnbWFCYXNlIGZyb20gJy4vc2lnbWFCYXNlJztcclxuaW1wb3J0ICogYXMgZ3JhcGhFbGVtZW50cyBmcm9tICcuLi9qb2ludFZpZXdzL2dyYXBoRWxlbWVudHMvZWxlbWVudHMnO1xyXG5pbXBvcnQgeyBnZXRQYXRoIH0gZnJvbSAnLi4vdXRpbHMvbGluZWFnZURpYWdyYW1VdGlscyc7XHJcblxyXG4vKiogXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiBNaW5pIG1hcCBpbiB0aGUgcmlnaHQtYm90dG9tIGNvcm5lcixcclxuICogd2hpY2ggc2hvd3MgdGhlIGZ1bGwgZ3JhcGggd2l0aCB2aWV3RnJhbWUncyBwb3NpdGlvbnMgd2l0aG91dCBsaW5rc1xyXG4gKiBAYXVnbWVudHMgU2lnbWFCYXNlXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBCaXJkRXllIChvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIGNvbnN0IF9jb2xvcnMgPSBwYXJhbWV0ZXJzLmNvbG9ycztcclxuICAgIGxldCBfcGF0aCA9IG51bGw7XHJcblxyXG4gICAgU2lnbWFCYXNlLmFwcGx5KHNlbGYsIFtvcHRpb25zLCBwYXJhbWV0ZXJzXSk7XHJcblxyXG4gICAgY29uc3Qgb2xkU2V0U2VsZWN0ZWRFbGVtZW50ID0gc2VsZi5zZXRTZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICBzZWxmLnNldFNlbGVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgbGV0IHNlbGVjdGVkRWxlbWVudDtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLk5vZGUgfHxcclxuICAgICAgICAgICAgZWxlbWVudCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuVGVybWluYXRpb25Ob2RlXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IGVsZW1lbnQub3JpZ2luYWxOb2RlIHx8IGVsZW1lbnQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5MaW5rKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBlbGVtZW50Lm9yaWdpbmFsTGluayB8fCBlbGVtZW50O1xyXG4gICAgICAgICAgICBzZWxlY3RlZEVsZW1lbnQgPSBsaW5rO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZEVsZW1lbnQgIT09IHNlbGVjdGVkRWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBfcGF0aCA9IGdldFBhdGgoc2VsZWN0ZWRFbGVtZW50LCBzZWxmLl9kYXRhQ29udGFpbmVyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9wYXRoID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBvbGRTZXRTZWxlY3RlZEVsZW1lbnQuY2FsbChzZWxmLCBzZWxlY3RlZEVsZW1lbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLl9yZWZyZXNoTm9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IHNlbGYuX2RhdGFDb250YWluZXIubWFwcy5ub2RlTWFwO1xyXG5cclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGgubm9kZXMoKS5mb3JFYWNoKHNpZ21hTm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChub2RlTWFwW3NpZ21hTm9kZS5pZF0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwW3NpZ21hTm9kZS5pZF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IG5vZGUubW9kZWw7XHJcbiAgICAgICAgICAgICAgICBzaWdtYU5vZGUueCA9IG1vZGVsLnBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgICAgICBzaWdtYU5vZGUueSA9IG1vZGVsLnBvc2l0aW9uLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2lnbWFOb2RlLmNvbG9yID0gc2VsZi5zZWxlY3RlZEVsZW1lbnQgJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaWQgPT09IHNlbGYuc2VsZWN0ZWRFbGVtZW50LmlkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZEVsZW1lbnQuYXNwZWN0cyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWRFbGVtZW50LmFzcGVjdHMuZmlsdGVyKGEgPT4gYS5pZCA9PT0gbm9kZS5pZCkubGVuZ3RoID4gMFxyXG4gICAgICAgICAgICAgICAgKSA/IFxyXG4gICAgICAgICAgICAgICAgICAgIF9jb2xvcnNbJ3NlbGVjdGVkJ10gOlxyXG4gICAgICAgICAgICAgICAgICAgICghX3BhdGh8fCBfcGF0aFtub2RlLmlkXSA/IF9jb2xvcnNbbW9kZWwudHlwZUlkXSA6IF9jb2xvcnNbJ2JsdXJlZCddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLl9yZWZyZXNoVmlld0ZyYW1lcyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuICAgIHNlbGYuX3JlZnJlc2hMaW5rcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguZWRnZXMoKS5mb3JFYWNoKGwgPT4ge1xyXG4gICAgICAgICAgICBsLnNpemUgPSBzZWxmLnNlbGVjdGVkRWxlbWVudCAmJiBsLmlkID09PSBzZWxmLnNlbGVjdGVkRWxlbWVudC5pZCA/IDUgOiAxLFxyXG4gICAgICAgICAgICBsLmNvbG9yID0gXHJcbiAgICAgICAgICAgICAgICAhX3BhdGggfHwgX3BhdGhbbC5pZF0gPyBcclxuICAgICAgICAgICAgICAgICAgICAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWRFbGVtZW50ICYmIGwuaWQgPT09IHNlbGYuc2VsZWN0ZWRFbGVtZW50LmlkID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb2xvcnNbJ3NlbGVjdGVkJ10gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FzcGVjdExpbmtzW2wuaWRdID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbG9yc1snYXNwZWN0TGluayddIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbG9yc1snbGluayddXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgX2NvbG9yc1snYmx1cmVkJ107XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBzZWxmLl9pbml0aWFsaXplKCk7XHJcbn1cclxuXHJcbkJpcmRFeWUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTaWdtYUJhc2UucHJvdG90eXBlKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJpcmRFeWU7XHJcbiIsImltcG9ydCBTaWdtYUJhc2UgZnJvbSAnLi9zaWdtYUJhc2UnO1xyXG5pbXBvcnQgKiBhcyBncmFwaEVsZW1lbnRzIGZyb20gJy4uL2pvaW50Vmlld3MvZ3JhcGhFbGVtZW50cy9lbGVtZW50cyc7XHJcblxyXG4vKiogXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiBNaW5pIG1hcCBpbiB0aGUgcmlnaHQtYm90dG9tIGNvcm5lcixcclxuICogd2hpY2ggc2hvd3MgdGhlIGZ1bGwgZ3JhcGggd2l0aCB2aWV3RnJhbWUncyBwb3NpdGlvbnMgd2l0aG91dCBsaW5rc1xyXG4gKiBAYXVnbWVudHMgU2lnbWFCYXNlXHJcbiAqIEBmaXJlcyB2aWV3LWZyYW1lcy1wb3NpdGlvbi1jaGFuZ2VkIChwYXJhbXM6IFZpZXdGcmFtZVB1YmxpY01vZGVsW10pXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBHcmFwaE1hcCAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICBsZXQgX3ZpZXdGcmFtZXNNYXAgPSB7fTtcclxuICAgIG9wdGlvbnMudmlld0ZyYW1lcy5mb3JFYWNoKHZmID0+IF92aWV3RnJhbWVzTWFwW3ZmLmlkXSA9IHZmKTtcclxuXHJcbiAgICBTaWdtYUJhc2UuYXBwbHkoc2VsZiwgW29wdGlvbnMsIHBhcmFtZXRlcnNdKTtcclxuXHJcbiAgICBzZWxmLl9nZXREYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7IG5vZGVzOiBzZWxmLl9kYXRhQ29udGFpbmVyLm5vZGVzLCBsaW5rczogW10gfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRlZmluaXRpb25cclxuICAgICAqL1xyXG4gICAgY29uc3Qgb2xkU2V0U2VsZWN0ZWRFbGVtZW50ID0gc2VsZi5zZXRTZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICBzZWxmLnNldFNlbGVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgbGV0IHNlbGVjdGVkRWxlbWVudDtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLk5vZGUgfHxcclxuICAgICAgICAgICAgZWxlbWVudCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuVGVybWluYXRpb25Ob2RlXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IGVsZW1lbnQub3JpZ2luYWxOb2RlIHx8IGVsZW1lbnQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5MaW5rKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBlbGVtZW50Lm9yaWdpbmFsTGluayB8fCBlbGVtZW50O1xyXG4gICAgICAgICAgICBzZWxlY3RlZEVsZW1lbnQgPSBsaW5rO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBncmFwaCA9IHNlbGYuc2lnbWFHcmFwaC5ncmFwaDtcclxuICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZEVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLkxpbmspIHtcclxuICAgICAgICAgICAgZ3JhcGguZHJvcEVkZ2Uoc2VsZi5zZWxlY3RlZEVsZW1lbnQuaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5MaW5rKSB7XHJcbiAgICAgICAgICAgIGdyYXBoLmFkZEVkZ2Uoc2VsZi5fY3JlYXRlTGluayhzZWxlY3RlZEVsZW1lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2xkU2V0U2VsZWN0ZWRFbGVtZW50LmNhbGwoc2VsZiwgc2VsZWN0ZWRFbGVtZW50KTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgb3ZlcnJpZGVSZWRyYXcgPSBzZWxmLnJlZHJhdztcclxuICAgIHNlbGYucmVkcmF3ID0gZnVuY3Rpb24gKHJlbmRlck9wdGlvbnMpIHtcclxuICAgICAgICBvdmVycmlkZVJlZHJhdyhyZW5kZXJPcHRpb25zKTtcclxuICAgICAgICByZW5kZXJPcHRpb25zID0gcmVuZGVyT3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBpZiAocmVuZGVyT3B0aW9ucy52aWV3RnJhbWVzKSByZW5kZXJPcHRpb25zLnZpZXdGcmFtZXMuZm9yRWFjaCh2ZiA9PiBfdmlld0ZyYW1lc01hcFt2Zi5pZF0gPSB2Zik7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IG92ZXJyaWRlZFNldERhdGEgPSBzZWxmLnNldERhdGE7XHJcbiAgICBzZWxmLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lcykge1xyXG4gICAgICAgIG92ZXJyaWRlZFNldERhdGEoZGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lcyk7XHJcbiAgICAgICAgX3ZpZXdGcmFtZXNNYXAgPSB7fTtcclxuICAgICAgICB2aWV3RnJhbWVzLmZvckVhY2godmYgPT4gX3ZpZXdGcmFtZXNNYXBbdmYuaWRdID0gdmYpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHZpZXdGcmFtZXMgc3RhdGUuIFxyXG4gICAgICogQHBhcmFtIHtWaWV3RnJhbWVQdWJsaWNNb2RlbH0gdmlld0ZyYW1lc1xyXG4gICAgICovXHJcbiAgICBjb25zdCBfb2xkSW1wbGVtZW50YXRpb24gPSBzZWxmLl9yZWZyZXNoVmlld0ZyYW1lcztcclxuICAgIHNlbGYuX3JlZnJlc2hWaWV3RnJhbWVzID0gZnVuY3Rpb24gKHZpZXdGcmFtZXMpIHtcclxuICAgICAgICBfb2xkSW1wbGVtZW50YXRpb24odmlld0ZyYW1lcyk7XHJcbiAgICAgICAgdmlld0ZyYW1lcy5mb3JFYWNoKHZmID0+IF92aWV3RnJhbWVzTWFwW3ZmLmlkXSA9IHZmKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVkZWZpbml0aW9uLlxyXG4gICAgICovXHJcbiAgICBzZWxmLl9zdWJzY3JpYmVPbkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguYmluZCgnY2xpY2tTdGFnZScsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbENsaWNrUG9pbnQgPSBfY29ubnZlcnRQb2ludChlKTtcclxuICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lcyA9IE9iamVjdC5rZXlzKF92aWV3RnJhbWVzTWFwKS5tYXAoa2V5ID0+IF92aWV3RnJhbWVzTWFwW2tleV0pO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpZXdGcmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZSA9IHZpZXdGcmFtZXNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXdGcmFtZS5hY3RpdmUpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5YOiB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbkJvdW5kcy5taW5YLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pblk6IHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uQm91bmRzLm1pblksXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WDogdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb25Cb3VuZHMubWF4WCArIHZpZXdGcmFtZS52aWV3UG9ydEJvdW5kcy53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBtYXhZOiB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbkJvdW5kcy5tYXhZICsgdmlld0ZyYW1lLnZpZXdQb3J0Qm91bmRzLmhlaWdodCxcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnRIaXRzVGhlQm91bmRzID0gYm91bmRzLm1pblggPD0gZ2xvYmFsQ2xpY2tQb2ludC54ICYmIGdsb2JhbENsaWNrUG9pbnQueCA8PSBib3VuZHMubWF4WCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLm1pblkgPD0gZ2xvYmFsQ2xpY2tQb2ludC55ICYmIGdsb2JhbENsaWNrUG9pbnQueSA8PSBib3VuZHMubWF4WTtcclxuICAgICAgICAgICAgICAgIGlmIChwb2ludEhpdHNUaGVCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3RnJhbWVPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdmlld0ZyYW1lLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3UG9ydFBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBnbG9iYWxDbGlja1BvaW50LnggLSB2aWV3RnJhbWUuc2l6ZS53aWR0aCAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBnbG9iYWxDbGlja1BvaW50LnkgLSB2aWV3RnJhbWUuc2l6ZS5oZWlnaHQgLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3ZpZXctZnJhbWVzLXBvc2l0aW9uLWNoYW5nZWQnLCBbW3ZpZXdGcmFtZU9wdGlvbnNdXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmJpbmQoJ2NsaWNrTm9kZScsIChldnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGV2dC5kYXRhLm5vZGUgPyBzZWxmLl9kYXRhQ29udGFpbmVyLm1hcHMubm9kZU1hcFtldnQuZGF0YS5ub2RlLmlkXSA6IG51bGw7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0U2VsZWN0ZWRFbGVtZW50KG5vZGUpO1xyXG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIG5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguYmluZCgnY2xpY2tFZGdlJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rID0gZXZ0LmRhdGEuZWRnZSA/IHNlbGYuX2RhdGFDb250YWluZXIubWFwcy5saW5rTWFwW2V2dC5kYXRhLmVkZ2UuaWRdIDogbnVsbDtcclxuICAgICAgICAgICAgc2VsZi5zZXRTZWxlY3RlZEVsZW1lbnQobGluayk7XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkJywgbGluayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIENhbGN1bGF0ZXMgc2lnbWEgcGFwZXIgcG9pbnQgdG8gam9pbnQgcGFwZXIgcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0ge1xyXG4gICAgICogIGRhdGE6IHtcclxuICAgICAqICAgICAgY3B0b3I6IHtcclxuICAgICAqICAgICAgICAgIGNsaWVudFgsXHJcbiAgICAgKiAgICAgICAgICBjbGllbnRZXHJcbiAgICAgKiAgICAgIH1cclxuICAgICAqICB9XHJcbiAgICAgKiB9IGV2ZW50XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2Nvbm52ZXJ0UG9pbnQgKGV2ZW50KSB7XHJcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBzZWxmLnNpZ21hR3JhcGgucmVuZGVyZXJzWzBdO1xyXG4gICAgICAgIGNvbnN0IF9wcmVmaXggPSByZW5kZXJlci5vcHRpb25zLnByZWZpeDtcclxuICAgICAgICByZXR1cm4gZXhlY3V0ZU5vZGVNb3VzZU1vdmUoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZU5vZGVNb3VzZU1vdmUgKCkge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX2NhbGN1bGF0ZU9mZnNldChyZW5kZXJlci5jb250YWluZXIpLFxyXG4gICAgICAgICAgICAgICAgeCA9IGV2ZW50LmRhdGEuY2FwdG9yLmNsaWVudFggLSBvZmZzZXQubGVmdCxcclxuICAgICAgICAgICAgICAgIHkgPSBldmVudC5kYXRhLmNhcHRvci5jbGllbnRZIC0gb2Zmc2V0LnRvcCxcclxuICAgICAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKHNlbGYuc2lnbWFHcmFwaC5jYW1lcmEuYW5nbGUpLFxyXG4gICAgICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oc2VsZi5zaWdtYUdyYXBoLmNhbWVyYS5hbmdsZSksXHJcbiAgICAgICAgICAgICAgICBub2RlcyA9IHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5ub2RlcygpLFxyXG4gICAgICAgICAgICAgICAgcmVmID0gW107XHJcblxyXG4gICAgICAgICAgICAvLyBHZXR0aW5nIGFuZCBkZXJvdGF0aW5nIHRoZSByZWZlcmVuY2UgY29vcmRpbmF0ZXMuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF1eCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBuLnggKiBjb3MgKyBuLnkgKiBzaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgeTogbi55ICogY29zIC0gbi54ICogc2luLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlblg6IG5bX3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVuWTogbltfcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZWYucHVzaChhdXgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseWluZyBsaW5lYXIgaW50ZXJwb2xhdGlvbi5cclxuICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGVzIGFyZSBvbiB0b3Agb2YgZWFjaCBvdGhlciwgd2UgdXNlIHRoZSBjYW1lcmEgcmF0aW8gdG8gaW50ZXJwb2xhdGVcclxuICAgICAgICAgICAgaWYgKHJlZlswXS54ID09PSByZWZbMV0ueCAmJiByZWZbMF0ueSA9PT0gcmVmWzFdLnkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB4UmF0aW8gPSAocmVmWzBdLnJlblggPT09IDApID8gMSA6IHJlZlswXS5yZW5YO1xyXG4gICAgICAgICAgICAgICAgdmFyIHlSYXRpbyA9IChyZWZbMF0ucmVuWSA9PT0gMCkgPyAxIDogcmVmWzBdLnJlblk7XHJcbiAgICAgICAgICAgICAgICB4ID0gKHJlZlswXS54IC8geFJhdGlvKSAqICh4IC0gcmVmWzBdLnJlblgpICsgcmVmWzBdLng7XHJcbiAgICAgICAgICAgICAgICB5ID0gKHJlZlswXS55IC8geVJhdGlvKSAqICh5IC0gcmVmWzBdLnJlblkpICsgcmVmWzBdLnk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4UmF0aW8gPSAocmVmWzFdLnJlblggLSByZWZbMF0ucmVuWCkgLyAocmVmWzFdLnggLSByZWZbMF0ueCk7XHJcbiAgICAgICAgICAgICAgICB5UmF0aW8gPSAocmVmWzFdLnJlblkgLSByZWZbMF0ucmVuWSkgLyAocmVmWzFdLnkgLSByZWZbMF0ueSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNvb3JkaW5hdGVzIGFyZSB0aGUgc2FtZSwgd2UgdXNlIHRoZSBvdGhlciByYXRpbyB0byBpbnRlcnBvbGF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlZlsxXS54ID09PSByZWZbMF0ueCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHhSYXRpbyA9IHlSYXRpbztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmVmWzFdLnkgPT09IHJlZlswXS55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeVJhdGlvID0geFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHggPSAoeCAtIHJlZlswXS5yZW5YKSAvIHhSYXRpbyArIHJlZlswXS54O1xyXG4gICAgICAgICAgICAgICAgeSA9ICh5IC0gcmVmWzBdLnJlblkpIC8geVJhdGlvICsgcmVmWzBdLnk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7IHg6ICh4ICogY29zIC0geSAqIHNpbiksIHk6ICh5ICogY29zICsgeCAqIHNpbikgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlcyB0aGUgZ2xvYmFsIG9mZnNldCBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBtb3JlIGFjY3VyYXRlbHkgdGhhblxyXG4gICAgLy8gZWxlbWVudC5vZmZzZXRUb3AgYW5kIGVsZW1lbnQub2Zmc2V0TGVmdC5cclxuICAgIGZ1bmN0aW9uIF9jYWxjdWxhdGVPZmZzZXQgKGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcclxuICAgICAgICB2YXIgZ2V0Q3NzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKS5yZXBsYWNlKCdweCcsICcnKSkgfHwgMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxlZnQ6IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIGdldENzc1Byb3BlcnR5KCdwYWRkaW5nLWxlZnQnKSxcclxuICAgICAgICAgICAgdG9wOiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIGdldENzc1Byb3BlcnR5KCdwYWRkaW5nLXRvcCcpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmLl9pbml0aWFsaXplKCk7XHJcbn1cclxuR3JhcGhNYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTaWdtYUJhc2UucHJvdG90eXBlKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEdyYXBoTWFwO1xyXG4iLCJpbXBvcnQgU2lnbWEgZnJvbSAnc2lnbWEnO1xyXG5pbXBvcnQgKiBhcyBTaWdtYVNuYXBzaG90UGx1Z2luIGZyb20gJy4vc2lnbWFQbGFnaW5zL3NpZ21hLnJlbmRlcmVycy5zbmFwc2hvdC9zaWdtYS5yZW5kZXJlcnMuc25hcHNob3QnO1xyXG5pbXBvcnQgU3Vic2NyaWJhYmxlIGZyb20gJy4uL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlJztcclxuaW1wb3J0ICogYXMgZ3JhcGhFbGVtZW50cyBmcm9tICcuLi9qb2ludFZpZXdzL2dyYXBoRWxlbWVudHMvZWxlbWVudHMnO1xyXG5pbXBvcnQgc2F2ZUFzIGZyb20gJ2ZpbGUtc2F2ZXJqcyc7XHJcbmltcG9ydCB7IGRhdGUyU3RyaW5nLCBwbmcyQmxvYiB9IGZyb20gJy4uL3V0aWxzL2RhdGFVdGlscyc7XHJcbmltcG9ydCB7IGdldEdsb2JhbE5vZGVQb3NpdGlvbiB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuXHJcblNpZ21hU25hcHNob3RQbHVnaW4udXNlUGx1Z2luKFNpZ21hKTtcclxuXHJcbi8qKiBcclxuICogQHByaXZhdGVcclxuICogQGNsYXNzXHJcbiAqIEl0J3MgdGhlIGJhc2UgY2xhc3MgZm9yIHNpZ21hIHZpZXdzLlxyXG4gKiBcclxuICogQ29uc3RydWN0b3IgcGFyYW1ldGVyczpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAcGFyYW0ge1xyXG4gKiAgZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lclxyXG4gKiAgdmlld0ZyYW1lczogVmlld0ZyYW1lUHVibGljTW9kZWxbXVxyXG4gKiAgZWw6IEhUTUxFbGVtZW50XHJcbiAqICBzZWxlY3RlZEVsZW1lbnQ6IE5vZGV8TGlua1xyXG4gKiAgc2NhbGU6bnVtYmVyXHJcbiAqIH0gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSBwYXJhbWV0ZXJzIHNldFxyXG4gKiBcclxuICogUHVibGljIHByb3BlcnRpZXM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogc2VsZWN0ZWRFbGVtZW50OiBOb2RlfExpbmtcclxuICogXHJcbiAqIFB1YmxpYyBtZXRob2RzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIHNldFNlbGVjdGVkRWxlbWVudDogKGVsZW1lbnQ6IE5vZGV8TGluaykgPT4gdm9pZFxyXG4gKiBzZXREYXRhOiAoZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lczogVmlld0ZyYW1lW10pID0+IHZvaWRcclxuICogc2V0U2NhbGU6IChzY2FsZTogbnVtYmVyKSA9PiB2b2lkXHJcbiAqIHJlZnJlc2g6ICgpID0+IHZvaWRcclxuICogZXhwb3J0OiAobmFtZT86IHN0cmluZykgPT4gdm9pZFxyXG4gKiBwcmludDogKCkgPT4gdm9pZFxyXG4gKiByZWRyYXc6ICgpID0+IHZvaWRcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBvbiAoZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6IGZ1bmN0aW9uKTogdm9pZFxyXG4gKiB1bnN1YnNjcmliZSAoY2FsbGJhY2s6IGZ1bmN0aW9uKTogdm9pZFxyXG4gKiB0cmlnZ2VyIChldmVudDogc3RyaW5nLCBwYXJhbWV0ZXJzOiBhbnkpOiB2b2lkXHJcbiAqIFxyXG4gKiBFdmVudHM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQGZpcmVzIHNlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCAocGFyYW1zOiBOb2RlfExpbmspXHJcbiAqIEBmaXJlcyBjZWxsLWRvdWJsZS1jbGljayAocGFyYW1zOiBOb2RlfExpbmspXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBTaWdtYUJhc2UgKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7ICAgLy8gbWFrZSB0aGlzIGNsYXNzIFN1YnNjcmliYWJsZVxyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgY29uc3QgX2NvbG9ycyA9IHBhcmFtZXRlcnMuY29sb3JzO1xyXG5cclxuICAgIGxldCBfbWF4Tm9kZVNpemUgPSAwO1xyXG4gICAgbGV0IF9yb290RWxlbWVudDtcclxuICAgIGxldCBfc2lnbWFGcmFtZXMgPSB7fTtcclxuXHJcbiAgICBzZWxmLl9hc3BlY3RMaW5rcyA9IHt9O1xyXG4gICAgc2VsZi5zZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICBzZWxmLl9kYXRhQ29udGFpbmVyOyAgICAvLyB0byBvdmVycmlkZVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgaW5pdGlhbGl6YXRpb24uIEl0J3MgZXhlY3V0ZWQgYWZ0ZXIgY3JlYXRpb24gYnkgZGVzY2VuZGFudFxyXG4gICAgICovXHJcbiAgICBzZWxmLl9pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9pbml0aWFsaXplKFxyXG4gICAgICAgICAgICBvcHRpb25zLmRhdGFDb250YWluZXIsXHJcbiAgICAgICAgICAgIG9wdGlvbnMudmlld0ZyYW1lcyxcclxuICAgICAgICAgICAgb3B0aW9ucy5lbCxcclxuICAgICAgICAgICAgb3B0aW9ucy5zZWxlY3RlZEVsZW1lbnQsXHJcbiAgICAgICAgICAgIG9wdGlvbnMuc2NhbGVcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0J3Mga2luZCBvZiBjb25zdHJ1Y3Rvciwgd2hpY2ggY2FsbGVkIGFmdGVyIGNyZWF0aW9uIHRoZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge0RhdGFDb250YWluZXJ9IGRhdGFDb250YWluZXJcclxuICAgICAqIEBwYXJhbSB7QXJyYXkgb2YgVmlld0ZyYW1lfSB2aWV3RnJhbWVzXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290RWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtOb2RlfExpbmt9IHNlbGVjdGVkRWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2luaXRpYWxpemUgKFxyXG4gICAgICAgIGRhdGFDb250YWluZXIsXHJcbiAgICAgICAgdmlld0ZyYW1lcyxcclxuICAgICAgICByb290RWxlbWVudCxcclxuICAgICAgICBzZWxlY3RlZEVsZW1lbnQsXHJcbiAgICApIHtcclxuICAgICAgICBfcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcclxuICAgICAgICBzZWxmLnNlbGVjdGVkRWxlbWVudCA9IHNlbGVjdGVkRWxlbWVudDtcclxuICAgICAgICB2aWV3RnJhbWVzID0gdmlld0ZyYW1lcyB8fCBbXTtcclxuICAgICAgICBzZWxmLl9kYXRhQ29udGFpbmVyID0gZGF0YUNvbnRhaW5lcjtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBzZWxmLl9nZXREYXRhKCk7XHJcbiAgICAgICAgY29uc3QgZyA9IHtcclxuICAgICAgICAgICAgbm9kZXM6IFtdLFxyXG4gICAgICAgICAgICBlZGdlczogW10sXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZGF0YS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdOb2RlID0gc2VsZi5fY3JlYXRlTm9kZShub2RlKTtcclxuICAgICAgICAgICAgZy5ub2Rlcy5wdXNoKG5ld05vZGUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkYXRhLmxpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0xpbmsgPSBzZWxmLl9jcmVhdGVMaW5rKGxpbmspO1xyXG4gICAgICAgICAgICBnLmVkZ2VzLnB1c2gobmV3TGluayk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGFzcGVjdExpbmtzID0gX2NyZWF0ZUFzcGVjdExpbmtzKGRhdGEubm9kZXMpO1xyXG4gICAgICAgIGFzcGVjdExpbmtzLmZvckVhY2goYWwgPT4ge1xyXG4gICAgICAgICAgICBnLmVkZ2VzLnB1c2goYWwpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfbWF4Tm9kZVNpemUgPSBfZ2V0Tm9kZVNpemUoKTtcclxuXHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoID0gbmV3IFNpZ21hKHtcclxuICAgICAgICAgICAgZ3JhcGg6IGcsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lcjogX3Jvb3RFbGVtZW50LFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgbWluTm9kZVNpemU6IDAsXHJcbiAgICAgICAgICAgICAgICBtYXhOb2RlU2l6ZTogX21heE5vZGVTaXplLFxyXG4gICAgICAgICAgICAgICAgbm9kZXNQb3dSYXRpbzogMSxcclxuICAgICAgICAgICAgICAgIGVuYWJsZUVkZ2VIb3ZlcmluZzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGVkZ2VIb3ZlckNvbG9yOiAnZWRnZScsXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0RWRnZUhvdmVyQ29sb3I6ICcjMDAwJyxcclxuICAgICAgICAgICAgICAgIGVkZ2VIb3ZlclNpemVSYXRpbzogNCxcclxuICAgICAgICAgICAgICAgIGVkZ2VIb3ZlckV4dHJlbWl0aWVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjbG9uZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBkb3VibGVDbGlja1pvb21pbmdSYXRpbzogMSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNlbGYuX3N1YnNjcmliZU9uRXZlbnRzKCk7XHJcbiAgICAgICAgX21heE5vZGVTaXplID0gX2dldE5vZGVTaXplKCk7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLnNldHRpbmdzKCdtYXhOb2RlU2l6ZScsIF9tYXhOb2RlU2l6ZSk7XHJcblxyXG4gICAgICAgIHZpZXdGcmFtZXMuZm9yRWFjaCh2aWV3RnJhbWUgPT4ge1xyXG4gICAgICAgICAgICBpZiAodmlld0ZyYW1lLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgX2FkZFZpZXdGcmFtZSh2aWV3RnJhbWUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3NpZ21hRnJhbWVzW3ZpZXdGcmFtZS5pZF0gPSBfY3JlYXRlU2lnbWFGcmFtZSh2aWV3RnJhbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5yZWZyZXNoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBvcnRzIGdyYXBoIHRvIHBuZyBmaWxlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlhZ3JhbU5hbWVcclxuICAgICovXHJcbiAgICBzZWxmLmV4cG9ydCA9IGZ1bmN0aW9uIChkaWFncmFtTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gZGlhZ3JhbU5hbWUgfHwgJ0xHX2JpcmRfZXllX3NuYXBzaG90XycgKyBkYXRlMlN0cmluZyhuZXcgRGF0ZSgpKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gc2VsZi5zaWdtYUdyYXBoLnJlbmRlcmVyc1swXS5zbmFwc2hvdCh7XHJcbiAgICAgICAgICAgIGZvcm1hdDogJ3BuZycsXHJcbiAgICAgICAgICAgIGRvd25sb2FkOiBmYWxzZSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgbGFiZWxzOiB0cnVlLFxyXG4gICAgICAgICAgICBmaWxlbmFtZTogZmlsZU5hbWUsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNhdmVBcyhwbmcyQmxvYihkYXRhKSwgZmlsZU5hbWUgKyAnLnBuZycpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4cG9ydHMgZ3JhcGggdG8gcGRmIGZpbGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaWFncmFtTmFtZVxyXG4gICAgKi9cclxuICAgIHNlbGYucHJpbnQgPSBmdW5jdGlvbiAoZGlhZ3JhbU5hbWUpIHtcclxuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGRpYWdyYW1OYW1lIHx8ICdMR19iaXJkX2V5ZV9zbmFwc2hvdF8nICsgZGF0ZTJTdHJpbmcobmV3IERhdGUoKSk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHNlbGYuc2lnbWFHcmFwaC5yZW5kZXJlcnNbMF0uc25hcHNob3Qoe1xyXG4gICAgICAgICAgICBmb3JtYXQ6ICdwbmcnLFxyXG4gICAgICAgICAgICBkb3dubG9hZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgIGxhYmVsczogdHJ1ZSxcclxuICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVOYW1lLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHByaW50V2luZG93ID0gd2luZG93Lm9wZW4oJycsIHVuZGVmaW5lZCwgJ3dpZHRoPTEyODAsaGVpZ2h0PTcyMCcpO1xyXG4gICAgICAgIGlmIChwcmludFdpbmRvdykge1xyXG4gICAgICAgICAgICBwcmludFdpbmRvdy5kb2N1bWVudC53cml0ZShgXHJcbiAgICAgICAgICAgICAgICA8aHRtbD5cclxuICAgICAgICAgICAgICAgICAgICA8Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCIke2RhdGF9XCIvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvYm9keT5cclxuICAgICAgICAgICAgICAgIDwvaHRtbD5cclxuICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgIHByaW50V2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHByaW50V2luZG93LmRvY3VtZW50LmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICBwcmludFdpbmRvdy5wcmludCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFsZXJ0KCdZb3Ugc2hvdWxkIHVuYmxvY2sgcG9wdXAgd2luZG93cyBmb3IgdGhlIGN1cnJlbnQgdXJsIHRvIGJlIGFibGUgdG8gcHJpbnQgdGhpcyBkaWFncmFtIScpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHNlbGVjdGVkIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0ge05vZGV8TGlua30gZWxlbWVudFxyXG4gICAgKi9cclxuICAgIHNlbGYuc2V0U2VsZWN0ZWRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICBsZXQgc2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgZWxlbWVudCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuTm9kZSB8fFxyXG4gICAgICAgICAgICBlbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5UZXJtaW5hdGlvbk5vZGVcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50ID0gZWxlbWVudC5vcmlnaW5hbE5vZGUgfHwgZWxlbWVudDtcclxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLkxpbmspIHtcclxuICAgICAgICAgICAgY29uc3QgbGluayA9IGVsZW1lbnQub3JpZ2luYWxMaW5rIHx8IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IGxpbms7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJlZnJlc2ggPSBzZWxmLnNlbGVjdGVkRWxlbWVudCAhPT0gc2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgIHNlbGYuc2VsZWN0ZWRFbGVtZW50ID0gc2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgIGlmIChyZWZyZXNoKSBzZWxmLnJlZHJhdygpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgbmV3IGRhdGEgY29udGFpbmVyXHJcbiAgICAgKiBAcGFyYW0ge0RhdGFDb250YWluZXJ9IGRhdGFDb250YWluZXJcclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lUHVibGljTW9kZWxbXX0gdmlld0ZyYW1lc1xyXG4gICAgKi9cclxuICAgIHNlbGYuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzKSB7XHJcbiAgICAgICAgc2VsZi5zZWxlY3RlZEVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIHNlbGYuX2RhdGFDb250YWluZXIgPSBkYXRhQ29udGFpbmVyO1xyXG4gICAgICAgIHZpZXdGcmFtZXMgPSB2aWV3RnJhbWVzIHx8IFtdO1xyXG5cclxuICAgICAgICBjb25zdCBkYXRhID0gc2VsZi5fZ2V0RGF0YSgpO1xyXG5cclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguY2xlYXIoKTtcclxuICAgICAgICBfbWF4Tm9kZVNpemUgPSBfZ2V0Tm9kZVNpemUoKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguc2V0dGluZ3MoJ21heE5vZGVTaXplJywgX21heE5vZGVTaXplKTtcclxuXHJcbiAgICAgICAgZGF0YS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdOb2RlID0gc2VsZi5fY3JlYXRlTm9kZShub2RlKTtcclxuICAgICAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmFkZE5vZGUobmV3Tm9kZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZpZXdGcmFtZXMuZm9yRWFjaCh2aWV3RnJhbWUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmcmFtZSA9IF9jcmVhdGVTaWdtYUZyYW1lKHZpZXdGcmFtZSk7XHJcbiAgICAgICAgICAgIF9zaWdtYUZyYW1lc1t2aWV3RnJhbWUuaWRdID0gZnJhbWU7XHJcbiAgICAgICAgICAgIGlmICh2aWV3RnJhbWUuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBfYWRkVmlld0ZyYW1lKHZpZXdGcmFtZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfc2lnbWFGcmFtZXNbdmlld0ZyYW1lLmlkXSA9IF9jcmVhdGVTaWdtYUZyYW1lKHZpZXdGcmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgYXNwZWN0TGlua3MgPSBfY3JlYXRlQXNwZWN0TGlua3MoZGF0YS5ub2Rlcyk7XHJcbiAgICAgICAgYXNwZWN0TGlua3MuZm9yRWFjaChhbCA9PiB7XHJcbiAgICAgICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5hZGRFZGdlKGFsKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZGF0YS5saW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdMaW5rID0gc2VsZi5fY3JlYXRlTGluayhsaW5rKTtcclxuICAgICAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmFkZEVkZ2UobmV3TGluayk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5yZWZyZXNoKCk7XHJcbiAgICAgICAgc2VsZi5yZWRyYXcoKTtcclxuICAgIH07XHJcblxyXG4gICAgbGV0IGRlYm91bmNlcjtcclxuICAgIC8qKlxyXG4gICAgICogUmVkcmF3cyBhbGwgZ3JhcGguIE1haW5seSAtIHVwZGF0ZXMgY29sb3JzIG9mIGVsZW1lbnRzXHJcbiAgICAgKiBAcGFyYW0ge3ZpZXdGcmFtZXMsIHNjYWxlLCBub2RlcywgZnVsbFNjcmVlbk1vZGV9IG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgc2VsZi5yZWRyYXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIF9tYXhOb2RlU2l6ZSA9IF9nZXROb2RlU2l6ZSgpO1xyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5zZXR0aW5ncygnbWF4Tm9kZVNpemUnLCBfbWF4Tm9kZVNpemUpO1xyXG5cclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShkZWJvdW5jZXIpO1xyXG4gICAgICAgIGRlYm91bmNlciA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHNlbGYuX3JlZnJlc2hOb2RlcygpO1xyXG4gICAgICAgICAgICBzZWxmLl9yZWZyZXNoTGlua3MoKTtcclxuICAgIFxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy52aWV3RnJhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9yZWZyZXNoVmlld0ZyYW1lcyhvcHRpb25zLnZpZXdGcmFtZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAgICAgc2VsZi5zaWdtYUdyYXBoLnJlZnJlc2goKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gY2FuIGJlIG92ZXJyaWRlZFxyXG4gICAgc2VsZi5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYucmVkcmF3KCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgbGlua3Mgc3RhdGVzLiBcclxuICAgICAqL1xyXG4gICAgc2VsZi5fcmVmcmVzaExpbmtzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGVkZ2VzID0gc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmVkZ2VzKCk7XHJcbiAgICAgICAgZWRnZXMuZm9yRWFjaChsID0+IHtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgbC5pZC5pbmRleE9mKCdfX3RvcCcpID09PSAtMSAmJlxyXG4gICAgICAgICAgICAgICAgbC5pZC5pbmRleE9mKCdfX2JvdHRvbScpID09PSAtMSAmJlxyXG4gICAgICAgICAgICAgICAgbC5pZC5pbmRleE9mKCdfX2xlZnQnKSA9PT0gLTEgJiZcclxuICAgICAgICAgICAgICAgIGwuaWQuaW5kZXhPZignX19yaWdodCcpID09PSAtMVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGwuc2l6ZSA9IHNlbGYuc2VsZWN0ZWRFbGVtZW50ICYmIGwuaWQgPT09IHNlbGYuc2VsZWN0ZWRFbGVtZW50LmlkID8gNSA6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgbC5jb2xvciA9IHNlbGYuc2VsZWN0ZWRFbGVtZW50ICYmIGwuaWQgPT09IHNlbGYuc2VsZWN0ZWRFbGVtZW50LmlkID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbG9yc1snc2VsZWN0ZWQnXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZWxmLl9hc3BlY3RMaW5rc1tsLmlkXSA/IF9jb2xvcnNbJ2FzcGVjdExpbmsnXSA6IF9jb2xvcnNbJ2xpbmsnXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBub2RlcyBzdGF0ZXMuIFxyXG4gICAgICovXHJcbiAgICBzZWxmLl9yZWZyZXNoTm9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IHNlbGYuX2RhdGFDb250YWluZXIubWFwcy5ub2RlTWFwO1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gc2VsZi5zaWdtYUdyYXBoLmdyYXBoLm5vZGVzKCk7XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChzaWdtYU5vZGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAobm9kZU1hcFtzaWdtYU5vZGUuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZU1hcFtzaWdtYU5vZGUuaWRdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24obm9kZSk7XHJcbiAgICAgICAgICAgICAgICBzaWdtYU5vZGUueCA9IHBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgICAgICBzaWdtYU5vZGUueSA9IHBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgICAgICBzaWdtYU5vZGUuY29sb3IgPSBzZWxmLnNlbGVjdGVkRWxlbWVudCAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZEVsZW1lbnQuaWQgPT09IHNpZ21hTm9kZS5pZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWRFbGVtZW50LmFzcGVjdHMgJiYgc2VsZi5zZWxlY3RlZEVsZW1lbnQuYXNwZWN0cy5maWx0ZXIoYSA9PiBhLmlkID09PSBzaWdtYU5vZGUuaWQpLmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgICAgICkgPyBfY29sb3JzWydzZWxlY3RlZCddIDogX2NvbG9yc1tub2RlLm1vZGVsLnR5cGVJZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHZpZXdGcmFtZXMgc3RhdGUuIFxyXG4gICAgICogQHBhcmFtIHtWaWV3RnJhbWVQdWJsaWNNb2RlbFtdfSB2aWV3RnJhbWVzXHJcbiAgICAgKi9cclxuICAgIHNlbGYuX3JlZnJlc2hWaWV3RnJhbWVzID0gZnVuY3Rpb24gKHZpZXdGcmFtZXMpIHtcclxuICAgICAgICB2aWV3RnJhbWVzLmZvckVhY2godmlld0ZyYW1lID0+IHtcclxuICAgICAgICAgICAgaWYgKHZpZXdGcmFtZS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gX3NpZ21hRnJhbWVzW3ZpZXdGcmFtZS5pZF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSBfZ2V0RnJhbWVzUG9pbnRzKHZpZXdGcmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZnJhbWUucDEueCA9IHBvaW50cy5wMS54O1xyXG4gICAgICAgICAgICAgICAgZnJhbWUucDEueSA9IHBvaW50cy5wMS55O1xyXG5cclxuICAgICAgICAgICAgICAgIGZyYW1lLnAyLnggPSBwb2ludHMucDIueDtcclxuICAgICAgICAgICAgICAgIGZyYW1lLnAyLnkgPSBwb2ludHMucDIueTtcclxuXHJcbiAgICAgICAgICAgICAgICBmcmFtZS5wMy54ID0gcG9pbnRzLnAzLng7XHJcbiAgICAgICAgICAgICAgICBmcmFtZS5wMy55ID0gcG9pbnRzLnAzLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgZnJhbWUucDQueCA9IHBvaW50cy5wNC54O1xyXG4gICAgICAgICAgICAgICAgZnJhbWUucDQueSA9IHBvaW50cy5wNC55O1xyXG5cclxuICAgICAgICAgICAgICAgIF9hZGRWaWV3RnJhbWUodmlld0ZyYW1lKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9yZW1vdmVWaWV3RnJhbWUodmlld0ZyYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdmlld0ZyYW1lIG9uIHRoZSBzaWdtYSBncmFwaC5cclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lUHVibGljTW9kZWx9IHZpZXdGcmFtZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfYWRkVmlld0ZyYW1lICh2aWV3RnJhbWUpIHtcclxuICAgICAgICBjb25zdCBmcmFtZSA9IF9zaWdtYUZyYW1lc1t2aWV3RnJhbWUuaWRdID1cclxuICAgICAgICAgICAgX3NpZ21hRnJhbWVzW3ZpZXdGcmFtZS5pZF0gfHwgX2NyZWF0ZVNpZ21hRnJhbWUodmlld0ZyYW1lKTtcclxuICAgICAgICBpZiAoIXZpZXdGcmFtZSB8fCBmcmFtZS5hY3RpdmUpIHJldHVybjsgICAgICAgIFxyXG5cclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguYWRkTm9kZShmcmFtZS5wMSk7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmFkZE5vZGUoZnJhbWUucDIpO1xyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5hZGROb2RlKGZyYW1lLnAzKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguYWRkTm9kZShmcmFtZS5wNCk7XHJcblxyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5hZGRFZGdlKGZyYW1lLnRvcCk7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmFkZEVkZ2UoZnJhbWUuYm90dG9tKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguYWRkRWRnZShmcmFtZS5sZWZ0KTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguYWRkRWRnZShmcmFtZS5yaWdodCk7XHJcblxyXG4gICAgICAgIGZyYW1lLmFjdGl2ZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHZpZXdGcmFtZSBmcm9tIHRoZSBzaWdtYSBncmFwaC5cclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lUHVibGljTW9kZWx9IHZpZXdGcmFtZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfcmVtb3ZlVmlld0ZyYW1lICh2aWV3RnJhbWUpIHtcclxuICAgICAgICBpZiAoIXZpZXdGcmFtZSB8fCAhX3NpZ21hRnJhbWVzW3ZpZXdGcmFtZS5pZF0uYWN0aXZlKSByZXR1cm47XHJcblxyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5kcm9wRWRnZSh2aWV3RnJhbWUuaWQgKyAnX190b3AnKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguZHJvcEVkZ2Uodmlld0ZyYW1lLmlkICsgJ19fYm90dG9tJyk7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmRyb3BFZGdlKHZpZXdGcmFtZS5pZCArICdfX2xlZnQnKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguZHJvcEVkZ2Uodmlld0ZyYW1lLmlkICsgJ19fcmlnaHQnKTtcclxuXHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmRyb3BOb2RlKHZpZXdGcmFtZS5pZCArICdfX1RMJyk7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmRyb3BOb2RlKHZpZXdGcmFtZS5pZCArICdfX0JMJyk7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmRyb3BOb2RlKHZpZXdGcmFtZS5pZCArICdfX1RSJyk7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmRyb3BOb2RlKHZpZXdGcmFtZS5pZCArICdfX0JSJyk7XHJcblxyXG4gICAgICAgIF9zaWdtYUZyYW1lc1t2aWV3RnJhbWUuaWRdLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBsaW5rcyBhbmQgbm9kZXMuXHJcbiAgICAgKiBAcmV0dXJucyB7e05vZGVbXSwgTGlua1tdfX1cclxuICAgICAqL1xyXG4gICAgc2VsZi5fZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geyBub2Rlczogc2VsZi5fZGF0YUNvbnRhaW5lci5ub2RlcywgbGlua3M6IHNlbGYuX2RhdGFDb250YWluZXIubGlua3MgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHNpZ21hIG5vZGUgZnJvbSBqb2ludGpzIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgXHJcbiAgICAgKi9cclxuICAgIHNlbGYuX2NyZWF0ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKG5vZGUpO1xyXG4gICAgICAgIGNvbnN0IG1vZGVsID0gbm9kZS5tb2RlbDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogbm9kZS5pZCxcclxuICAgICAgICAgICAgbGFiZWw6IG1vZGVsLmxhYmVsLFxyXG4gICAgICAgICAgICB4OiBwb3NpdGlvbi54LFxyXG4gICAgICAgICAgICB5OiBwb3NpdGlvbi55LFxyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICBjb2xvcjogbm9kZSA9PT0gc2VsZi5zZWxlY3RlZEVsZW1lbnQgfHwgKHNlbGYuc2VsZWN0ZWRFbGVtZW50ICYmXHJcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRWxlbWVudC5hc3BlY3RzICYmXHJcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRWxlbWVudC5hc3BlY3RzLmZpbHRlcihhID0+IGEuaWQgPT09IG5vZGUuaWQpLmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgKSA/IF9jb2xvcnNbJ3NlbGVjdGVkJ10gOiBfY29sb3JzW21vZGVsLnR5cGVJZF0sXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHNpZ21hIGVkZ2UgZnJvbSBqb2ludGpzIGxpbmsuXHJcbiAgICAgKiBAcGFyYW0ge0xpbmt9IGxpbmsgXHJcbiAgICAgKi9cclxuICAgIHNlbGYuX2NyZWF0ZUxpbmsgPSBmdW5jdGlvbiAobGluaykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBsaW5rLmlkLFxyXG4gICAgICAgICAgICBzb3VyY2U6IGxpbmsubW9kZWwuc291cmNlLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IGxpbmsubW9kZWwudGFyZ2V0LFxyXG4gICAgICAgICAgICBzaXplOiBsaW5rID09PSBzZWxmLnNlbGVjdGVkRWxlbWVudCA/IDUgOiAxLFxyXG4gICAgICAgICAgICBjb2xvcjogbGluayA9PT0gc2VsZi5zZWxlY3RlZEVsZW1lbnQgPyBfY29sb3JzWydzZWxlY3RlZCddIDogJ2JsYWNrJyxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXMgb24gZXZlbnRzLlxyXG4gICAgICogQGZpcmVzOiBzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWQgKHBhcmFtczogTm9kZXxMaW5rKVxyXG4gICAgICogQGZpcmVzOiBjZWxsLWRvdWJsZS1jbGljayAocGFyYW1zOiBOb2RlfExpbmspXHJcbiAgICAgKi9cclxuICAgIHNlbGYuX3N1YnNjcmliZU9uRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5iaW5kKCdjbGlja05vZGUgY2xpY2tTdGFnZScsIGUgPT4gX29uQ2xpY2soZSwgXHJcbiAgICAgICAgICAgIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGV2ZW50LmRhdGEubm9kZSA/IHNlbGYuX2RhdGFDb250YWluZXIubWFwcy5ub2RlTWFwW2V2ZW50LmRhdGEubm9kZS5pZF0gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgfHwgIWV2ZW50LmRhdGEuY2FwdG9yLmlzRHJhZ2dpbmcgJiYgIW5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldFNlbGVjdGVkRWxlbWVudChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBldmVudC5kYXRhLmVkZ2UgPyBzZWxmLl9kYXRhQ29udGFpbmVyLm1hcHMubGlua01hcFtldmVudC5kYXRhLmVkZ2UuaWRdIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignY2VsbC1kb3VibGUtY2xpY2snLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICkpO1xyXG5cclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguYmluZCgnY2xpY2tFZGdlJywgZSA9PiBfb25DbGljayhlLCBcclxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gZXZlbnQuZGF0YS5lZGdlID8gc2VsZi5fZGF0YUNvbnRhaW5lci5tYXBzLmxpbmtNYXBbZXZlbnQuZGF0YS5lZGdlLmlkXSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnNldFNlbGVjdGVkRWxlbWVudChsaW5rKTtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkJywgbGluayk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGV2ZW50LmRhdGEuZWRnZSA/IHNlbGYuX2RhdGFDb250YWluZXIubWFwcy5saW5rTWFwW2V2ZW50LmRhdGEuZWRnZS5pZF0gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdjZWxsLWRvdWJsZS1jbGljaycsIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBkZWZhdWx0IHNpemUgZm9yIG5vZGVzLiBcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldE5vZGVTaXplICgpIHtcclxuICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgIGlmIChzZWxmLl9kYXRhQ29udGFpbmVyLm5vZGVzLmxlbmd0aCA8PSAwKSByZXR1cm4gMDtcclxuICAgICAgICBpZiAoc2VsZi5zaWdtYUdyYXBoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gc2VsZi5zaWdtYUdyYXBoLnJlbmRlcmVyc1swXSB8fCB7IHdpZHRoOiBfcm9vdEVsZW1lbnQuY2xpZW50V2lkdGgsIGhlaWdodDogX3Jvb3RFbGVtZW50LmNsaWVudEhlaWdodCwgfTtcclxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMuZWxlbWVudFNpemUud2lkdGggPiBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVuZGVyZXIud2lkdGggLyAocGFyYW1ldGVycy5lbGVtZW50U2l6ZS53aWR0aCArIHBhcmFtZXRlcnMubGF5b3V0U3RlcC54KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlbmRlcmVyLmhlaWdodCAvIChwYXJhbWV0ZXJzLmVsZW1lbnRTaXplLmhlaWdodCArIHBhcmFtZXRlcnMubGF5b3V0U3RlcC55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IDU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWxmLl9nZXROb2RlU2l6ZSkgcmV0dXJuIHNlbGYuX2dldE5vZGVTaXplKHJlc3VsdCk7XHJcbiAgICAgICAgZWxzZSByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhc3BlY3QgbGlua3MuXHJcbiAgICAgKiBAcGFyYW0ge05vZGVbXX0gbm9kZXNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUFzcGVjdExpbmtzIChub2Rlcykge1xyXG4gICAgICAgIHNlbGYuX2FzcGVjdExpbmtzID0ge307XHJcbiAgICAgICAgY29uc3QgbGlua3NUb1JldHVybiA9IFtdO1xyXG4gICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBhc3BlY3RzID0gbm9kZS5hc3BlY3RzO1xyXG5cclxuICAgICAgICAgICAgYXNwZWN0cy5mb3JFYWNoKGFzcGVjdCA9PiB7XHJcbiAgICAgICAgICAgICAgICBhZGRMaW5rKG5vZGUsIGFzcGVjdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhZGRMaW5rIChub2RlLCBhc3BlY3QpIHtcclxuICAgICAgICAgICAgY29uc3QgaWQxID0gbm9kZS5pZCArICd+I3RxTGdBc3BlY3RMaW5rI34nICsgYXNwZWN0LmlkO1xyXG4gICAgICAgICAgICBjb25zdCBpZDIgPSBhc3BlY3QuaWQgKyAnfiN0cUxnQXNwZWN0TGluayN+JyArIG5vZGUuaWQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXNlbGYuX2FzcGVjdExpbmtzW2lkMV0gJiYgIXNlbGYuX2FzcGVjdExpbmtzW2lkMl0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZDEsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBub2RlLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogYXNwZWN0LmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBfY29sb3JzWydhc3BlY3RMaW5rJ10sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fYXNwZWN0TGlua3NbaWQxXSA9IGFsO1xyXG4gICAgICAgICAgICAgICAgbGlua3NUb1JldHVybi5wdXNoKGFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGxpbmtzVG9SZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHNpZ21hIG5vdGF0aW9uIG9mIHRoZSBqb2ludCB2aWV3RnJhbWUgYW5kIHBsYWNlcyBvbiB0aGUgc2lnbWEgZ3JhcGguXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZVB1YmxpY01vZGVsfSB2aWV3RnJhbWVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZVNpZ21hRnJhbWUgKHZpZXdGcmFtZSkge1xyXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IF9nZXRGcmFtZXNQb2ludHModmlld0ZyYW1lKTtcclxuICAgICAgICBjb25zdCBjb2xvciA9IHZpZXdGcmFtZS5ib3JkZXJDb2xvcjtcclxuXHJcbiAgICAgICAgLy8gbm9kZXNcclxuXHJcbiAgICAgICAgY29uc3QgcDEgPSB7XHJcbiAgICAgICAgICAgIGlkOiB2aWV3RnJhbWUuaWQgKyAnX19UTCcsXHJcbiAgICAgICAgICAgIGxhYmVsOiB2aWV3RnJhbWUuaWQsXHJcbiAgICAgICAgICAgIHg6IHBvaW50cy5wMS54LFxyXG4gICAgICAgICAgICB5OiBwb2ludHMucDEueSxcclxuICAgICAgICAgICAgc2l6ZTogMC4zLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgcDIgPSB7XHJcbiAgICAgICAgICAgIGlkOiB2aWV3RnJhbWUuaWQgKyAnX19CTCcsXHJcbiAgICAgICAgICAgIGxhYmVsOiB2aWV3RnJhbWUuaWQsXHJcbiAgICAgICAgICAgIHg6IHBvaW50cy5wMy54LFxyXG4gICAgICAgICAgICB5OiBwb2ludHMucDMueSxcclxuICAgICAgICAgICAgc2l6ZTogMC4zLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgcDMgPSB7XHJcbiAgICAgICAgICAgIGlkOiB2aWV3RnJhbWUuaWQgKyAnX19UUicsXHJcbiAgICAgICAgICAgIGxhYmVsOiB2aWV3RnJhbWUuaWQsXHJcbiAgICAgICAgICAgIHg6IHBvaW50cy5wMi54LFxyXG4gICAgICAgICAgICB5OiBwb2ludHMucDIueSxcclxuICAgICAgICAgICAgc2l6ZTogMC4zLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgcDQgPSB7XHJcbiAgICAgICAgICAgIGlkOiB2aWV3RnJhbWUuaWQgKyAnX19CUicsXHJcbiAgICAgICAgICAgIGxhYmVsOiB2aWV3RnJhbWUuaWQsXHJcbiAgICAgICAgICAgIHg6IHBvaW50cy5wNC54LFxyXG4gICAgICAgICAgICB5OiBwb2ludHMucDQueSxcclxuICAgICAgICAgICAgc2l6ZTogMC4zLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gRWRnZXNcclxuXHJcbiAgICAgICAgY29uc3QgdG9wID0ge1xyXG4gICAgICAgICAgICBpZDogdmlld0ZyYW1lLmlkICsgJ19fdG9wJyxcclxuICAgICAgICAgICAgc291cmNlOiB2aWV3RnJhbWUuaWQgKyAnX19UTCcsXHJcbiAgICAgICAgICAgIHRhcmdldDogdmlld0ZyYW1lLmlkICsgJ19fVFInLFxyXG4gICAgICAgICAgICBzaXplOiAxMCxcclxuICAgICAgICAgICAgY29sb3I6IGNvbG9yXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgYm90dG9tID0ge1xyXG4gICAgICAgICAgICBpZDogdmlld0ZyYW1lLmlkICsgJ19fYm90dG9tJyxcclxuICAgICAgICAgICAgc291cmNlOiB2aWV3RnJhbWUuaWQgKyAnX19CTCcsXHJcbiAgICAgICAgICAgIHRhcmdldDogdmlld0ZyYW1lLmlkICsgJ19fQlInLFxyXG4gICAgICAgICAgICBzaXplOiAxMCxcclxuICAgICAgICAgICAgY29sb3I6IGNvbG9yXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgbGVmdCA9IHtcclxuICAgICAgICAgICAgaWQ6IHZpZXdGcmFtZS5pZCArICdfX2xlZnQnLFxyXG4gICAgICAgICAgICBzb3VyY2U6IHZpZXdGcmFtZS5pZCArICdfX1RMJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiB2aWV3RnJhbWUuaWQgKyAnX19CTCcsXHJcbiAgICAgICAgICAgIHNpemU6IDEwLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3JcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCByaWdodCA9IHtcclxuICAgICAgICAgICAgaWQ6IHZpZXdGcmFtZS5pZCArICdfX3JpZ2h0JyxcclxuICAgICAgICAgICAgc291cmNlOiB2aWV3RnJhbWUuaWQgKyAnX19UUicsXHJcbiAgICAgICAgICAgIHRhcmdldDogdmlld0ZyYW1lLmlkICsgJ19fQlInLFxyXG4gICAgICAgICAgICBzaXplOiAxMCxcclxuICAgICAgICAgICAgY29sb3I6IGNvbG9yXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcDE6IHAxLFxyXG4gICAgICAgICAgICBwMjogcDIsXHJcbiAgICAgICAgICAgIHAzOiBwMyxcclxuICAgICAgICAgICAgcDQ6IHA0LFxyXG5cclxuICAgICAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgICAgIGJvdHRvbTogYm90dG9tLFxyXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgICAgICByaWdodDogcmlnaHQsXHJcblxyXG4gICAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldEZyYW1lc1BvaW50cyAodmlld0ZyYW1lKSB7XHJcbiAgICAgICAgY29uc3QgcDEgPSB7XHJcbiAgICAgICAgICAgIHg6IHZpZXdGcmFtZS52aWV3UG9ydEJvdW5kcy5taW5YLFxyXG4gICAgICAgICAgICB5OiB2aWV3RnJhbWUudmlld1BvcnRCb3VuZHMubWluWSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHAyID0geyB4OiBwMS54ICsgdmlld0ZyYW1lLnZpZXdQb3J0Qm91bmRzLndpZHRoLCB5OiBwMS55IH07XHJcbiAgICAgICAgY29uc3QgcDMgPSB7IHg6IHAxLngsIHk6IHAxLnkgKyB2aWV3RnJhbWUudmlld1BvcnRCb3VuZHMuaGVpZ2h0IH07XHJcbiAgICAgICAgY29uc3QgcDQgPSB7IHg6IHAxLnggKyB2aWV3RnJhbWUudmlld1BvcnRCb3VuZHMud2lkdGgsIHk6IHAxLnkgKyB2aWV3RnJhbWUudmlld1BvcnRCb3VuZHMuaGVpZ2h0IH07XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHAxOiBwMSxcclxuICAgICAgICAgICAgcDI6IHAyLFxyXG4gICAgICAgICAgICBwMzogcDMsXHJcbiAgICAgICAgICAgIHA0OiBwNCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpeGluZyB0aGUgc2lnbWEgYnVnIHdpdGggaG9yaXpvbnRhbC92ZXJ0aWNhbCBsaW5lcyBob3ZlcmluZy5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgU2lnbWEudXRpbHMuaXNQb2ludE9uU2VnbWVudCA9IGZ1bmN0aW9uICh4LCB5LCB4MSwgeTEsIHgyLCB5MiwgZXBzaWxvbikge1xyXG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMyODEyMlxyXG4gICAgICAgIHZhciBjcm9zc1Byb2R1Y3QgPSBNYXRoLmFicygoeSAtIHkxKSAqICh4MiAtIHgxKSAtICh4IC0geDEpICogKHkyIC0geTEpKSxcclxuICAgICAgICAgICAgZCA9IFNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSxcclxuICAgICAgICAgICAgbkNyb3NzUHJvZHVjdCA9IGNyb3NzUHJvZHVjdCAvIGQ7IC8vIG5vcm1hbGl6ZWQgY3Jvc3MgcHJvZHVjdFxyXG5cclxuICAgICAgICByZXR1cm4gKG5Dcm9zc1Byb2R1Y3QgPCBlcHNpbG9uICYmXHJcbiAgICAgICAgICAgIE1hdGgubWluKHgxLCB4MikgLSBlcHNpbG9uIDw9IHggJiYgeCA8PSBNYXRoLm1heCh4MSwgeDIpICsgZXBzaWxvbiAmJlxyXG4gICAgICAgICAgICBNYXRoLm1pbih5MSwgeTIpIC0gZXBzaWxvbiA8PSB5ICYmIHkgPD0gTWF0aC5tYXgoeTEsIHkyKSArIGVwc2lsb24pO1xyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgX2NsaWNrcyA9IDA7XHJcbiAgICBmdW5jdGlvbiBfb25DbGljayAoZXZlbnQsIGNsaWNrQ2FsbGJhY2ssIGRvdWJsZUNsaWNrQ2FsbGJhY2spIHtcclxuICAgICAgICBfY2xpY2tzKys7XHJcblxyXG4gICAgICAgIGlmIChfY2xpY2tzID49IDIpIHtcclxuICAgICAgICAgICAgX2NsaWNrcyA9IDA7XHJcbiAgICAgICAgICAgIGRvdWJsZUNsaWNrQ2FsbGJhY2soZXZlbnQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoX2NsaWNrcyA9PT0gMSkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfY2xpY2tzID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tDYWxsYmFjayhldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfY2xpY2tzID0gMDtcclxuICAgICAgICAgICAgfSwgMjUwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgU2lnbWFCYXNlO1xyXG4iLCJleHBvcnQgZnVuY3Rpb24gdXNlUGx1Z2luIChzaWdtYSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbWEgUmVuZGVyZXIgU25hcHNob3QgVXRpbGl0eVxyXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAqXHJcbiAgICAgKiBUaGUgYWltIG9mIHRoaXMgcGx1Z2luIGlzIHRvIGVuYWJsZSB1c2VycyB0byByZXRyaWV2ZSBhIHN0YXRpYyBpbWFnZVxyXG4gICAgICogb2YgdGhlIGdyYXBoIGJlaW5nIHJlbmRlcmVkLlxyXG4gICAgICpcclxuICAgICAqIEF1dGhvcjogR3VpbGxhdW1lIFBsaXF1ZSAoWW9tZ3VpdGhlcmVhbClcclxuICAgICAqIFZlcnNpb246IDAuMC4xXHJcbiAgICAgKi9cclxuXHJcbiAgICAvLyBUZXJtaW5hdGluZyBpZiBzaWdtYSB3ZXJlIG5vdCB0byBiZSBmb3VuZFxyXG4gICAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgdGhyb3cgJ3NpZ21hLnJlbmRlcmVycy5zbmFwc2hvdDogc2lnbWEgbm90IGluIHNjb3BlLic7XHJcblxyXG4gICAgLy8gQ29uc3RhbnRzXHJcbiAgICB2YXIgQ09OVEVYVFMgPSBbJ3NjZW5lJywgJ2VkZ2VzJywgJ25vZGVzJywgJ2xhYmVscyddLFxyXG4gICAgICAgIFRZUEVTID0ge1xyXG4gICAgICAgICAgICBwbmc6ICdpbWFnZS9wbmcnLFxyXG4gICAgICAgICAgICBqcGc6ICdpbWFnZS9qcGVnJyxcclxuICAgICAgICAgICAgZ2lmOiAnaW1hZ2UvZ2lmJyxcclxuICAgICAgICAgICAgdGlmZjogJ2ltYWdlL3RpZmYnXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAvLyBVdGlsaXRpZXNcclxuICAgIGZ1bmN0aW9uIGRvd25sb2FkIChkYXRhVXJsLCBleHRlbnNpb24sIGZpbGVuYW1lKSB7XHJcblxyXG4gICAgICAgIC8vIEFuY2hvclxyXG4gICAgICAgIHZhciBhbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnaHJlZicsIGRhdGFVcmwpO1xyXG4gICAgICAgIGFuY2hvci5zZXRBdHRyaWJ1dGUoJ2Rvd25sb2FkJywgZmlsZW5hbWUgfHwgJ2dyYXBoLicgKyBleHRlbnNpb24pO1xyXG5cclxuICAgICAgICAvLyBDbGljayBldmVudFxyXG4gICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XHJcbiAgICAgICAgZXZlbnQuaW5pdE1vdXNlRXZlbnQoJ2NsaWNrJywgdHJ1ZSwgZmFsc2UsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xyXG5cclxuICAgICAgICBhbmNob3IuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgICAgYW5jaG9yID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1haW4gZnVuY3Rpb25cclxuICAgIGZ1bmN0aW9uIHNuYXBzaG90IChwYXJhbXMpIHtcclxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XHJcblxyXG4gICAgICAgIC8vIEVuZm9yY2luZ1xyXG4gICAgICAgIGlmIChwYXJhbXMuZm9ybWF0ICYmICEocGFyYW1zLmZvcm1hdCBpbiBUWVBFUykpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdzaWdtYS5yZW5kZXJlcnMuc25hcGhvdDogdW5zdXBwb3J0ZWQgZm9ybWF0IFwiJyArXHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZm9ybWF0ICsgJ1wiLicpO1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAgIHdlYmdsID0gdGhpcyBpbnN0YW5jZW9mIHNpZ21hLnJlbmRlcmVycy53ZWJnbCxcclxuICAgICAgICAgICAgZG9uZUNvbnRleHRzID0gW107XHJcblxyXG4gICAgICAgIC8vIENyZWF0aW5nIGEgZmFsc2UgY2FudmFzIHdoZXJlIHdlJ2xsIG1lcmdlIHRoZSBvdGhlclxyXG4gICAgICAgIHZhciBtZXJnZWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcclxuICAgICAgICAgICAgbWVyZ2VkQ29udGV4dCA9IG1lcmdlZC5nZXRDb250ZXh0KCcyZCcpLFxyXG4gICAgICAgICAgICBzaXplZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBJdGVyYXRpbmcgdGhyb3VnaCBjb250ZXh0XHJcbiAgICAgICAgQ09OVEVYVFMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICBpZiAoIXNlbGYuY29udGV4dHNbbmFtZV0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAocGFyYW1zLmxhYmVscyA9PT0gZmFsc2UgJiYgbmFtZSA9PT0gJ2xhYmVscycpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gc2VsZi5kb21FbGVtZW50c1tuYW1lXSB8fCBzZWxmLmRvbUVsZW1lbnRzWydzY2VuZSddLFxyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IHNlbGYuY29udGV4dHNbbmFtZV07XHJcblxyXG4gICAgICAgICAgICBpZiAofmRvbmVDb250ZXh0cy5pbmRleE9mKGNvbnRleHQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzaXplZCkge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkLndpZHRoID0gd2ViZ2wgJiYgY29udGV4dCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCA/XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoIC8gMiA6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkLmhlaWdodCA9IHdlYmdsICYmIGNvbnRleHQgaW5zdGFuY2VvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgP1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgLyAyIDpcclxuICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgc2l6ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERvIHdlIHdhbnQgYSBiYWNrZ3JvdW5kIGNvbG9yP1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5iYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkQ29udGV4dC5yZWN0KDAsIDAsIG1lcmdlZC53aWR0aCwgbWVyZ2VkLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkQ29udGV4dC5maWxsU3R5bGUgPSBwYXJhbXMuYmFja2dyb3VuZDtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRDb250ZXh0LmZpbGwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQpXHJcbiAgICAgICAgICAgICAgICBtZXJnZWRDb250ZXh0LmRyYXdJbWFnZShjYW52YXMsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBtZXJnZWRDb250ZXh0LmRyYXdJbWFnZShjYW52YXMsIDAsIDApO1xyXG5cclxuICAgICAgICAgICAgZG9uZUNvbnRleHRzLnB1c2goY29udGV4dCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciBkYXRhVXJsID0gbWVyZ2VkLnRvRGF0YVVSTChUWVBFU1twYXJhbXMuZm9ybWF0IHx8ICdwbmcnXSk7XHJcblxyXG4gICAgICAgIGlmIChwYXJhbXMuZG93bmxvYWQpXHJcbiAgICAgICAgICAgIGRvd25sb2FkKFxyXG4gICAgICAgICAgICAgICAgZGF0YVVybCxcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5mb3JtYXQgfHwgJ3BuZycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZmlsZW5hbWVcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gQ2xlYW5pbmdcclxuICAgICAgICBtZXJnZWRDb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIG1lcmdlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBkb25lQ29udGV4dHMgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhVXJsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4dGVuZGluZyBjYW52YXMgYW5kIHdlYmwgcmVuZGVyZXJzXHJcbiAgICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5zbmFwc2hvdCA9IHNuYXBzaG90O1xyXG4gICAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5zbmFwc2hvdCA9IHNuYXBzaG90O1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IHVzZVBsdWdpbjsiLCIndXNlIHN0cmljdCc7XHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCBERUZBVUxUX0RFQ0tfTEVOR1RIID0gNDtcclxuXHJcbi8qKlxyXG4gKiBTdG9yZSBzdGF0ZXMgb2YgTEcuIFN0YXRlcyBpcyBhIERpYWdyYW1zIHJlbmRlcmVkIGFyb3VuZCBmb2N1c05vZGUuXHJcbiAqIEBjbGFzc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBDb25zdHJ1Y3RvciBwYXJhbWV0ZXJzXHJcbiAqICBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnNcclxuXHJcbiAqIFB1YmxpYyBtZXRob2RzOlxyXG4gKiBwdXNoU3RhdGU6ICgpID0+IHZvaWRcclxuICogZ2V0SGlzdG9yeTogKCkgPT4ge1xyXG4gKiAgc3RhdGVzOiB7IG5vZGVzOiBOb2RlW10sIGxpbmtzOiBMaW5rW10sIGZvY3VzTm9kZTogTm9kZSB9W10sXHJcbiAqICBjdXJyZW50SW5kZXg6IG51bWJlcixcclxuICogfVxyXG4gKiB1bmRvU3RhdGU6ICgpID0+IHZvaWRcclxuICogcmVkb1N0YXRlOiAoKSA9PiB2b2lkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU3RhdGVTdG9yYWdlIChwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIGlmICghcGFyYW1ldGVycykgcGFyYW1ldGVycyA9IHt9O1xyXG5cclxuICAgIGNvbnN0IF9zdGF0ZURlY2sgPSBbXTtcclxuICAgIGNvbnN0IF9tYXhEZWNrTGVuZ3RoID0gcGFyYW1ldGVycy5kZWNrTGVuZ3RoIHx8IERFRkFVTFRfREVDS19MRU5HVEg7XHJcbiAgICBsZXQgX2N1cnJlbnRJbmRleCA9IC0xO1xyXG5cclxuICAgIHNlbGYucHVzaFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZURlY2subGVuZ3RoIC0gMSA+IF9jdXJyZW50SW5kZXgpIHtcclxuICAgICAgICAgICAgX3N0YXRlRGVjay5zcGxpY2UoX2N1cnJlbnRJbmRleCArIDEsIF9zdGF0ZURlY2subGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3N0YXRlRGVjay5wdXNoKHN0YXRlKTtcclxuICAgICAgICBfY2hlY2soKTtcclxuICAgICAgICBfY3VycmVudEluZGV4ID0gX3N0YXRlRGVjay5sZW5ndGggLSAxO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgX3N0YXRlRGVja1tfY3VycmVudEluZGV4XSA9IHN0YXRlO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldEhpc3RvcnkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhdGVzOiBjbG9uZURlZXAoX3N0YXRlRGVjayksXHJcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleDogX2N1cnJlbnRJbmRleCxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnVuZG9TdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX2N1cnJlbnRJbmRleCA+IDApIHtcclxuICAgICAgICAgICAgX2N1cnJlbnRJbmRleC0tO1xyXG4gICAgICAgICAgICByZXR1cm4gX3JldHVyblN0YXRlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnJlZG9TdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX2N1cnJlbnRJbmRleCArIDEgPCBfc3RhdGVEZWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBfY3VycmVudEluZGV4Kys7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmV0dXJuU3RhdGUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBfcmV0dXJuU3RhdGUgKCkge1xyXG4gICAgICAgIHJldHVybiBfc3RhdGVEZWNrW19jdXJyZW50SW5kZXhdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9jaGVjayAoKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZURlY2subGVuZ3RoID4gX21heERlY2tMZW5ndGgpIF9zdGF0ZURlY2suc2hpZnQoKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3RhdGVTdG9yYWdlO1xyXG5cclxuIiwiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuXG4vKiogXG4gKiBJdCdzIGJhc2UgY2xhc3Mgd2hpY2ggcHJvdmlkZXMgc3Vic2NyaXB0aW9uIEFQSSBmb3Igc3VjY2Vzc29ycy5cbiAqIEBjbGFzc1xuKi9cbmV4cG9ydCBmdW5jdGlvbiBTdWJzY3JpYmFibGUgKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuX3N1YnNjcmlidGlvbnMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBhbGxvd3MgdG8gc3Vic2NyaWJlIG9uIGEgc29tZSBzcGVjaWZpYyBldmVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBldmVudCBpZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gZXZlbnQgaGFuZGxlclxuICAgICAqIEBtZW1iZXJvZiBTdWJzY3JpYmFibGVcbiAgICAgKiBAbWV0aG9kXG4gICAgKi9cbiAgICBzZWxmLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXNlbGYuX3N1YnNjcmlidGlvbnNbZXZlbnRdKSBzZWxmLl9zdWJzY3JpYnRpb25zW2V2ZW50XSA9IFtdO1xuICAgICAgICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgc2VsZi5fc3Vic2NyaWJ0aW9uc1tldmVudF0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgdHlwZSBvZiBjYWxsYmFjayEnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgYWxsb3dzIHRvIHVuc3Vic2NyaWJlIGZyb20gYSBzb21lIHNwZWNpZmljIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gZXZlbnQgaGFuZGxlclxuICAgICAqIEBtZW1iZXJvZiBTdWJzY3JpYmFibGVcbiAgICAgKiBAbWV0aG9kXG4gICAgKi9cbiAgICBzZWxmLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIF8udmFsdWVzKHNlbGYuX3N1YnNjcmlidGlvbnMpLmZvckVhY2goc3Vic2NyaWJlcnMgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHN1YnNjcmliZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Qgd2hpY2ggZmlyZXMgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIGV2ZW50IGlkXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gcGFyYW1ldGVyc1xuICAgICAqIEBtZW1iZXJvZiBTdWJzY3JpYmFibGVcbiAgICAgKiBAbWV0aG9kXG4gICAgKi9cbiAgICBzZWxmLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgaWYgKCEocGFyYW1ldGVycyBpbnN0YW5jZW9mIEFycmF5KSkgcGFyYW1ldGVycyA9IFtwYXJhbWV0ZXJzXTtcbiAgICAgICAgaWYgKHNlbGYuX3N1YnNjcmlidGlvbnMgJiYgc2VsZi5fc3Vic2NyaWJ0aW9uc1tldmVudF0pIHtcbiAgICAgICAgICAgIHNlbGYuX3N1YnNjcmlidGlvbnNbZXZlbnRdLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICAgICAgYy5hcHBseSh0aGlzLCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydCBkZWZhdWx0IFN1YnNjcmliYWJsZTtcbiIsImltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0ICogYXMgZ3JhcGhFbGVtZW50cyBmcm9tICcuLi9qb2ludFZpZXdzL2dyYXBoRWxlbWVudHMvZWxlbWVudHMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEJhc2VFbGVtZW50IChlbGVtZW50KSB7XHJcbiAgICBpZiAoIWVsZW1lbnQpIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQub3JpZ2luYWxMaW5rIHx8IGVsZW1lbnQub3JpZ2luYWxOb2RlIHx8IGVsZW1lbnQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjaGVja0xnUmF3RGF0YSAoZGF0YSkge1xyXG4gICAgaWYgKCghZGF0YS5saW5rcykgJiYgKCFkYXRhLm5vZGVzKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gZGF0YSB0byBzaG93IScpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRhdGEubm9kZXMpIHtcclxuICAgICAgICBpZiAoIShkYXRhLm5vZGVzIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXFwnbm9kZXNcXCcgc2hvdWxkIGJlIGFuIEFycmF5LCBidXQgaXQgaXMgb2JqZWN0IScpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5ub2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBubyBkYXRhIHRvIHNob3chJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIG5vZGVzIGluZm9ybWF0aW9uIGluIHRoZSBkYXRhLCBzbyB3ZSBoYXZlIG5vdGhpbmcgdG8gc2hvdyEnKTtcclxuICAgIH1cclxuICAgIGlmIChkYXRhLmxpbmtzICYmICEoZGF0YS5saW5rcyBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXFwnbGlua3NcXCcgc2hvdWxkIGJlIGFuIEFycmF5LCBidXQgaXQgaXMgb2JqZWN0IScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjaGVja0RtUmF3RGF0YSAoZGF0YSkge1xyXG4gICAgaWYgKCghZGF0YS5lZGdlcykgJiYgKCFkYXRhLm5vZGVzKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gZGF0YSB0byBzaG93IScpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRhdGEubm9kZXMpIHtcclxuICAgICAgICBpZiAoIShkYXRhLm5vZGVzIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXFwnbm9kZXNcXCcgc2hvdWxkIGJlIGFuIEFycmF5LCBidXQgaXQgaXMgb2JqZWN0IScpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5ub2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBubyBkYXRhIHRvIHNob3chJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIG5vZGVzIGluZm9ybWF0aW9uIGluIHRoZSBkYXRhLCBzbyB3ZSBoYXZlIG5vdGhpbmcgdG8gc2hvdyEnKTtcclxuICAgIH1cclxuICAgIGlmIChkYXRhLmxpbmtzICYmICEoZGF0YS5lZGdlcyBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXFwnbGlua3NcXCcgc2hvdWxkIGJlIGFuIEFycmF5LCBidXQgaXQgaXMgb2JqZWN0IScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogVmlldyBmcmFtZSBkZWZpbml0aW9uLFxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3RnJhbWVEZWZpbml0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFZpZXcgZnJhbWUgaWRlbnRpZnllclxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWwgLSBUaXRsZSBvZiB0aGUgdmlldyBmcmFtZSxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJvcmRlckNvbG9yIC0gQ29sb3Igb2YgdGhlIGJvcmRlclxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYmFja2dyb3VuZENvbG9yIC0gQ29sb3Igb2YgdGhlIGJhY2tncm91bmRcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNwYWNlU2hhcmUgLSBIb3cgbXVjaCB0aGUgdmlldyBmcmFtZSB3aWxsIHRha2VcclxuICogQHByb3BlcnR5IHtib29sZWFufSBjb2xsYXBzZWQgLSBEZWZpbmUgZGVmYXVsdCBzdGF0ZVxyXG4gKiBmcm9tIHdob2xlIHNwYWNlIG9mIHRoZSBncmFwaCAoWW91IGNhbiB0YWtlIGl0IGFzIHBlcnNlbnRzIG9yIGZsZXggZ3JvdylcclxuKi9cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmZW5pdGlvblRvUHVibGljTW9kZWwgKGRlZmVuaXRpb24sIGZ1bGxTY3JlZW5Nb2RlKSB7XHJcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGZ1bGxTY3JlZW5Nb2RlID8gZmFsc2UgOiAhZGVmZW5pdGlvbi5jb2xsYXBzZWQ7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogZGVmZW5pdGlvbi5pZCxcclxuICAgICAgICBsYWJlbDogZGVmZW5pdGlvbi5sYWJlbCxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGRlZmVuaXRpb24uYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgIGJvcmRlckNvbG9yOiBkZWZlbml0aW9uLmJvcmRlckNvbG9yLFxyXG4gICAgICAgIGFjdGl2ZTogaXNBY3RpdmUsXHJcbiAgICAgICAgZXhwYW5kZWQ6ICFkZWZlbml0aW9uLmNvbGxhcHNlZCxcclxuICAgICAgICBwb3NpdGlvbjogdW5kZWZpbmVkLFxyXG4gICAgICAgIHZpZXdQb3J0UG9zaXRpb246IHVuZGVmaW5lZCxcclxuICAgICAgICB2aWV3UG9ydFBvc2l0aW9uQm91bmRzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgdmlld1BvcnRCb3VuZHM6IHVuZGVmaW5lZCxcclxuICAgICAgICBub2RlQm91bmRzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgc2l6ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgIGN1c3RvbWVTaXplZDogZmFsc2UsXHJcbiAgICAgICAgc3BhY2VTaGFyZTogZGVmZW5pdGlvbi5zcGFjZVNoYXJlLFxyXG4gICAgICAgIHVwZGF0ZUJvdW5kczogZmFsc2UsXHJcbiAgICAgICAgaXNPdmVyVmlldzogZmFsc2UsXHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogQ3JldGVzIGpvaW50IG5vZGVzIGZyb20gbm9kZU1vZGVsc1xyXG4gKiBAcGFyYW0ge1xyXG4gKiAgICAgIEFycmF5IG9mIHtcclxuICAgICAgICAgICAgaWQ6IHN0cmluZyxcclxuICAgICAgICAgICAgbGFiZWw6IHN0cmluZyxcclxuICAgICAgICAgICAgdmlld0ZyYW1lOiBzdHJpbmcsXHJcbiAgICAgICAgICAgIHR5cGVJZDogc3RyaW5nLFxyXG4gICAgICAgICAgICByZXNvdXJjZVR5cGU6IHN0cmluZyxcclxuICAgICAgICAgICAgcmVzb3VyY2U6IHN0cmluZyxcclxuICogICAgICB9XHJcbiAqIH0gTm9kZU1vZGVscyAtIGxpc3Qgb2YgbW9kZWxzXHJcbiAqIEByZXR1cm5zIHtBcnJheSBvZiBOb2RlfSBsaXN0IG9mIGpvaW50IG5vZGVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSm9pbnROb2RlcyAobm9kZU1vZGVscywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgam9pbnROb2RlcyA9IFtdO1xyXG4gICAgbm9kZU1vZGVscy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgIGpvaW50Tm9kZXMucHVzaChuZXcgZ3JhcGhFbGVtZW50cy5Ob2RlKG5vZGUsIHBhcmFtZXRlcnMpKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGpvaW50Tm9kZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBDcmV0ZXMgam9pbnQgbGlua3MgZnJvbSBtb2RlbHMgKG5hdGl2ZUxpbmtzKVxyXG4gKiBAcGFyYW0ge1xyXG4gKiAgICAgIEFycmF5IG9mIHtcclxuICogICAgICAgICAgaWQ6IHN0cmluZyxcclxuICogICAgICAgICAgdGFyZ2V0OiBzdHJpbmcsXHJcbiAqICAgICAgICAgIHNvdXJjZTogc3RyaW5nLFxyXG4gKiAgICAgIH1cclxuICogfSBuYXRpdmVMaW5rcyAtIGxpc3Qgb2YgbW9kZWxzXHJcbiAqIEByZXR1cm5zIHtMaW5rW119IGxpc3Qgb2Ygam9pbnQgbGlua3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVKb2ludExpbmtzIChsaW5rTW9kZWxzLCBqb2ludE5vZGVzLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBqb2ludExpbmtzID0gW107XHJcbiAgICBjb25zdCBpZE1hcCA9IHt9O1xyXG4gICAgam9pbnROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgIGlkTWFwW25vZGUubW9kZWwuaWRdID0gbm9kZS5pZDtcclxuICAgIH0pO1xyXG4gICAgbGlua01vZGVscy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgIHZhciBsaW5rTW9kZWwgPSBfLmNsb25lRGVlcChsaW5rKTtcclxuICAgICAgICBsaW5rTW9kZWwuc291cmNlVHlwZSA9IGxpbmsuc291cmNlO1xyXG4gICAgICAgIGxpbmtNb2RlbC50YXJnZXRUeXBlID0gbGluay50YXJnZXQ7XHJcbiAgICAgICAgbGlua01vZGVsLnNvdXJjZSA9IGlkTWFwW2xpbmsuc291cmNlXTtcclxuICAgICAgICBsaW5rTW9kZWwudGFyZ2V0ID0gaWRNYXBbbGluay50YXJnZXRdO1xyXG4gICAgICAgIGxpbmtNb2RlbC5yb3V0aW5nID0gcGFyYW1ldGVycy5saW5rUm91dGluZztcclxuICAgICAgICBjb25zdCBuZXdMaW5rID0gbmV3IGdyYXBoRWxlbWVudHMuTGluayhsaW5rTW9kZWwsIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIGpvaW50TGlua3MucHVzaChuZXdMaW5rKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGpvaW50TGlua3M7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkYXRlMlN0cmluZyAoZGF0ZSkge1xyXG4gICAgcmV0dXJuIHBhZFN0cihkYXRlLmdldEZ1bGxZZWFyKCkpICsgJ18nICtcclxuICAgICAgICAgICAgcGFkU3RyKDEgKyBkYXRlLmdldE1vbnRoKCkpICsgJ18nICtcclxuICAgICAgICAgICAgcGFkU3RyKGRhdGUuZ2V0RGF0ZSgpKSArICdfJyArXHJcbiAgICAgICAgICAgIHBhZFN0cihkYXRlLmdldEhvdXJzKCkpICsgJ18nICtcclxuICAgICAgICAgICAgcGFkU3RyKGRhdGUuZ2V0TWludXRlcygpKSArICdfJyArXHJcbiAgICAgICAgICAgIHBhZFN0cihkYXRlLmdldFNlY29uZHMoKSk7XHJcblxyXG4gICAgZnVuY3Rpb24gcGFkU3RyIChpKSB7XHJcbiAgICAgICAgcmV0dXJuIChpIDwgMTApID8gJzAnICsgaSA6ICcnICsgaTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBuZzJCbG9iIChkYXRhVVJJKSB7XHJcbiAgICAvLyBjb252ZXJ0IGJhc2U2NCB0byByYXcgYmluYXJ5IGRhdGEgaGVsZCBpbiBhIHN0cmluZ1xyXG4gICAgLy8gZG9lc24ndCBoYW5kbGUgVVJMRW5jb2RlZCBEYXRhVVJJcyAtIHNlZSBTTyBhbnN3ZXIgIzY4NTAyNzYgZm9yIGNvZGUgdGhhdCBkb2VzIHRoaXNcclxuICAgIHZhciBieXRlU3RyaW5nID0gYXRvYihkYXRhVVJJLnNwbGl0KCcsJylbMV0pO1xyXG5cclxuICAgIC8vIHdyaXRlIHRoZSBieXRlcyBvZiB0aGUgc3RyaW5nIHRvIGFuIEFycmF5QnVmZmVyXHJcbiAgICB2YXIgYWIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVN0cmluZy5sZW5ndGgpO1xyXG4gICAgdmFyIGlhID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWFbaV0gPSBieXRlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd3JpdGUgdGhlIEFycmF5QnVmZmVyIHRvIGEgYmxvYiwgYW5kIHlvdSdyZSBkb25lXHJcbiAgICB2YXIgYmIgPSBuZXcgQmxvYihbYWJdLCB7IHR5cGU6ICdpbWFnZS9wbmcnIH0pO1xyXG4gICAgcmV0dXJuIGJiO1xyXG59IiwiaW1wb3J0IHtcclxuICAgIGFycmF5VG9NYXAsXHJcbiAgICBtYXBUb0FycmF5LFxyXG4gICAgZ2V0R2xvYmFsTm9kZVBvc2l0aW9uLFxyXG4gICAgc2NhbGVkVG9HbG9iYWxTaXplLFxyXG5cclxufSBmcm9tICcuL3V0aWxzJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0TmF0aXZlVG9MYXlvdXRNb2RlbHMgKG5vZGVNb2RlbHMsIGxpbmtNb2RlbHMsIHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNpemUgPSBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBub2RlTW9kZWxzVG9MYXlvdXROb2Rlcyhub2RlTW9kZWxzLCBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplKTtcclxuICAgIGNvbnN0IGxpbmtzID0gbGlua01vZGVsc1RvTGF5b3V0TGlua3MobGlua01vZGVscywgbm9kZXMpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxyXG4gICAgICAgIGxpbmtzOiBsaW5rcyxcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gbm9kZU1vZGVsc1RvTGF5b3V0Tm9kZXMgKG5vZGVNb2RlbHMpIHtcclxuICAgICAgICByZXR1cm4gbm9kZU1vZGVscy5tYXAobm9kZU1vZGVsID0+IG5vZGVNb2RlbFRvTGF5b3V0Tm9kZShub2RlTW9kZWwpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gbGlua01vZGVsc1RvTGF5b3V0TGlua3MgKGxpbmtNb2RlbHMsIG5vZGVzKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IGFycmF5VG9NYXAobm9kZXMpO1xyXG4gICAgICAgIGNvbnN0IGxpbmtzID0gbGlua01vZGVscy5tYXAobGluayA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5rTW9kZWxUb0xheW91dExpbmsobGluaywgbm9kZU1hcCk7XHJcbiAgICAgICAgfSkuZmlsdGVyKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbGluay5zb3VyY2UgJiYgbGluay50YXJnZXQgJiYgbGluay5zb3VyY2UgIT09IGxpbmsudGFyZ2V0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIGxpbmsuc291cmNlLnRhcmdldExpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgICAgIGxpbmsudGFyZ2V0LnNvdXJjZUxpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmtzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5vZGVNb2RlbFRvTGF5b3V0Tm9kZSAobm9kZU1vZGVsKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IG5vZGVNb2RlbC5pZCxcclxuICAgICAgICAgICAgeDogbm9kZU1vZGVsLnBvc2l0aW9uLnggfHwgTWF0aC5yYW5kb20oKSxcclxuICAgICAgICAgICAgeTogbm9kZU1vZGVsLnBvc2l0aW9uLnkgfHwgTWF0aC5yYW5kb20oKSxcclxuICAgICAgICAgICAgb3JpZ2luYWxOb2RlOiBub2RlTW9kZWwsXHJcbiAgICAgICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxyXG4gICAgICAgICAgICB0YXJnZXRMaW5rczogW10sXHJcbiAgICAgICAgICAgIHNvdXJjZUxpbmtzOiBbXSxcclxuICAgICAgICAgICAgdmlld0ZyYW1lOiBub2RlTW9kZWwudmlld0ZyYW1lLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbGlua01vZGVsVG9MYXlvdXRMaW5rIChsaW5rTW9kZWwsIG5vZGVNYXApIHtcclxuICAgICAgICBjb25zdCBzb3VyY2UgPSBub2RlTWFwW2xpbmtNb2RlbC5zb3VyY2VdO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG5vZGVNYXBbbGlua01vZGVsLnRhcmdldF07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3JpZ2luYWxMaW5rOiBsaW5rTW9kZWwsXHJcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICAgICAgdmFsdWU6IDEsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRMR0VsZW1lbnRzVG9MYXlvdXRNb2RlbHMgKGxnTm9kZXMsIGxnTGlua3MsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHNjYWxlID0gb3B0aW9ucy5zY2FsZTtcclxuICAgIGNvbnN0IG5vZGVzID0gbGdOb2Rlcy5tYXAobm9kZSA9PiBub2RlVG9MYXlvdXROb2RlKG5vZGUpKTtcclxuICAgIGNvbnN0IGxpbmtzID0gbGlua3NUb0xheW91dExpbmtzKGxnTGlua3MsIG5vZGVzKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5vZGVzOiBub2RlcyxcclxuICAgICAgICBsaW5rczogbGlua3MsXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGxpbmtzVG9MYXlvdXRMaW5rcyAobGluaywgbm9kZXMpIHtcclxuICAgICAgICBjb25zdCBub2RlTWFwID0gYXJyYXlUb01hcChub2Rlcyk7XHJcbiAgICAgICAgY29uc3QgbGlua3MgPSBsaW5rLm1hcChsaW5rID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGxpbmtUb0xheW91dExpbmsobGluaywgbm9kZU1hcCk7XHJcbiAgICAgICAgfSkuZmlsdGVyKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbGluay5zb3VyY2UgJiYgbGluay50YXJnZXQgJiYgbGluay5zb3VyY2UgIT09IGxpbmsudGFyZ2V0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIGxpbmsuc291cmNlLnRhcmdldExpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgICAgIGxpbmsudGFyZ2V0LnNvdXJjZUxpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmtzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5vZGVUb0xheW91dE5vZGUgKG5vZGUpIHtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldEdsb2JhbE5vZGVQb3NpdGlvbihub2RlKTtcclxuICAgICAgICBjb25zdCBzaXplID0gc2NhbGVkVG9HbG9iYWxTaXplKG5vZGUuc2l6ZSwgc2NhbGUpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBub2RlLmlkLFxyXG4gICAgICAgICAgICB4OiBwb3NpdGlvbi54LFxyXG4gICAgICAgICAgICB5OiBwb3NpdGlvbi55LFxyXG4gICAgICAgICAgICBvcmlnaW5hbE5vZGU6IG5vZGUsXHJcbiAgICAgICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlndGg6IHNpemUuaGVpZ3RoLFxyXG4gICAgICAgICAgICB0YXJnZXRMaW5rczogW10sXHJcbiAgICAgICAgICAgIHNvdXJjZUxpbmtzOiBbXSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxpbmtUb0xheW91dExpbmsgKGxpbmssIG5vZGVNYXApIHtcclxuICAgICAgICBjb25zdCBzb3VyY2UgPSBub2RlTWFwW2xpbmsubW9kZWwuc291cmNlXTtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBub2RlTWFwW2xpbmsubW9kZWwudGFyZ2V0XTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvcmlnaW5hbExpbms6IGxpbmssXHJcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICAgICAgdmFsdWU6IDEsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0RE1FbGVtZW50c1RvTGF5b3V0TW9kZWxzIChkbU5vZGVzLCBkbUxpbmtzKSB7XHJcbiAgICBjb25zdCBub2RlTWFwID0gYXJyYXlUb01hcChkbU5vZGVzLm1hcChub2RlID0+IG5vZGVUb0xheW91dE5vZGUobm9kZSkpKTtcclxuICAgIGNvbnN0IGxpbmtzID0gbGlua3NUb0xheW91dExpbmtzKGRtTGlua3MsIG5vZGVNYXApO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9kZXM6IG1hcFRvQXJyYXkobm9kZU1hcCksXHJcbiAgICAgICAgbGlua3M6IGxpbmtzLFxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBsaW5rc1RvTGF5b3V0TGlua3MgKGxpbmssIG5vZGVNYXApIHtcclxuICAgICAgICBjb25zdCBsaW5rcyA9IGxpbmsubWFwKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbGlua1RvTGF5b3V0TGluayhsaW5rLCBub2RlTWFwKTtcclxuICAgICAgICB9KS5maWx0ZXIobGluayA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5rLnNvdXJjZSAmJiBsaW5rLnRhcmdldCAmJiBsaW5rLnNvdXJjZSAhPT0gbGluay50YXJnZXQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgbGluay5zb3VyY2UudGFyZ2V0TGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICAgICAgbGluay50YXJnZXQuc291cmNlTGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbGlua3M7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbm9kZVRvTGF5b3V0Tm9kZSAobm9kZSkge1xyXG4gICAgICAgIGNvbnN0IHBvcnRQcmltaXRpdmUgPSBub2RlLmdldFBvcnQoKS5wcmltaXRpdmU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IHBvcnRQcmltaXRpdmUuaWQsXHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsTm9kZTogcG9ydFByaW1pdGl2ZSxcclxuICAgICAgICAgICAgdGFyZ2V0TGlua3M6IFtdLFxyXG4gICAgICAgICAgICBzb3VyY2VMaW5rczogW10sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gbGlua1RvTGF5b3V0TGluayAobGluaywgbm9kZU1hcCkge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZVByaW1pdGl2ZSA9IGxpbmsuc291cmNlLmdldFBvcnQoKS5wcmltaXRpdmU7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0UHJpbWl0aXZlID0gbGluay50YXJnZXQuZ2V0UG9ydCgpLnByaW1pdGl2ZTtcclxuXHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gbm9kZU1hcFtzb3VyY2VQcmltaXRpdmUuaWRdO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG5vZGVNYXBbdGFyZ2V0UHJpbWl0aXZlLmlkXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2FjaGVJZDogY2FjaExpbmtGdW5jdGlvbiAoc291cmNlUHJpbWl0aXZlLCB0YXJnZXRQcmltaXRpdmUpLFxyXG4gICAgICAgICAgICBvcmlnaW5hbExpbms6IGxpbmssXHJcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICAgICAgdmFsdWU6IDEsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjYWNoTGlua0Z1bmN0aW9uIChzb3VyY2UsIHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2UuaWQgKyAnfiN0cURNTGluayN+JyArIHRhcmdldC5pZDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRKb2ludEVsZW1lbnRzVG9MYXlvdXRNb2RlbHMgKGpOb2RlcywgakxpbmtzKSB7XHJcbiAgICBjb25zdCBub2RlTWFwID0gYXJyYXlUb01hcChqTm9kZXMubWFwKG5vZGUgPT4gbm9kZVRvTGF5b3V0Tm9kZShub2RlKSkpO1xyXG4gICAgY29uc3QgbGlua3MgPSBsaW5rc1RvTGF5b3V0TGlua3MoakxpbmtzLCBub2RlTWFwKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5vZGVzOiBtYXBUb0FycmF5KG5vZGVNYXApLFxyXG4gICAgICAgIGxpbmtzOiBsaW5rcyxcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gbGlua3NUb0xheW91dExpbmtzIChsaW5rLCBub2RlTWFwKSB7XHJcbiAgICAgICAgY29uc3QgbGlua3MgPSBsaW5rLm1hcChsaW5rID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGxpbmtUb0xheW91dExpbmsobGluaywgbm9kZU1hcCk7XHJcbiAgICAgICAgfSkuZmlsdGVyKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbGluay5zb3VyY2UgJiYgbGluay50YXJnZXQgJiYgbGluay5zb3VyY2UgIT09IGxpbmsudGFyZ2V0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIGxpbmsuc291cmNlLnRhcmdldExpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgICAgIGxpbmsudGFyZ2V0LnNvdXJjZUxpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmtzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5vZGVUb0xheW91dE5vZGUgKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogbm9kZS5pZCxcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgdGFyZ2V0TGlua3M6IFtdLFxyXG4gICAgICAgICAgICBzb3VyY2VMaW5rczogW10sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gbGlua1RvTGF5b3V0TGluayAobGluaywgbm9kZU1hcCkge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG5vZGVNYXBbbGluay5nZXQoJ3NvdXJjZScpLmlkXTtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBub2RlTWFwW2xpbmsuZ2V0KCd0YXJnZXQnKS5pZF07XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICAgICAgdmFsdWU6IDEsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN1bSAoYXJyYXksIGYpIHtcclxuICAgIGxldCBzID0gMCxcclxuICAgICAgICBuID0gYXJyYXkubGVuZ3RoLFxyXG4gICAgICAgIGEsXHJcbiAgICAgICAgaSA9IC0xO1xyXG5cclxuICAgIGlmIChmID09IG51bGwpIHtcclxuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xyXG4gICAgICAgICAgICBhID0gK2FycmF5W2ldO1xyXG4gICAgICAgICAgICBpZiAoYSkgcyArPSBhO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcclxuICAgICAgICAgICAgYSA9ICtmKGFycmF5W2ldLCBpLCBhcnJheSk7XHJcbiAgICAgICAgICAgIGlmIChhKSBzICs9IGE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzO1xyXG59XHJcblxyXG5sZXQgcHJlZml4ID0gJyQnO1xyXG5mdW5jdGlvbiBNYXAgKCkge31cclxuTWFwLnByb3RvdHlwZSA9IG1hcCQxLnByb3RvdHlwZSA9IHtcclxuICAgIGNvbnN0cnVjdG9yOiBNYXAsXHJcbiAgICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICByZXR1cm4gKHByZWZpeCArIGtleSkgaW4gdGhpcztcclxuICAgIH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpc1twcmVmaXggKyBrZXldO1xyXG4gICAgfSxcclxuICAgIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzW3ByZWZpeCArIGtleV0gPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBsZXQgcHJvcGVydHkgPSBwcmVmaXggKyBrZXk7XHJcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgZGVsZXRlIHRoaXNbcHJvcGVydHldO1xyXG4gICAgfSxcclxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGRlbGV0ZSB0aGlzW3Byb3BlcnR5XTtcclxuICAgIH0sXHJcbiAgICBrZXlzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGV0IGtleXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkga2V5cy5wdXNoKHByb3BlcnR5LnNsaWNlKDEpKTtcclxuICAgICAgICByZXR1cm4ga2V5cztcclxuICAgIH0sXHJcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsZXQgdmFsdWVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIHZhbHVlcy5wdXNoKHRoaXNbcHJvcGVydHldKTtcclxuICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgfSxcclxuICAgIGVudHJpZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsZXQgZW50cmllcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBlbnRyaWVzLnB1c2goe2tleTogcHJvcGVydHkuc2xpY2UoMSksIHZhbHVlOiB0aGlzW3Byb3BlcnR5XX0pO1xyXG4gICAgICAgIHJldHVybiBlbnRyaWVzO1xyXG4gICAgfSxcclxuICAgIHNpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsZXQgc2l6ZSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpICsrc2l6ZTtcclxuICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgIH0sXHJcbiAgICBlbXB0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgZWFjaDogZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgZih0aGlzW3Byb3BlcnR5XSwgcHJvcGVydHkuc2xpY2UoMSksIHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcCQxIChvYmplY3QsIGYpIHtcclxuICAgIGxldCBtYXAgPSBuZXcgTWFwO1xyXG5cclxuICAgIC8vIENvcHkgY29uc3RydWN0b3IuXHJcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWFwKSBvYmplY3QuZWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkgeyBtYXAuc2V0KGtleSwgdmFsdWUpOyB9KTtcclxuXHJcbiAgICAvLyBJbmRleCBhcnJheSBieSBudW1lcmljIGluZGV4IG9yIHNwZWNpZmllZCBrZXkgZnVuY3Rpb24uXHJcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcclxuICAgICAgICBsZXQgaSA9IC0xLFxyXG4gICAgICAgICAgICBuID0gb2JqZWN0Lmxlbmd0aCxcclxuICAgICAgICAgICAgbztcclxuXHJcbiAgICAgICAgaWYgKGYgPT0gbnVsbCkgd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQoaSwgb2JqZWN0W2ldKTtcclxuICAgICAgICBlbHNlIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KGYobyA9IG9iamVjdFtpXSwgaSwgb2JqZWN0KSwgbyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29udmVydCBvYmplY3QgdG8gbWFwLlxyXG4gICAgZWxzZSBpZiAob2JqZWN0KSBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSBtYXAuc2V0KGtleSwgb2JqZWN0W2tleV0pO1xyXG5cclxuICAgIHJldHVybiBtYXA7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbmVzdCAoKSB7XHJcbiAgICBsZXQga2V5cyA9IFtdLFxyXG4gICAgICAgIHNvcnRLZXlzID0gW10sXHJcbiAgICAgICAgc29ydFZhbHVlcyxcclxuICAgICAgICByb2xsdXAsXHJcbiAgICAgICAgbmVzdDtcclxuXHJcbiAgICBmdW5jdGlvbiBhcHBseSAoYXJyYXksIGRlcHRoLCBjcmVhdGVSZXN1bHQsIHNldFJlc3VsdCkge1xyXG4gICAgICAgIGlmIChkZXB0aCA+PSBrZXlzLmxlbmd0aCkgcmV0dXJuIHJvbGx1cCAhPSBudWxsXHJcbiAgICAgICAgICAgID8gcm9sbHVwKGFycmF5KSA6IChzb3J0VmFsdWVzICE9IG51bGxcclxuICAgICAgICAgICAgPyBhcnJheS5zb3J0KHNvcnRWYWx1ZXMpXHJcbiAgICAgICAgICAgIDogYXJyYXkpO1xyXG5cclxuICAgICAgICBsZXQgaSA9IC0xLFxyXG4gICAgICAgICAgICBuID0gYXJyYXkubGVuZ3RoLFxyXG4gICAgICAgICAgICBrZXkgPSBrZXlzW2RlcHRoKytdLFxyXG4gICAgICAgICAgICBrZXlWYWx1ZSxcclxuICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgIHZhbHVlc0J5S2V5ID0gbWFwJDEoKSxcclxuICAgICAgICAgICAgdmFsdWVzLFxyXG4gICAgICAgICAgICByZXN1bHQgPSBjcmVhdGVSZXN1bHQoKTtcclxuXHJcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcclxuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzQnlLZXkuZ2V0KGtleVZhbHVlID0ga2V5KHZhbHVlID0gYXJyYXlbaV0pICsgJycpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXNCeUtleS5zZXQoa2V5VmFsdWUsIFt2YWx1ZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YWx1ZXNCeUtleS5lYWNoKGZ1bmN0aW9uICh2YWx1ZXMsIGtleSkge1xyXG4gICAgICAgICAgICBzZXRSZXN1bHQocmVzdWx0LCBrZXksIGFwcGx5KHZhbHVlcywgZGVwdGgsIGNyZWF0ZVJlc3VsdCwgc2V0UmVzdWx0KSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZW50cmllcyAobWFwLCBkZXB0aCkge1xyXG4gICAgICAgIGlmICgrK2RlcHRoID4ga2V5cy5sZW5ndGgpIHJldHVybiBtYXA7XHJcbiAgICAgICAgbGV0IGFycmF5LCBzb3J0S2V5ID0gc29ydEtleXNbZGVwdGggLSAxXTtcclxuICAgICAgICBpZiAocm9sbHVwICE9IG51bGwgJiYgZGVwdGggPj0ga2V5cy5sZW5ndGgpIGFycmF5ID0gbWFwLmVudHJpZXMoKTtcclxuICAgICAgICBlbHNlIGFycmF5ID0gW10sIG1hcC5lYWNoKGZ1bmN0aW9uICh2LCBrKSB7IGFycmF5LnB1c2goe2tleTogaywgdmFsdWVzOiBlbnRyaWVzKHYsIGRlcHRoKX0pOyB9KTtcclxuICAgICAgICByZXR1cm4gc29ydEtleSAhPSBudWxsID8gYXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gc29ydEtleShhLmtleSwgYi5rZXkpOyB9KSA6IGFycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXN0ID0ge1xyXG4gICAgICAgIG9iamVjdDogZnVuY3Rpb24gKGFycmF5KSB7IHJldHVybiBhcHBseShhcnJheSwgMCwgY3JlYXRlT2JqZWN0LCBzZXRPYmplY3QpOyB9LFxyXG4gICAgICAgIG1hcDogZnVuY3Rpb24gKGFycmF5KSB7IHJldHVybiBhcHBseShhcnJheSwgMCwgY3JlYXRlTWFwLCBzZXRNYXApOyB9LFxyXG4gICAgICAgIGVudHJpZXM6IGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gZW50cmllcyhhcHBseShhcnJheSwgMCwgY3JlYXRlTWFwLCBzZXRNYXApLCAwKTsgfSxcclxuICAgICAgICBrZXk6IGZ1bmN0aW9uIChkKSB7IGtleXMucHVzaChkKTsgcmV0dXJuIG5lc3Q7IH0sXHJcbiAgICAgICAgc29ydEtleXM6IGZ1bmN0aW9uIChvcmRlcikgeyBzb3J0S2V5c1trZXlzLmxlbmd0aCAtIDFdID0gb3JkZXI7IHJldHVybiBuZXN0OyB9LFxyXG4gICAgICAgIHNvcnRWYWx1ZXM6IGZ1bmN0aW9uIChvcmRlcikgeyBzb3J0VmFsdWVzID0gb3JkZXI7IHJldHVybiBuZXN0OyB9LFxyXG4gICAgICAgIHJvbGx1cDogZnVuY3Rpb24gKGYpIHsgcm9sbHVwID0gZjsgcmV0dXJuIG5lc3Q7IH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0ICgpIHtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0T2JqZWN0IChvYmplY3QsIGtleSwgdmFsdWUpIHtcclxuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hcCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcCQxKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0TWFwIChtYXAsIGtleSwgdmFsdWUpIHtcclxuICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVpbnRlcnBvbGF0ZSAoYSwgYikge1xyXG4gICAgcmV0dXJuIGEgPSArYSwgYiAtPSBhLCBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIHJldHVybiBhICsgYiAqIHQ7XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWluIChhcnJheSwgZikge1xyXG4gICAgbGV0IGkgPSAtMSxcclxuICAgICAgICBuID0gYXJyYXkubGVuZ3RoLFxyXG4gICAgICAgIGEsXHJcbiAgICAgICAgYjtcclxuXHJcbiAgICBpZiAoZiA9PSBudWxsKSB7XHJcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPj0gYikgeyBhID0gYjsgYnJlYWs7IH1cclxuICAgICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYSA+IGIpIGEgPSBiO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZihhcnJheVtpXSwgaSwgYXJyYXkpKSAhPSBudWxsICYmIGIgPj0gYikgeyBhID0gYjsgYnJlYWs7IH1cclxuICAgICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZihhcnJheVtpXSwgaSwgYXJyYXkpKSAhPSBudWxsICYmIGEgPiBiKSBhID0gYjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYTtcclxufSIsImltcG9ydCAqIGFzIGpvaW50IGZyb20gJ3JhcHBpZCc7XHJcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWNoZUlkRm9yVmlld0ZyYW1lVUkgKHZpZXdGcmFtZSkge1xyXG4gICAgcmV0dXJuICd0cS1sZy12aWV3LWZyYW1lLXVpLScgKyB2aWV3RnJhbWUuaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWaWV3RnJhbWVJZEZvck5vZGUgKG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnZpZXdGcmFtZU93bmVySWQgfHwgbm9kZS5tb2RlbC52aWV3RnJhbWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjaGVja1BhZ2luYXRpb24gKHZpZXdGcmFtZSkge1xyXG4gICAgY29uc3Qgdmlld1BvcnRQb3NpdGlvbkJvdW5kcyA9IHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uQm91bmRzO1xyXG4gICAgY29uc3Qgdmlld1BvcnRQb3NpdGlvbiA9IHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2FuTW92ZVVwOiB2aWV3UG9ydFBvc2l0aW9uQm91bmRzICYmIHZpZXdQb3J0UG9zaXRpb24ueSA+IHZpZXdQb3J0UG9zaXRpb25Cb3VuZHMubWluWSxcclxuICAgICAgICBjYW5Nb3ZlRG93bjogdmlld1BvcnRQb3NpdGlvbkJvdW5kcyAmJiB2aWV3UG9ydFBvc2l0aW9uLnkgPCB2aWV3UG9ydFBvc2l0aW9uQm91bmRzLm1heFksXHJcbiAgICAgICAgY2FuTW92ZUxlZnQ6IHZpZXdQb3J0UG9zaXRpb25Cb3VuZHMgJiYgdmlld1BvcnRQb3NpdGlvbi54ID4gdmlld1BvcnRQb3NpdGlvbkJvdW5kcy5taW5YLFxyXG4gICAgICAgIGNhbk1vdmVSaWdodDogdmlld1BvcnRQb3NpdGlvbkJvdW5kcyAmJiB2aWV3UG9ydFBvc2l0aW9uLnggPCB2aWV3UG9ydFBvc2l0aW9uQm91bmRzLm1heFgsXHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogUmV0dXJucyBwb2ludCBvZiBjcm9zc2luZyBvZiB0d28gbGluZXNcclxuICogQHBhcmFtIHtQb2ludH0gcDEgLSB0aGUgZmlyc3QgcG9pbnQgb2YgbGluZS0xXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHAyIC0gdGhlIHNlY29uZCBwb2ludCBvZiBsaW5lLTFcclxuICogQHBhcmFtIHtQb2ludH0gcDMgLSB0aGUgZmlyc3QgcG9pbnQgb2YgbGluZS0yXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHA0IC0gdGhlIHNlY29uZCBwb2ludCBvZiBsaW5lLTJcclxuICogQHJldHVybnMge1BvaW50fVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENyb3NQb2ludCAocDEsIHAyLCBwMywgcDQpIHtcclxuICAgIGxldCB4MSA9IHAxLng7XHJcbiAgICBsZXQgeTEgPSBwMS55O1xyXG5cclxuICAgIGxldCB4MiA9IHAyLng7XHJcbiAgICBsZXQgeTIgPSBwMi55O1xyXG4gICAgXHJcbiAgICBsZXQgeDMgPSBwMy54O1xyXG4gICAgbGV0IHkzID0gcDMueTtcclxuICAgIFxyXG4gICAgbGV0IHg0ID0gcDQueDtcclxuICAgIGxldCB5NCA9IHA0Lnk7XHJcblxyXG4gICAgbGV0IGsxLCBrMiwgYjEsIGIyO1xyXG4gICAgbGV0IHJ4LCByeSwgeHgsIHl5O1xyXG4gICAgbGV0IHJlcyA9IHt9O1xyXG4gICAgXHJcbiAgICBpZiAoeDEgPT0geDIgJiYgeDMgPT0geDQpIHJldHVybiBudWxsO1xyXG4gICAgaWYgKHgxID09PSB4Mikge1xyXG4gICAgICAgIGsyID0gKHkzIC0geTQpIC8gKHgzIC0geDQpO1xyXG4gICAgICAgIGIyID0geTMgLSBrMiAqIHgzO1xyXG5cclxuICAgICAgICByeCA9IHgxO1xyXG4gICAgICAgIHJ5ID0gazIgKiByeCArIGIyO1xyXG4gICAgfSBlbHNlIGlmICh4MyA9PT0geDQpIHtcclxuICAgICAgICBrMSA9ICh5MSAtIHkyKSAvICh4MSAtIHgyKTtcclxuICAgICAgICBiMSA9IHkxIC0gazEgKiB4MTtcclxuXHJcbiAgICAgICAgcnggPSB4MztcclxuICAgICAgICByeSA9IGsxICogcnggKyBiMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgazEgPSAoeTEgLSB5MikgLyAoeDEgLSB4Mik7XHJcbiAgICAgICAgYjEgPSB5MSAtIGsxICogeDE7XHJcblxyXG4gICAgICAgIGsyID0gKHkzIC0geTQpIC8gKHgzIC0geDQpO1xyXG4gICAgICAgIGIyID0geTMgLSBrMiAqIHgzO1xyXG5cclxuICAgICAgICBpZiAoazEgPT0gazIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgcnggPSAoYjIgLSBiMSkgLyAoazEgLSBrMik7XHJcbiAgICAgICAgcnkgPSBrMSAqIHJ4ICsgYjE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHkyIDwgeTEpIHtcclxuICAgICAgICB5eSA9IHkxO1xyXG4gICAgICAgIHkxID0geTI7XHJcbiAgICAgICAgeTIgPSB5eTtcclxuICAgIH1cclxuICAgIGlmICh5NCA8IHkzKSB7XHJcbiAgICAgICAgeXkgPSB5MztcclxuICAgICAgICB5MyA9IHk0O1xyXG4gICAgICAgIHk0ID0geXk7XHJcbiAgICB9XHJcbiAgICBpZiAoeDIgPCB4MSkge1xyXG4gICAgICAgIHh4ID0geDE7XHJcbiAgICAgICAgeDEgPSB4MjtcclxuICAgICAgICB4MiA9IHh4O1xyXG4gICAgfVxyXG4gICAgaWYgKHg0IDwgeDMpIHtcclxuICAgICAgICB4eCA9IHgzO1xyXG4gICAgICAgIHgzID0geDQ7XHJcbiAgICAgICAgeDQgPSB4eDtcclxuICAgIH1cclxuICAgIHJlcy54ID0gcng7XHJcbiAgICByZXMueSA9IHJ5O1xyXG4gICAgY29uc3QgZXJyb3IgPSAxO1xyXG4gICAgaWYgKFxyXG4gICAgICAgIHgxIC0gZXJyb3IgPD0gcmVzLnggJiYgcmVzLnggPD0geDIgKyBlcnJvciAmJlxyXG4gICAgICAgIHgzIC0gZXJyb3IgPD0gcmVzLnggJiYgcmVzLnggPD0geDQgKyBlcnJvciAmJlxyXG4gICAgICAgIHkxIC0gZXJyb3IgPD0gcmVzLnkgJiYgcmVzLnkgPD0geTIgKyBlcnJvciAmJlxyXG4gICAgICAgIHkzIC0gZXJyb3IgPD0gcmVzLnkgJiYgcmVzLnkgPD0geTQgKyBlcnJvciBcclxuICAgICkge1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBUaGlzIGlzIHRoZSBtYXhpbXVtIGRpc3RhbmNlIGJldHdlZW4gbGlua3NcclxuZXhwb3J0IGNvbnN0IEdBUCA9IDEwOyAvLyBweFxyXG4vLyBPbmx5IGZvciBEZXJpdmF0aW9uIG1hcFxyXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0VmVydGljZXMgKGdyYXBoLCBjZWxsKSB7XHJcbiAgICBpZiAoIWNlbGwpIHtcclxuICAgICAgICBncmFwaC5nZXRMaW5rcygpLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcclxuICAgICAgICAgICAgYWRqdXN0VmVydGljZXMoZ3JhcGgsIGxpbmspO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIElmIHRoZSBjZWxsIGlzIGEgdmlldywgZmluZCBpdHMgbW9kZWwuXHJcbiAgICBjZWxsID0gY2VsbC5tb2RlbCAmJiBjZWxsLm1vZGVsLmdldCA/IGNlbGwubW9kZWwgOiBjZWxsO1xyXG5cclxuICAgIGlmIChjZWxsIGluc3RhbmNlb2Ygam9pbnQuZGlhLkVsZW1lbnQpIHtcclxuICAgICAgICBncmFwaC5nZXRDb25uZWN0ZWRMaW5rcyhjZWxsKS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XHJcbiAgICAgICAgICAgIGFkanVzdFZlcnRpY2VzKGdyYXBoLCBsaW5rKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChjZWxsLmhpZGRlbikgcmV0dXJuO1xyXG4gICAgY2VsbC5zZXQoJ3ZlcnRpY2VzJywgW10pO1xyXG4gICAgXHJcbiAgICAvLyBUaGUgY2VsbCBpcyBhIGxpbmsuIExldCdzIGZpbmQgaXRzIHNvdXJjZSBhbmQgdGFyZ2V0IG1vZGVscy5cclxuICAgIGNvbnN0IHNyY0lkID0gY2VsbC5nZXQoJ3NvdXJjZScpLmlkIHx8IGNlbGwucHJldmlvdXMoJ3NvdXJjZScpLmlkO1xyXG4gICAgY29uc3QgdHJnSWQgPSBjZWxsLmdldCgndGFyZ2V0JykuaWQgfHwgY2VsbC5wcmV2aW91cygndGFyZ2V0JykuaWQ7XHJcbiAgICBjb25zdCBzcmNQb3J0ID0gY2VsbC5nZXQoJ3NvdXJjZScpLnBvcnQgfHwgY2VsbC5wcmV2aW91cygnc291cmNlJykucG9ydDtcclxuICAgIGNvbnN0IHRyZ1BvcnQgPSBjZWxsLmdldCgndGFyZ2V0JykucG9ydCB8fCBjZWxsLnByZXZpb3VzKCd0YXJnZXQnKS5wb3J0O1xyXG5cclxuICAgIC8vIElmIG9uZSBvZiB0aGUgZW5kcyBpcyBub3QgYSBtb2RlbCwgdGhlIGxpbmsgaGFzIG5vIHNpYmxpbmdzLlxyXG4gICAgaWYgKCFzcmNJZCB8fCAhdHJnSWQpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBzaWJsaW5ncyA9IGdyYXBoLmdldExpbmtzKCkuZmlsdGVyKHNpYmxpbmcgPT4ge1xyXG4gICAgICAgIGlmIChzaWJsaW5nLmhpZGRlbikgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IF9zcmNJZCA9IHNpYmxpbmcuZ2V0KCdzb3VyY2UnKS5pZDtcclxuICAgICAgICBjb25zdCBfdHJnSWQgPSBzaWJsaW5nLmdldCgndGFyZ2V0JykuaWQ7XHJcbiAgICAgICAgY29uc3QgX3NyY1BvcnQgPSBzaWJsaW5nLmdldCgnc291cmNlJykucG9ydDtcclxuICAgICAgICBjb25zdCBfdHJnUG9ydCA9IHNpYmxpbmcuZ2V0KCd0YXJnZXQnKS5wb3J0O1xyXG5cclxuICAgICAgICBjb25zdCBzYW1lRW5kc1NhbWVEaXJlY3Rpb24gPSBfc3JjSWQgPT09IHNyY0lkICYmIF90cmdJZCA9PT0gdHJnSWQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3JjUG9ydCA9PT0gc3JjUG9ydCAmJiBfdHJnUG9ydCA9PT0gdHJnUG9ydDtcclxuICAgICAgICBjb25zdCBzYW1lRW5kc1NhbWVPcHBvc2l0ZURpcmVjdGlvbiA9IF9zcmNJZCA9PT0gdHJnSWQgJiYgX3RyZ0lkID09PSBzcmNJZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zcmNQb3J0ID09PSB0cmdQb3J0ICYmIF90cmdQb3J0ID09PSBzcmNQb3J0O1xyXG4gICAgICAgIHJldHVybiAoc2FtZUVuZHNTYW1lRGlyZWN0aW9uKSB8fCAoc2FtZUVuZHNTYW1lT3Bwb3NpdGVEaXJlY3Rpb24pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgc3dpdGNoIChzaWJsaW5ncy5sZW5ndGgpIHtcclxuICAgIGNhc2UgMDpcclxuICAgIGNhc2UgMTpcclxuICAgICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAvLyBUaGVyZSBpcyBtb3JlIHRoYW4gb25lIHNpYmxpbmdzLiBXZSBuZWVkIHRvIGNyZWF0ZSB2ZXJ0aWNlcy5cclxuICAgICAgICAvLyBGaXJzdCBvZiBhbGwgd2UnbGwgZmluZCB0aGUgbWlkZGxlIHBvaW50IG9mIHRoZSBsaW5rLlxyXG4gICAgICAgIGNvbnN0IHNyY0NlbGwgPSBncmFwaC5nZXRDZWxsKHNyY0lkKTtcclxuICAgICAgICBjb25zdCBzcmNQb3NpdGlvbiA9IHNyY0NlbGwucG9zaXRpb24oKTtcclxuICAgICAgICBjb25zdCBzcmNQb3J0ID0gc3JjQ2VsbC5hdHRyKCcuJyArIGNlbGwuZ2V0KCdzb3VyY2UnKS5wb3J0KTtcclxuICAgICAgICBpZiAoIXNyY1BvcnQpIHJldHVybjtcclxuICAgICAgICBjb25zdCBzcmNQb3J0UG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgIHg6IHNyY1BvcnRbJ3JlZi14J10gKyBzcmNQb3NpdGlvbi54LFxyXG4gICAgICAgICAgICB5OiBzcmNQb3J0WydyZWYteSddICsgc3JjUG9zaXRpb24ueSxcclxuICAgICAgICAgICAgdGhldGE6IGpvaW50LmcucG9pbnQucHJvdG90eXBlLnRoZXRhLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgdHJnQ2VsbCA9IGdyYXBoLmdldENlbGwodHJnSWQpO1xyXG4gICAgICAgIGNvbnN0IHRyZ1Bvc2l0aW9uID0gdHJnQ2VsbC5wb3NpdGlvbigpO1xyXG4gICAgICAgIGNvbnN0IHRyZ1BvcnQgPSB0cmdDZWxsLmF0dHIoJy4nICsgY2VsbC5nZXQoJ3RhcmdldCcpLnBvcnQpO1xyXG4gICAgICAgIGlmICghdHJnUG9ydCkgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IHRyZ1BvcnRQb3NpdGlvbiA9IHtcclxuICAgICAgICAgICAgeDogdHJnUG9ydFsncmVmLXgnXSArIHRyZ1Bvc2l0aW9uLngsXHJcbiAgICAgICAgICAgIHk6IHRyZ1BvcnRbJ3JlZi15J10gKyB0cmdQb3NpdGlvbi55LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgbWlkUG9pbnQgPSBqb2ludC5nLmxpbmUoc3JjUG9ydFBvc2l0aW9uLCB0cmdQb3J0UG9zaXRpb24pLm1pZHBvaW50KCk7XHJcblxyXG4gICAgICAgIC8vIFRoZW4gZmluZCB0aGUgYW5nbGUgaXQgZm9ybXMuXHJcbiAgICAgICAgY29uc3QgdGhldGEgPSBzcmNQb3J0UG9zaXRpb24udGhldGEodHJnUG9ydFBvc2l0aW9uKTtcclxuICAgICAgICBjb25zdCBjZWxsSW5kZXggPSBzaWJsaW5ncy5pbmRleE9mKGNlbGwpO1xyXG5cclxuICAgICAgICAvLyBXZSB3YW50IHRoZSBvZmZzZXQgdmFsdWVzIHRvIGJlIGNhbGN1bGF0ZWQgYXMgZm9sbG93cyAwLCAyMCwgMjAsIDQwLCA0MCwgNjAsIDYwIC4uXHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gR0FQICogTWF0aC5jZWlsKChjZWxsSW5kZXggKyAoc2libGluZ3MubGVuZ3RoICUgMiA9PT0gMCA/IDEgOiAwKSkgLyAyKTtcclxuXHJcbiAgICAgICAgLy8gTm93IHdlIG5lZWQgdGhlIHZlcnRpY2VzIHRvIGJlIHBsYWNlZCBhdCBwb2ludHMgd2hpY2ggYXJlICdvZmZzZXQnIHBpeGVscyBkaXN0YW50XHJcbiAgICAgICAgLy8gZnJvbSB0aGUgZmlyc3QgbGluayBhbmQgZm9ybXMgYSBwZXJwZW5kaWN1bGFyIGFuZ2xlIHRvIGl0LiBBbmQgYXMgaW5kZXggZ29lcyB1cFxyXG4gICAgICAgIC8vIGFsdGVybmF0ZSBsZWZ0IGFuZCByaWdodC5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICBeICBvZGQgaW5kZXhlcyBcclxuICAgICAgICAvLyAgfFxyXG4gICAgICAgIC8vICB8LS0tLT4gIGluZGV4IDAgbGluZSAoc3RyYWlnaHQgbGluZSBiZXR3ZWVuIGEgc291cmNlIGNlbnRlciBhbmQgYSB0YXJnZXQgY2VudGVyLlxyXG4gICAgICAgIC8vICB8XHJcbiAgICAgICAgLy8gIHYgIGV2ZW4gaW5kZXhlc1xyXG4gICAgICAgIGNvbnN0IHNpZ24gPSBjZWxsSW5kZXggJSAyID8gMSA6IC0xO1xyXG4gICAgICAgIGNvbnN0IGFuZ2xlID0gam9pbnQuZy50b1JhZCh0aGV0YSArIHNpZ24gKiA5MCk7XHJcblxyXG4gICAgICAgIC8vIFdlIGZvdW5kIHRoZSB2ZXJ0ZXguXHJcbiAgICAgICAgY29uc3QgdmVydGV4ID0gam9pbnQuZy5wb2ludC5mcm9tUG9sYXIob2Zmc2V0LCBhbmdsZSwgbWlkUG9pbnQpO1xyXG5cclxuICAgICAgICBjZWxsLnNldCgndmVydGljZXMnLCBbeyB4OiB2ZXJ0ZXgueCwgeTogdmVydGV4LnkgfV0pO1xyXG4gICAgfX1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhdGggKHNlbGVjdGVkRWxlbWVudCwgZGF0YUNvbnRhaW5lcikge1xyXG4gICAgY29uc3Qgc291cmNlTWFwID0gZGF0YUNvbnRhaW5lci5tYXBzLnNvdXJjZU1hcDtcclxuICAgIGNvbnN0IHRhcmdldE1hcCA9IGRhdGFDb250YWluZXIubWFwcy50YXJnZXRNYXA7XHJcbiAgICBjb25zdCBub2RlTWFwID0gZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXA7XHJcblxyXG4gICAgY29uc3QgcGF0aE5vZGVzID0ge307XHJcbiAgICBjb25zdCBwYXRoTGlua3NXZXN0ID0ge307XHJcbiAgICBjb25zdCBwYXRoTGlua3NFYXN0ID0ge307XHJcblxyXG4gICAgaWYgKG5vZGVNYXBbc2VsZWN0ZWRFbGVtZW50LmlkXSkge1xyXG4gICAgICAgIHNlbGVjdE5vZGUgKHNlbGVjdGVkRWxlbWVudCwgdHJ1ZSk7XHJcbiAgICAgICAgc2VsZWN0Tm9kZSAoc2VsZWN0ZWRFbGVtZW50LCBmYWxzZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhdGhMaW5rc1dlc3Rbc2VsZWN0ZWRFbGVtZW50LmlkXSA9IHNlbGVjdGVkRWxlbWVudDtcclxuICAgICAgICBwYXRoTGlua3NFYXN0W3NlbGVjdGVkRWxlbWVudC5pZF0gPSBzZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICAgICAgc2VsZWN0Tm9kZSAobm9kZU1hcFtzZWxlY3RlZEVsZW1lbnQubW9kZWwudGFyZ2V0XSwgdHJ1ZSk7XHJcbiAgICAgICAgc2VsZWN0Tm9kZSAobm9kZU1hcFtzZWxlY3RlZEVsZW1lbnQubW9kZWwuc291cmNlXSwgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNlbGVjdE5vZGUgKGN1ck5vZGUsIGRpcmVjdGlvbikge1xyXG4gICAgICAgIHBhdGhOb2Rlc1tjdXJOb2RlLmlkXSA9IGN1ck5vZGU7XHJcbiAgICAgICAgY3VyTm9kZS5hc3BlY3RzLmZvckVhY2goYXNwZWN0ID0+IHBhdGhOb2Rlc1thc3BlY3QuaWRdID0gYXNwZWN0KTtcclxuICAgICAgICBjb25zdCBsaW5rcyA9IGRpcmVjdGlvbiA/IHRhcmdldE1hcFtjdXJOb2RlLmlkXSA6IHNvdXJjZU1hcFtjdXJOb2RlLmlkXTtcclxuICAgICAgICBpZiAobGlua3MpIHtcclxuICAgICAgICAgICAgbGlua3MuZm9yRWFjaCAobGluayA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgIXBhdGhMaW5rc0Vhc3RbbGluay5pZF0gJiYgZGlyZWN0aW9uIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIXBhdGhMaW5rc1dlc3RbbGluay5pZF0gJiYgIWRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoTGlua3NFYXN0W2xpbmsuaWRdID0gbGluaztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoTGlua3NXZXN0W2xpbmsuaWRdID0gbGluaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0Tm9kZShub2RlTWFwW2RpcmVjdGlvbiA/IGxpbmsubW9kZWwudGFyZ2V0IDogbGluay5tb2RlbC5zb3VyY2VdLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIF8ubWVyZ2UocGF0aExpbmtzRWFzdCwgcGF0aExpbmtzV2VzdCwgcGF0aE5vZGVzKTtcclxufSIsImltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBSZXR1cm5zIGxpbWl0dGVkIGJ5IGJvdW5kcyBwb2ludCB2YWx1ZVxyXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludCBcclxuICogQHBhcmFtIHtCb3VuZHN9IGJvdW5kcyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsaW1pdFBvaW50UG9zaXRpb24gKHBvaW50LCBib3VuZHMpIHtcclxuICAgIGlmICghYm91bmRzKSByZXR1cm4gcG9pbnQ7XHJcbiAgICBcclxuICAgIGNvbnN0IHggPSBNYXRoLm1heChcclxuICAgICAgICBNYXRoLm1pbihcclxuICAgICAgICAgICAgcG9pbnQueCxcclxuICAgICAgICAgICAgYm91bmRzLm1heFgsXHJcbiAgICAgICAgKSxcclxuICAgICAgICBib3VuZHMubWluWCxcclxuICAgICk7XHJcbiAgICBjb25zdCB5ID0gTWF0aC5tYXgoXHJcbiAgICAgICAgTWF0aC5taW4oXHJcbiAgICAgICAgICAgIHBvaW50LnksXHJcbiAgICAgICAgICAgIGJvdW5kcy5tYXhZLFxyXG4gICAgICAgICksXHJcbiAgICAgICAgYm91bmRzLm1pblksXHJcbiAgICApO1xyXG4gICAgXHJcbiAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XHJcbn1cclxuXHJcbi8vIGdsb2JhbCA9IHtcclxuLy8gICAgIHg6IDEsXHJcbi8vICAgICB5OiAxLFxyXG4vLyB9XHJcbi8vIHNjYWxlZCA9IHtcclxuLy8gICAgIHg6IGdsb2JhbC54ICogc2NhbGUsXHJcbi8vICAgICB5OiBnbG9iYWwueSAqIHNjYWxlLFxyXG4vLyB9XHJcbi8vIGxvY2FsID0ge1xyXG4vLyAgICAgeDogc2NhbGVkLnggKyB2aWV3RnJhbWVTY2FsZWRQb3MueCAtIHZpZXdGcmFtZVZpZXdQb3J0UG9zaXRpb24ueCxcclxuLy8gICAgIHk6IHNjYWxlZC55ICsgdmlld0ZyYW1lU2NhbGVkUG9zLnkgLSB2aWV3RnJhbWVWaWV3UG9ydFBvc2l0aW9uLnksXHJcbi8vIH1cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGVkVmlld0ZyYW1lUG9zaXRpb24gKHZpZXdGcmFtZSkge1xyXG4gICAgaWYgKHZpZXdGcmFtZS5wb3NpdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdGcmFtZS5wb3NpdGlvbigpO1xyXG4gICAgfSBlbHNlIGlmICh2aWV3RnJhbWUucG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdmlld0ZyYW1lLnBvc2l0aW9uO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBwYXJhbWV0ZXIhJyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRHbG9iYWxWaWV3UG9ydFBvc2l0aW9uICh2aWV3RnJhbWUpIHtcclxuICAgIGlmICh2aWV3RnJhbWUucG9zaXRpb25WaWV3UG9ydCkge1xyXG4gICAgICAgIHJldHVybiB2aWV3RnJhbWUucG9zaXRpb25WaWV3UG9ydCgpO1xyXG4gICAgfSBlbHNlIGlmICh2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbikge1xyXG4gICAgICAgIHJldHVybiB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgcGFyYW1ldGVyIScpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uIChub2RlKSB7XHJcbiAgICByZXR1cm4gXy5jbG9uZShub2RlLm1vZGVsLnBvc2l0aW9uKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjYWxlZE5vZGVQb3NpdGlvbiAobm9kZSwgc2NhbGUpIHtcclxuICAgIGlmICghc2NhbGUpIHRocm93IG5ldyBFcnJvcignU2NhbGUgaXMgdW5kZWZpbmVkIScpO1xyXG5cclxuICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKG5vZGUpO1xyXG4gICAgcmV0dXJuIGdsb2JhbFRvU2NhbGVkUG9pbnQocG9zaXRpb24sIHNjYWxlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2FsTm9kZVBvc2l0aW9uIChub2RlLCBzY2FsZSwgdmlld0ZyYW1lKSB7XHJcbiAgICBpZiAoIXNjYWxlKSB0aHJvdyBuZXcgRXJyb3IoJ1NjYWxlIGlzIHVuZGVmaW5lZCEnKTtcclxuXHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IGdldEdsb2JhbE5vZGVQb3NpdGlvbihub2RlKTtcclxuICAgIHJldHVybiBnbG9iYWxUb0xvY2FsUG9pbnQocG9zaXRpb24sIHNjYWxlLCB2aWV3RnJhbWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsTm9kZVNpemUgKG5vZGUsIHNjYWxlKSB7XHJcbiAgICBjb25zdCBzY2FsZWRTaXplID0gZ2V0U2NhbGVkTm9kZVNpemUobm9kZSk7XHJcblxyXG4gICAgcmV0dXJuIHNjYWxlZFRvR2xvYmFsU2l6ZShzY2FsZWRTaXplLCBzY2FsZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2FsZWROb2RlU2l6ZSAobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUuZ2V0KCdzaXplJyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnbG9iYWxUb1NjYWxlZFBvaW50IChwb2ludCwgc2NhbGUpIHtcclxuICAgIGlmICghc2NhbGUpIHRocm93IG5ldyBFcnJvcignU2NhbGUgaXMgdW5kZWZpbmVkIScpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogcG9pbnQueCAqIHNjYWxlLngsXHJcbiAgICAgICAgeTogcG9pbnQueSAqIHNjYWxlLnksXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVkVG9HbG9iYWxQb2ludCAocG9pbnQsIHNjYWxlKSB7XHJcbiAgICBpZiAoIXNjYWxlKSB0aHJvdyBuZXcgRXJyb3IoJ1NjYWxlIGlzIHVuZGVmaW5lZCEnKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHBvaW50LnggLyBzY2FsZS54LFxyXG4gICAgICAgIHk6IHBvaW50LnkgLyBzY2FsZS55LFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdsb2JhbFRvTG9jYWxQb2ludCAocG9pbnQsIHNjYWxlLCB2aWV3RnJhbWUpIHtcclxuICAgIGlmICghc2NhbGUpIHRocm93IG5ldyBFcnJvcignU2NhbGUgaXMgdW5kZWZpbmVkIScpO1xyXG4gICAgY29uc3Qgc2NhbGVkUG9pbnQgPSBnbG9iYWxUb1NjYWxlZFBvaW50KHBvaW50LCBzY2FsZSk7XHJcblxyXG4gICAgcmV0dXJuIHNjYWxlZFRvTG9jYWxQb2ludChzY2FsZWRQb2ludCwgc2NhbGUsIHZpZXdGcmFtZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsb2NhbFRvR2xvYmFsUG9pbnQgKHBvaW50LCBzY2FsZSwgdmlld0ZyYW1lKSB7XHJcbiAgICBpZiAoIXNjYWxlKSB0aHJvdyBuZXcgRXJyb3IoJ1NjYWxlIGlzIHVuZGVmaW5lZCEnKTtcclxuICAgIGNvbnN0IHNjYWxlZFBvaW50ID0gbG9jYWxUb1NjYWxlZFBvaW50KHBvaW50LCBzY2FsZSwgdmlld0ZyYW1lKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHNjYWxlZFRvR2xvYmFsUG9pbnQoc2NhbGVkUG9pbnQsIHNjYWxlLCB2aWV3RnJhbWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxUb1NjYWxlZFBvaW50IChwb2ludCwgc2NhbGUsIHZpZXdGcmFtZSkge1xyXG4gICAgaWYgKCFzY2FsZSkgdGhyb3cgbmV3IEVycm9yKCdTY2FsZSBpcyB1bmRlZmluZWQhJyk7XHJcblxyXG4gICAgY29uc3Qgc2NhbGVkVmlld0ZyYW1lT2Zmc2V0ID0gZ2V0U2NhbGVkVmlld0ZyYW1lUG9zaXRpb24odmlld0ZyYW1lKTtcclxuICAgIGNvbnN0IGdsb2JhbFZpZXdQb3J0T2Zmc2V0ID0gZ2V0R2xvYmFsVmlld1BvcnRQb3NpdGlvbih2aWV3RnJhbWUpO1xyXG4gICAgY29uc3Qgc2NhbGVkVmlld1BvcnRPZmZzZXQgPSBnbG9iYWxUb1NjYWxlZFBvaW50KGdsb2JhbFZpZXdQb3J0T2Zmc2V0LCBzY2FsZSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBwb2ludC54IC0gc2NhbGVkVmlld0ZyYW1lT2Zmc2V0LnggKyBzY2FsZWRWaWV3UG9ydE9mZnNldC54LFxyXG4gICAgICAgIHk6IHBvaW50LnkgLSBzY2FsZWRWaWV3RnJhbWVPZmZzZXQueSArIHNjYWxlZFZpZXdQb3J0T2Zmc2V0LnksXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVkVG9Mb2NhbFBvaW50IChwb2ludCwgc2NhbGUsIHZpZXdGcmFtZSkge1xyXG4gICAgaWYgKCFzY2FsZSkgdGhyb3cgbmV3IEVycm9yKCdTY2FsZSBpcyB1bmRlZmluZWQhJyk7XHJcblxyXG4gICAgY29uc3Qgc2NhbGVkVmlld0ZyYW1lT2Zmc2V0ID0gZ2V0U2NhbGVkVmlld0ZyYW1lUG9zaXRpb24odmlld0ZyYW1lKTtcclxuICAgIGNvbnN0IGdsb2JhbFZpZXdQb3J0T2Zmc2V0ID0gZ2V0R2xvYmFsVmlld1BvcnRQb3NpdGlvbih2aWV3RnJhbWUpO1xyXG4gICAgY29uc3Qgc2NhbGVkVmlld1BvcnRPZmZzZXQgPSBnbG9iYWxUb1NjYWxlZFBvaW50KGdsb2JhbFZpZXdQb3J0T2Zmc2V0LCBzY2FsZSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBwb2ludC54ICsgc2NhbGVkVmlld0ZyYW1lT2Zmc2V0LnggLSBzY2FsZWRWaWV3UG9ydE9mZnNldC54LFxyXG4gICAgICAgIHk6IHBvaW50LnkgKyBzY2FsZWRWaWV3RnJhbWVPZmZzZXQueSAtIHNjYWxlZFZpZXdQb3J0T2Zmc2V0LnksXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2xvYmFsVG9TY2FsZWRTaXplIChzaXplLCBzY2FsZSkge1xyXG4gICAgaWYgKCFzY2FsZSkgdGhyb3cgbmV3IEVycm9yKCdTY2FsZSBpcyB1bmRlZmluZWQhJyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHdpZHRoOiBzaXplLndpZHRoICogc2NhbGUueCxcclxuICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0ICogc2NhbGUueSxcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzY2FsZWRUb0dsb2JhbFNpemUgKHNpemUsIHNjYWxlKSB7XHJcbiAgICBpZiAoIXNjYWxlKSB0aHJvdyBuZXcgRXJyb3IoJ1NjYWxlIGlzIHVuZGVmaW5lZCEnKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgd2lkdGg6IHNpemUud2lkdGggLyBzY2FsZS54LFxyXG4gICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQgLyBzY2FsZS55LFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdsb2JhbFRvU2NhbGVkQm91bmRzIChib3VuZHMsIHNjYWxlKSB7XHJcbiAgICBjb25zdCBzY2FsZWRNaW5Qb3NpdGlvbiA9IGdsb2JhbFRvU2NhbGVkUG9pbnQoeyB4OiBib3VuZHMubWluWCwgeTogYm91bmRzLm1pblkgfSwgc2NhbGUpO1xyXG4gICAgY29uc3Qgc2NhbGVkTWF4UG9zaXRpb24gPSBnbG9iYWxUb1NjYWxlZFBvaW50KHsgeDogYm91bmRzLm1heFgsIHk6IGJvdW5kcy5tYXhZIH0sIHNjYWxlKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWluWDogc2NhbGVkTWluUG9zaXRpb24ueCxcclxuICAgICAgICBtYXhYOiBzY2FsZWRNYXhQb3NpdGlvbi54LFxyXG4gICAgICAgIG1pblk6IHNjYWxlZE1pblBvc2l0aW9uLnksXHJcbiAgICAgICAgbWF4WTogc2NhbGVkTWF4UG9zaXRpb24ueSxcclxuICAgICAgICB3aWR0aDogc2NhbGVkTWF4UG9zaXRpb24ueCAtIHNjYWxlZE1pblBvc2l0aW9uLngsXHJcbiAgICAgICAgaGVpZ2h0OiBzY2FsZWRNYXhQb3NpdGlvbi55IC0gc2NhbGVkTWluUG9zaXRpb24ueSxcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzY2FsZWRUb0dsb2JhbEJvdW5kcyAoYm91bmRzLCBzY2FsZSkge1xyXG4gICAgY29uc3Qgc2NhbGVkTWluUG9zaXRpb24gPSBzY2FsZWRUb0dsb2JhbFBvaW50KHsgeDogYm91bmRzLm1pblgsIHk6IGJvdW5kcy5taW5ZIH0sIHNjYWxlKTtcclxuICAgIGNvbnN0IHNjYWxlZE1heFBvc2l0aW9uID0gc2NhbGVkVG9HbG9iYWxQb2ludCh7IHg6IGJvdW5kcy5tYXhYLCB5OiBib3VuZHMubWF4WSB9LCBzY2FsZSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1pblg6IHNjYWxlZE1pblBvc2l0aW9uLngsXHJcbiAgICAgICAgbWF4WDogc2NhbGVkTWF4UG9zaXRpb24ueCxcclxuICAgICAgICBtaW5ZOiBzY2FsZWRNaW5Qb3NpdGlvbi55LFxyXG4gICAgICAgIG1heFk6IHNjYWxlZE1heFBvc2l0aW9uLnksXHJcbiAgICAgICAgd2lkdGg6IHNjYWxlZE1heFBvc2l0aW9uLnggLSBzY2FsZWRNaW5Qb3NpdGlvbi54LFxyXG4gICAgICAgIGhlaWdodDogc2NhbGVkTWF4UG9zaXRpb24ueSAtIHNjYWxlZE1pblBvc2l0aW9uLnksXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2hyaW5rQm91bmRzIChib3VuZHMsIHBhZGRpbmdSZWN0YW5nbGUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWluWDogYm91bmRzLm1pblggKyBwYWRkaW5nUmVjdGFuZ2xlLngsXHJcbiAgICAgICAgbWF4WDogYm91bmRzLm1heFggLSBwYWRkaW5nUmVjdGFuZ2xlLngsXHJcbiAgICAgICAgbWluWTogYm91bmRzLm1pblkgKyBwYWRkaW5nUmVjdGFuZ2xlLnksXHJcbiAgICAgICAgbWF4WTogYm91bmRzLm1heFkgLSBwYWRkaW5nUmVjdGFuZ2xlLnksXHJcbiAgICAgICAgd2lkdGg6IGJvdW5kcy5tYXhYIC0gYm91bmRzLm1pblggLSBwYWRkaW5nUmVjdGFuZ2xlLnggKiAyLFxyXG4gICAgICAgIGhlaWdodDogYm91bmRzLm1heFkgLSBib3VuZHMubWluWSAtIHBhZGRpbmdSZWN0YW5nbGUueSAqIDIsXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kQm91bmRzIChib3VuZHMsIGV4dGVuZEJ5KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1pblg6IGJvdW5kcy5taW5YIC0gZXh0ZW5kQnkueCxcclxuICAgICAgICBtYXhYOiBib3VuZHMubWF4WCArIGV4dGVuZEJ5LngsXHJcbiAgICAgICAgbWluWTogYm91bmRzLm1pblkgLSBleHRlbmRCeS55LFxyXG4gICAgICAgIG1heFk6IGJvdW5kcy5tYXhZICsgZXh0ZW5kQnkueSxcclxuICAgICAgICB3aWR0aDogYm91bmRzLm1heFggKyBleHRlbmRCeS54ICogMiAtIGJvdW5kcy5taW5YLFxyXG4gICAgICAgIGhlaWdodDogYm91bmRzLm1heFkgKyBleHRlbmRCeS55ICogMiAtIGJvdW5kcy5taW5ZLFxyXG4gICAgfTtcclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnRTaXplIChyb290SWQpIHtcclxuICAgIGNvbnN0IHBhcGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocm9vdElkKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgd2lkdGg6IHBhcGVyLmNsaWVudFdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogcGFwZXIuY2xpZW50SGVpZ2h0LFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5VG9NYXAgKGFycmF5LCB1c2VBc0lkKSB7XHJcbiAgICB1c2VBc0lkID0gdXNlQXNJZCB8fCAnaWQnO1xyXG4gICAgY29uc3QgbWFwID0ge307XHJcbiAgICBhcnJheS5mb3JFYWNoKGVsID0+IHtcclxuICAgICAgICBtYXBbZWxbdXNlQXNJZF1dID0gZWw7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBtYXA7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0FycmF5IChtYXApIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhtYXApLm1hcChrZXkgPT4gbWFwW2tleV0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzdCAocDEsIHAyKSB7XHJcbiAgICBsZXQgeDEgPSBwMS54O1xyXG4gICAgbGV0IHkxID0gcDEueTtcclxuXHJcbiAgICBsZXQgeDIgPSBwMi54O1xyXG4gICAgbGV0IHkyID0gcDIueTtcclxuXHJcbiAgICBjb25zdCBtaW5YID0gTWF0aC5taW4oeDEsIHgyKTtcclxuICAgIGNvbnN0IG1pblkgPSBNYXRoLm1pbih5MSwgeTIpO1xyXG5cclxuICAgIGlmIChtaW5YIDwgMCkge1xyXG4gICAgICAgIHgxICs9IC1taW5YO1xyXG4gICAgICAgIHgyICs9IC1taW5YO1xyXG4gICAgfVxyXG4gICAgaWYgKG1pblkgPCAwKSB7XHJcbiAgICAgICAgeTEgKz0gLW1pblk7XHJcbiAgICAgICAgeTIgKz0gLW1pblk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDIsIDIpICsgTWF0aC5wb3coeTEgLSB5MiwgMikpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlmZiAobjEsIG4yKSB7XHJcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihuMSwgbjIpO1xyXG4gICAgaWYgKG1pbiA8IDApIHtcclxuICAgICAgICBuMSArPSAtbWluO1xyXG4gICAgICAgIG4yICs9IC1taW47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWF0aC5hYnMobjIgLSBuMSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBvbkRyYWdTdGFydCAoZXZlbnQsIG1vdmVDYWxsYmFjaywgcmVsZWFzZUNhbGxiYWNrKSB7XHJcbiAgICBsZXQgc3RhcnRYID0gMDtcclxuICAgIGxldCBzdGFydFkgPSAwO1xyXG4gIFxyXG4gICAgY29uc3QgcG9pbnRQcm92aWRlciA9IGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCA/IGV2ZW50IDogZXZlbnQudG91Y2hlc1swXTtcclxuICBcclxuICAgIGlmIChwb2ludFByb3ZpZGVyLnBhZ2VYKSBzdGFydFggPSBwb2ludFByb3ZpZGVyLnBhZ2VYO1xyXG4gICAgZWxzZSBpZiAocG9pbnRQcm92aWRlci5jbGllbnRYKSBzdGFydFggPSBwb2ludFByb3ZpZGVyLmNsaWVudFg7XHJcbiAgXHJcbiAgICBpZiAocG9pbnRQcm92aWRlci5wYWdlWSkgc3RhcnRZID0gcG9pbnRQcm92aWRlci5wYWdlWTtcclxuICAgIGVsc2UgaWYgKHBvaW50UHJvdmlkZXIuY2xpZW50WSkgc3RhcnRZID0gcG9pbnRQcm92aWRlci5jbGllbnRZO1xyXG4gIFxyXG4gICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xyXG4gIFxyXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfb25jaGFuZ2UpO1xyXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX29uZW5kKTtcclxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX29uY2hhbmdlKTtcclxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfb25lbmQpO1xyXG4gIFxyXG4gICAgZnVuY3Rpb24gX29uY2hhbmdlIChldmVudCkge1xyXG4gICAgICAgIGNvbnN0IHBvaW50UHJvdmlkZXIgPSBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBldmVudCA6IGV2ZW50LnRvdWNoZXNbMF07XHJcbiAgXHJcbiAgICAgICAgbGV0IGVuZFggPSAwO1xyXG4gICAgICAgIGlmIChwb2ludFByb3ZpZGVyLnBhZ2VYKSBlbmRYID0gcG9pbnRQcm92aWRlci5wYWdlWDtcclxuICAgICAgICBlbHNlIGlmIChwb2ludFByb3ZpZGVyLmNsaWVudFgpIGVuZFggPSBwb2ludFByb3ZpZGVyLmNsaWVudFg7XHJcbiAgXHJcbiAgICAgICAgY29uc3QgZGlmZlggPSBlbmRYIC0gc3RhcnRYO1xyXG4gICAgICAgIHN0YXJ0WCA9IGVuZFg7XHJcbiAgXHJcbiAgICAgICAgbGV0IGVuZFkgPSAwO1xyXG4gICAgICAgIGlmIChwb2ludFByb3ZpZGVyLnBhZ2VZKSBlbmRZID0gcG9pbnRQcm92aWRlci5wYWdlWTtcclxuICAgICAgICBlbHNlIGlmIChwb2ludFByb3ZpZGVyLmNsaWVudFkpIGVuZFkgPSBwb2ludFByb3ZpZGVyLmNsaWVudFk7XHJcbiAgXHJcbiAgICAgICAgY29uc3QgZGlmZlkgPSBlbmRZIC0gc3RhcnRZO1xyXG4gICAgICAgIHN0YXJ0WSA9IGVuZFk7XHJcbiAgXHJcbiAgICAgICAgbW92ZUNhbGxiYWNrKHsgeDogZGlmZlgsIHk6IGRpZmZZLCB9KTtcclxuICAgIH1cclxuICBcclxuICAgIGZ1bmN0aW9uIF9vbmVuZCAoKSB7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5vbm1vdXNlbW92ZSA9IGRvY3VtZW50LmJvZHkub25tb3VzZXVwID0gbnVsbDtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF9vbmNoYW5nZSk7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX29uZW5kKTtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF9vbmNoYW5nZSk7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF9vbmVuZCk7XHJcbiAgICAgICAgaWYgKHJlbGVhc2VDYWxsYmFjaykgcmVsZWFzZUNhbGxiYWNrKCk7XHJcbiAgICB9XHJcbiAgfSJdfQ==
