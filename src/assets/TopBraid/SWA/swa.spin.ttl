# baseURI: http://topbraid.org/swa.spin
# imports: http://datashapes.org/dash
# imports: http://spinrdf.org/spl
# imports: http://uispin.org/ui

@prefix afn: <http://jena.hpl.hp.com/ARQ/function#> .
@prefix arg: <http://spinrdf.org/arg#> .
@prefix dash: <http://datashapes.org/dash#> .
@prefix fn: <http://www.w3.org/2005/xpath-functions#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix spif: <http://spinrdf.org/spif#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix spl: <http://spinrdf.org/spl#> .
@prefix swa: <http://topbraid.org/swa#> .
@prefix tosh: <http://topbraid.org/tosh#> .
@prefix ui: <http://uispin.org/ui#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

arg:appName
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:class
  rdf:type rdf:Property ;
  rdfs:label "class" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:component
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:datatype
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:focusNode
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:graph
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:index
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:lang
  rdf:type rdf:Property ;
  rdfs:label "lang" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:letter
  rdf:type rdf:Property ;
  rdfs:label "letter" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:module
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:node
  rdf:type rdf:Property ;
  rdfs:label "node" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:object
  rdf:type rdf:Property ;
  rdfs:label "object" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:parameter
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:predicate
  rdf:type rdf:Property ;
  rdfs:label "predicate" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:property
  rdf:type rdf:Property ;
  rdfs:label "property" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:propertyShape
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:range
  rdf:type rdf:Property ;
  rdfs:label "range" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:regex
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resource
  rdf:type rdf:Property ;
  rdfs:label "resource" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceGraph
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceType
  rdf:type rdf:Property ;
  rdfs:label "resource type" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:shape
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:shapeOrConstraint
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:string
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:subString
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:subject
  rdf:type rdf:Property ;
  rdfs:label "subject" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:text
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:url
  rdf:type rdf:Property ;
  rdfs:label "url" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:valueType
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:valueTypeGraph
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:zindex
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
swa:CategoryFunctions
  rdf:type spin:Function ;
  spin:abstract "true"^^xsd:boolean ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to categorize." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Abstract base class of categorization functions (used by swa:AutoComplete)." ;
  rdfs:label "Category functions" ;
  rdfs:subClassOf swa:Functions ;
.
swa:ClassAxiomProperty
  rdf:type rdfs:Class ;
  rdfs:comment "A marker type to distinguish class axiom properties from others." ;
  rdfs:label "Class axiom property" ;
  rdfs:subClassOf rdf:Property ;
.
swa:ClassFunctorFunctions
  rdf:type spin:Function ;
  spin:abstract "true"^^xsd:boolean ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to start traversal at." ;
    ] ;
  rdfs:comment "Abstract superclass that groups together various functors on classes." ;
  rdfs:label "Class functor functions" ;
  rdfs:subClassOf swa:Functions ;
.
swa:Country
  rdf:type rdfs:Class ;
  rdfs:comment "A class that is used to link languages with locales (countries). The library contains instances for the most frequently needed countries." ;
  rdfs:label "Country" ;
.
swa:Country-al
  rdf:type swa:Country ;
  swa:countryCode "al" ;
  swa:languageCode "sq" ;
.
swa:Country-bg
  rdf:type swa:Country ;
  swa:countryCode "bg" ;
  swa:languageCode "bg" ;
.
swa:Country-by
  rdf:type swa:Country ;
  swa:countryCode "by" ;
  swa:languageCode "be" ;
.
swa:Country-cn
  rdf:type swa:Country ;
  swa:countryCode "cn" ;
  swa:languageCode "zh" ;
.
swa:Country-cz
  rdf:type swa:Country ;
  swa:countryCode "cz" ;
  swa:languageCode "cs" ;
.
swa:Country-de
  rdf:type swa:Country ;
  swa:countryCode "de" ;
  swa:languageCode "de" ;
.
swa:Country-dk
  rdf:type swa:Country ;
  swa:countryCode "dk" ;
  swa:languageCode "da" ;
.
swa:Country-ee
  rdf:type swa:Country ;
  swa:countryCode "ee" ;
  swa:languageCode "et" ;
.
swa:Country-es
  rdf:type swa:Country ;
  swa:countryCode "es" ;
  swa:languageCode "ca" ;
  swa:languageCode "es" ;
.
swa:Country-fi
  rdf:type swa:Country ;
  swa:countryCode "fi" ;
  swa:languageCode "fi" ;
.
swa:Country-fr
  rdf:type swa:Country ;
  swa:countryCode "fr" ;
  swa:languageCode "fr" ;
.
swa:Country-gb
  rdf:type swa:Country ;
  swa:countryCode "gb" ;
  swa:languageCode "en" ;
.
swa:Country-gr
  rdf:type swa:Country ;
  swa:countryCode "gr" ;
  swa:languageCode "el" ;
.
swa:Country-hr
  rdf:type swa:Country ;
  swa:countryCode "hr" ;
  swa:languageCode "hr" ;
.
swa:Country-hu
  rdf:type swa:Country ;
  swa:countryCode "hu" ;
  swa:languageCode "hu" ;
.
swa:Country-id
  rdf:type swa:Country ;
  swa:countryCode "id" ;
  swa:languageCode "in" ;
.
swa:Country-ie
  rdf:type swa:Country ;
  swa:countryCode "ie" ;
  swa:languageCode "ga" ;
.
swa:Country-il
  rdf:type swa:Country ;
  swa:countryCode "il" ;
  swa:languageCode "iw" ;
.
swa:Country-in
  rdf:type swa:Country ;
  swa:countryCode "in" ;
  swa:languageCode "hi" ;
.
swa:Country-is
  rdf:type swa:Country ;
  swa:countryCode "is" ;
  swa:languageCode "is" ;
.
swa:Country-it
  rdf:type swa:Country ;
  swa:countryCode "it" ;
  swa:languageCode "it" ;
.
swa:Country-jp
  rdf:type swa:Country ;
  swa:countryCode "jp" ;
  swa:languageCode "ja" ;
.
swa:Country-kr
  rdf:type swa:Country ;
  swa:countryCode "kr" ;
  swa:languageCode "ko" ;
.
swa:Country-lt
  rdf:type swa:Country ;
  swa:countryCode "lt" ;
  swa:languageCode "lt" ;
.
swa:Country-lv
  rdf:type swa:Country ;
  swa:countryCode "lv" ;
  swa:languageCode "lv" ;
.
swa:Country-me
  rdf:type swa:Country ;
  swa:countryCode "me" ;
  swa:languageCode "sr" ;
.
swa:Country-mk
  rdf:type swa:Country ;
  swa:countryCode "mk" ;
  swa:languageCode "mk" ;
.
swa:Country-mt
  rdf:type swa:Country ;
  swa:countryCode "mt" ;
  swa:languageCode "mt" ;
.
swa:Country-my
  rdf:type swa:Country ;
  swa:countryCode "my" ;
  swa:languageCode "ms" ;
.
swa:Country-nl
  rdf:type swa:Country ;
  swa:countryCode "nl" ;
  swa:languageCode "nl" ;
.
swa:Country-no
  rdf:type swa:Country ;
  swa:countryCode "no" ;
  swa:languageCode "no" ;
.
swa:Country-pl
  rdf:type swa:Country ;
  swa:countryCode "pl" ;
  swa:languageCode "pl" ;
.
swa:Country-pt
  rdf:type swa:Country ;
  swa:countryCode "pt" ;
  swa:languageCode "pt" ;
.
swa:Country-ro
  rdf:type swa:Country ;
  swa:countryCode "ro" ;
  swa:languageCode "ro" ;
.
swa:Country-ru
  rdf:type swa:Country ;
  swa:countryCode "ru" ;
  swa:languageCode "ru" ;
.
swa:Country-sa
  rdf:type swa:Country ;
  swa:countryCode "sa" ;
  swa:languageCode "ar" ;
.
swa:Country-se
  rdf:type swa:Country ;
  swa:countryCode "se" ;
  swa:languageCode "sv" ;
.
swa:Country-si
  rdf:type swa:Country ;
  swa:countryCode "si" ;
  swa:languageCode "sl" ;
.
swa:Country-sk
  rdf:type swa:Country ;
  swa:countryCode "sk" ;
  swa:languageCode "sk" ;
.
swa:Country-th
  rdf:type swa:Country ;
  swa:countryCode "th" ;
  swa:languageCode "th" ;
.
swa:Country-tr
  rdf:type swa:Country ;
  swa:countryCode "tr" ;
  swa:languageCode "tr" ;
.
swa:Country-ua
  rdf:type swa:Country ;
  swa:countryCode "ua" ;
  swa:languageCode "uk" ;
.
swa:Country-va
  rdf:type swa:Country ;
  swa:countryCode "va" ;
  swa:languageCode "la" ;
.
swa:Country-vn
  rdf:type swa:Country ;
  swa:countryCode "vn" ;
  swa:languageCode "vi" ;
.
swa:Functions
  rdf:type spin:Function ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:comment "Just an abstract superclass to group together the various functions from this namespace in tree viewers." ;
  rdfs:label "Functions" ;
  rdfs:subClassOf spin:Functions ;
.
swa:GetLabel
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:label ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the label of." ;
    ] ;
  rdfs:comment "A simple SPIN template that can be used by Ajax clients to retrieve the ui:label of a given resource from the server." ;
  rdfs:label "Get label" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:GetRelevantPropertiesOfClass
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            sp:varName "propertyLabel" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "propertyURI" ;
          ]
          [
            sp:varName "propertyLabel" ;
          ]
          [
            sp:varName "rangeURI" ;
          ]
        ) ;
      sp:where (
          (
            [
              sp:object [
                  sp:varName "class" ;
                ] ;
              sp:predicate spl:relevantPropertyAtClass ;
              sp:subject [
                  sp:varName "property" ;
                ] ;
            ]
          )
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type xsd:string ;
                sp:arg1 [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "propertyURI" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:label ;
                sp:arg1 [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "propertyLabel" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type xsd:string ;
                sp:arg1 [
                    rdf:type swa:localRangeAtClass ;
                    arg:class [
                        sp:varName "class" ;
                      ] ;
                    arg:property [
                        sp:varName "property" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "rangeURI" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the relevant properties of." ;
    ] ;
  rdfs:comment """Gets all relevant properties for a given class. This template can be used as a web service by arbitrary web components, ideally with json-simple mime type.

Result values:

- propertyURI: the URI of the property
- propertyLabel: the display label of the property
- rangeURI: the URI of the range of the property""" ;
  rdfs:label "Get relevant properties of class" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:GetResourceValues
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            sp:varName "property" ;
          ]
          [
            sp:varName "objectLabel" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "propertyURI" ;
          ]
          [
            sp:varName "propertyLabel" ;
          ]
          [
            sp:varName "objectLabel" ;
          ]
          [
            sp:varName "objectURI" ;
          ]
          [
            sp:varName "objectDatatypeURI" ;
          ]
          [
            sp:varName "objectLang" ;
          ]
          [
            sp:varName "objectEncoded" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type xsd:string ;
                sp:arg1 [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "propertyURI" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:label ;
                sp:arg1 [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "propertyLabel" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:label ;
                sp:arg1 [
                    sp:varName "object" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "objectLabel" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:isIRI ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type xsd:string ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "none" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "objectURI" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:isLiteral ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type xsd:string ;
                    sp:arg1 [
                        rdf:type sp:datatype ;
                        sp:arg1 [
                            sp:varName "object" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "none" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "objectDatatypeURI" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:lang ;
                sp:arg1 [
                    sp:varName "object" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "objectLang" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:encodeNode ;
                sp:arg1 [
                    sp:varName "object" ;
                  ] ;
                sp:arg2 "true"^^xsd:boolean ;
                sp:arg3 "true"^^xsd:boolean ;
              ] ;
            sp:variable [
                sp:varName "objectEncoded" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get - leave empty for all properties." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the values of." ;
    ] ;
  rdfs:comment """Gets all property values (objects) for a given resource (subject). For each value, it returns information about the property and the datatype. This template can be used as a web service by arbitrary web components, ideally with json-simple mime type.

The property argument is optional: leave empty to return all properties.

Result values:

- propertyURI: the URI of the property
- propertyLabel: the display label of the property
- objectLabel: the display label of the value
- objectURI: the URI of the value, if it is a URI resource
- objectDatatypeURI: the URI of the datatype if the value is a literal
- objectLang: the language code of the datatype if the value is a string
- objectEncoded: the SPARQL-encoded serialization of the value""" ;
  rdfs:label "Get resource values" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:NumericDatatype
  rdf:type rdfs:Class ;
  rdfs:comment "A marker class for all numeric datatypes." ;
  rdfs:label "Numeric datatype" ;
  rdfs:subClassOf rdfs:Datatype ;
.
swa:PropertyAxiomProperty
  rdf:type rdfs:Class ;
  rdfs:comment "A marker type to distinguish property axiom properties from others." ;
  rdfs:label "Property axiom property" ;
  rdfs:subClassOf rdf:Property ;
.
swa:PropertyWidgetGroupFilterFunctions
  rdf:type spin:Function ;
  spin:abstract "true"^^xsd:boolean ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject resource (optional)." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to check." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Abstract superclass for the various kinds of filter functions that can be used to select properties for widget groups." ;
  rdfs:label "Property widget group filter functions" ;
  rdfs:subClassOf swa:Functions ;
.
swa:ResourcesWithLetter
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:orderBy (
          [
            rdf:type fn:lower-case ;
            sp:arg1 [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "resource" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "resourceType" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:isIRI ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:label ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type fn:starts-with ;
                sp:arg1 [
                    rdf:type fn:upper-case ;
                    sp:arg1 [
                        sp:varName "label" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    sp:varName "letter" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:letter ;
      spl:valueType xsd:string ;
      rdfs:comment "The (uppercase) letter to match." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The resource type." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:comment "Gets an ordered list of all instances of a given class that start with a given letter." ;
  rdfs:label "Resources with letter" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:ResourcesWithNonLetter
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:orderBy (
          [
            rdf:type fn:lower-case ;
            sp:arg1 [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "resource" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "resourceType" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:isIRI ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:label ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type fn:upper-case ;
                sp:arg1 [
                    rdf:type fn:substring ;
                    sp:arg1 [
                        sp:varName "label" ;
                      ] ;
                    sp:arg2 1 ;
                    sp:arg3 1 ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "first" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:not ;
                sp:arg1 [
                    rdf:type fn:contains ;
                    sp:arg1 "ABCDEFGHIJKLMNOPQRSTUVWXYZ" ;
                    sp:arg2 [
                        sp:varName "first" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resources to match (will include subclasses of the type)." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:comment "Gets an ordered list of all instances of a given type that do not start with a letter from A-Z." ;
  rdfs:label "Resources with non letter" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:TypesHaveSuperClass
  rdf:type spin:AskTemplate ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate spif:split ;
            sp:subject [
                sp:varName "uri" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "typesList" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object " " ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:iri ;
                sp:arg1 [
                    sp:varName "uri" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "type" ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "resourceType" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type to match against." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:typesList ;
      spl:valueType xsd:string ;
      rdfs:comment "The list of URIs separated by spaces containing the types to check." ;
    ] ;
  rdfs:comment "Checks whether any of the types defined in a space-separated list of URIs has a given type as its superclass." ;
  rdfs:label "Types have super class" ;
  rdfs:subClassOf spin:AskTemplates ;
.
swa:URIExistsPreCondition
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 spin:_arg1 ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:eq ;
                    sp:arg1 [
                        rdf:type fn:string-length ;
                        sp:arg1 spin:_arg1 ;
                      ] ;
                    sp:arg2 0 ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression "Missing URI." ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "Can be used in ui:preCondition to check whether a given URI exists and is not empty." ;
  rdfs:label "uri exists pre condition" ;
  rdfs:subClassOf swa:Functions ;
.
swa:ViewsContainingText
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "rootView" ;
          ]
          [
            sp:varName "element" ;
          ]
        ) ;
      sp:where (
          (
            [
              sp:object [
                  sp:varName "o" ;
                ] ;
              sp:predicate [
                  sp:varName "p" ;
                ] ;
              sp:subject [
                  sp:varName "s" ;
                ] ;
            ]
            [
              rdf:type sp:Filter ;
              sp:expression [
                  rdf:type sp:regex ;
                  sp:arg1 [
                      sp:varName "o" ;
                    ] ;
                  sp:arg2 [
                      sp:varName "regex" ;
                    ] ;
                ] ;
            ]
            [
              rdf:type sp:Filter ;
              sp:expression [
                  rdf:type spl:instanceOf ;
                  sp:arg1 [
                      sp:varName "s" ;
                    ] ;
                  sp:arg2 ui:Element ;
                ] ;
            ]
          )
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:rootView ;
                arg:view [
                    sp:varName "s" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "rootView" ;
              ] ;
          ]
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "rootView" ;
                    ] ;
                  sp:predicate ui:prototype ;
                  sp:subject [
                      sp:varName "element" ;
                    ] ;
                ]
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:regex ;
      spl:valueType xsd:string ;
      rdfs:comment "The regular expression to search for." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:comment "Finds all SWP views that contain a given regular expression. Returns the root SWP element and, if available, the named element that has this root element as its ui:prototype." ;
  rdfs:label "Views containing text" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:allValuesFromFunctor
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "allValuesFrom" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "allValuesFrom" ;
              ] ;
            sp:predicate owl:allValuesFrom ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate owl:onProperty ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to look for." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdfs:Class ;
  rdfs:comment "Can be used in conjunction with spif:walkObjects to get the \"first\" declared owl:allValuesFrom restriction of a given property (?property) at a given class (?class)." ;
  rdfs:label "all values from functor" ;
  rdfs:subClassOf swa:ClassFunctorFunctions ;
.
swa:appName
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type ui:contextValue ;
                sp:arg1 "swaAppName" ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the current SWA application name. This can be set in as context variable \"swaAppName\"." ;
  rdfs:label "app name" ;
  rdfs:subClassOf swa:Functions ;
.
swa:canEditResource
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
                sp:arg2 rdf:type ;
              ] ;
            sp:variable [
                sp:varName "type" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:bound ;
                    sp:arg1 [
                        sp:varName "type" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type swa:isReadOnlyTriple ;
                        sp:arg1 [
                            sp:varName "resource" ;
                          ] ;
                        sp:arg2 rdf:type ;
                        sp:arg3 [
                            sp:varName "type" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg3 "true"^^xsd:boolean ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to edit." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether the currently logged in user has the privilege to edit a given resource. The default implementation of this always returns true unless the rdf:type of the resource is a read-only triple, but this behavior can be overloaded for specific platforms." ;
  rdfs:label "can edit resource" ;
  rdfs:subClassOf swa:Functions ;
.
swa:categoryByNamespace
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type afn:namespace ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "ns" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:iri ;
                sp:arg1 [
                    rdf:type sp:if ;
                    sp:arg1 [
                        rdf:type sp:strends ;
                        sp:arg1 [
                            sp:varName "ns" ;
                          ] ;
                        sp:arg2 "#" ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:substr ;
                        sp:arg1 [
                            sp:varName "ns" ;
                          ] ;
                        sp:arg2 1 ;
                        sp:arg3 [
                            rdf:type sp:sub ;
                            sp:arg1 [
                                rdf:type sp:strlen ;
                                sp:arg1 [
                                    sp:varName "ns" ;
                                  ] ;
                              ] ;
                            sp:arg2 1 ;
                          ] ;
                      ] ;
                    sp:arg3 [
                        sp:varName "ns" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "graphURI" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:coalesce ;
                sp:arg1 [
                    rdf:type swa:graphLabel ;
                    arg:graph [
                        rdf:type sp:iri ;
                        sp:arg1 [
                            sp:varName "ns" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type swa:graphLabel ;
                    arg:graph [
                        sp:varName "graphURI" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    rdf:type sp:concat ;
                    sp:arg1 "<" ;
                    sp:arg2 [
                        sp:varName "ns" ;
                      ] ;
                    sp:arg3 ">" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:label "category by namespace" ;
  rdfs:subClassOf swa:CategoryFunctions ;
.
swa:columnLabel
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:where (
          (
            [
              rdf:type sp:Filter ;
              sp:expression [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "dataProvider" ;
                    ] ;
                ] ;
            ]
          )
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "column" ;
                    ] ;
                  sp:predicate spin:column ;
                  sp:subject [
                      sp:varName "dataProvider" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "index" ;
                    ] ;
                  sp:predicate spin:columnIndex ;
                  sp:subject [
                      sp:varName "column" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "label" ;
                    ] ;
                  sp:predicate rdfs:label ;
                  sp:subject [
                      sp:varName "column" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:dataProvider ;
      spl:valueType spin:TableDataProvider ;
      rdfs:comment "The data provider - may be null in which case the function returns unbound too." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:index ;
      spl:valueType xsd:integer ;
    ] ;
  rdfs:comment "Gets a column label based on a given spin:TableDataProvider. Tries to find the rdfs:label of a spin:Column with the provided index." ;
  rdfs:label "column label" ;
  rdfs:subClassOf swa:Functions ;
.
swa:configGraph
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression <http://server.topbraidlive.org/dynamic/uiconfig> ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:cachable "true"^^xsd:boolean ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the global UI config graph - <http://server.topbraidlive.org/dynamic/uiconfig>" ;
  rdfs:label "config graph" ;
  rdfs:subClassOf swa:Functions ;
.
swa:constraint
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "component" ;
          ]
          [
            sp:varName "value" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  (
                    [
                      sp:object [
                          sp:varName "component" ;
                        ] ;
                      sp:predicate swa:constraintComponent ;
                      sp:subject spin:_arg1 ;
                    ]
                    [
                      rdf:type sp:Bind ;
                      sp:expression [
                          rdf:type swa:singleParameter ;
                          arg:component [
                              sp:varName "component" ;
                            ] ;
                        ] ;
                      sp:variable [
                          sp:varName "predicate" ;
                        ] ;
                    ]
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:bound ;
                          sp:arg1 [
                              sp:varName "predicate" ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "value" ;
                      ] ;
                    sp:predicate [
                        sp:varName "predicate" ;
                      ] ;
                    sp:subject spin:_arg1 ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "component" ;
                      ] ;
                    sp:predicate swa:constraintComponent ;
                    sp:subject spin:_arg1 ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type swa:singleParameter ;
                        arg:component [
                            sp:varName "component" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "predicate" ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:not ;
                        sp:arg1 [
                            rdf:type sp:bound ;
                            sp:arg1 [
                                sp:varName "predicate" ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The shape to get the constraints of." ;
    ] ;
  rdfs:comment """For a given shape, gets all declared constraints, identified by their constraint component and (if applicable) their parameter value.

Example usage: ?shape swa:constraint ( ?component ?value ) .""" ;
  rdfs:label "constraint" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:constraintComponent
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:resultVariables (
          [
            sp:varName "component" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate [
                sp:varName "predicate" ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "parameter" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "parameter" ;
              ] ;
            sp:predicate sh:parameter ;
            sp:subject [
                sp:varName "component" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type spl:instanceOf ;
                sp:arg1 [
                    sp:varName "component" ;
                  ] ;
                sp:arg2 sh:ConstraintComponent ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The shape to get the constraints of." ;
    ] ;
  spin:returnType sh:ConstraintComponent ;
  rdfs:comment """For a given shape, gets the constraint components of all declared constraints.

Example usage: ?shape swa:constraintComponent ?component .""" ;
  rdfs:label "constraint component" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:constraintLabel
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:parameter ;
      rdfs:comment "The (single) parameter value in cases such as sh:class, where multiple values may be present." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:component ;
      spl:valueType sh:ConstraintComponent ;
      rdfs:comment "The sh:ConstraintComponent." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:shape ;
      spl:valueType sh:Shape ;
      rdfs:comment "The shape defining the constraint." ;
    ] ;
  rdfs:comment "Gets a display label for a constraint at a shape, using any declared sh:labelTemplate where possible." ;
  rdfs:label "constraint label" ;
  rdfs:subClassOf swa:Functions ;
.
swa:countStringMatches
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:string ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to search in." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:subString ;
      spl:valueType xsd:string ;
      rdfs:comment "The sub-string that is expected to be part of the other string." ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Counts how many times the substring appears in the larger string." ;
  rdfs:label "count string matches" ;
  rdfs:subClassOf swa:Functions ;
.
swa:countryCode
  rdf:type rdf:Property ;
  rdfs:comment "The two-letter country code for a Country." ;
  rdfs:domain swa:Country ;
  rdfs:label "country code" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:countryCodeForLang
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "code" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:eq ;
                    sp:arg1 [
                        rdf:type fn:string-length ;
                        sp:arg1 [
                            sp:varName "lang" ;
                          ] ;
                      ] ;
                    sp:arg2 2 ;
                  ] ;
                sp:arg2 [
                    rdf:type swa:defaultCountryCodeForLanguageCode ;
                    arg:lang [
                        sp:varName "lang" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    rdf:type spif:lowerCase ;
                    sp:arg1 [
                        rdf:type fn:substring ;
                        sp:arg1 [
                            sp:varName "lang" ;
                          ] ;
                        sp:arg2 4 ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "code" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:lang ;
      spl:valueType xsd:string ;
      rdfs:comment "The lang code, either with 2 or 5 letters." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes the lang of a given literal and picks a suitable country code for it. If it's a two-letter code then it tries to find the default one associated with the language using swa:defaultCountryCodeForLanguageCode. For 5-letter codes such as en-UK it simply returns the second part lower-cased." ;
  rdfs:label "country code for lang" ;
  rdfs:subClassOf swa:Functions ;
.
swa:createPropertyShapeURI
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "shape" ;
                      ] ;
                  ] ;
                sp:arg2 "-" ;
                sp:arg3 [
                    rdf:type afn:localname ;
                    sp:arg1 [
                        sp:varName "predicate" ;
                      ] ;
                  ] ;
                sp:arg4 [
                    rdf:type sp:if ;
                    sp:arg1 [
                        sp:varName "inverse" ;
                      ] ;
                    sp:arg2 "-inverse" ;
                    sp:arg3 "" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "base" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:iri ;
                sp:arg1 [
                    rdf:type sp:if ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "zindex" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:concat ;
                        sp:arg1 [
                            sp:varName "base" ;
                          ] ;
                        sp:arg2 "-" ;
                        sp:arg3 [
                            rdf:type sp:str ;
                            sp:arg1 [
                                sp:varName "zindex" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:arg3 [
                        sp:varName "base" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "iri" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:exists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "anyO" ;
                            ] ;
                          sp:predicate [
                              sp:varName "anyP" ;
                            ] ;
                          sp:subject [
                              sp:varName "iri" ;
                            ] ;
                        ]
                      ) ;
                  ] ;
                sp:arg2 [
                    rdf:type swa:createPropertyShapeURI ;
                    arg:inverse [
                        sp:varName "inverse" ;
                      ] ;
                    arg:predicate [
                        sp:varName "predicate" ;
                      ] ;
                    arg:shape [
                        sp:varName "shape" ;
                      ] ;
                    arg:zindex [
                        rdf:type sp:coalesce ;
                        sp:arg1 [
                            rdf:type sp:add ;
                            sp:arg1 [
                                sp:varName "zindex" ;
                              ] ;
                            sp:arg2 1 ;
                          ] ;
                        sp:arg2 0 ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "iri" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:zindex ;
      spl:valueType xsd:integer ;
      rdfs:comment "An optional index that will be used in recursive calls." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:inverse ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to create an inverse." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to create a constraint for." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:shape ;
      spl:valueType sh:Shape ;
      rdfs:comment "The shape to add the constraint to (must be a URI)." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Produces a \"suggested\" URI for a property shape at a given shape for a given predicate. Results will be of the form [SHAPE-URI]-[PREDICATE-LOCAL-NAME][-\"inverse], possibly with \"-0\", \"-1\" etc appended to make them unique." ;
  rdfs:label "create property shape URI" ;
  rdfs:subClassOf swa:Functions ;
.
swa:dataGraph
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:coalesce ;
                sp:arg1 [
                    rdf:type ui:contextValue ;
                    sp:arg1 "dataGraph" ;
                  ] ;
                sp:arg2 [
                    rdf:type ui:currentQueryGraph ;
                  ] ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the current data graph. By default this is simply the current query graph. Can be set to some other value using the context variable \"dataGraph\". This is used by the SWA form mechanism: a form may switch to a different query graph to collect schema information (properties, ranges etc), but some widgets need to return to the domain/instances model in call-backs (such as auto-complete)." ;
  rdfs:label "data graph" ;
  rdfs:subClassOf swa:Functions ;
.
swa:defaultCountryCodeForLanguageCode
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "countryCode" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "lang" ;
                    ] ;
                  sp:predicate swa:languageCode ;
                  sp:subject [
                      sp:varName "country" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "countryCode" ;
                    ] ;
                  sp:predicate swa:countryCode ;
                  sp:subject [
                      sp:varName "country" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode <http://topbraid.org/swa.spin> ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:lang ;
      spl:valueType xsd:string ;
      rdfs:comment "The language code." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "Looks up a country code for a given two-letter language code, based on the instances of swa:Country." ;
  rdfs:label "default country code for language code" ;
  rdfs:subClassOf swa:Functions ;
.
swa:defaultNamespace
  rdf:type rdf:Property ;
  rdfs:comment "Can be used to specify a default namespace for new resources." ;
  rdfs:domain owl:Ontology ;
  rdfs:label "default namespace" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:defaultOntology
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:coalesce ;
                sp:arg1 [
                    sp:varName "ontology" ;
                  ] ;
                sp:arg2 [
                    rdf:type ui:currentQueryGraph ;
                  ] ;
                sp:arg3 <urn:x-error:no-ontology-found> ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  sp:object owl:Ontology ;
                  sp:predicate rdf:type ;
                  sp:subject [
                      sp:varName "ontology" ;
                    ] ;
                ]
              ) ;
          ]
        ) ;
    ] ;
  spin:returnType owl:Ontology ;
  rdfs:comment "Gets the \"default\" owl:Ontology in the current query graph. This is simply returning the first that it finds, so the context should make sure that only one exists or - at least - that the graph is a MultiUnion where the most relevant match is in the base graph that will be queried first. If no owl:Ontology is found, it uses ui:currentQueryGraph() and if that's not bound either then it's making up a URI." ;
  rdfs:label "default ontology" ;
  rdfs:subClassOf swa:Functions ;
.
swa:defaultPropertyShape
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:iri ;
                sp:arg1 [
                    rdf:type sp:concat ;
                    sp:arg1 [
                        rdf:type sp:str ;
                        sp:arg1 [
                            sp:varName "shape" ;
                          ] ;
                      ] ;
                    sp:arg2 "-" ;
                    sp:arg3 [
                        rdf:type afn:localname ;
                        sp:arg1 [
                            sp:varName "property" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The path property." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:shape ;
      spl:valueType sh:NodeShape ;
      rdfs:comment "The shape or class to create the property shape for." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the default property shape URI for a given shape/property combination. This is the URI of the shape + \"-\" + the local name of the property." ;
  rdfs:label "default property shape" ;
  rdfs:subClassOf swa:Functions ;
.
swa:defaultRange
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:or ;
                    sp:arg1 [
                        rdf:type spl:instanceOf ;
                        sp:arg1 [
                            sp:varName "property" ;
                          ] ;
                        sp:arg2 owl:DatatypeProperty ;
                      ] ;
                    sp:arg2 [
                        rdf:type spl:instanceOf ;
                        sp:arg1 [
                            sp:varName "property" ;
                          ] ;
                        sp:arg2 owl:AnnotationProperty ;
                      ] ;
                  ] ;
                sp:arg2 xsd:string ;
                sp:arg3 rdfs:Resource ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the default range of." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the default range for a given property. owl:DatatypeProperties and owl:AnnotationProperties get xsd:string, all others get rdfs:Resource." ;
  rdfs:label "default range" ;
  rdfs:subClassOf swa:Functions ;
.
swa:directCompositeChild
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:resultVariables (
          [
            sp:varName "child" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNode ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "propertyShape" ;
              ] ;
            sp:predicate sh:property ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object "true"^^xsd:boolean ;
            sp:predicate dash:composite ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "path" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:isIRI ;
                        sp:arg1 [
                            sp:varName "path" ;
                          ] ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "child" ;
                      ] ;
                    sp:predicate [
                        sp:varName "path" ;
                      ] ;
                    sp:subject spin:_arg1 ;
                  ]
                )
                (
                  (
                    [
                      sp:object [
                          sp:varName "inverse" ;
                        ] ;
                      sp:predicate sh:inversePath ;
                      sp:subject [
                          sp:varName "path" ;
                        ] ;
                    ]
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:isIRI ;
                          sp:arg1 [
                              sp:varName "inverse" ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object spin:_arg1 ;
                    sp:predicate [
                        sp:varName "inverse" ;
                      ] ;
                    sp:subject [
                        sp:varName "child" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The parent resource." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "For a given parent resource (left hand side) this magic property delivers all \"depending\" objects declared via dash:composite. The right hand side of this magic property must be an unbound variable. Works only for sh:path expressions that are either IRIs or consist of a single inverse path with a named predicate, not arbitrary sh:paths." ;
  rdfs:label "direct composite child" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:directForm
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "form" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "form" ;
              ] ;
            sp:predicate ui:instanceView ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "ids" ;
              ] ;
            sp:predicate ui:id ;
            sp:subject [
                sp:varName "form" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate spif:split ;
            sp:subject [
                sp:varName "id" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "ids" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object " " ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:eq ;
                sp:arg1 [
                    sp:varName "id" ;
                  ] ;
                sp:arg2 "form" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class that the form is attached to." ;
    ] ;
  spin:returnType ui:Element ;
  rdfs:comment "Gets a ui:instanceView of a class that has been marked to match id \"form\". This function needs to be called from within the ui:graph." ;
  rdfs:label "direct form" ;
  rdfs:subClassOf swa:Functions ;
.
swa:directFormInConfigGraph
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "form" ;
          ]
        ) ;
      sp:where (
          (
            [
              rdf:type sp:Bind ;
              sp:expression [
                  rdf:type swa:configGraph ;
                ] ;
              sp:variable [
                  sp:varName "config" ;
                ] ;
            ]
          )
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type swa:directForm ;
                      arg:class [
                          sp:varName "class" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "form" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "config" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class that the form is attached to." ;
    ] ;
  spin:returnType ui:Element ;
  rdfs:comment "Gets a ui:instanceView of a class that has been marked to match id \"form\" in the ui:configGraph()." ;
  rdfs:label "direct form in config graph" ;
  rdfs:subClassOf swa:Functions ;
.
swa:directRelevantClassOfProperty
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    sp:object spin:_arg1 ;
                    sp:predicate rdfs:domain ;
                    sp:subject [
                        sp:varName "property" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "restriction" ;
                      ] ;
                    sp:predicate rdfs:subClassOf ;
                    sp:subject spin:_arg1 ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate owl:onProperty ;
                    sp:subject [
                        sp:varName "restriction" ;
                      ] ;
                  ]
                )
                (
                  (
                    [
                      sp:object [
                          sp:varName "shape" ;
                        ] ;
                      sp:predicate swa:directShapesForType ;
                      sp:subject spin:_arg1 ;
                    ]
                    [
                      rdf:type sp:TriplePath ;
                      sp:object [
                          sp:varName "propertyShape" ;
                        ] ;
                      sp:path [
                          rdf:type sp:AltPath ;
                          sp:path1 sh:property ;
                          sp:path2 sh:parameter ;
                        ] ;
                      sp:subject [
                          sp:varName "shape" ;
                        ] ;
                    ]
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:not ;
                          sp:arg1 [
                              rdf:type dash:isDeactivated ;
                              sp:arg1 [
                                  sp:varName "propertyShape" ;
                                ] ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate sh:path ;
                    sp:subject [
                        sp:varName "propertyShape" ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:isIRI ;
                        sp:arg1 [
                            sp:varName "property" ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:isIRI ;
                sp:arg1 spin:_arg1 ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the properties of." ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment """Finds the properties that are directly attached to a given class.

Note that this magic property should only be used if the class (left hand side) is given and the property (right hand side) is a variable. For the inverse operation, use swa:directRelevantPropertyOfClass.""" ;
  rdfs:label "direct relevant class of property" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:directRelevantPropertyOfClass
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:resultVariables (
          [
            sp:varName "class" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "class" ;
                      ] ;
                    sp:predicate rdfs:domain ;
                    sp:subject spin:_arg1 ;
                  ]
                )
                (
                  [
                    sp:object spin:_arg1 ;
                    sp:predicate owl:onProperty ;
                    sp:subject [
                        sp:varName "restriction" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "restriction" ;
                      ] ;
                    sp:predicate rdfs:subClassOf ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                )
                (
                  (
                    [
                      sp:object spin:_arg1 ;
                      sp:predicate sh:path ;
                      sp:subject [
                          sp:varName "propertyShape" ;
                        ] ;
                    ]
                    [
                      rdf:type sp:TriplePath ;
                      sp:object [
                          sp:varName "propertyShape" ;
                        ] ;
                      sp:path [
                          rdf:type sp:AltPath ;
                          sp:path1 sh:property ;
                          sp:path2 sh:parameter ;
                        ] ;
                      sp:subject [
                          sp:varName "shape" ;
                        ] ;
                    ]
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:not ;
                          sp:arg1 [
                              rdf:type dash:isDeactivated ;
                              sp:arg1 [
                                  sp:varName "propertyShape" ;
                                ] ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "shape" ;
                      ] ;
                    sp:predicate swa:directShapesForType ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:isIRI ;
                sp:arg1 [
                    sp:varName "class" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the classes of." ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment """Finds the classes that are directly attached to a given property. In SWA this is used by the class/property tree.

Note that this magic property should only be used if the property (left hand side) is given. For the inverse operation, use swa:directRelevantClassOfProperty.""" ;
  rdfs:label "direct relevant property of class" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:directShapesForType
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:resultVariables (
          [
            sp:varName "shape" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    sp:object spin:_arg1 ;
                    sp:predicate sh:targetClass ;
                    sp:subject [
                        sp:varName "shape" ;
                      ] ;
                  ]
                )
                (
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:and ;
                        sp:arg1 [
                            rdf:type sp:bound ;
                            sp:arg1 spin:_arg1 ;
                          ] ;
                        sp:arg2 [
                            rdf:type spl:instanceOf ;
                            sp:arg1 spin:_arg1 ;
                            sp:arg2 sh:Shape ;
                          ] ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression spin:_arg1 ;
                    sp:variable [
                        sp:varName "shape" ;
                      ] ;
                  ]
                )
                (
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:and ;
                        sp:arg1 [
                            rdf:type sp:and ;
                            sp:arg1 [
                                rdf:type sp:bound ;
                                sp:arg1 [
                                    sp:varName "shape" ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                rdf:type spl:instanceOf ;
                                sp:arg1 [
                                    sp:varName "shape" ;
                                  ] ;
                                sp:arg2 rdfs:Class ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            rdf:type spl:instanceOf ;
                            sp:arg1 [
                                sp:varName "shape" ;
                              ] ;
                            sp:arg2 sh:Shape ;
                          ] ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        sp:varName "shape" ;
                      ] ;
                    sp:variable spin:_arg1 ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type to get the property groups for." ;
    ] ;
  spin:returnType sh:Shape ;
  rdfs:comment """Gets all sh:Shapes associated with a given type. This is not walking up the class hierarchy but collects all classes that are also instances of sh:Shape, and any shapes declared using sh:targetClass.

This magic property can be used in both directions, i.e. if either the class or the shape are given.""" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:falseOrUnbound
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "value" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        sp:varName "value" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:value ;
      spl:valueType xsd:boolean ;
      rdfs:comment "The input value." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether the provided argument is unbound or false." ;
  rdfs:label "false or unbound" ;
  rdfs:subClassOf swa:Functions ;
.
swa:genericTreeInverseProperties
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
          [
            sp:varName "editable" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:SubQuery ;
            sp:query [
                rdf:type sp:Select ;
                sp:groupBy (
                    [
                      sp:varName "property" ;
                    ]
                  ) ;
                sp:resultVariables (
                    [
                      sp:varName "property" ;
                    ]
                    [
                      sp:expression [
                          rdf:type sp:Min ;
                          sp:expression [
                              sp:varName "editableL" ;
                            ] ;
                        ] ;
                      sp:varName "editable" ;
                    ]
                  ) ;
                sp:where (
                    [
                      rdf:type sp:Union ;
                      sp:elements (
                          (
                            (
                              [
                                rdf:type sp:TriplePath ;
                                sp:object [
                                    sp:varName "type" ;
                                  ] ;
                                sp:path [
                                    rdf:type sp:ModPath ;
                                    sp:modMax -2 ;
                                    sp:modMin 0 ;
                                    sp:subPath rdfs:subClassOf ;
                                  ] ;
                                sp:subject spin:_arg1 ;
                              ]
                              [
                                sp:object [
                                    sp:varName "type" ;
                                  ] ;
                                sp:predicate rdfs:range ;
                                sp:subject [
                                    sp:varName "superProperty" ;
                                  ] ;
                              ]
                              [
                                rdf:type sp:TriplePath ;
                                sp:object [
                                    sp:varName "superProperty" ;
                                  ] ;
                                sp:path [
                                    rdf:type sp:ModPath ;
                                    sp:modMax -2 ;
                                    sp:modMin 0 ;
                                    sp:subPath rdfs:subPropertyOf ;
                                  ] ;
                                sp:subject [
                                    sp:varName "property" ;
                                  ] ;
                              ]
                              [
                                sp:object [
                                    sp:varName "domain" ;
                                  ] ;
                                sp:predicate rdfs:domain ;
                                sp:subject [
                                    sp:varName "superProperty" ;
                                  ] ;
                              ]
                              [
                                rdf:type sp:Filter ;
                                sp:expression [
                                    rdf:type swa:filterSystemResources ;
                                    sp:arg1 [
                                        sp:varName "property" ;
                                      ] ;
                                  ] ;
                              ]
                              [
                                rdf:type sp:Filter ;
                                sp:expression [
                                    rdf:type swa:filterSystemResources ;
                                    sp:arg1 [
                                        sp:varName "type" ;
                                      ] ;
                                  ] ;
                              ]
                            )
                            [
                              rdf:type sp:Bind ;
                              sp:expression [
                                  rdf:type sp:and ;
                                  sp:arg1 [
                                      rdf:type sp:eq ;
                                      sp:arg1 [
                                          sp:varName "domain" ;
                                        ] ;
                                      sp:arg2 [
                                          sp:varName "type" ;
                                        ] ;
                                    ] ;
                                  sp:arg2 [
                                      rdf:type sp:not ;
                                      sp:arg1 [
                                          rdf:type spl:instanceOf ;
                                          sp:arg1 [
                                              sp:varName "property" ;
                                            ] ;
                                          sp:arg2 spin:MagicProperty ;
                                        ] ;
                                    ] ;
                                ] ;
                              sp:variable [
                                  sp:varName "editableL" ;
                                ] ;
                            ]
                          )
                          (
                            [
                              rdf:type sp:TriplePath ;
                              sp:object [
                                  sp:varName "type" ;
                                ] ;
                              sp:path [
                                  rdf:type sp:ModPath ;
                                  sp:modMax -2 ;
                                  sp:modMin 0 ;
                                  sp:subPath rdfs:subClassOf ;
                                ] ;
                              sp:subject spin:_arg1 ;
                            ]
                            [
                              sp:object [
                                  sp:varName "type" ;
                                ] ;
                              sp:predicate sh:class ;
                              sp:subject [
                                  sp:varName "ps" ;
                                ] ;
                            ]
                            [
                              sp:object [
                                  sp:varName "property" ;
                                ] ;
                              sp:predicate sh:path ;
                              sp:subject [
                                  sp:varName "ps" ;
                                ] ;
                            ]
                            [
                              sp:object [
                                  sp:varName "ps" ;
                                ] ;
                              sp:predicate sh:property ;
                              sp:subject [
                                  sp:varName "domain" ;
                                ] ;
                            ]
                            [
                              rdf:type sp:Filter ;
                              sp:expression [
                                  rdf:type sp:isIRI ;
                                  sp:arg1 [
                                      sp:varName "property" ;
                                    ] ;
                                ] ;
                            ]
                            [
                              rdf:type sp:Filter ;
                              sp:expression [
                                  rdf:type swa:filterSystemResources ;
                                  sp:arg1 [
                                      sp:varName "type" ;
                                    ] ;
                                ] ;
                            ]
                            [
                              rdf:type sp:Bind ;
                              sp:expression [
                                  rdf:type sp:and ;
                                  sp:arg1 [
                                      rdf:type sp:eq ;
                                      sp:arg1 [
                                          sp:varName "domain" ;
                                        ] ;
                                      sp:arg2 [
                                          sp:varName "type" ;
                                        ] ;
                                    ] ;
                                  sp:arg2 [
                                      rdf:type sp:not ;
                                      sp:arg1 [
                                          rdf:type spl:instanceOf ;
                                          sp:arg1 [
                                              sp:varName "property" ;
                                            ] ;
                                          sp:arg2 spin:MagicProperty ;
                                        ] ;
                                    ] ;
                                ] ;
                              sp:variable [
                                  sp:varName "editableL" ;
                                ] ;
                            ]
                          )
                        ) ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The resource type." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:label "generic tree inverse properties" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:genericTreeProperties
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
          [
            sp:varName "editable" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:SubQuery ;
            sp:query [
                rdf:type sp:Select ;
                sp:groupBy (
                    [
                      sp:varName "property" ;
                    ]
                  ) ;
                sp:resultVariables (
                    [
                      sp:varName "property" ;
                    ]
                    [
                      sp:expression [
                          rdf:type sp:Min ;
                          sp:expression [
                              sp:varName "editableL" ;
                            ] ;
                        ] ;
                      sp:varName "editable" ;
                    ]
                  ) ;
                sp:where (
                    [
                      rdf:type sp:Union ;
                      sp:elements (
                          (
                            (
                              (
                                [
                                  rdf:type sp:TriplePath ;
                                  sp:object [
                                      sp:varName "type" ;
                                    ] ;
                                  sp:path [
                                      rdf:type sp:ModPath ;
                                      sp:modMax -2 ;
                                      sp:modMin 0 ;
                                      sp:subPath rdfs:subClassOf ;
                                    ] ;
                                  sp:subject spin:_arg1 ;
                                ]
                                [
                                  sp:object [
                                      sp:varName "type" ;
                                    ] ;
                                  sp:predicate rdfs:domain ;
                                  sp:subject [
                                      sp:varName "superProperty" ;
                                    ] ;
                                ]
                                [
                                  rdf:type sp:TriplePath ;
                                  sp:object [
                                      sp:varName "superProperty" ;
                                    ] ;
                                  sp:path [
                                      rdf:type sp:ModPath ;
                                      sp:modMax -2 ;
                                      sp:modMin 0 ;
                                      sp:subPath rdfs:subPropertyOf ;
                                    ] ;
                                  sp:subject [
                                      sp:varName "property" ;
                                    ] ;
                                ]
                                [
                                  rdf:type sp:Filter ;
                                  sp:expression [
                                      rdf:type swa:filterSystemResources ;
                                      sp:arg1 [
                                          sp:varName "property" ;
                                        ] ;
                                    ] ;
                                ]
                                [
                                  rdf:type sp:Filter ;
                                  sp:expression [
                                      rdf:type sp:or ;
                                      sp:arg1 [
                                          rdf:type sp:eq ;
                                          sp:arg1 [
                                              sp:varName "property" ;
                                            ] ;
                                          sp:arg2 [
                                              sp:varName "superProperty" ;
                                            ] ;
                                        ] ;
                                      sp:arg2 [
                                          rdf:type sp:notExists ;
                                          sp:elements (
                                              [
                                                sp:object [
                                                    sp:varName "ownDomain" ;
                                                  ] ;
                                                sp:predicate rdfs:domain ;
                                                sp:subject [
                                                    sp:varName "property" ;
                                                  ] ;
                                              ]
                                            ) ;
                                        ] ;
                                    ] ;
                                ]
                              )
                              [
                                rdf:type sp:Bind ;
                                sp:expression [
                                    rdf:type swa:localRangeAtClass ;
                                    arg:class [
                                        sp:varName "type" ;
                                      ] ;
                                    arg:property [
                                        sp:varName "property" ;
                                      ] ;
                                  ] ;
                                sp:variable [
                                    sp:varName "range" ;
                                  ] ;
                              ]
                            )
                            [
                              rdf:type sp:Filter ;
                              sp:expression [
                                  rdf:type sp:exists ;
                                  sp:elements (
                                      [
                                        rdf:type sp:TriplePath ;
                                        sp:object owl:Thing ;
                                        sp:path [
                                            rdf:type sp:ModPath ;
                                            sp:modMax -2 ;
                                            sp:modMin 0 ;
                                            sp:subPath rdfs:subClassOf ;
                                          ] ;
                                        sp:subject [
                                            sp:varName "range" ;
                                          ] ;
                                      ]
                                    ) ;
                                ] ;
                            ]
                            [
                              rdf:type sp:Bind ;
                              sp:expression [
                                  rdf:type sp:and ;
                                  sp:arg1 [
                                      rdf:type sp:eq ;
                                      sp:arg1 [
                                          sp:varName "range" ;
                                        ] ;
                                      sp:arg2 [
                                          sp:varName "type" ;
                                        ] ;
                                    ] ;
                                  sp:arg2 [
                                      rdf:type sp:not ;
                                      sp:arg1 [
                                          rdf:type spl:instanceOf ;
                                          sp:arg1 [
                                              sp:varName "property" ;
                                            ] ;
                                          sp:arg2 spin:MagicProperty ;
                                        ] ;
                                    ] ;
                                ] ;
                              sp:variable [
                                  sp:varName "editableL" ;
                                ] ;
                            ]
                          )
                          (
                            (
                              (
                                [
                                  rdf:type sp:TriplePath ;
                                  sp:object [
                                      sp:varName "type" ;
                                    ] ;
                                  sp:path [
                                      rdf:type sp:ModPath ;
                                      sp:modMax -2 ;
                                      sp:modMin 0 ;
                                      sp:subPath rdfs:subClassOf ;
                                    ] ;
                                  sp:subject spin:_arg1 ;
                                ]
                                [
                                  rdf:type sp:TriplePath ;
                                  sp:object [
                                      sp:varName "property" ;
                                    ] ;
                                  sp:path [
                                      rdf:type sp:SeqPath ;
                                      sp:path1 sh:property ;
                                      sp:path2 sh:path ;
                                    ] ;
                                  sp:subject [
                                      sp:varName "type" ;
                                    ] ;
                                ]
                                [
                                  rdf:type sp:Filter ;
                                  sp:expression [
                                      rdf:type sp:isIRI ;
                                      sp:arg1 [
                                          sp:varName "property" ;
                                        ] ;
                                    ] ;
                                ]
                                [
                                  rdf:type sp:Filter ;
                                  sp:expression [
                                      rdf:type swa:filterSystemResources ;
                                      sp:arg1 [
                                          sp:varName "property" ;
                                        ] ;
                                    ] ;
                                ]
                              )
                              [
                                rdf:type sp:Bind ;
                                sp:expression [
                                    rdf:type swa:localRangeAtClass ;
                                    arg:class [
                                        sp:varName "type" ;
                                      ] ;
                                    arg:property [
                                        sp:varName "property" ;
                                      ] ;
                                  ] ;
                                sp:variable [
                                    sp:varName "range" ;
                                  ] ;
                              ]
                            )
                            [
                              rdf:type sp:Filter ;
                              sp:expression [
                                  rdf:type sp:exists ;
                                  sp:elements (
                                      [
                                        rdf:type sp:TriplePath ;
                                        sp:object owl:Thing ;
                                        sp:path [
                                            rdf:type sp:ModPath ;
                                            sp:modMax -2 ;
                                            sp:modMin 0 ;
                                            sp:subPath rdfs:subClassOf ;
                                          ] ;
                                        sp:subject [
                                            sp:varName "range" ;
                                          ] ;
                                      ]
                                    ) ;
                                ] ;
                            ]
                            [
                              rdf:type sp:Bind ;
                              sp:expression [
                                  rdf:type sp:and ;
                                  sp:arg1 [
                                      rdf:type sp:eq ;
                                      sp:arg1 [
                                          sp:varName "range" ;
                                        ] ;
                                      sp:arg2 [
                                          sp:varName "type" ;
                                        ] ;
                                    ] ;
                                  sp:arg2 [
                                      rdf:type sp:not ;
                                      sp:arg1 [
                                          rdf:type spl:instanceOf ;
                                          sp:arg1 [
                                              sp:varName "property" ;
                                            ] ;
                                          sp:arg2 spin:MagicProperty ;
                                        ] ;
                                    ] ;
                                ] ;
                              sp:variable [
                                  sp:varName "editableL" ;
                                ] ;
                            ]
                          )
                        ) ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The resource type." ;
    ] ;
  rdfs:label "generic tree properties" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:getDefaultNamespace
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:defaultOntology ;
              ] ;
            sp:variable [
                sp:varName "ontology" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "ontology" ;
                  ] ;
                sp:arg2 swa:defaultNamespace ;
              ] ;
            sp:variable [
                sp:varName "default" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:coalesce ;
                sp:arg1 [
                    sp:varName "default" ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:concat ;
                    sp:arg1 [
                        rdf:type xsd:string ;
                        sp:arg1 [
                            sp:varName "ontology" ;
                          ] ;
                      ] ;
                    sp:arg2 "/" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Picks a default namespace for new resources. This uses swa:defaultOntology to get hold of the default ontology. If this has a swa:defaultNamespace, then this will be used. Otherwise, the base URI + '/' of the default ontology is used." ;
  rdfs:label "get default namespace" ;
  rdfs:subClassOf swa:Functions ;
.
swa:getEditorTextError
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject node." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate being edited." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:text ;
      spl:valueType xsd:string ;
      rdfs:comment "The text to check." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "Attempts to parse a string as an expression for a given subject/predicate combination. This uses the logic from the built-in editing widgets of TopBraid Composer including the Turtle-based SHACL shape editors. Returns nothing if the provided text string is valid, or an error message." ;
  rdfs:label "get editor text error" ;
  rdfs:subClassOf swa:Functions ;
.
swa:globalRange
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "range" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "p" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subPropertyOf ;
              ] ;
            sp:subject [
                sp:varName "property" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "range" ;
              ] ;
            sp:predicate rdfs:range ;
            sp:subject [
                sp:varName "p" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the range of." ;
    ] ;
  spin:returnType rdfs:Class ;
  rdfs:comment "Gets the global range (rdfs:range) of a property. If none is provided, it will walk up super-properties." ;
  rdfs:label "global range" ;
  rdfs:subClassOf swa:Functions ;
.
swa:googleMapsAPIKey
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type ui:systemPreference ;
                sp:arg1 "GoogleMapsAPIKey" ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the currently registered Google Maps API key." ;
  rdfs:label "Google Maps API key" ;
  rdfs:subClassOf swa:Functions ;
.
swa:graphIsEmpty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      rdf:type sp:NamedGraph ;
                      sp:elements (
                          [
                            sp:object [
                                sp:varName "o" ;
                              ] ;
                            sp:predicate [
                                sp:varName "p" ;
                              ] ;
                            sp:subject [
                                sp:varName "s" ;
                              ] ;
                          ]
                        ) ;
                      sp:graphNameNode [
                          sp:varName "graph" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:graph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph to test." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given graph is empty." ;
  rdfs:label "graph is empty" ;
  rdfs:subClassOf swa:Functions ;
.
swa:graphLabel
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "result" ;
                      ] ;
                    sp:predicate rdfs:label ;
                    sp:subject [
                        sp:varName "graph" ;
                      ] ;
                  ]
                )
                (
                  [
                    rdf:type sp:NamedGraph ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "result" ;
                            ] ;
                          sp:predicate rdfs:label ;
                          sp:subject [
                              sp:varName "graph" ;
                            ] ;
                        ]
                      ) ;
                    sp:graphNameNode ui:graph ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:graph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph to get the label for." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the display label of a given graph, with special handling of certain system namespaces." ;
  rdfs:label "graph label" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasAppName
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          (
            [
              rdf:type sp:Filter ;
              sp:expression [
                  rdf:type sp:and ;
                  sp:arg1 [
                      rdf:type sp:bound ;
                      sp:arg1 spin:_arg1 ;
                    ] ;
                  sp:arg2 [
                      rdf:type sp:bound ;
                      sp:arg1 spin:_arg2 ;
                    ] ;
                ] ;
            ]
          )
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate spif:split ;
            sp:subject [
                sp:varName "sub1" ;
              ] ;
          ]
          [
            sp:object spin:_arg1 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object "," ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?2" ;
              ] ;
            sp:predicate spif:split ;
            sp:subject [
                sp:varName "sub2" ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?2" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?3" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?2" ;
              ] ;
          ]
          [
            sp:object "," ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?3" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?3" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:eq ;
                sp:arg1 [
                    sp:varName "sub1" ;
                  ] ;
                sp:arg2 [
                    sp:varName "sub2" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to check - may contain a comma-separated list of app names." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The name to match against, e.g. \"EVN\"." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given string contains a given app name." ;
  rdfs:label "has app name" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasCurrentAppName
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type swa:hasAppName ;
                sp:arg1 [
                    rdf:type ui:contextValue ;
                    sp:arg1 "swaAppName" ;
                  ] ;
                sp:arg2 [
                    sp:varName "appName" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:appName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name to match against, e.g. \"EVN\"." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if the current context is in a given application, as identified by the context variable \"swaAppName\"." ;
  rdfs:label "has current app name" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasDirectForm
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type swa:directForm ;
                      arg:class [
                          sp:varName "class" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "form" ;
                    ] ;
                ]
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type sp:bound ;
                      sp:arg1 [
                          sp:varName "form" ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to check for a form." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether there is a direct form attached to a given class." ;
  rdfs:label "has direct form" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasDirectFormOutsideConfigGraph
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                (
                  (
                    [
                      sp:object [
                          sp:varName "form" ;
                        ] ;
                      sp:predicate ui:instanceView ;
                      sp:subject [
                          sp:varName "class" ;
                        ] ;
                    ]
                    [
                      rdf:type sp:Bind ;
                      sp:expression [
                          rdf:type swa:directFormInConfigGraph ;
                          arg:class [
                              sp:varName "class" ;
                            ] ;
                        ] ;
                      sp:variable [
                          sp:varName "configForm" ;
                        ] ;
                    ]
                  )
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:or ;
                        sp:arg1 [
                            rdf:type sp:not ;
                            sp:arg1 [
                                rdf:type sp:bound ;
                                sp:arg1 [
                                    sp:varName "configForm" ;
                                  ] ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            rdf:type sp:ne ;
                            sp:arg1 [
                                sp:varName "form" ;
                              ] ;
                            sp:arg2 [
                                sp:varName "configForm" ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                )
                [
                  sp:object [
                      sp:varName "ids" ;
                    ] ;
                  sp:predicate ui:id ;
                  sp:subject [
                      sp:varName "form" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "?0" ;
                    ] ;
                  sp:predicate spif:split ;
                  sp:subject [
                      sp:varName "id" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "ids" ;
                    ] ;
                  sp:predicate rdf:first ;
                  sp:subject [
                      sp:varName "?0" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "?1" ;
                    ] ;
                  sp:predicate rdf:rest ;
                  sp:subject [
                      sp:varName "?0" ;
                    ] ;
                ]
                [
                  sp:object " " ;
                  sp:predicate rdf:first ;
                  sp:subject [
                      sp:varName "?1" ;
                    ] ;
                ]
                [
                  sp:object () ;
                  sp:predicate rdf:rest ;
                  sp:subject [
                      sp:varName "?1" ;
                    ] ;
                ]
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type sp:eq ;
                      sp:arg1 [
                          sp:varName "id" ;
                        ] ;
                      sp:arg2 "form" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given class has a direct form attached to it, outside of the swa:configGraph(). Only classes that return false here can be edited by end users." ;
  rdfs:label "has direct form outside config graph" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasPrefix
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type afn:namespace ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "namespace" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "prefix" ;
              ] ;
            sp:predicate spif:prefix ;
            sp:subject [
                sp:varName "namespace" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:bound ;
                sp:arg1 [
                    sp:varName "prefix" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to check for a prefix." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if the current query model defines a prefix for a given URI resource." ;
  rdfs:label "has prefix" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasPrimaryKey
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:primaryKeyProperty ;
                arg:class [
                    sp:varName "class" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "property" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:bound ;
                sp:arg1 [
                    sp:varName "property" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to check for the primary key." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:label "has primary key" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasPropertyGroupValue
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNodeFiltered ;
            sp:subject [
                sp:varName "focusNode" ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "propertyShape" ;
              ] ;
            sp:path [
                rdf:type sp:AltPath ;
                sp:path1 sh:property ;
                sp:path2 sh:parameter ;
              ] ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "group" ;
              ] ;
            sp:predicate sh:group ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "path" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:and ;
                    sp:arg1 [
                        rdf:type sp:isIRI ;
                        sp:arg1 [
                            sp:varName "path" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:exists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "any" ;
                                ] ;
                              sp:predicate [
                                  sp:varName "path" ;
                                ] ;
                              sp:subject [
                                  sp:varName "focusNode" ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:and ;
                    sp:arg1 [
                        rdf:type sp:isBlank ;
                        sp:arg1 [
                            sp:varName "path" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:exists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "inverse" ;
                                ] ;
                              sp:predicate sh:inversePath ;
                              sp:subject [
                                  sp:varName "path" ;
                                ] ;
                            ]
                            [
                              sp:object [
                                  sp:varName "focusNode" ;
                                ] ;
                              sp:predicate [
                                  sp:varName "inverse" ;
                                ] ;
                              sp:subject [
                                  sp:varName "any" ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node to test." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:group ;
      spl:valueType sh:PropertyGroup ;
      rdfs:comment "The property group." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given focus node has a value for any property (or inverse properties) enumerated by a given sh:PropertyGroup." ;
  rdfs:label "has property group value" ;
  rdfs:subClassOf swa:Functions ;
.
swa:imageURLSuffix
  rdf:type rdf:Property ;
  rdfs:comment "Lists the registered file suffixes that are regarded to be image files." ;
  rdfs:label "image URLSuffix" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:isAbstractClass
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object "true"^^xsd:boolean ;
            sp:path [
                rdf:type sp:AltPath ;
                sp:path1 [
                    rdf:type sp:AltPath ;
                    sp:path1 dash:abstract ;
                    sp:path2 spin:abstract ;
                  ] ;
                sp:path2 ui:abstract ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The class to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given class is \"abstract\" which means that it should not have any direct instances. The is true if the class either has dash:abstract, spin:abstract or ui:abstract set to true." ;
  rdfs:label "is abstract class" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isAnnotationProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type spl:instanceOf ;
                sp:arg1 [
                    sp:varName "predicate" ;
                  ] ;
                sp:arg2 owl:AnnotationProperty ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:comment "Checks whether a given property is an annotation property." ;
  rdfs:label "is annotation property" ;
  rdfs:subClassOf swa:PropertyWidgetGroupFilterFunctions ;
.
swa:isAutoAddRowProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:notIn ;
                sp:arg1 [
                    sp:varName "property" ;
                  ] ;
                sp:arg2 sh:property ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The property to check." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a widget for a given property will automatically add a new row when it has no values. This is currently true for all properties except some SHACL ones." ;
  rdfs:label "is auto add row property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isClassAxiomProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:exists ;
                sp:elements (
                    [
                      rdf:type sp:NamedGraph ;
                      sp:elements (
                          [
                            sp:object swa:ClassAxiomProperty ;
                            sp:predicate rdf:type ;
                            sp:subject [
                                sp:varName "predicate" ;
                              ] ;
                          ]
                        ) ;
                      sp:graphNameNode ui:graph ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:comment "Checks whether a given property has been marked as swa:ClassAxiomProperty." ;
  rdfs:label "is class axiom property" ;
  rdfs:subClassOf swa:PropertyWidgetGroupFilterFunctions ;
.
swa:isDatatypeEnumeration
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "list" ;
              ] ;
            sp:predicate owl:oneOf ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            sp:object rdfs:Datatype ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node to test." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Tests if a given range is a data range with a owl:oneOf." ;
  rdfs:label "is datatype enumeration" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isDatatypeRange
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:bound ;
                sp:arg1 [
                    sp:varName "range" ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:eq ;
                    sp:arg1 [
                        sp:varName "range" ;
                      ] ;
                    sp:arg2 rdfs:Literal ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:exists ;
                    sp:elements (
                        [
                          sp:object rdfs:Datatype ;
                          sp:predicate rdf:type ;
                          sp:subject [
                              sp:varName "range" ;
                            ] ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:range ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The range to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given resource (typically the range of a property) is a datatype. It must either be equal to rdfs:Literal or an instance of rdfs:Datatype." ;
  rdfs:label "is datatype range" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isFromSHACLDatatypeConstraint
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNodeFiltered ;
            sp:subject [
                sp:varName "subject" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate sh:property ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "property" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:exists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "datatype" ;
                            ] ;
                          sp:predicate sh:datatype ;
                          sp:subject [
                              sp:varName "property" ;
                            ] ;
                        ]
                      ) ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:exists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "list" ;
                            ] ;
                          sp:predicate sh:or ;
                          sp:subject [
                              sp:varName "property" ;
                            ] ;
                        ]
                        [
                          rdf:type sp:TriplePath ;
                          sp:object [
                              sp:varName "datatype" ;
                            ] ;
                          sp:path [
                              rdf:type sp:SeqPath ;
                              sp:path1 [
                                  rdf:type sp:SeqPath ;
                                  sp:path1 [
                                      rdf:type sp:ModPath ;
                                      sp:modMax -2 ;
                                      sp:modMin 0 ;
                                      sp:subPath rdf:rest ;
                                    ] ;
                                  sp:path2 rdf:first ;
                                ] ;
                              sp:path2 sh:datatype ;
                            ] ;
                          sp:subject [
                              sp:varName "list" ;
                            ] ;
                        ]
                        [
                          rdf:type sp:Filter ;
                          sp:expression [
                              rdf:type sp:notExists ;
                              sp:elements (
                                  [
                                    rdf:type sp:TriplePath ;
                                    sp:object xsd:string ;
                                    sp:path [
                                        rdf:type sp:SeqPath ;
                                        sp:path1 rdf:first ;
                                        sp:path2 sh:datatype ;
                                      ] ;
                                    sp:subject [
                                        sp:varName "list" ;
                                      ] ;
                                  ]
                                  [
                                    rdf:type sp:TriplePath ;
                                    sp:object rdf:langString ;
                                    sp:path [
                                        rdf:type sp:SeqPath ;
                                        sp:path1 [
                                            rdf:type sp:SeqPath ;
                                            sp:path1 rdf:rest ;
                                            sp:path2 rdf:first ;
                                          ] ;
                                        sp:path2 sh:datatype ;
                                      ] ;
                                    sp:subject [
                                        sp:varName "list" ;
                                      ] ;
                                  ]
                                  [
                                    rdf:type sp:TriplePath ;
                                    sp:object () ;
                                    sp:path [
                                        rdf:type sp:SeqPath ;
                                        sp:path1 rdf:rest ;
                                        sp:path2 rdf:rest ;
                                      ] ;
                                    sp:subject [
                                        sp:varName "list" ;
                                      ] ;
                                  ]
                                ) ;
                            ] ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:datatype ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "The rdfs:Datatype to look for." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject resource." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given datatype has been declared as sh:datatype in a shape relevant to a given subject/predicate combination. This also looks into sh:datatypes from sh:or lists." ;
  rdfs:label "is from SHACL datatype constraint" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isImageURL
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type spif:lastIndexOf ;
                      sp:arg1 [
                          sp:varName "url" ;
                        ] ;
                      sp:arg2 "." ;
                    ] ;
                  sp:variable [
                      sp:varName "lastDot" ;
                    ] ;
                ]
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type sp:gt ;
                      sp:arg1 [
                          sp:varName "lastDot" ;
                        ] ;
                      sp:arg2 0 ;
                    ] ;
                ]
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type spif:lowerCase ;
                      sp:arg1 [
                          rdf:type fn:substring ;
                          sp:arg1 [
                              sp:varName "url" ;
                            ] ;
                          sp:arg2 [
                              rdf:type sp:add ;
                              sp:arg1 [
                                  sp:varName "lastDot" ;
                                ] ;
                              sp:arg2 1 ;
                            ] ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "suffix" ;
                    ] ;
                ]
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type sp:exists ;
                      sp:elements (
                          [
                            sp:object [
                                sp:varName "suffix" ;
                              ] ;
                            sp:predicate swa:imageURLSuffix ;
                            sp:subject [
                                sp:varName "someSubject" ;
                              ] ;
                          ]
                        ) ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL to check." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  swa:imageURLSuffix ".gif" ;
  swa:imageURLSuffix ".jpg" ;
  swa:imageURLSuffix ".png" ;
  rdfs:comment "Checks whether a given URL represents an image based on its suffix (.jpg, .gif or .png are recognized by default, but others can be added by putting an imageURLSuffix triple into a globally registered SWP file)." ;
  rdfs:label "is image URL" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isImportedResource
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type spif:isReadOnlyTriple ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
                sp:arg2 rdf:type ;
                sp:arg3 [
                    sp:varName "type" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given resource is \"imported\", which is defined to be true if the resource has at least one rdf:type triple that is read-only." ;
  rdfs:label "is imported resource" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isInferredProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate sh:predicate ;
            sp:subject [
                sp:varName "rule" ;
              ] ;
          ]
          [
            sp:object sh:this ;
            sp:predicate sh:subject ;
            sp:subject [
                sp:varName "rule" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "rule" ;
              ] ;
            sp:predicate sh:rule ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type tosh:isInTargetOf ;
                sp:arg1 [
                    sp:varName "subject" ;
                  ] ;
                sp:arg2 [
                    sp:varName "shape" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to check." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject resource." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given property is being computed by inference (from SHACL triple rules) for a given subject." ;
  rdfs:label "is inferred property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isMandatory
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type swa:isMandatoryInOWL ;
                    arg:property [
                        sp:varName "property" ;
                      ] ;
                    arg:subject [
                        sp:varName "subject" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type swa:isMandatoryInSHACL ;
                    arg:property [
                        sp:varName "property" ;
                      ] ;
                    arg:subject [
                        sp:varName "subject" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject - may be unbound to fall back to the subjectType." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given subject/predicate combination requires at least one value, according to the ontology. This checks for owl:minCardinality|owl:cardinality|owl:qualifiedCardinality restrictions and sh:minCount constraints." ;
  rdfs:label "is mandatory" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isMandatoryInOWL
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "class" ;
              ] ;
            sp:predicate swa:resourceTypes ;
            sp:subject [
                sp:varName "subject" ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "restriction" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate owl:onProperty ;
            sp:subject [
                sp:varName "restriction" ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "minOWL" ;
              ] ;
            sp:path [
                rdf:type sp:AltPath ;
                sp:path1 [
                    rdf:type sp:AltPath ;
                    sp:path1 owl:minCardinality ;
                    sp:path2 owl:cardinality ;
                  ] ;
                sp:path2 owl:qualifiedCardinality ;
              ] ;
            sp:subject [
                sp:varName "restriction" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:gt ;
                sp:arg1 [
                    sp:varName "minOWL" ;
                  ] ;
                sp:arg2 0 ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:label "is mandatory in OWL" ;
  rdfs:subClassOf swa:isMandatory ;
.
swa:isMandatoryInSHACL
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNodeFiltered ;
            sp:subject [
                sp:varName "subject" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "propertyShape" ;
              ] ;
            sp:predicate sh:property ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "minCount" ;
              ] ;
            sp:predicate sh:minCount ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:gt ;
                sp:arg1 [
                    sp:varName "minCount" ;
                  ] ;
                sp:arg2 0 ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:label "is mandatory SHACL" ;
  rdfs:subClassOf swa:isMandatory ;
.
swa:isMulti
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      sp:object owl:FunctionalProperty ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "property" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:resourceType ;
                arg:resource [
                    sp:varName "subject" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "class" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:owlMaxCardinality ;
                arg:class [
                    sp:varName "class" ;
                  ] ;
                arg:property [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "max" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "max" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:gt ;
                    sp:arg1 [
                        sp:varName "max" ;
                      ] ;
                    sp:arg2 1 ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:splArgumentOnProperty ;
                arg:class [
                    sp:varName "class" ;
                  ] ;
                arg:property [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "arg" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:not ;
                sp:arg1 [
                    rdf:type sp:bound ;
                    sp:arg1 [
                        sp:varName "arg" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject - may be unbound to fall back to the subjectType." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment """Checks whether a given subject/predicate combination can have multiple values, according to the ontology. This checks for owl:maxCardinality restrictions, existing spl:Argument constraints and whether the property is functional.

Note that TopBraid Suite uses a native (optimized) implementation of this function, i.e. the SPIN body is never called when used inside of TopBraid Suite.""" ;
  rdfs:label "is multi" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isNonAnnotationProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:not ;
                sp:arg1 [
                    rdf:type spl:instanceOf ;
                    sp:arg1 [
                        sp:varName "predicate" ;
                      ] ;
                    sp:arg2 owl:AnnotationProperty ;
                  ] ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:comment "Checks whether a property is not an annotation property." ;
  rdfs:label "is non annotation property" ;
  rdfs:subClassOf swa:PropertyWidgetGroupFilterFunctions ;
.
swa:isNonClassAxiomProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:and ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type swa:isClassAxiomProperty ;
                        arg:predicate [
                            sp:varName "predicate" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type swa:isAnnotationProperty ;
                        arg:predicate [
                            sp:varName "predicate" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:comment "Checks whether a property is neither a class axiom property nor annotation property." ;
  rdfs:label "is non class axiom property" ;
  rdfs:subClassOf swa:PropertyWidgetGroupFilterFunctions ;
.
swa:isNonPropertyAxiomProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:and ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type swa:isPropertyAxiomProperty ;
                        arg:predicate [
                            sp:varName "predicate" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type swa:isAnnotationProperty ;
                        arg:predicate [
                            sp:varName "predicate" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:comment "Checks whether a property is neither a property axiom property nor annotation property." ;
  rdfs:label "is non property axiom property" ;
  rdfs:subClassOf swa:PropertyWidgetGroupFilterFunctions ;
.
swa:isNotUsedInInversePath
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "shape" ;
                        ] ;
                      sp:predicate swa:shapesForNodeFiltered ;
                      sp:subject [
                          sp:varName "resource" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "ps" ;
                        ] ;
                      sp:predicate sh:property ;
                      sp:subject [
                          sp:varName "shape" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "inversePath" ;
                        ] ;
                      sp:predicate sh:path ;
                      sp:subject [
                          sp:varName "ps" ;
                        ] ;
                    ]
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:isBlank ;
                          sp:arg1 [
                              sp:varName "inversePath" ;
                            ] ;
                        ] ;
                    ]
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:exists ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "anyGroup" ;
                                  ] ;
                                sp:predicate sh:group ;
                                sp:subject [
                                    sp:varName "ps" ;
                                  ] ;
                              ]
                            ) ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "predicate" ;
                        ] ;
                      sp:predicate sh:inversePath ;
                      sp:subject [
                          sp:varName "inversePath" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to look for." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The (object) resource." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Can be used as filter function in swa:SubjectsGroup to suppress an \"Incoming References\" widget for properties already inserted via SHACL property groups." ;
  rdfs:label "is not used in inverse path" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isNumericDatatype
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  sp:object swa:NumericDatatype ;
                  sp:predicate rdf:type ;
                  sp:subject [
                      sp:varName "node" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:node ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node to check." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given node is a numeric datatype. The numeric types are marked with the class swa:NumericDatatype in the UI graph." ;
  rdfs:label "is numeric datatype" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isOntologyResource
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:or ;
                    sp:arg1 [
                        rdf:type spl:instanceOf ;
                        sp:arg1 [
                            sp:varName "resource" ;
                          ] ;
                        sp:arg2 rdfs:Class ;
                      ] ;
                    sp:arg2 [
                        rdf:type spl:instanceOf ;
                        sp:arg1 [
                            sp:varName "resource" ;
                          ] ;
                        sp:arg2 rdf:Property ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type spl:instanceOf ;
                    sp:arg1 [
                        sp:varName "resource" ;
                      ] ;
                    sp:arg2 sh:Shape ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given resource is an \"ontology resource\", which is either a class, property or shape. This can be used to determine whether a resource should become editable on a form, depending on whether the current vocabulary is supposed to only contain individuals." ;
  rdfs:label "is ontology resource" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isPropertyAxiomProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:exists ;
                sp:elements (
                    [
                      rdf:type sp:NamedGraph ;
                      sp:elements (
                          [
                            sp:object swa:PropertyAxiomProperty ;
                            sp:predicate rdf:type ;
                            sp:subject [
                                sp:varName "predicate" ;
                              ] ;
                          ]
                        ) ;
                      sp:graphNameNode ui:graph ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:comment "Checks whether a given property has been marked as swa:PropertyAxiomProperty." ;
  rdfs:label "is property axiom property" ;
  rdfs:subClassOf swa:PropertyWidgetGroupFilterFunctions ;
.
swa:isReadOnlyTriple
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type spif:isReadOnlyTriple ;
                sp:arg1 spin:_arg1 ;
                sp:arg2 spin:_arg2 ;
                sp:arg3 spin:_arg3 ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg3 ;
      rdfs:comment "The object." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given subject/predicate/object combination is a read-only triple. All parameters must be present, i.e. no wild-card matching is supported. For the current framework, triples are marked as read-only by the corresponding spif:isReadOnlyTriple function (that in turn may look at the local installation, workspace etc)." ;
  rdfs:label "is read only triple" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isResourceEnumeration
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "list" ;
              ] ;
            sp:predicate owl:oneOf ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            sp:object owl:Class ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node to test." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Tests if a given range is a class with an owl:oneOf enumeration." ;
  rdfs:label "is resource enumeration" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isSingle
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:not ;
                sp:arg1 [
                    rdf:type swa:isMulti ;
                    arg:property [
                        sp:varName "predicate" ;
                      ] ;
                    arg:subject [
                        sp:varName "subject" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject - may be unbound to fall back to the subjectType." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the local range of." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given subject/predicate combination can have at most one value, according to the ontology. If subject isn't given then this function falls back to a provided subjectType class. The function will return true if the property is owl:FunctionalProperty, or if the maxCardinality is 1 or if it has an spl:Argument." ;
  rdfs:label "is single" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isSingleInverse
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNodeFiltered ;
            sp:subject [
                sp:varName "object" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "ps" ;
              ] ;
            sp:predicate sh:property ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "path" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "ps" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate sh:inversePath ;
            sp:subject [
                sp:varName "path" ;
              ] ;
          ]
          [
            sp:object 1 ;
            sp:predicate sh:maxCount ;
            sp:subject [
                sp:varName "ps" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:isBlank ;
                sp:arg1 [
                    sp:varName "path" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object (resource)." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to check." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Similar to swa:isSingle but for an inverse property and only based on sh:maxCount 1." ;
  rdfs:label "is single inverse" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isValidObjectForPredicateAtSubject
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "shape" ;
                        ] ;
                      sp:predicate swa:shapesForNodeFiltered ;
                      sp:subject [
                          sp:varName "subject" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "propertyShape" ;
                        ] ;
                      sp:predicate sh:property ;
                      sp:subject [
                          sp:varName "shape" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "predicate" ;
                        ] ;
                      sp:predicate sh:path ;
                      sp:subject [
                          sp:varName "propertyShape" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "not" ;
                        ] ;
                      sp:predicate sh:not ;
                      sp:subject [
                          sp:varName "propertyShape" ;
                        ] ;
                    ]
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type tosh:hasShape ;
                          sp:arg1 [
                              sp:varName "object" ;
                            ] ;
                          sp:arg2 [
                              sp:varName "not" ;
                            ] ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:object ;
      rdfs:comment "The object to check." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The predicate to check." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to check at." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given node would be a valid object for a given subject/predicate combination, based on SHACL constraints. This will walk through all applicable property constraints at shapes that have the subject in its target. From those, it will currently only look for sh:not shapes." ;
  rdfs:label "is valid object for predicate at subject" ;
  rdfs:subClassOf swa:Functions ;
.
swa:labelExistsPreCondition
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 spin:_arg1 ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:eq ;
                    sp:arg1 [
                        rdf:type fn:string-length ;
                        sp:arg1 spin:_arg1 ;
                      ] ;
                    sp:arg2 0 ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression "Missing label." ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "Can be used in ui:preCondition to check whether a given input string exists and is not empty." ;
  rdfs:label "label exists pre condition" ;
  rdfs:subClassOf swa:Functions ;
.
swa:labelInGraph
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type ui:label ;
                      sp:arg1 [
                          sp:varName "resource" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "label" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "resourceGraph" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph to operate on." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Calls ui:label in the context of a given graph." ;
  rdfs:label "label in graph" ;
  rdfs:subClassOf swa:Functions ;
.
swa:languageCode
  rdf:type rdf:Property ;
  rdfs:comment "The two-letter language code for a language associated with a Country." ;
  rdfs:domain swa:Country ;
  rdfs:label "language code" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:letters
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "letter" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression "ABCDEFGHIJKLMNOPQRSTUVWXYZ" ;
            sp:variable [
                sp:varName "str" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type fn:string-length ;
                sp:arg1 [
                    sp:varName "str" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "length" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate spif:for ;
            sp:subject [
                sp:varName "x" ;
              ] ;
          ]
          [
            sp:object 1 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "length" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type fn:substring ;
                sp:arg1 [
                    sp:varName "str" ;
                  ] ;
                sp:arg2 [
                    sp:varName "x" ;
                  ] ;
                sp:arg3 1 ;
              ] ;
            sp:variable [
                sp:varName "letter" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "Binds the variable on the left with all letters from A-Z." ;
  rdfs:label "letters" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:lineBreak
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression """
""" ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Produces a line break (\\n) character." ;
  rdfs:label "line break" ;
  rdfs:subClassOf swa:Functions ;
.
swa:listMemberShape
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "result" ;
              ] ;
            sp:predicate sh:property ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "list" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "result" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "zeroOrMore" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "list" ;
              ] ;
          ]
          [
            sp:object rdf:rest ;
            sp:predicate sh:zeroOrMorePath ;
            sp:subject [
                sp:varName "zeroOrMore" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "first" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "list" ;
              ] ;
          ]
          [
            sp:object rdf:first ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "first" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "first" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:propertyShape ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The property shape to get the list member shape of." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType sh:PropertyShape ;
  rdfs:comment "For a given property shape, this function returns a nested sh:property shape on rdf:rest*/rdf:first if such a thing exists." ;
  rdfs:label "list member shape" ;
  rdfs:subClassOf swa:Functions ;
.
swa:listMemberType
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNodeFiltered ;
            sp:subject [
                sp:varName "subject" ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "propertyShape" ;
              ] ;
            sp:path [
                rdf:type sp:AltPath ;
                sp:path1 sh:property ;
                sp:path2 sh:parameter ;
              ] ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "nested" ;
              ] ;
            sp:predicate sh:property ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "sequence" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "nested" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "first" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "sequence" ;
              ] ;
          ]
          [
            sp:object rdf:rest ;
            sp:predicate sh:zeroOrMorePath ;
            sp:subject [
                sp:varName "first" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "rest" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "sequence" ;
              ] ;
          ]
          [
            sp:object rdf:first ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "rest" ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "result" ;
              ] ;
            sp:path [
                rdf:type sp:AltPath ;
                sp:path1 sh:datatype ;
                sp:path2 sh:class ;
              ] ;
            sp:subject [
                sp:varName "nested" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The rdf:List-valued property." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to get the member type of." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the declared type of list members for a given rdf:List-valued property at a given subject. This looks for SHACL patterns, currently limited to sh:property rdf:rest*/rdf:first combined with sh:datatype or sh:class." ;
  rdfs:label "list member type" ;
  rdfs:subClassOf swa:Functions ;
.
swa:localDomain
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "domain" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "shape" ;
                      ] ;
                    sp:predicate swa:shapesForNodeFiltered ;
                    sp:subject [
                        sp:varName "object" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "ps" ;
                      ] ;
                    sp:predicate sh:property ;
                    sp:subject [
                        sp:varName "shape" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "path" ;
                      ] ;
                    sp:predicate sh:path ;
                    sp:subject [
                        sp:varName "ps" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "predicate" ;
                      ] ;
                    sp:predicate sh:inversePath ;
                    sp:subject [
                        sp:varName "path" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "domain" ;
                      ] ;
                    sp:predicate sh:class ;
                    sp:subject [
                        sp:varName "ps" ;
                      ] ;
                  ]
                )
                (
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "p" ;
                      ] ;
                    sp:path [
                        rdf:type sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subPropertyOf ;
                      ] ;
                    sp:subject [
                        sp:varName "predicate" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "domain" ;
                      ] ;
                    sp:predicate rdfs:domain ;
                    sp:subject [
                        sp:varName "p" ;
                      ] ;
                  ]
                )
                (
                  [
                    rdf:type sp:Bind ;
                    sp:expression rdfs:Resource ;
                    sp:variable [
                        sp:varName "domain" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object resource." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the domain of." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdfs:Class ;
  rdfs:comment "Gets the \"domain\" of a property at an object. This is used to narrow down the Subjects widgets at edit time. Currently only uses rdfs:domain of the property and, if present, the sh:class at a property shape that has the given predicate as its sh:inversePath." ;
  rdfs:label "local domain" ;
  rdfs:subClassOf swa:Functions ;
.
swa:localRange
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:resourceType ;
                arg:resource [
                    sp:varName "subject" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "subjectType" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:localRangeAtClass ;
                arg:class [
                    sp:varName "subjectType" ;
                  ] ;
                arg:property [
                    sp:varName "predicate" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "raw" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:or ;
                    sp:arg1 [
                        rdf:type sp:or ;
                        sp:arg1 [
                            rdf:type sp:isIRI ;
                            sp:arg1 [
                                sp:varName "raw" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            rdf:type swa:isDatatypeEnumeration ;
                            arg:resource [
                                sp:varName "raw" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type swa:isResourceEnumeration ;
                        arg:resource [
                            sp:varName "raw" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    sp:varName "raw" ;
                  ] ;
                sp:arg3 rdfs:Resource ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject - may be unbound to fall back to the subjectType." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the local range of." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Computes the local range of a property at a given subject. This uses swa:localRangeAtClass for the actual work, but falls back to rdfs:Resource if needed. In other words, this function will always return a result. Blank node ranges are only supported if they are enumerations, but owl:unionOf ranges are mapped to rdfs:Resource." ;
  rdfs:label "local range" ;
  rdfs:subClassOf swa:Functions ;
.
swa:localRangeAtClass
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:coalesce ;
                sp:arg1 [
                    rdf:type spif:walkObjects ;
                    sp:arg1 [
                        sp:varName "class" ;
                      ] ;
                    sp:arg2 rdfs:subClassOf ;
                    sp:arg3 swa:allValuesFromFunctor ;
                    sp:arg4 [
                        sp:varName "property" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type spif:walkObjects ;
                    sp:arg1 [
                        sp:varName "class" ;
                      ] ;
                    sp:arg2 rdfs:subClassOf ;
                    sp:arg3 swa:splValueTypeFunctor ;
                    sp:arg4 [
                        sp:varName "property" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    rdf:type swa:globalRange ;
                    arg:property [
                        sp:varName "property" ;
                      ] ;
                  ] ;
                sp:arg4 [
                    rdf:type swa:defaultRange ;
                    arg:property [
                        sp:varName "property" ;
                      ] ;
                  ] ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to start traversal at." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the local range of." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdfs:Resource ;
  rdfs:comment """Checks (in that order) for declared SHACL sh:class/sh:datatype constraints (including those from sh:or and sh:node dash:ListShape for rdf:Lists), owl:allValuesFrom restrictions in superclasses, spl:valueType in SPIN constraints (spl:Argument and spl:Attribute) and finally rdfs:range at the property. It falls back to swa:defaultRange if nothing else is found.

Note that TopBraid Suite uses a native (optimized) implementation of this function, i.e. the SPIN body is never called when used inside of TopBraid Suite and the SPIN body has a slightly different behavior.""" ;
  rdfs:label "local range at class" ;
  rdfs:subClassOf swa:Functions ;
.
swa:localUnionRangeAtClass
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to start traversal at." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the local range of." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given class has multiple \"ranges\" for a given property, defined via sh:or constraints at the nearest shape, and returns that sh:or if it does. Otherwise, returns nothing." ;
  rdfs:label "local union range at class" ;
  rdfs:subClassOf swa:Functions ;
.
swa:matchingArgumentPredicate
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            sp:varName "predicate" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "predicate" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "arg" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "module" ;
              ] ;
          ]
          [
            sp:object spl:Argument ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "arg" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "argValueType" ;
              ] ;
            sp:predicate spl:valueType ;
            sp:subject [
                sp:varName "arg" ;
              ] ;
          ]
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:TriplePath ;
                  sp:object [
                      sp:varName "argValueType" ;
                    ] ;
                  sp:path [
                      rdf:type sp:ModPath ;
                      sp:modMax -2 ;
                      sp:modMin 0 ;
                      sp:subPath rdfs:subClassOf ;
                    ] ;
                  sp:subject [
                      sp:varName "valueType" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "valueTypeGraph" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate spl:predicate ;
            sp:subject [
                sp:varName "arg" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:module ;
      spl:valueType spin:Module ;
      rdfs:comment "The SPIN module to query." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:valueType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The value type to match." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:valueTypeGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph containing the type declaration of the valueType, e.g. subclasses of skos:Concept." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdf:Property ;
  rdfs:comment "Walks through all declared arguments of a given SPIN module (e.g. SPIN Template or SM function) and compares the value type with a given type. The function returns the first argument where the type could be used as value." ;
  rdfs:label "matching argument predicate" ;
  rdfs:subClassOf swa:Functions ;
.
swa:newResource
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:coalesce ;
                sp:arg1 [
                    rdf:type swa:newResourceByIndex ;
                    arg:resourceType [
                        sp:varName "resourceType" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type swa:newResourceByUUID ;
                    arg:resourceType [
                        sp:varName "resourceType" ;
                      ] ;
                  ] ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the new resource." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Produces a suggestion for a URI for a new resource. This first tries to produce a unique URI by appending a number behind a base URI. If that fails, it uses a UUID." ;
  rdfs:label "new resource" ;
  rdfs:subClassOf swa:Functions ;
.
swa:newResourceByIndex
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:getDefaultNamespace ;
              ] ;
            sp:variable [
                sp:varName "base" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type afn:localname ;
                sp:arg1 [
                    sp:varName "resourceType" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "name" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate spif:for ;
            sp:subject [
                sp:varName "index" ;
              ] ;
          ]
          [
            sp:object 0 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object 9999 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:iri ;
                sp:arg1 [
                    rdf:type fn:concat ;
                    sp:arg1 [
                        rdf:type xsd:string ;
                        sp:arg1 [
                            sp:varName "base" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        sp:varName "name" ;
                      ] ;
                    sp:arg3 "_" ;
                    sp:arg4 [
                        sp:varName "index" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "anyType" ;
                        ] ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "result" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the new resource." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Produces a suggestion for a URI for a new resource. This uses the declared default namespace as base, and then adds the type local name and then a running number. The function makes sure that the URI is not used in the current model yet." ;
  rdfs:label "new resource by index" ;
  rdfs:subClassOf swa:Functions ;
.
swa:newResourceByLabel
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          (
            [
              rdf:type sp:Bind ;
              sp:expression [
                  rdf:type swa:getDefaultNamespace ;
                ] ;
              sp:variable [
                  sp:varName "base" ;
                ] ;
            ]
            [
              rdf:type sp:Filter ;
              sp:expression [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "base" ;
                    ] ;
                ] ;
            ]
          )
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "base" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:encode_for_uri ;
                    sp:arg1 [
                        sp:varName "label" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "name" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate spif:for ;
            sp:subject [
                sp:varName "index" ;
              ] ;
          ]
          [
            sp:object 0 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object 9999 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:iri ;
                sp:arg1 [
                    rdf:type sp:if ;
                    sp:arg1 [
                        rdf:type sp:eq ;
                        sp:arg1 [
                            sp:varName "index" ;
                          ] ;
                        sp:arg2 0 ;
                      ] ;
                    sp:arg2 [
                        sp:varName "name" ;
                      ] ;
                    sp:arg3 [
                        rdf:type sp:concat ;
                        sp:arg1 [
                            sp:varName "name" ;
                          ] ;
                        sp:arg2 "_" ;
                        sp:arg3 [
                            rdf:type sp:str ;
                            sp:arg1 [
                                sp:varName "index" ;
                              ] ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "anyType" ;
                        ] ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "result" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The label as entered by a user." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Produces a suggestion for a URI for a new resource. This uses the default namespace as base, and then adds a URI-encoded label and then a running number. The function makes sure that the URI is not used in the current model yet." ;
  rdfs:label "new resource by label" ;
  rdfs:subClassOf swa:Functions ;
.
swa:newResourceByUUID
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:getDefaultNamespace ;
              ] ;
            sp:variable [
                sp:varName "base" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:coalesce ;
                sp:arg1 [
                    rdf:type afn:localname ;
                    sp:arg1 [
                        sp:varName "resourceType" ;
                      ] ;
                  ] ;
                sp:arg2 "Thing" ;
              ] ;
            sp:variable [
                sp:varName "name" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:iri ;
                sp:arg1 [
                    rdf:type sp:concat ;
                    sp:arg1 [
                        rdf:type sp:str ;
                        sp:arg1 [
                            sp:varName "base" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        sp:varName "name" ;
                      ] ;
                    sp:arg3 "_" ;
                    sp:arg4 [
                        rdf:type spif:generateUUID ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the new resource." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Produces a suggestion for a URI for a new resource. This uses the URI of the main owl:Ontology as base, and then adds the type local name and then a UUID." ;
  rdfs:label "new resource by UUID" ;
  rdfs:subClassOf swa:Functions ;
.
swa:nonAbstractClassPreCondition
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type swa:isAbstractClass ;
                arg:class spin:_arg1 ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression "Cannot create instance of abstract class." ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the new resource" ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "Can be used in ui:preCondition to check whether a given class is not abstract." ;
  rdfs:label "non abstract class pre condition" ;
  rdfs:subClassOf swa:Functions ;
.
swa:nonEmptyPrimaryKeyPreCondition
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          (
            [
              rdf:type sp:Filter ;
              sp:expression [
                  rdf:type swa:hasPrimaryKey ;
                  arg:class [
                      sp:varName "resourceType" ;
                    ] ;
                ] ;
            ]
          )
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:primaryKeyURIStart ;
                arg:class [
                    sp:varName "resourceType" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "uriStart" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:eq ;
                sp:arg1 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "uri" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    sp:varName "uriStart" ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression "Missing primary key value" ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the resource." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:uri ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI to check." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "Can be used in ui:preCondition to check whether a given URI is different from the uri start (if a primary key has been set)." ;
  rdfs:subClassOf swa:Functions ;
.
swa:object
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:bound ;
                    sp:arg1 spin:_arg1 ;
                  ] ;
                sp:arg2 [
                    rdf:type spl:object ;
                    sp:arg1 spin:_arg1 ;
                    sp:arg2 [
                        sp:varName "predicate" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "nothing" ;
                  ] ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:comment "Gets the best matching object for a given subject/predicate combination. Returns nothing if the subject (?arg1) is unbound." ;
  rdfs:label "object" ;
  rdfs:subClassOf swa:Functions ;
.
swa:objectsList
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to get the objects of." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the objects of." ;
    ] ;
  rdfs:comment "Collects all values (objects) of a given subject/predicate combination into a single string list, separated by commas. If there is just a single literal value, then return that value in the original data type. Used by SWA search forms to display optional (key) columns." ;
  rdfs:label "objects list" ;
  rdfs:subClassOf swa:Functions ;
  owl:versionInfo """An approximate implementation of this is

SELECT ((GROUP_CONCAT(?label; SEPARATOR=', ')) AS ?result)
WHERE {
    ( ?arg1 ?arg2 ) swa:orderedObjectLabels ?label .
}
ORDER BY (?label)

but it needs to return the original datatype (not a string) if there is just a single value.""" ;
.
swa:orderedObjectLabels
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate spin:_arg2 ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:label ;
                sp:arg1 [
                    sp:varName "value" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to get the objects of." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate" ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "Produces an ordered iterator over the ui:labels of the objects of a given subject/predicate combination. This is required by swa:objectsList because the GROUP_CONCAT is applied before ORDER BY (probably a Jena bug)." ;
  rdfs:label "ordered object labels" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:orderedSubjectLabels
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate spin:_arg2 ;
            sp:subject [
                sp:varName "value" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:label ;
                sp:arg1 [
                    sp:varName "value" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object to get the subjects of." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate" ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "Produces an ordered iterator over the ui:labels of the subjects of a given object/predicate combination. This is required by swa:subjectsList because the GROUP_CONCAT is applied before ORDER BY (probably a Jena bug)." ;
  rdfs:label "ordered subject labels" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:owlMaxCardinality
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "c" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "superClass" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate owl:onProperty ;
            sp:subject [
                sp:varName "superClass" ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "c" ;
              ] ;
            sp:path [
                rdf:type sp:AltPath ;
                sp:path1 owl:cardinality ;
                sp:path2 owl:maxCardinality ;
              ] ;
            sp:subject [
                sp:varName "superClass" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get cardinality at." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the cardinality of." ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Walks up the class tree to find the closest owl:maxCardinality or owl:cardinality restriction on a given property." ;
  rdfs:label "owl max cardinality" ;
  rdfs:subClassOf swa:Functions ;
.
swa:predicatesInGroup
  rdf:type spin:MagicProperty ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The focus node or unbound." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType sh:PropertyGroup ;
      rdfs:comment "The property group to get the predicate of." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:comment """Gets all predicates that are in a given group (?arg1) at a given focus node (?arg2). If no focus node is given, it will use the context variable that is also used by swa:resourceType(). The right hand side must be a list of three unbound variables - the first will contain the predicate, the second the predicate's label and the third is a boolean that is true if the path was walked in inverse direction.

This magic property is implemented natively by TopBraid for performance reasons.""" ;
  rdfs:label "predicates in group" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:primaryKeyProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "type" ;
                      ] ;
                    sp:path [
                        rdf:type sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "constraint" ;
                      ] ;
                    sp:predicate spin:constraint ;
                    sp:subject [
                        sp:varName "type" ;
                      ] ;
                  ]
                  [
                    sp:object spl:PrimaryKeyPropertyConstraint ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "constraint" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate arg:property ;
                    sp:subject [
                        sp:varName "constraint" ;
                      ] ;
                  ]
                )
                (
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "type" ;
                      ] ;
                    sp:path [
                        rdf:type sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "ps" ;
                      ] ;
                    sp:predicate sh:property ;
                    sp:subject [
                        sp:varName "type" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "uriStart" ;
                      ] ;
                    sp:predicate dash:uriStart ;
                    sp:subject [
                        sp:varName "ps" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate sh:path ;
                    sp:subject [
                        sp:varName "ps" ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:isIRI ;
                        sp:arg1 [
                            sp:varName "property" ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the primary key of." ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment "Gets the primary key property for a given class or its superclasses - either defined using SPIN or DASH." ;
  rdfs:label "primary key property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:primaryKeyURIStart
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "uriStart" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "type" ;
                      ] ;
                    sp:path [
                        rdf:type sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "constraint" ;
                      ] ;
                    sp:predicate spin:constraint ;
                    sp:subject [
                        sp:varName "type" ;
                      ] ;
                  ]
                  [
                    sp:object spl:PrimaryKeyPropertyConstraint ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "constraint" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "uriStart" ;
                      ] ;
                    sp:predicate arg:uriStart ;
                    sp:subject [
                        sp:varName "constraint" ;
                      ] ;
                  ]
                )
                (
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "type" ;
                      ] ;
                    sp:path [
                        rdf:type sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "ps" ;
                      ] ;
                    sp:predicate sh:property ;
                    sp:subject [
                        sp:varName "type" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "uriStart" ;
                      ] ;
                    sp:predicate dash:uriStart ;
                    sp:subject [
                        sp:varName "ps" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the primary key of." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the URI start of the primary key for a given class or its superclasses - either defined using SPIN or DASH." ;
  rdfs:label "primary key URI start" ;
  rdfs:subClassOf swa:Functions ;
.
swa:propertyCommentAtNode
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the comment of." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:type ;
      rdfs:comment "The node for the context." ;
    ] ;
  rdfs:comment "Gets the display comment of a property in the context of a given node, falling back to swa:resourceType() if no node is provided. This is usually the rdfs:comment of the property but may be the sh:description if a suitable shape exists. This function is natively implemented for performance reasons." ;
  rdfs:label "property comment at class or shape" ;
  rdfs:subClassOf swa:Functions ;
.
swa:propertyEditWidget
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:propertyShapePropertyAtNode ;
                arg:predicate [
                    sp:varName "property" ;
                  ] ;
                arg:property tosh:editWidget ;
                arg:resource [
                    sp:varName "focusNode" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:focusNode ;
      rdfs:comment "The focus node." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the widget for." ;
    ] ;
  rdfs:comment "Gets a tosh:editWidget defined for a given property at a given focus node." ;
  rdfs:label "property edit widget" ;
  rdfs:subClassOf swa:Functions ;
.
swa:propertyGroupsForNode
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:resultVariables (
          [
            sp:varName "group" ;
          ]
        ) ;
      sp:where (
          (
            [
              sp:object [
                  sp:varName "shape" ;
                ] ;
              sp:predicate swa:shapesForNodeFiltered ;
              sp:subject spin:_arg1 ;
            ]
            [
              rdf:type sp:TriplePath ;
              sp:object [
                  sp:varName "propertyShape" ;
                ] ;
              sp:path [
                  rdf:type sp:AltPath ;
                  sp:path1 sh:property ;
                  sp:path2 sh:parameter ;
                ] ;
              sp:subject [
                  sp:varName "shape" ;
                ] ;
            ]
          )
          [
            sp:object [
                sp:varName "group" ;
              ] ;
            sp:predicate sh:group ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:not ;
                sp:arg1 [
                    rdf:type dash:isDeactivated ;
                    sp:arg1 [
                        sp:varName "propertyShape" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the property groups for." ;
    ] ;
  spin:returnType sh:PropertyGroup ;
  rdfs:comment "Gets all sh:PropertyGroups associated with a given node via property constraints, falling back to swa:resourceType() if no node is provided. This is walking up the class hierarchy for any shapes that are in target, then walks the property constraint and parameter declarations of these shapes to find sh:groups." ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:propertyLabelAtClassOrShape
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdfs:Property ;
      rdfs:comment "The property to get the label of." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:theClassOrShape ;
      rdfs:comment "The class/shape for the context." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the display label of a property in the context of a given class or shape. This is usually the rdfs:label of the property but may be the sh:name if a suitable shape exists. This function is natively implemented for performance reasons." ;
  rdfs:subClassOf swa:Functions ;
.
swa:propertyLabelAtNode
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The focus node, for context." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the display label of a property in the context of a given node, falling back to swa:resourceType() if no node is given. This is usually the rdfs:label of the property but may be the sh:name if a suitable shape exists. This function is natively implemented for performance reasons." ;
  rdfs:subClassOf swa:Functions ;
.
swa:propertyShapePropertyAtClass
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "value" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForType ;
            sp:subject [
                sp:varName "resourceType" ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "propertyShape" ;
              ] ;
            sp:path [
                rdf:type sp:AltPath ;
                sp:path1 sh:property ;
                sp:path2 sh:parameter ;
              ] ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:cachableForOntologies "true"^^xsd:boolean ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The constrained property (value of sh:predicate)." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get, e.g. sh:order." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class." ;
    ] ;
  rdfs:comment "Gets the \"first\" value of a given property (such as sh:name) from all shapes associated with a given shape or class." ;
  rdfs:subClassOf swa:Functions ;
.
swa:propertyShapePropertyAtNode
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "value" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNode ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "propertyShape" ;
              ] ;
            sp:path [
                rdf:type sp:AltPath ;
                sp:path1 sh:property ;
                sp:path2 sh:parameter ;
              ] ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node or unbound." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The constrained property (value of sh:predicate)." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get, e.g. sh:order." ;
    ] ;
  rdfs:comment "Gets the \"first\" value of a given property (such as sh:name) from all shapes associated with a given focus node. If the focus node is unbound (e.g. in search forms), this falls back to the swa:resourceTypes." ;
  rdfs:subClassOf swa:Functions ;
.
swa:propertyViewWidget
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:propertyShapePropertyAtNode ;
                arg:predicate [
                    sp:varName "property" ;
                  ] ;
                arg:property tosh:viewWidget ;
                arg:resource [
                    sp:varName "focusNode" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:focusNode ;
      rdfs:comment "The focus node." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the widget for." ;
    ] ;
  rdfs:comment "Gets a tosh:viewWidget defined for a given property at a given focus node." ;
  rdfs:label "property view widget" ;
  rdfs:subClassOf swa:Functions ;
.
swa:relevantClassOfProperty
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "cls" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate swa:directRelevantClassOfProperty ;
            sp:subject [
                sp:varName "cls" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the properties of." ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment "Finds the properties that are attached to a given class or its superclasses." ;
  rdfs:label "relevant class of property" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:resourceType
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:coalesce ;
                sp:arg1 [
                    rdf:type ui:contextValue ;
                    sp:arg1 "resourceType" ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:if ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "resource" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:coalesce ;
                        sp:arg1 [
                            rdf:type spl:object ;
                            sp:arg1 [
                                sp:varName "resource" ;
                              ] ;
                            sp:arg2 rdf:type ;
                          ] ;
                        sp:arg2 rdfs:Resource ;
                      ] ;
                    sp:arg3 rdfs:Resource ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource (may be unbound)." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdfs:Class ;
  rdfs:comment "Gets a valid rdf:type for a given resource. If the context variable 'resourceType' is bound, then return that. Otherwise return the 'first' rdf:type of ?resource. As a fall-back, always use rdfs:Resource." ;
  rdfs:label "resource type" ;
  rdfs:subClassOf swa:Functions ;
.
swa:resourceTypes
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  (
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:and ;
                          sp:arg1 [
                              rdf:type sp:bound ;
                              sp:arg1 spin:_arg1 ;
                            ] ;
                          sp:arg2 [
                              rdf:type sp:exists ;
                              sp:elements (
                                  [
                                    sp:object [
                                        sp:varName "any" ;
                                      ] ;
                                    sp:predicate rdf:type ;
                                    sp:subject spin:_arg1 ;
                                  ]
                                ) ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "result" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject spin:_arg1 ;
                  ]
                )
                (
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:or ;
                        sp:arg1 [
                            rdf:type sp:not ;
                            sp:arg1 [
                                rdf:type sp:bound ;
                                sp:arg1 spin:_arg1 ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            rdf:type sp:notExists ;
                            sp:elements (
                                [
                                  sp:object [
                                      sp:varName "any" ;
                                    ] ;
                                  sp:predicate rdf:type ;
                                  sp:subject spin:_arg1 ;
                                ]
                              ) ;
                          ] ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type sp:coalesce ;
                        sp:arg1 [
                            rdf:type ui:contextValue ;
                            sp:arg1 "resourceType" ;
                          ] ;
                        sp:arg2 rdfs:Resource ;
                      ] ;
                    sp:variable [
                        sp:varName "result" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the types of, or unbound to fall back to the context value." ;
    ] ;
  spin:returnType rdfs:Class ;
  rdfs:comment "Gets all rdf:types of a resource. The resource may actually not be given (e.g. when we are populating a Search form), in which case it will try to find the value of the context variable \"resourceType\", which is set by the surrounding form. If none of these are present, it falls back to rdfs:Resource." ;
  rdfs:label "resource types" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:rootView
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "parent" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:TriplePath ;
                  sp:object [
                      sp:varName "view" ;
                    ] ;
                  sp:path [
                      rdf:type sp:ModPath ;
                      sp:modMax -2 ;
                      sp:modMin 0 ;
                      sp:subPath ui:child ;
                    ] ;
                  sp:subject [
                      sp:varName "parent" ;
                    ] ;
                ]
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type sp:notExists ;
                      sp:elements (
                          [
                            sp:object [
                                sp:varName "parent" ;
                              ] ;
                            sp:predicate ui:child ;
                            sp:subject [
                                sp:varName "another" ;
                              ] ;
                          ]
                        ) ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:view ;
      spl:valueType ui:Element ;
      rdfs:comment "The view to get the root of." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType ui:Element ;
  rdfs:comment "Walks up the child hierarchy of SWP nodes in the ui:graph until it finds no further parent for the provided view." ;
  rdfs:label "root view" ;
  rdfs:subClassOf swa:Functions ;
.
swa:shapesForNode
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:resultVariables (
          [
            sp:varName "shape" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:predicate swa:resourceTypes ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForType ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node." ;
    ] ;
  spin:returnType sh:Shape ;
  rdfs:comment "Gets all sh:Shapes associated with a given (focus) node. This is looking at the swa:resourceTypes of the node and then walks up the class hierarchy and collects all classes that are also instances of sh:Shape, and any shapes declared using sh:targetClass. Future versions will also be looking for sh:targetObjectsOf triples." ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:shapesForNodeFiltered
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:resultVariables (
          [
            sp:varName "shape" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNode ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:not ;
                sp:arg1 [
                    rdf:type dash:isDeactivated ;
                    sp:arg1 [
                        sp:varName "shape" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node." ;
    ] ;
  spin:returnType sh:Shape ;
  rdfs:comment "Same as swa:shapesForNode but only returning the non-deactivated shapes." ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:shapesForType
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:resultVariables (
          [
            sp:varName "shape" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "type" ;
                      ] ;
                    sp:predicate sh:targetClass ;
                    sp:subject [
                        sp:varName "shape" ;
                      ] ;
                  ]
                )
                (
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type spl:instanceOf ;
                        sp:arg1 [
                            sp:varName "type" ;
                          ] ;
                        sp:arg2 sh:Shape ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        sp:varName "type" ;
                      ] ;
                    sp:variable [
                        sp:varName "shape" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type to get the shapes for." ;
    ] ;
  spin:returnType sh:Shape ;
  rdfs:comment """Gets all sh:Shapes associated with a given type. This is walking up the class hierarchy and collects all classes that are also instances of sh:Shape, and any shapes declared using sh:targetClass.

In TopBraid, this magic property is implemented as a native Java function for performance reasons.""" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:singleParameter
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "predicate" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 sh:parameter ;
                sp:path2 sh:path ;
              ] ;
            sp:subject [
                sp:varName "component" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:and ;
                sp:arg1 [
                    rdf:type sp:isIRI ;
                    sp:arg1 [
                        sp:varName "predicate" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:notExists ;
                    sp:elements (
                        [
                          rdf:type sp:TriplePath ;
                          sp:object [
                              sp:varName "other" ;
                            ] ;
                          sp:path [
                              rdf:type sp:SeqPath ;
                              sp:path1 sh:parameter ;
                              sp:path2 sh:path ;
                            ] ;
                          sp:subject [
                              sp:varName "component" ;
                            ] ;
                        ]
                        [
                          rdf:type sp:Filter ;
                          sp:expression [
                              rdf:type sp:ne ;
                              sp:arg1 [
                                  sp:varName "other" ;
                                ] ;
                              sp:arg2 [
                                  sp:varName "predicate" ;
                                ] ;
                            ] ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:component ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The constraint component." ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment "Gets the predicate of the parameter if a constraint component has exactly one parameter." ;
  rdfs:label "single parameter" ;
  rdfs:subClassOf swa:Functions ;
.
swa:splArgumentOnProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "arg" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "superClass" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "arg" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "superClass" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spl:predicate ;
            sp:subject [
                sp:varName "arg" ;
              ] ;
          ]
          [
            sp:object spl:Argument ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "arg" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to start traversal at." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to look for." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType spl:Argument ;
  rdfs:comment "Walks up the class hierarchy to look for spl:Arguments on the property." ;
  rdfs:label "spl:Argument on property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:splValueTypeFunctor
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "valueType" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "constraint" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spl:predicate ;
            sp:subject [
                sp:varName "constraint" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "valueType" ;
              ] ;
            sp:predicate spl:valueType ;
            sp:subject [
                sp:varName "constraint" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to look for." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdfs:Class ;
  rdfs:comment "Can be used in conjunction with spif:walkObjects to get the \"first\" declared spin:constraint with an spl:valueType on a given spl:predicate (?property) at a given class (?class)." ;
  rdfs:label "spl:valueType functor" ;
  rdfs:subClassOf swa:ClassFunctorFunctions ;
.
swa:subjectsList
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:GroupConcat ;
                sp:expression [
                    sp:varName "label" ;
                  ] ;
                sp:separator ", " ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "label" ;
              ] ;
            sp:predicate swa:orderedSubjectLabels ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object to get the subjects of." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the objects of." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Collects all subjects of a given object/predicate combination into a single string list, separated by commas. Used by SWA search forms to display optional (key) columns." ;
  rdfs:label "subjects list" ;
  rdfs:subClassOf swa:Functions ;
.
swa:systemProperty
  rdf:type rdf:Property ;
  rdfs:label "system property" ;
.
swa:typesWithoutSuperclasses
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "type" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "otherType" ;
                        ] ;
                      sp:predicate rdf:type ;
                      sp:subject spin:_arg1 ;
                    ]
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:ne ;
                          sp:arg1 [
                              sp:varName "type" ;
                            ] ;
                          sp:arg2 [
                              sp:varName "otherType" ;
                            ] ;
                        ] ;
                    ]
                    [
                      rdf:type sp:TriplePath ;
                      sp:object [
                          sp:varName "type" ;
                        ] ;
                      sp:path [
                          rdf:type sp:ModPath ;
                          sp:modMax -2 ;
                          sp:modMin 1 ;
                          sp:subPath rdfs:subClassOf ;
                        ] ;
                      sp:subject [
                          sp:varName "otherType" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject resource." ;
    ] ;
  rdfs:comment "For a given resource (left hand side), this returns all direct rdf:types (right hand side), dropping any types that are superclasses of these direct types. For example, if a property has rdf:types owl:AnnotationProperty and rdf:Property, then the rdf:Property triple will not be returned because rdf:Property is a super-property of owl:AnnotationProperty." ;
  rdfs:label "types without superclasses" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:uiObject
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "object" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type spl:object ;
                      sp:arg1 spin:_arg1 ;
                      sp:arg2 spin:_arg2 ;
                    ] ;
                  sp:variable [
                      sp:varName "object" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate." ;
    ] ;
  rdfs:comment "Similar to spl:object, but executed within the ui:graph." ;
  rdfs:label "ui object" ;
  rdfs:subClassOf swa:Functions ;
.
swa:unusedURIPreCondition
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "message" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:exists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "o" ;
                            ] ;
                          sp:predicate [
                              sp:varName "p" ;
                            ] ;
                          sp:subject [
                              sp:varName "resource" ;
                            ] ;
                        ]
                      ) ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:exists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "resource" ;
                            ] ;
                          sp:predicate [
                              sp:varName "p" ;
                            ] ;
                          sp:subject [
                              sp:varName "s" ;
                            ] ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type fn:concat ;
                sp:arg1 "The URI " ;
                sp:arg2 [
                    rdf:type xsd:string ;
                    sp:arg1 [
                        sp:varName "resource" ;
                      ] ;
                  ] ;
                sp:arg3 " is already used." ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to check." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Can be used in conjunction with ui:preCondition to check whether a given URI has already been used in the current query graph." ;
  rdfs:label "unused URIPre condition" ;
  rdfs:subClassOf swa:Functions ;
.
swa:unwrap
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:substr ;
                sp:arg1 [
                    sp:varName "string" ;
                  ] ;
                sp:arg2 2 ;
                sp:arg3 [
                    rdf:type sp:sub ;
                    sp:arg1 [
                        rdf:type sp:strlen ;
                        sp:arg1 [
                            sp:varName "string" ;
                          ] ;
                      ] ;
                    sp:arg2 2 ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:string ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes a string such as <http://example.org> and returns the substring between the first and the last character, e.g. http://example.org" ;
  rdfs:label "unwrap" ;
  rdfs:subClassOf swa:Functions ;
.
swa:validURIPreCondition
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:not ;
                sp:arg1 [
                    rdf:type spif:isValidURI ;
                    sp:arg1 spin:_arg1 ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type fn:concat ;
                sp:arg1 "Not a well-formed absolute URI: " ;
                sp:arg2 spin:_arg1 ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The argument string." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Can be used with ui:preCondition to check whether a given string is a valid URI." ;
  rdfs:label "valid URI pre-condition" ;
  rdfs:subClassOf swa:Functions ;
.
<http://topbraid.org/swa.spin>
  rdf:type owl:Ontology ;
  rdfs:comment "A collection of SPIN functions and auxiliary definitions to support building interactive web applications." ;
  rdfs:label "SWA SPIN Modules" ;
  owl:imports <http://datashapes.org/dash> ;
  owl:imports <http://spinrdf.org/spl> ;
  owl:imports <http://uispin.org/ui> ;
.
rdf:
  rdfs:label "RDF" ;
.
rdfs:
  rdfs:label "RDF Schema" ;
.
rdfs:domain
  rdf:type swa:PropertyAxiomProperty ;
.
rdfs:range
  rdf:type swa:PropertyAxiomProperty ;
.
rdfs:subClassOf
  rdf:type swa:ClassAxiomProperty ;
.
rdfs:subPropertyOf
  rdf:type swa:PropertyAxiomProperty ;
.
xsd:
  rdfs:label "XML Schema" ;
.
xsd:byte
  rdf:type swa:NumericDatatype ;
.
xsd:decimal
  rdf:type swa:NumericDatatype ;
.
xsd:double
  rdf:type swa:NumericDatatype ;
.
xsd:float
  rdf:type swa:NumericDatatype ;
.
xsd:int
  rdf:type swa:NumericDatatype ;
.
xsd:integer
  rdf:type swa:NumericDatatype ;
.
xsd:long
  rdf:type swa:NumericDatatype ;
.
xsd:negativeInteger
  rdf:type swa:NumericDatatype ;
.
xsd:nonNegativeInteger
  rdf:type swa:NumericDatatype ;
.
xsd:nonPositiveInteger
  rdf:type swa:NumericDatatype ;
.
xsd:positiveInteger
  rdf:type swa:NumericDatatype ;
.
xsd:short
  rdf:type swa:NumericDatatype ;
.
xsd:unsignedByte
  rdf:type swa:NumericDatatype ;
.
xsd:unsignedInt
  rdf:type swa:NumericDatatype ;
.
xsd:unsignedLong
  rdf:type swa:NumericDatatype ;
.
xsd:unsignedShort
  rdf:type swa:NumericDatatype ;
.
owl:
  rdfs:label "Web Ontology Language (OWL)" ;
.
owl:complementOf
  rdf:type swa:ClassAxiomProperty ;
.
owl:disjointUnionOf
  rdf:type swa:ClassAxiomProperty ;
.
owl:disjointWith
  rdf:type swa:ClassAxiomProperty ;
.
owl:equivalentClass
  rdf:type swa:ClassAxiomProperty ;
.
owl:equivalentProperty
  rdf:type swa:PropertyAxiomProperty ;
.
owl:hasKey
  rdf:type swa:ClassAxiomProperty ;
.
owl:intersectionOf
  rdf:type swa:ClassAxiomProperty ;
.
owl:inverseOf
  rdf:type swa:PropertyAxiomProperty ;
.
owl:oneOf
  rdf:type swa:ClassAxiomProperty ;
.
owl:propertyChainAxiom
  rdf:type swa:PropertyAxiomProperty ;
.
owl:propertyDisjointWith
  rdf:type swa:PropertyAxiomProperty ;
.
owl:unionOf
  rdf:type swa:ClassAxiomProperty ;
.
