# baseURI: http://topbraid.org/sparqlmotionlib-tb
# imports: http://datashapes.org/graphql
# imports: http://topbraid.org/email
# imports: http://topbraid.org/search
# imports: http://topbraid.org/sparqlmotionfunctions
# imports: http://topbraid.org/sparqlmotionlib-core
# imports: http://uispin.org/ui

@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sm: <http://topbraid.org/sparqlmotion#> .
@prefix smf: <http://topbraid.org/sparqlmotionfunctions#> .
@prefix sml: <http://topbraid.org/sparqlmotionlib#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix spl: <http://spinrdf.org/spl#> .
@prefix sxml: <http://topbraid.org/sxml#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

<http://spinrdf.org/arg#divider>
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
<http://spinrdf.org/arg#endIndex>
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
<http://spinrdf.org/arg#password>
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
<http://spinrdf.org/arg#sourceFilePath>
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
<http://spinrdf.org/arg#startIndex>
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
<http://spinrdf.org/arg#url>
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
<http://spinrdf.org/arg#userName>
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
sml:AddGraph
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:uri ;
      spl:valueType xsd:string ;
      rdfs:comment "The URI of the graph to add the triples to." ;
    ] ;
  rdfs:comment "Performs a bulk update in which all triples from the input graph are added to a given named graph." ;
  rdfs:label "Add graph" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:AddUserDictionaryWord
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:word ;
      spl:valueType xsd:string ;
      rdfs:comment "The word to add." ;
    ] ;
  rdfs:comment "Adds a given word to the user dictionary used for spell-checking (see sml:CheckSpelling)." ;
  rdfs:label "Add user dictionary word" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:BindByXPath
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue xsd:string ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:datatype ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "The datatype of the result variable (xsd:string if left blank)." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "value" ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the variable to bind." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:xml ;
      rdfs:comment "The XML document or node to operate on." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:xpath ;
      spl:valueType xsd:string ;
      rdfs:comment "The XPath to process." ;
    ] ;
  rdfs:comment "Evaluates an XPath on a given XML node (or document) and binds the first result to a given variable." ;
  rdfs:label "Bind by XPath" ;
  rdfs:subClassOf sml:XMLProcessingModules ;
.
sml:BindWithParameter
  rdf:type sm:Module ;
  rdf:type owl:DeprecatedClass ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:comment "Deprecated since 2.0.0: Web Services are now defined like user-defined functions and SPIN functions, and the parameters are instances of spl:Argument." ;
  rdfs:label "Bind with parameter" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:CheckSpelling
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:selectQuery ;
      spl:valueType sp:Select ;
      rdfs:comment "The SELECT query that delivers all the literals that shall be spell checked." ;
    ] ;
  rdfs:comment """Runs a SPARQL select query and binds result variables for each matching result set.  Strings bound to variables in the SELECT clause will be passed to a TBL spellchecker, which will parse the string into individual words and return triples representing each word from the string not in the dictionary.  Each word returned is represented as an instance of the class http://topbraid.org/spellcheckresults#SpellResult with properties inputString, foundError, mispelledWords, and suggestions, all with the same prefix as SpellResult, http://topbraid.org/spellcheckresults#. The value of the suggestions property is an rdf:Bag with five suggested replacements for the word. In the checked content, terms in all upper-case such as acronyms are ignored.

The spellcheck dictionary is included with TopBraid Live (both Personal and Enterprise Server).  Words can be added to the dictionary through the sml:UpdateUserWordDictionary module.""" ;
  rdfs:label "Check spelling" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:CollectGarbage
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:baseURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The base URI of the RDF model to \"forget\"." ;
    ] ;
  rdfs:comment "Collects \"garbage\" to clean up memory from RDF models that are no longer used. Currently, this requires specifying the base URI of a graph that has been previously loaded. Note that the use of this module is not safe in a multi-user setting, and should only be used if you know what you are doing." ;
  rdfs:label "Collect garbage" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:ConvertDDLToRDF
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "true"^^xsd:boolean ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:withDatatypeLinks ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true (the default), triples connecting columns to their datatypes are generated." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "true"^^xsd:boolean ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:withDatatypes ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true (the default), datatypes are imported." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "true"^^xsd:boolean ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:withSchema ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true (the default), schema elements such as tables and columns are imported." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "false"^^xsd:boolean ;
      spl:predicate sml:datatypesBaseURI ;
      spl:valueType xsd:string ;
      rdfs:comment "If specified, URIs for datatype definitions will be breated from this base URI instead of the sml:baseURI." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "false"^^xsd:boolean ;
      spl:predicate sml:text ;
      spl:valueType xsd:string ;
      rdfs:comment "The input SQL script" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:baseURI ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "URIs for schema elements such as tables, columns, etc. will be created from this base URI. If not present, an example URI will be used." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:databaseName ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional database name or catalog name that will be used as a prefix for schema elements when generating URIs and labels" ;
    ] ;
  rdfs:comment "Converts a SQL script containing DDL statements, such as \"CREATE TABLE\", to RDF. The input is given as a text string. The output will use classes and properties from the EDG Data Models schema." ;
  rdfs:label "Convert DDL to RDF" ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:ConvertDatatype
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:datatype ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "The datatype (e.g. xsd:string) of the new triples. If the datatype is rdfs:Resource and the lexical form of the old value is a valid URI, then the resulting triple will point to a resource with that URI." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the triples that shall be replaced." ;
    ] ;
  rdfs:comment "Replaces all triples that have a given property as predicate (specified by sml:predicate) by converting its object literals into a different RDF datatype (specified as sml:datatype)." ;
  rdfs:label "Convert datatype" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:ConvertJSONToRDF
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "root" ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the result variable (defaults to \"root\") that will contain the root object of the converted JSON code." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:keepRootObject ;
      spl:valueType xsd:boolean ;
      rdfs:comment "In GraphQL mode (sml:service is provided) then the root object is typically just a container derived from the Query. By default, the triples of this root object will not be kept. Set to true to keep these triples in the result graph." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:service ;
      spl:valueType <http://datashapes.org/graphql#Schema> ;
      rdfs:comment "A GraphQL service object providing information on how to map the JSON to RDF using SHACL shapes." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:text ;
      spl:valueType xsd:string ;
      rdfs:comment "The JSON input text, either a JSON object or array." ;
    ] ;
  rdfs:comment """Takes a JSON object or array (represented as text) and converts it to RDF triples with the same structure. The result graph will only contain the generated triples - the input graph will be ignored and may need to be passed on with a separate sm:next relationship. The graph uses the namespace prefix.

This module operates in two modes. By default it will use the \"json\" namespace (http://topbraid.org/json#) for properties and create blank nodes of type json:Object. However, if sml:service is set it will look for GraphQL shapes and walk them in parallel to the JSON object tree.

The conversion will start at the JSON root and does a recursive walk through of the JSON objects and arrays. Each JSON object becomes a resource. Each attribute of the JSON object is mapped into a property. In the simple case, it will pick a property from the json namespace, e.g. attribute \"firstName\" becomes a property json:firstName. In simple more, the values of those properties depend on the JSON attribute value and arrays are converted to rdf:Lists, JSON objects recursively become new blank nodes. Numbers, booleans and strings become corresponding RDF literals. In GraphQL mode, the shapes define how the mapping is performed and the root node must be a JSON object.

Optionally, the module can bind a new variable pointing at the root object of the new JSON data structure in RDF. This does not work if the provided JSON string is an Array with multiple entries.""" ;
  rdfs:label "Convert JSON to RDF" ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:ConvertRDFToXML
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "false"^^xsd:boolean ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:isAttributeUnqualified ;
      sml:hidden "true"^^xsd:boolean ;
      rdfs:comment "Indicates if the attributes in the RDF are unqualified. Default is false." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "xml" ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The name of the variable that will hold the resulting XML data. Default: xml." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:document ;
      spl:valueType sxml:Document ;
      rdfs:comment "The sxml:Document to use - if unspecified it will pick one found in the model, which will be unpredictable if multiple sxml:Document instances exist." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:fullNamespaces ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true then the converter will no longer trim xmlns attributes of their / or # endings. " ;
    ] ;
  rdfs:comment "Converts RDF into XML using the Semantic XML (sxml) ontology for the round-tripping. The resulting XML will be bound to the specified output variable. Note that this requires the RDF model to contain an SXML root document element - this function does not work with arbitrary RDF data!  For more, see Help > Import and Export > Creating, Importing, Querying, Saving XML documents with Semantic XML." ;
  rdfs:label "Convert RDF to XML" ;
  rdfs:seeAlso <http://composing-the-semantic-web.blogspot.com/2007/11/xmap-mapping-arbitrary-xml-documents-to.html> ;
  rdfs:seeAlso sml:ConvertXMLToRDF ;
  rdfs:subClassOf sml:XMLProcessingModules ;
.
sml:ConvertSpreadsheetToRDF
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:className ;
      rdfs:comment "The optional name of the target class. If this value is unspecified, then cell (0, 0) of the spreadsheet is used instead. This value can be a localname, a qname or a URI string. If it doesn't exist, then it is created." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:encoding ;
      rdfs:comment "The canonical name of the text encoding of the spreadsheet file. If no value for this property is given, then the default JRE encoding is used. If an encoding value is given for this property, then the spreadsheet file will be evaluated using this value. The supported encodings can be found at the website: <http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html>" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:importToInputGraph ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true, then the import will attempt to reuse properties defined in the input RDF graph for the column-to-property mapping." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:instancePattern ;
      rdfs:comment "The naming pattern for the generated instances. This can contain static characters or placeholders for columns. For example Person-%1 will create names that consist of the static string \"Person-\" and then the value of the first column." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:propertyPrefix ;
      rdfs:comment "The prefix that shall be used for the generated property names. Only used if no qname is specified for a column property and if a new graph is created from the spreadsheet, i.e. importToInputGraph value is false." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:sourceFilePath ;
      rdfs:comment "An optional file path to the spreadsheet. If this is specified then the module will directly do streaming loading from the given file. This should make it possible to handle files of arbitrary size." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:text ;
      rdfs:comment "The spreadsheet's text that shall be converted. If sml:sourceFilePath is set then this value is ignored." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:useUnderscore ;
      rdfs:comment "If true, it replaces special characters, i.e. characters that cannot be imported by default to create a resource URI, with an underscore. If false, these characters are ignored during import." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:useVerbatim ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true, it imports special characters, i.e. characters that cannot be imported by default to create a resource URI. If false, these characters are ignored during import." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:schemaNamespace ;
      rdfs:comment "The base namespace of the target schema." ;
    ] ;
  rdfs:comment """Creates an RDF graph from a tab-separated spreadsheet which is specified from a given string variable. In a typical use case, this will be used after sml:ImportTextFile, which binds the variable text which is also the default input variable of this module. For very large files that cannot be loaded into memory, the module provides the option to specify a file directly using sml:sourceFilePath.

Note that TopBraid supports multiple spreadsheet importer algorithms, including Semantic Tables and the Excel cell importer (sml:ImportExcelCellInstances). This module provides the functionality that is accessible through the TopBraid Composer Spreadsheet import wizard (Help > Import > Import Tab-Delimited Spreadsheet File).""" ;
  rdfs:label "Convert spreadsheet to RDF" ;
  rdfs:seeAlso sml:ImportExcelCellInstances ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:ConvertXMLByXSLT
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "xml" ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The generated XML string variable. The recommended module to export or return the value of this variable is sml:ExportToXMLFile or sml:ReturnXML." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:template ;
      rdfs:comment "The string variable holding the XSLT script" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:xml ;
      rdfs:comment "The source XML variable" ;
    ] ;
  rdfs:comment """Converts an XML document into another XML document using XSLT. The source XML document is either a XML or string variable. The target XML document is a string variable. XSLT script is provided as a string.

Any property other than the expected arguments (sm:outputVariable, sml:template, sml:xml, rdfs:label, and rdf:type) can be used to specify additional parameters for the XSL transformer. The local name of the property will be the parameter name. The values must be string literals. For example, set arg:myParam to \"{?myValue}\" and the value of the variable ?myValue will be set as parameter \"myParam\".""" ;
  rdfs:label "Convert XML by XSLT" ;
  rdfs:subClassOf sml:XMLProcessingModules ;
.
sml:ConvertXMLToRDF
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:xmlType ;
      spl:valueType xsd:string ;
      rdfs:comment "An (optional) type indicator for the Semantic XML conversion. Current supported values are \"XHTML\" (treats the input as HTML source, and may run a tidy algorithm in case the HTML is not well-formed XHTML)." ;
    ] ;
  rdfs:seeAlso sml:ConvertRDFToXML ;
.
sml:CreateTDB
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to overwrite any pre-existing database at this location." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:baseURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The base URI for the TDB repository." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:targetFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the TDB database." ;
    ] ;
  rdfs:comment "Create a new TDB graph from the input RDF triples to a given Jena TDB database. Also loads and registers the new graph." ;
  rdfs:label "Create TDB" ;
  rdfs:subClassOf sml:ExportToLocalModules ;
.
sml:CreateWekaClassifier
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:key ;
      spl:valueType xsd:string ;
      rdfs:comment "The identifier under which the resulting classifier can be accessed later." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:path ;
      spl:valueType xsd:string ;
      rdfs:comment "A string representation of the rdf:Property or property path that shall be classified, i.e. for which the classifier can suggest values. This must be exactly in the same syntax as the path string in the shape, e.g. needs to use the same prefixes for abbreviated property URIs. This can only be used for property paths that are marked as sh:maxCount 1 in the shape, because these are the only ones that are mapped to a single attribute in Weka." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:shape ;
      spl:valueType <http://www.w3.org/ns/shacl#NodeShape> ;
      rdfs:comment "The shape holding the definition of the properties and paths to define the attributes for weka. Use sh:maxCount 1 where possible." ;
    ] ;
  rdfs:comment "Creates a new Weka classifier (based on a shape definition) that is trained using the focus nodes of the shape and which can be used to \"classify\" the values of a given new instance using weka:classify." ;
  rdfs:label "Create Weka classifier" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:DatabaseType
  rdf:type rdfs:Class ;
  rdfs:comment "The class of database configurations used by Jena SDB (and possibly other databases)." ;
  rdfs:label "Database type" ;
.
sml:DeleteSampleData
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:baseURI ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:sampleCount ;
      spl:valueType xsd:integer ;
    ] ;
  rdfs:comment "Deletes sample data extracted by a JDBC schema import." ;
  rdfs:label "Delete sample data" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:DeleteWekaClassifier
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:key ;
      spl:valueType xsd:string ;
      rdfs:comment "The identifier under which the resulting classifier was created." ;
    ] ;
  rdfs:comment "Deletes a Weka classifier from the Maui server. This should be called whenever the classifiers produced by sml:CreateWekaClassifier are no longer needed." ;
  rdfs:label "Delete Weka classifier" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:Diff
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:ignoreBlankNodes ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to bypass comparison of blank nodes - which may take up a lot of time." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:newGraph ;
      spl:valueType sm:Modules ;
      rdfs:comment "The module representing the new graph. Must be a predecessor of the current module to ensure that the module has been executed before." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:oldGraph ;
      spl:valueType sm:Modules ;
      rdfs:comment "The module representing the old graph. Must be a predecessor of the current module to ensure that the module has been executed before." ;
    ] ;
  rdfs:comment "This module exposes the functionality known from TopBraid Composer under Model > Compare current RDF Model with... It returns a diff graph between an old graph and a new graph. This module is related to the old graph with sml:oldGraph and the new graph with sml:newGraph properties. The output is a collection of instances from the http://topbraid.org/diff namespace." ;
  rdfs:label "Diff" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:ExportBatch
  rdf:type sml:OracleExportMode ;
  rdfs:label "ExportBatch" ;
.
sml:ExportBulk
  rdf:type sml:OracleExportMode ;
  rdfs:label "ExportBulk" ;
.
sml:ExportIncremental
  rdf:type sml:OracleExportMode ;
  rdfs:label "ExportIncremental" ;
.
sml:ExportToJMS
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "ConnectionFactory" ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:jmsConnectionFactory ;
      spl:valueType xsd:string ;
      rdfs:comment "Connection Factory name for the JMS Queue" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "JMS broker username." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:className ;
      spl:valueType xsd:string ;
      rdfs:comment "Fully qualified class name of JNDI Initial Context Factory for the JMS Queue." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:jmsDestination ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the JMS queue to send the message to." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:text ;
      spl:valueType xsd:string ;
      rdfs:comment "The text to be submitted to the JMS queue." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL of the JMS broker." ;
    ] ;
  rdfs:comment "Exports a string to a JMS queue.  The text to export must be specified as value of the argument sml:text." ;
  rdfs:label "Export to JMS" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ExportToSDB
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "false"^^xsd:boolean ;
      spl:predicate sml:initialize ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Indicates that the SDB database shall be initialized." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "false"^^xsd:boolean ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Indicates whether all existing content of the SDB shall be overwritten." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:createGraph ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true the exported graph will be output from the module. Otherwise the output graph remains unchanged from the input." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:graphName ;
      spl:valueType xsd:string ;
      rdfs:comment "the named graph URI" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
      rdfs:comment "The password to log in with. Can be left empty if the built-in security mechanism (of Eclipse) shall be used." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:targetFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The (optional) path to a .sdb file that can later be opened from within TopBraid." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "The user name to log in with." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:baseURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The base URI of the target SDB database. This will serve as a unique identifier of the triple store in TopBraid, and is typically also represented by an owl:Ontology." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:databaseType ;
      spl:valueType sml:DatabaseType ;
      rdfs:comment "The database type, e.g. Oracle." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL of the database." ;
    ] ;
  rdfs:comment """Writes the input triples to a specified Jena SDB database.

Note: This is a low-level system module. The preferred way of writing to databases is using sml:PerformUpdate.""" ;
  rdfs:label "Export to SDB" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ExportToSesameRemoteRepository
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:baseURI ;
      rdfs:comment "The base URI of the target repository. Must be specified if a connection file (*.s2r) shall be created." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:graphName ;
      spl:valueType xsd:string ;
      rdfs:comment "the graph name URI" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:modelName ;
      rdfs:comment "The id of the model on the server, if necessary." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:password ;
      rdfs:comment "The password if required to log into the repository. Can be left empty if the built-in security mechanism (of Eclipse) shall be used." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:replace ;
      rdfs:comment "true clears the repository before writing into it." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:targetFilePath ;
      rdfs:comment "An (optional) path to a connection metadata file that will be created so that tools can connect to the repository later. This path is relative to the workspace root, e.g. \"/myProject/myFolder/myFile.s2r\". Must be used in conjunction with sml:baseURI." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:userName ;
      rdfs:comment "The user name if required to log into the repository." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:url ;
      rdfs:comment "The URL of the Sesame server." ;
    ] ;
  rdfs:comment """Writes the input triples into a Sesame remote repository.

Note: This is a low-level system module. The preferred way of writing to databases is using sml:PerformUpdate.""" ;
  rdfs:label "Export to Sesame remote repository" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ExportToSolrFields
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "http://localhost:8983/solr" ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL of the Solr server." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
      rdfs:comment "Password for authentication at the Solr server (if needed). If left blank and a user name is provided, then the system will look up a password from TopBraid's secure storage." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to clear out the Solr index before adding the fields." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:selectQuery ;
      spl:valueType sp:Select ;
      rdfs:comment "An optional SELECT query that returns all resources that shall be exported. If not specified, then the module will export all subjects." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:useURIs ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to use full URIs for field names - the system will try to use qnames otherwise and this may lead to problems if either no prefixes exist or names clash." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "User name for authentication at the Solr server (if needed)." ;
    ] ;
  rdfs:comment "Exports documents and their fields derived from the current input graph to a given Solr instance. The algorithm iterates over a set of subjects, which can be specified by a given selectQuery. It turns each subject into a Solr document, and each property of the subject by default is mapped to a dynamic field, based on the types of the values. For example, a single-valued xsd:string property ex:myProperty is mapped to a Solr field \"ex_myProperty_s\" (if the qname option has been selected). Each document also has an \"id\" field which contains the URI of the subject, and a \"name\" field which contains the human-readable label of the subject. In contrast, rdfs:label and its sub-properties are not exported unless explicitly overridden. It is possible to override the property naming convention by attaching the solr:fieldName values to the properties in the RDF graph. If the value of solr:fieldName is \"-\" then the property will not be exported at all." ;
  rdfs:label "Export to Solr fields" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ExportToTDB
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:createGraph ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true the exported graph will be output from the module. Otherwise the output graph remains unchanged from the input." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to overwrite any pre-existing database at this location." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:baseURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The base URI for the TDB repository." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:targetFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the TDB database." ;
    ] ;
  rdfs:comment """Export the input RDF triples to a given Jena TDB database.

Note: This is a low-level system module. The preferred way of writing to databases is using sml:PerformUpdate.""" ;
  rdfs:label "Export to TDB" ;
  rdfs:subClassOf sml:ExportToLocalModules ;
.
sml:ExportToZIPFile
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:sourceFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The sourceFilePath can be relative to the current script's folder (e.g. pathDir/data).  Or it can be multiple absolute or relative workspace paths separated by comma. (e.g. /myProject/myFolder/data, pathDir/data)" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:targetFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the file that shall be created. The path can be relative to the current script's folder (e.g. test.zip) or absolute to the workspace root (e.g. /myProject/myFolder/test.zip)." ;
    ] ;
  rdfs:comment "Saves files in sourceFilePath to a zip file in targetFilePath." ;
  rdfs:label "Export to ZIP file" ;
  rdfs:subClassOf sml:ExportToLocalModules ;
.
sml:ExtractJDBCSchema
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "true"^^xsd:boolean ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:withDatatypeLinks ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true (the default), triples connecting columns to their datatypes are generated." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "true"^^xsd:boolean ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:withDatatypes ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true (the default), datatypes are imported." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "true"^^xsd:boolean ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:withSchema ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true (the default), schema elements such as tables and columns are imported." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "false"^^xsd:boolean ;
      spl:predicate sml:datatypesBaseURI ;
      spl:valueType xsd:string ;
      rdfs:comment "If specified, URIs for datatype definitions will be breated from this base URI instead of the sml:baseURI." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:baseURI ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "URIs for schema elements such as tables, columns, etc. will be created from this base URI. If not present, an example URI will be used." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:databaseName ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional database name or catalog name that will be used as a prefix for schema elements when generating URIs and labels" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:sampleCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "The number of sample rows to be stored for profile" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:withSamples ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:withStats ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
    ] ;
  rdfs:comment "Creates a JDBC connection to the specifed database to extract schema. The output will use classes and properties from the EDG Data Models schema." ;
  rdfs:label "Extract JDBC Schema" ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:FilterByFilterGraph
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:filterGraph ;
      spl:valueType sm:Modules ;
      rdfs:comment "The module that contains the triples that shall be filtered out. Must be one of the predecessors of this module, to make sure that it has been executed before." ;
    ] ;
  rdfs:comment "Filters input graphs with filter graphs. This module is linked to filter graph modules by sml:filterGraph property." ;
  rdfs:label "Filter by filter graph" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:GenerateRandomData
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:namespace ;
      spl:valueType xsd:string ;
      rdfs:comment "The default namespace to use for newly created instances." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:replaceInvalidValues ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to post-process the values of the generated properties using SHACL, attempting to replace values that violate constraints. Activating this feature may cause significant performance degradation." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:targetGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional target graph to write the triples to. If unspecified, the new triples will be added into a newly created in-memory graph." ;
    ] ;
  rdfs:comment "Generates random instances of classes as defined by the input triples using the datagen namespace (TopBraid/SHACL/datagen.ttl). The output graph of the module is the graph containing the generated triples." ;
  rdfs:label "Generate random data" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:GenerateReport
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:focusNode ;
      rdfs:comment "An optional focus node. If specified then only results related to that focus node will be produced." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:ids ;
      spl:valueType xsd:string ;
      rdfs:comment "A comma-separated list of IDs of individual result generators that shall be executed. By default, all generators are called." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:ignoreImports ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only run this on resources that appear as subject in a triple from the base graph. In other words, focus nodes defined only in imported graphs will be skipped." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:result ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource that shall hold the sh:result triples in the results graph." ;
    ] ;
  rdfs:comment "Generates a report for a given focus node or the whole input graph. This module provides access to an extension mechanism of TopBraid, including a growing number of individual result generators. Each of these result generators has a unique ID that can be used by this module to select which generators to execute. The output graph of this module is a new graph consisting of the union of all individual results. The results are represented by subclasses of sh:AbstractResult." ;
  rdfs:label "Generate report" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:ImportAndSplitTextFile
  rdf:type spin:SelectTemplate ;
  rdf:type sm:Module ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "segment" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "sourceFilePath" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "divider" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?2" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "startIndex" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?2" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?3" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?2" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "endIndex" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?3" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?3" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "segment" ;
              ] ;
            sp:predicate smf:splitTextFile ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate <http://spinrdf.org/arg#endIndex> ;
      spl:valueType xsd:integer ;
      rdfs:comment "The segment index to end with (first matching segment has index 1)." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate <http://spinrdf.org/arg#startIndex> ;
      spl:valueType xsd:integer ;
      rdfs:comment "The segment index to start with (first matching segment has index 1)." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate <http://spinrdf.org/arg#divider> ;
      spl:valueType xsd:string ;
      rdfs:comment "The string dividing the segments in the text file, for example \",\" for comma-separated snippets." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate <http://spinrdf.org/arg#sourceFilePath> ;
      spl:valueType xsd:string ;
      rdfs:comment "The absolute path to the text file in the workspace (e.g., /myProject/myFolder/test.txt)." ;
    ] ;
  rdfs:comment """Performs a streaming load over a text file and iterates over a selection of segments (divided by a given separator) inside of that text file. The body of this module will be executed for each matching segment, and the variable ?segment will be bound in each iteration.

This module uses the magic property smf:splitTextfile for the bulk of the work, and you can also use that magic property for finer-grained control of the iteration.""" ;
  rdfs:label "Import and split text file" ;
  rdfs:subClassOf sm:SelectTemplates ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ImportCurrentRDF
  rdf:type sm:Module ;
  rdfs:comment """Depending on the context, this module delivers different results.

When called from TBC, this will return the RDF graph of the currently open file. In many use cases this will include the script itself, unless the script is a background service such as an sml:TrackChanges script.

When called from a user-defined SPARQLMotion/SPIN Function, this module will return the context graph, which is the graph that the surrounding SPARQL query will currently operate on.

When called as a TopBraid Live (stand-alone) web service, this module will throw an exception because there is no current graph available.""" ;
  rdfs:label "Import current RDF" ;
  rdfs:subClassOf sml:ImportFromVariousModules ;
.
sml:ImportDirectoryWithTika
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "false"^^xsd:boolean ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:html ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true, attempt to extract content as HTML markup instead of plain text." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:recursive ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to walk the path recursively." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:path ;
      spl:valueType xsd:string ;
      rdfs:comment "The source path." ;
    ] ;
  rdfs:comment "Each file in the specified directory (and sub-directories if 'recursive' is true) is parsed with Apache Tika. The path can be an absolute path in the workspace, an absolute path in the general file system, or a relative path in relation to the script's location. A graph is generated from the results in the namespace 'http://topbraid.org/document#'. This graph will contain all available metadata, and all parseable text." ;
  rdfs:label "Import directory with Tika" ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ImportEMails
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:loadBodies ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Indicates whether the bodies of the email should also be downloaded. Note that the value of true will be significantly slower than the (default value) false." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:path ;
      rdfs:comment "An (optional) path to those folders the headers of which shall be loaded. For example /INBOX/TBC-MailingList will load the emails from the TBC-MailingList folder inside of the INBOX folder." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:baseURI ;
      rdfs:comment "The base URI of the RDF objects created from the emails." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:emailAccount ;
      spl:valueType <http://topbraid.org/email#Address> ;
      rdfs:comment "The address to load the emails from. The address must have valid values for email:userName, email:protocol, email:password, email:server." ;
    ] ;
  rdfs:comment "Imports email messages from an account. This feature is based on the TopBraid email ontology (http://topbraid.org/email). The property sml:emailAccount must point to one email:Address instance. The system will connect to the account and import its emails into OWL instances of the email ontology." ;
  rdfs:label "Import emails" ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:ImportExcelCellInstances
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:sourceFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the Excel source file in the workspace. The path can be relative to the current script's folder (e.g., myFolder/test.xls) or absolute to the workspace root /myProject/myFolder/test.xls." ;
    ] ;
  rdfs:comment """Loads an Excel file into instances of the TopBraid spreadsheets ontology - each non-empty cell becomes an instance of ss:Cell. In a typical scenario, the resulting cell instances are passed into other modules (such as sml:ApplyConstruct) to convert the raw data into a more useful format. This module provides the functionality that is accessible from TBC, as described in Help > Import > Import Excel File into Spreadsheet Ontology.

This module is distinct from the Semantic Tables importer, which can be used with sml:ImportRDFFormWorkspace to also import Excel files. The latter is better suited for spreadsheets consisting of regular tables, while this module here is optimized for cases in which the Excel file is not well-structured and each individual cell has a different meaning or role.""" ;
  rdfs:label "Import Excel cell instances" ;
  rdfs:seeAlso sml:ConvertSpreadsheetToRDF ;
  rdfs:seeAlso sml:ImportRDFFromWorkspace ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ImportFileWithTika
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "false"^^xsd:boolean ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:html ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true, attempt to extract content as HTML markup instead of plain text." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:overrideFileName ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional file name that Tika may use to determine what parser to use, etc." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:resultURI ;
      rdfs:comment "The URI to use for the document in the output graph. If unspecified, the sourceURL or a file:/// URI representing sourceFilePath will be used." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:sourceFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The file to be imported. The path can be an absolute path in the workspace, or a relative path in relation to the script's location." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:sourceURL ;
    ] ;
  rdfs:comment "Imports a document from a workspace file (sourceFilePath) or from the web (sourceURL), and parses it with Apache Tika. The output graph will contain all available metadata, and all parseable text." ;
  rdfs:label "Import file with Tika" ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ImportJSONFromGraphQLService
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "json" ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the output variable, defaulting to \"json\"." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:arguments ;
      spl:valueType xsd:string ;
      rdfs:comment "A JSON object with name-value pairs for the arguments." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
      rdfs:comment "The password to use for authentication - leave empty to rely on the password stored in secure storage. Only used if sml:userName is set." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "The user name for authentication." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:query ;
      spl:valueType xsd:string ;
      rdfs:comment "The GraphQL query string." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL of the GraphQL service." ;
    ] ;
  rdfs:comment "Executes a GraphQL query against a given service, possibly including variable bindings. The resulting JSON is then bound to a variable downstream." ;
  rdfs:label "Import JSON from GraphQL service" ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:ImportSDB
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:graphName ;
      spl:valueType xsd:string ;
      rdfs:comment "the named graph URI" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
      rdfs:comment "The password of the connection. Can be left empty if the built-in security mechanism (of Eclipse) shall be used." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "The user name of the connection." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:databaseType ;
      spl:valueType sml:DatabaseType ;
      rdfs:comment "The database type, such as Oracle." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The database URL." ;
    ] ;
  rdfs:comment """Connects to an existing Jena SDB database.

Note: This is a low-level system module. The preferred way of operating on existing SDBs is using sml:ImportRDFFromWorkspace.""" ;
  rdfs:label "Import SDB" ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:ImportSesameRemoteRepository
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:graphName ;
      spl:valueType xsd:string ;
      rdfs:comment "the named graph URI" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:modelName ;
      rdfs:comment "The id of the model on the server, if necessary." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:password ;
      rdfs:comment "The password if required to log into the repository. Can be left empty if the built-in security mechanism (of Eclipse) shall be used." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:userName ;
      rdfs:comment "The user name if required to log into the repository." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:url ;
      rdfs:comment "The URL of the Sesame server." ;
    ] ;
  rdfs:comment """Connects to a remote Sesame 2 repository.

Note: This is a low-level system module. The preferred way of operating on existing databases is using sml:ImportRDFFromWorkspace.""" ;
  rdfs:label "Import Sesame remote repository" ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:ImportTDB
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:dataPath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the TBD data files. This is usually the .tdb connector file name plus .data." ;
    ] ;
  rdfs:comment """Opens a Jena TDB database stored in the workspace at a given path.

Note: This is a low-level system module. The preferred way of operating on existing TDBs is using sml:ImportRDFFromWorkspace.""" ;
  rdfs:label "Import TDB" ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ImportXHTML
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "xml" ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The name of the variable that will contain the XHTML as an XML document. Default: xml." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:url ;
      rdfs:comment "The URL of the HTML page. May contain variables such as {?varName}." ;
    ] ;
  rdfs:comment "Opens an HTML document from a URI, using Tidy to convert it to XHTML (XML). The url must point to the URL of the file. The URL may contain variables from the input modules. The resulting XML will be assigned to the specified output variable." ;
  rdfs:label "Import XHTML" ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:IterateOverArguments
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sm:body ;
      rdfs:comment "The body to execute with the two variable bindings (?argName and ?argValue)." ;
    ] ;
  rdfs:comment "In scripts that are called as web service, this module can be used to iterate over all arguments of the web service. In each iteration, the body will be executed with two variable bindings: the argument name (?argName) and argument value (?argValue), both as xsd:string literals. The result of the module itself will be the union of the results of all body iterations, comparable to sml:IterateOverSelect. In a typical scenario, the body would consist of sml:ApplyConstruct modules that turn the raw arguments into some more meaningful data structure, that is then further processed by the rest of the script." ;
  rdfs:label "Iterate over arguments" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:IterateOverSQL
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
      rdfs:comment "The (optional) password to log into the database. Can be left empty if the built-in security storage mechanism (of Eclipse/Equinox) shall be used." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "The user name for the database." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:databaseType ;
      spl:valueType sml:DatabaseType ;
      rdfs:comment "The type of the database." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:sql ;
      spl:valueType xsd:string ;
      rdfs:comment "The SQL SELECT query to send to the database." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL of the database." ;
    ] ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sm:body ;
      rdfs:comment "The body of the iteration loop." ;
    ] ;
  rdfs:comment """Repeats a given sub-script for each matching result set of a given SQL Select query. The system will do a mapping of SQL values to suitable XSD datatypes.

The start of the sub-script is specified by the body property, and the input RDF of the body is the same as the input of the iteration module itself. The result variables of the Select query will be bound in each iteration of the loop.

The result of this module are the accumulated triples from the end nodes of the body scripts. No internal variable bindings of the body will be used outside of the body.""" ;
  rdfs:label "Iterate over SQL" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:IterateOverXPath
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "xml" ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the variable that will be bound in each iteration." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:xml ;
      rdfs:comment "The XML node (document or element) to operate on." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:xpath ;
      spl:valueType xsd:string ;
      rdfs:comment "The XPath to evaluate." ;
    ] ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sm:body ;
      rdfs:comment "The body to execute in each iteration." ;
    ] ;
  rdfs:comment "Evaluates an XPath on a given XML document (or node) and executes a given body for each binding. The outputVariable will be bound in each iteration of the loop, bound to the XML node. The main use case of this module is in combination with sml:BindByXPath: IterateOverXPath walks through a list of top-level nodes and sml:BindByXPath is then used to extract individual values in each iteration." ;
  rdfs:label "Iterate over XPath" ;
  rdfs:subClassOf sml:XMLProcessingModules ;
.
sml:MySQL
  rdf:type sml:DatabaseType ;
  rdfs:label "MySQL" ;
.
sml:Oracle
  rdf:type sml:DatabaseType ;
  rdfs:label "Oracle" ;
.
sml:OracleExportMode
  rdf:type rdfs:Class ;
  rdfs:comment "The export modes supported by Oracle RDF." ;
  rdfs:label "Oracle export mode" ;
  owl:equivalentClass [
      rdf:type owl:Class ;
      owl:oneOf (
          sml:ExportBatch
          sml:ExportBulk
          sml:ExportIncremental
        ) ;
    ] ;
.
sml:PerformFacetedSearch
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:search ;
      spl:valueType <http://topbraid.org/search#Search> ;
      rdfs:comment "The Search to execute." ;
    ] ;
  rdfs:comment """Executes a faceted search. The main input to this module is a search:Search object that describes the search:Facets that shall be delivered and search:FacetValues used for filtering. The module will issue this search to the target specified in the Search and add the resulting counts to the search:Search object. By default, the Search will be executed against the RDF graph mentioned in search:queryGraph. However, if the Search is an instance of solr:Search, then it will be sent to a Solr server.

Note that the input resource will be modified and in a typical use case this should be in a temporary graph, such as one created with ui:createSessionGraph().""" ;
  rdfs:label "Perform faceted search" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:PostRequest
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "response" ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the output variable to bind the result with." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:content ;
      spl:valueType xsd:string ;
      rdfs:comment "The content to send." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:contentType ;
      spl:valueType xsd:string ;
      rdfs:comment "The type of the content to be sent." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:encoding ;
      spl:valueType xsd:string ;
      rdfs:comment "The file encoding such as UTF-8. If left blank, the HTTP default (ISO-8859-1) will be used." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
      rdfs:comment "The password to use for authentication - leave empty to rely on the password stored in secure storage. Only used if sml:userName is set." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "The user name for authentication." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL to post to." ;
    ] ;
  rdfs:comment "Sends a POST request to a web server and binds the result stream with the outputVariable. The request will include variable bindings for all non-system properties of this module. For example, you can set arg:test to some value that will be mapped to the name-value-pair \\\"test\\\". The recommended way of doing this is to subclass the sml:PostRequest class and declare the additional arguments as spin:constraints. The user is allowed to send either the arguments or the content through the variable sml:content. If a variable starts with \"httpHeader_\" then the value will be used as HTTP request header with the partial name after the _." ;
  rdfs:label "Post request" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:PostgreSQL
  rdf:type sml:DatabaseType ;
  rdfs:label "PostgreSQL" ;
.
sml:RefreshWorkspace
  rdf:type sm:Module ;
  rdfs:comment "Refreshes the TopBraid workspace so that changes to files made outside of TopBraid's control become known to the system, and all registries are updated. This is a low-level operation that should be used with care, ideally when no other processes are running." ;
  rdfs:label "Refresh workspace" ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ReleaseLock
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "http://topbraid.org/sparqlmotionlib#DefaultLock" ;
      spl:predicate sml:uri ;
      rdfs:comment "the lock URI (either xsd:string or resource)" ;
    ] ;
  rdfs:comment "Releases any exclusive system lock that was identified by the URI given as an argument and received previously using sml:RequestLock." ;
  rdfs:label "Release lock" ;
  rdfs:seeAlso sml:RequestLock ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:RemoveUserDictionaryWord
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:word ;
      spl:valueType xsd:string ;
      rdfs:comment "The word to remove." ;
    ] ;
  rdfs:comment "Removed a given word from the user dictionary used for spell-checking (see sml:CheckSpelling)." ;
  rdfs:label "Remove user dictionary word" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:RequestLock
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "http://topbraid.org/sparqlmotionlib#DefaultLock" ;
      spl:predicate sml:uri ;
      rdfs:comment "the lock URI (either xsd:string or resource)" ;
    ] ;
  rdfs:comment """Requests an exclusive system lock identified by the URI given as an argument. This will make sure that the following modules in the script can proceed without risking interrupts or concurrent modification exceptions for the duration of the lock. When another thread attempts to request a lock with the same URI, the module will wait until the lock is released and then continue execution. The lock will be released if the script terminates or sml:ReleaseLock is reached.

Please use this module with care and release the lock as quickly as possible to avoid contention issues. Other concurrent requests may need to wait until the script has been finished.""" ;
  rdfs:label "Request lock" ;
  rdfs:seeAlso sml:ReleaseLock ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:SQLServer
  rdf:type sml:DatabaseType ;
  rdfs:label "Microsoft SQL Server" ;
.
sml:SelectedResourceArgument
  rdf:type spin:Template ;
  spin:labelTemplate "Selected Resource {?predicate}" ;
  rdfs:comment """A system argument representing the \"selected\" resource. This can be used to implement services that operate on the currently selected resource in TopBraid Composer or Ensemble. The value of this argument will be set automatically by the engine in TBC. In TBE the selected resource's URI needs to be passed in.
Note: this replaces sml:BindWithSelectedResource from older TBC versions.""" ;
  rdfs:label "Selected resource argument" ;
  rdfs:subClassOf spl:Argument ;
.
sml:SendEMails
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:selectQuery ;
      spl:valueType sp:Select ;
      rdfs:comment "A SPARQL Select query that binds instances of email:Message to send out. If left blank, all instances of email:Message in the input graph will be sent." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:smtpServer ;
      spl:valueType <http://topbraid.org/email#Server> ;
      rdfs:comment "The SMTP server that shall be used to send the emails from. If no server has been specified, the default SMTP server from the TBL server configuration will be used." ;
    ] ;
  rdfs:comment "Sends one or more emails. In a typical scenario, previous steps such as sml:ApplyConstruct have created instances of email:Message. The body of the emails could be created using sml:CreateUISPINDocument. A SPARQL Select query is then used to select those messages that shall be sent out, based on the given server parameters." ;
  rdfs:label "Send emails" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:UpdateUserWordDictionary
  rdf:type sm:Module ;
  rdf:type owl:DeprecatedClass ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:selectQuery ;
      spl:valueType sp:Select ;
      rdfs:comment "The SELECT query that delivers action (remove / add) and the literal that shall be removed / added from / to the dictionary of user specified words. <http://topbraid.org/spellcheckresults#removeWord> is used to specify remove action and <http://topbraid.org/spellcheckresults#addWord> is used to specify add action." ;
    ] ;
  rdfs:comment """SM Module for adding and removing words from the dictionary of user specified words. Words in the dictionary of user specified words are ignored by the CheckSpelling module.

Deprecated: Use sml:AddUserDictionaryWord and sml:RemoveUserDictionaryWord instead.""" ;
  rdfs:label "Update user word dictionary" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
  owl:deprecated "true"^^xsd:boolean ;
.
sml:arguments
  rdf:type rdf:Property ;
  rdfs:label "arguments" ;
.
sml:databaseName
  rdf:type rdf:Property ;
  rdfs:label "database name" ;
  rdfs:range xsd:string ;
.
sml:datatypesBaseURI
  rdf:type rdf:Property ;
  rdfs:label "datatypes base URI" ;
  rdfs:range xsd:string ;
.
sml:document
  rdf:type rdf:Property ;
  rdfs:label "document" ;
.
sml:emailAccount
  rdf:type rdf:Property ;
  rdfs:label "emailAccount" ;
  rdfs:range <http://topbraid.org/email#Address> ;
.
sml:fullNamespaces
  rdf:type rdf:Property ;
  rdfs:label "full namespaces" ;
  rdfs:range xsd:boolean ;
.
sml:html
  rdf:type rdf:Property ;
  rdfs:label "html" ;
  rdfs:range xsd:boolean ;
.
sml:ids
  rdf:type rdf:Property ;
  rdfs:label "IDs" ;
.
sml:ignoreBlankNodes
  rdf:type rdf:Property ;
  rdfs:label "ignore blank nodes" ;
  rdfs:range xsd:boolean ;
.
sml:initialize
  rdf:type rdf:Property ;
  rdfs:comment "Specifies that a module shall uncondionally initialize the triple store (SDB) it is writing to. If set to true (default is false), then all triples contained in the triple store will be permanently lost." ;
  rdfs:label "initialize" ;
  rdfs:range xsd:boolean ;
.
sml:keepRootObject
  rdf:type rdf:Property ;
  rdfs:label "keep root object" ;
.
sml:key
  rdf:type rdf:Property ;
  rdfs:label "key" ;
  rdfs:range xsd:string ;
.
sml:namespace
  rdf:type rdf:Property ;
  rdfs:label "namespace" ;
.
sml:overrideFileName
  rdf:type rdf:Property ;
  rdfs:label "override file name" ;
.
sml:query
  rdf:type rdf:Property ;
  rdfs:label "query" ;
.
sml:recursive
  rdf:type rdf:Property ;
  rdfs:label "recursive" ;
.
sml:replaceInvalidValues
  rdf:type rdf:Property ;
  rdfs:label "replace invalid values" ;
  rdfs:range xsd:boolean ;
.
sml:resultURI
  rdf:type rdf:Property ;
  rdfs:label "result URI" ;
.
sml:sampleCount
  rdf:type rdf:Property ;
  rdfs:label "sample count" ;
  rdfs:range xsd:integer ;
.
sml:search
  rdf:type rdf:Property ;
  rdfs:label "search" ;
.
sml:service
  rdf:type rdf:Property ;
  rdfs:label "service" ;
.
sml:shape
  rdf:type rdf:Property ;
  rdfs:label "shape" ;
.
sml:smtpServer
  rdf:type rdf:Property ;
  rdfs:label "smtpServer" ;
  rdfs:range <http://topbraid.org/email#Server> ;
.
sml:sourceURL
  rdf:type rdf:Property ;
  rdfs:label "source URL" ;
.
sml:targetGraph
  rdf:type rdf:Property ;
  rdfs:label "target graph" ;
.
sml:useURIs
  rdf:type rdf:Property ;
  rdfs:label "use URIs" ;
.
sml:withDatatypeLinks
  rdf:type rdf:Property ;
  rdfs:label "with datatype links" ;
  rdfs:range xsd:boolean ;
.
sml:withDatatypes
  rdf:type rdf:Property ;
  rdfs:label "with datatypes" ;
  rdfs:range xsd:boolean ;
.
sml:withSamples
  rdf:type rdf:Property ;
  rdfs:label "with data samples" ;
  rdfs:range xsd:boolean ;
.
sml:withSchema
  rdf:type rdf:Property ;
  rdfs:label "with schema" ;
  rdfs:range xsd:boolean ;
.
sml:withStats
  rdf:type rdf:Property ;
  rdfs:label "with data statistics" ;
  rdfs:range xsd:boolean ;
.
sml:word
  rdf:type rdf:Property ;
  rdfs:label "word" ;
  rdfs:range xsd:string ;
.
<http://topbraid.org/sparqlmotionlib-tb>
  rdf:type owl:Ontology ;
  rdfs:comment "A library of SPARQLMotion modules that are supported by the TopBraid platform, including TopBraid Live and Composer." ;
  owl:imports <http://datashapes.org/graphql> ;
  owl:imports <http://topbraid.org/email> ;
  owl:imports <http://topbraid.org/search> ;
  owl:imports <http://topbraid.org/sparqlmotionfunctions> ;
  owl:imports <http://topbraid.org/sparqlmotionlib-core> ;
  owl:imports <http://uispin.org/ui> ;
.
